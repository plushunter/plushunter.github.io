<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Free Will</title>
  <icon>https://www.gravatar.com/avatar/5210824d1d63b2352ab190a38412be77</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-15T14:06:38.979Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>狗皮膏药</name>
    <email>934825769@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>陆建德：回忆中的“新乐音”</title>
    <link href="http://yoursite.com/2019/02/15/Holzwege-5/"/>
    <id>http://yoursite.com/2019/02/15/Holzwege-5/</id>
    <published>2019-02-15T12:20:28.000Z</published>
    <updated>2019-02-15T14:06:38.979Z</updated>
    
    <content type="html"><![CDATA[<p>（本文是陆建德为朱利安·巴恩斯《终结的感觉》所撰导言，该书2012年8月由译林出版社出版。）</p><a id="more"></a><p>不变的自我往往是美好的虚构。我们不少成语（如白璧无瑕、怀瑾握瑜、怀真抱素、泥而不滓）都强调人的恒定性，《离骚》里的诗人还自称“纷吾既有此内美兮，又重之以修能”。（楚辞中有很多类似的表述，比如《怀沙》：“内厚质正”；“文质疏内兮，众不知余之异彩。” ）“内美”指先天的品质，是一种先于社会与历史的完足，就像橘树的基因一般。其实自我受制于时间，通过回忆不断生成变化。如果一个人在不同的时候对发生在自己身上的事理解有所不同，那么回忆在发挥关键作用。朱利安•巴恩斯（1946—）的《终结的感觉》是一部回忆之书，它既是在回忆中写成，也是对回忆的心理特点的探究。小说叙述者对过去的理解变了，对自己的认识也变了。“我是谁？”这一问题不仅在无形中引导主人公与自己的搏斗，也在每一位读者的耳边回响。</p><p>回忆是一口深井。爱尔兰诗人西默斯•希尼在《个人的诗泉》里写道：有的浅井闪过访问者的脸庞，而“有些井发出回声，用纯洁的新乐音/应对你的呼声”。两种不同的井象征了不同的回忆目的，一种是自恋式的，另一种是为了发掘：<br>　　<br>去拨弄污泥，去窥测根子，<br>去凝视泉水中的那喀索斯，他有双大眼睛，<br>都有伤成年人的自尊。我写诗<br>是为了认识自己，使黑暗发出回音。<br>　　　　　<br>但是“拨弄污泥，去窥测根子”很难与“认识自己”完全对立起来。有时候人们需要有“拨弄污泥，去窥测根子”的勇气，因为那个沉睡的地带也许正是自己记忆的禁区。《终结的感觉》的叙述者就是不断在记忆深处中挖掘，冲破自己不知不觉间设置的障碍，最终听到了“纯洁的新乐音”。他跳脱出狭隘的自我，开始从他人的角度来观察、分析自己的历史，并且变得具有同情心。</p><p>早在80年代，巴恩斯就凭他为数不多的几部小说跻身英国一流作家的行列，我国英语文学研究界早就对他寄予厚望。1997年出版的《英国小说研究》第四卷《现代主义之后》（中国社会科学出版社）就收有阮炜先生论巴恩斯和他的成名之作《福楼拜的鹦鹉》（1984）的文章。</p><p>巴恩斯在牛津就学时读的是“现代语言”专业，主修法语。《福楼拜的鹦鹉》展示出巴恩斯在法国文学上的精湛知识，深得法国人好感，出版那年获法国梅迪奇奖，数年后作者还被法国文化部授予文学艺术军官勋章。可以说他在法国是最受欢迎的当代英语作家之一。巴恩斯曾任《纽约客》的伦敦通讯员，在美国也拥有大量读者。以笔者之见，巴恩斯是当今世界上最优秀的作家之一。</p><p> 《终结的感觉》叙述者托尼•韦布斯特是一个极其普通的人，年龄应该与巴恩斯差不多，在上世纪60年代上的大学。小说分为两部分。第一部分是托尼对学生时代的回顾（也夹杂了四十年之后的评点），主要讲他中学与大学的生活。</p><p>托尼在中学里有两个好朋友，形成三人帮，他们的手表表面从来戴在手腕内侧，后来这“铁三角”增加了艾德里安•芬。艾德里安智力超群，他喜爱的作家是加缪和尼采，可见高出同学一截。他在课堂上的表现如此出色，看来是读书的好料子。艾德里安的母亲早就离家出走，父亲一人抚养他和妹妹。小团伙里的同伴用粗鲁的语言追问艾德里安，他母亲究竟为什么离开，艾德里安不知道，他的回答十分平和。他说自己“爱母亲，敬重父亲”。奇怪的是艾德里安没有因为成长于单亲家庭而愤世嫉俗，怨天尤人。反之，他待人接物显得比“铁三角”中的成员都要成熟，对少年人故意冲撞的用语，他小心回避。他获得奖学金进剑桥，大家并不意外。</p><p>中学毕业后，托尼到布里斯托尔读大学，很快就交上了维罗妮卡，一位学西班牙文学的女生。他曾经把自己的女朋友介绍给中学里那几位朋友，一起在伦敦留了影。有一次托尼应邀到维罗妮卡家度周末，那是一次让他难以忘怀的经历。托尼带的皮箱偏大了，维罗妮卡的父亲借此开玩笑，很不得体，他的一系列语言都有故意伤害托尼自尊心之嫌。托尼意识到自己家庭背景不及女友，感到有点羞愧。维罗妮卡家是独栋房子，位于比较殷实的肯特郡，她父亲还是公务员，那在英国是受人尊敬的职业，而托尼压根儿没有提及他自己的父亲，想来是他的自卑在作怪。托尼做客时因自卑更加拘谨，然而只有维罗妮卡的母亲使他感到一丝温暖。托尼究竟爱维罗妮卡吗？从托尼早期的回忆来看，他对这位身材娇小的姑娘的兴趣主要停留在生理学层面上，性冲动说来就来，情感之流却是受到压制的。他认定维罗妮卡是处女，仅仅因为她不愿意和他上床。并不合理的推断会被下意识地误解为“事实”，一旦“事实”崩塌，心理上就无法承受。</p><p>他们最终还是上床了，但是在托尼的回忆里是这样表述的：“我们分手以后，她和我上了床。” 对托尼而言，那次经历太重要了，然而他的叙述十分简略，可见他是不大愉快的。托尼没有告诉读者他的重大发现以及随之而起的不快，这一点逃不过读者的眼睛。维罗妮卡有一点如何安全做爱经验，这让托尼无法忍受。但是他没有说。巴恩斯在关节处留白，这是他的高明。实际上两人上床并不是在分手之后，而是在分手之前。托尼颠倒时间次序，图的是自己的方便：他不必因做爱而负有责任，以更明确的语言来界定两人的关系。维罗妮卡意识到了他的畏缩与自私，说：“你可以相信任何你愿意相信的事情。”</p><p>两人居然就这样在上床后立即分手了，维罗妮卡感觉极坏，不过她并没有记恨。维罗妮卡的慷慨可以从这件事上看出来：大学最后一年，艾德里安写信给托尼，表示想跟维罗妮卡交往，希望征得托尼的理解与同意。这封信本来是善意的见证，如果托尼回信，做出一些友好的表示，他们可以继续做朋友，结束托尼制造出来的他与维罗妮卡之间的敌对。但是托尼对这封本来不应引起误会的信件做了很多猜想，断定是维罗妮卡“想让我知道，她，维罗妮卡，是如何以旧换新的：换成了我最聪明的朋友，……，同时，也为了警告我：如果我打算去见艾德里安，她也会悠然到场——很明显，这是想让我不要和艾德里安见面。” 他习惯于从最坏的方面来认识别人的动机，一而再，再而三。</p><p>这是他的自白：“我觉得我有一种生存的本能，一种自我保护的本能。也许这就是维罗妮卡所说的胆小吧，但我称之为温和。”他回了信，并且交代了大致内容：他的顾忌和告诫，然后是他的祝福。他决心再也不受这两人的干扰，要把他们从自己的生活中清除出去。托尼自己受到了非正常情绪的伤害，但是他却断定维罗妮卡“很早以前一定受过伤害”。他并不是完全无意识的。他知道，很多人做出一个本能的决定，会找出一些大道理来解释自己的决定，并将结果称为常识。然而，托尼关于自己那封回信的记忆是否有误？</p><p>就在他大学毕业不久，传来艾德里安在剑桥自杀的消息。在这样的时候，他应该向维罗妮卡表达哀思，但是他是这样想的：“她肯定会觉得我很虚伪。如果我联系她，她要么会对我不理不睬，要么就会扭曲事实，那样我更没办法理清头绪了。”</p><p>小说第二部分是主人公退休之后的叙述。托尼志愿管理住处附近一家医院的图书室，穿梭于病房送书、收书。但是有一天，他的生活变了：他收到了法律事务所来信，原来维罗妮卡的母亲去世了，她五年前立下了遗嘱，要遗赠托尼五百英镑，并要把艾德里安的日记转给托尼保管。为什么有这笔遗赠？为什么维罗妮卡的母亲有权支配艾德里安的日记？正是这些问题启动了托尼对自己过往历史的修正，寻回了被记忆扭曲、删改甚至完全抽毁的片段。</p><p>无非出于好奇，他想知道维罗妮卡和艾德里安后来的生活，更想从维罗妮卡那里索取法律上说现在应该属于他的艾德里安日记。托尼又与维罗妮卡联系，即使碰了钉子，还是不依不饶。维罗妮卡不堪其扰，当面交给他一封信的复印件，那就是托尼当年写给艾德里安的所谓告诫与祝福。信上处处是平庸的恶毒，如不是亲眼所见，托尼难以相信。此时他带着羞愧回忆往事。多年封压住自己记忆的那块青石板渐渐被移开，托尼“拨弄污泥，去窥测根子”，开始真正认识他自己。</p><p>他的记忆之城出现了裂痕，原来坚实的地基动摇了。记忆作弄人，只说明时间是宰制一切的神力：“时间先安顿我们，继而又迷惑我们。我们以为自己是在慢慢成熟，而其实我们只是安然无恙而已。我们以为自己很有担当，其实我们十分懦弱。我们所谓的务实，充其量不过是逃避现实，绝非直面以对。”托尼突然明白，他以往的人生故事是讲给人听的，更是讲给自己听的，免不了有很多下意识的调整、修饰和剔除。维罗妮卡和艾德里安决定写信给托尼，告知他们的恋爱关系，绝非故意为之的残酷之举。托尼自问：<br>　　<br>我为什么要[在回信中]表现出很愤怒呢？因为受伤的自尊、考试前的压力、孤立感？这些全都是借口而已。不，我此刻没有感到耻辱，或者愧疚，而是我生命中很少有过的、比前两者更强烈的感觉：悔恨。<br>　　<br>托尼在自己这封粗鄙的信面前低下头来，他向维罗妮卡真诚致歉，并通过搜寻记忆深处角落里的点点滴滴来建构一个新的自我。原来他关注的焦点总是自己，现在他打听四十年来维罗妮卡和她家庭的境况。她父亲过世后，母亲把房子卖了，在伦敦买了公寓，后来收了房客。这些虽然是简约得不能再简约的陈述，而且没有任何抱怨或感伤，读者却不会不意识到一家人经济与社会地位的变化。维罗妮卡自己的居住区也是各种肤色的人杂居的，那区域在一般伦敦人心目中的地位不必明言。</p><p>新的细节的涌现还使托尼想到别人。中学同学罗布森因女友怀孕自杀了，只留下一张纸条，上面写着：“妈，对不起。”当时“铁三角”听到这消息非但毫无触动，甚至还妒忌乃至怨恨罗布森：为什么你这个小子有福气把女生肚子搞大？他们猜测死者的女友究竟是一本正经的处女还是脏婊子。现在托尼由自己的经历想到当年那位从未谋面的姑娘，想到她所受的压力，她的痛苦和社会对她的歧视，想到她腹中的胎儿如生下来已经年近五十。这时他想请求她原谅自己和朋友们的冷漠和恶毒，尽管她完全不知道。</p><p>最重要的是他渐渐想起一些朦胧的情愫在他和维罗妮卡之间萌发。有一天晚上，从来不喜欢跳舞的维罗妮卡心血来潮，竟然在他房间里踩着留声机上播放的歌曲拍子轻盈起舞。她跳得优美，让人怀疑她学过芭蕾；她跳得投入，“转啊转地就撞到我身上来了”。可是当时的托尼却是拘谨的，大概还在担心维罗妮卡嫌他音乐鉴赏的档次偏低。</p><p>同一件事出现于两个部分，内容却不能吻合。小说开头有六个场景，第四个是：“——一条河莫名地逆流而上，奔涌跃腾，在六七缕追逐的手电筒光线照耀下破光粼粼”。同样的场面又出现于小说收尾处，可见它特别的分量。在年轻的托尼的叙述中，某晚他和同学们到布里斯托尔旁的塞汶河河边观潮。他的记忆是这样的：“我们一干人在河岸上一直等到午夜以后，终于，等待获得了回报。”然后是小说中轰然作响的潮汐描写。维罗妮卡一直不在场。但是在四十年之后的回忆中，缺席的维罗妮卡出场了：托尼和维罗妮卡两人一起坐在河边一块湿漉漉的毯子上，手握着手，溶溶月色下潮汐汹涌卷来。同去的朋友们打着手电筒追随潮汐消失在夜色之中，他们两人依然在老地方坐着，谈论着世上不可思议之事。那天出行时，维罗妮卡还带上一只保温瓶，装满热巧克力饮料，想必是为她和托尼准备的，两人可以从同一个杯子里饮用。为什么前后记忆出现如此巨大的偏差？对此，小说的开端有所交代。那是第五个场景：<br>　　<br>——另一条河，宽阔而灰暗，一阵狂风搅乱了水面，掩盖了河的流向。</p><p>读完小说回到第一页，我们才明白这句话可能喻指托尼自己的生命之河，他的黑暗的自我，他意识层面之下的潜流。这“另一条河”在隐约规定着四十年前托尼的选择，使他永远失去了生活中的一种可能性，并且间接为相关人物（包括维罗妮卡和艾德里安）的命运负责。觉醒之后的“新乐音”让人感到温暖，它带来新生，也带来别样的痛苦。小说的“终结”表达了叙述者托尼的不安，也令读者不安：“有累积。有责任。除此之外，还有动荡不安。浩大的动荡不安。”</p><p>这条“宽阔而灰暗”的河流也可以象征艾德里安的情感世界。艾德里安究竟是怎样的人，依然不很确定。表面上看起来他见识不凡，极其冷静而富有理性，最后走上自杀之路，仿佛全部是出于自己的选择和意志。这只是托尼的印象而已，绝非艾德里安人生故事的全部。为了保留悬念，这篇序言不涉及小说最后披露的情节。</p><p>对一位上世纪60年代的中学生而言，艾德里安的历史观是非常新潮的。历史既不是胜利者的谎言，也不是失败者的自欺欺人，也许，“不可靠的记忆与不充分的材料相遇所产生的确定性就是历史。”我们可以说，巴恩斯几十年来都在试图回答英国史学家E. H. 卡尔提出来的问题：什么是历史？在讨论谁该为第一次世界大战爆发负责的时候，艾德里安说：“这一整个追究责任的行为难道不就是一种逃避吗？我们责备某个个人，其目的就是想为其余人开脱罪责。或者呢，我们归咎于历史进程，是想为一个个个体免责。抑或将一切归咎于一片混沌，那结果也一样。在我看来，似乎有——或者曾经有—— 一条个体责任链，所有责任不可或缺，但此链并非无限之长，不然谁都可以轻率归咎于他人。当然，我想要究责，这或许只是反映了我本人的心境，并非对事件的合理分析。”</p><p>因此，各种历史故事难免经过写作者的中介和建构：“我们必须了解历史学家的历史才能理解此刻放在我们面前的历史版本。”就《福楼拜的鹦鹉》来说，读者要了解故事的真相，还得进入叙述者、退休医生布雷斯科特的情感生活。在该书卷首，巴恩斯引用了福楼拜在致剧作家费多信中一句带有反讽意味的话：“当你为朋友立传时，一定要做得像你在为他报仇雪恨那样。”很多传记确实像是出自传主好友的手笔。司马迁为屈原、贾谊作传，何尝不是在为他们报仇雪恨？不是为他自己报仇雪恨？下意识地在传中为朋友报仇，是把意愿等同于事实。福楼拜这句话说明他不仅怀疑单一视角，而且怀疑历史是否可靠。然而常人读书往往被书上的文字牵着鼻子走。《十又二分之一章世界史》（1989）是巴恩斯的另一部杰作，小说一开头就颠覆了最权威的故事：《旧约•创世记》中的挪亚方舟。讲故事的细微的声音来自方舟上藏身于船体的木蠹。挪亚虚构出上帝以及上帝与他的契约，为的是自己可以随心所欲，为的是可以[永远]借着上帝的名义压迫或消灭他自己不喜欢的周边其他部落和民族。他才是真正的暴君。在这部书的“二分之一章”中，讨论着“爱”的主题的叙述者说：“我们编造出故事来掩盖我们不知道或者不能接受的事实；我们保留一些事情真相，围绕这些事实编织新的故事。我们的恐慌和痛苦只有靠安慰性的编造功夫缓解；我们称之为历史。”在《终结的感觉》里，托尼所面临的任务是透过记忆的迷雾认识他自己的“编织”，他那几乎是出于自我保护的潜意识中“安慰性的编造功夫”。</p><p>末了再提供一些与此书相关的花絮。巴恩斯这部新作是献给“帕特”的，即他夫人帕特•凯伐纳（巴恩斯在《福楼拜的鹦鹉》，之前出版过几本犯罪小说，都用了“丹•凯伐纳”的笔名）一位著名的文学经纪人，2008年10月死于脑瘤。小说家马丁•艾米斯（《幸运的吉姆》作者金斯利•艾米斯之子）一度也是凯伐纳的主顾。90年代中期，马丁•艾米斯中断与凯伐纳的合同，他与巴恩斯之间不免产生一点嫌隙，一时成为媒体上的热门话题。关注一下艾米斯关于穆斯林、伊拉克的言论，不难知道艾米斯与巴恩斯道不相谋。艾米斯不会从木蠹的角度来挑战自以为蒙上帝之恩的挪亚的权威话语。《终结的感觉》是帕特•凯伐纳逝世后巴恩斯的第一部小说，获2011年曼—布克奖，也可以让作者告慰亡妻。还要说一下，这一届曼-布克小说奖评委会主席是身份非常特殊的斯泰拉•雷明顿。她多年服务于英国军情五处，1992年任该处主管，1996年退休，出版了回忆录《公开的秘密》和侦探小说数种。一个享有世界声誉的国家级情报机构主管有如此难得的文学才能，在各国是少见的。“9.11”后，雷明顿曾批评美国，称布什政府反应过度。</p><p>《终结的感觉》也可以理解为巴恩斯对著名学者弗兰克•克莫德（1919—2010）的追忆。克莫德的批评著作《终结的意义：小说理论研究》（1967年，2000年再版）讨论的是末世论思维与阅读、写作小说的关系。克莫德认为，对终局的预测反过来会影响到对初始和中间阶段的理解，或者说，故事的结尾使得前面发生的一切具有意义。在巴恩斯这部同名小说第二部第一页，托尼设定自己站在未来的某一点回望过去，体会岁月或时间带来的新的情感。可以断定，巴恩斯得益于克莫德四十几年前的小说理论。但是对人写的历史的真实性，巴恩斯也许更加悲观：如果每个人都有私密的、未曾记录的历史，而“我”以及“我”的记忆又受制于时间，史学家怎么才能讲出可信的故事来？好在他竟从怀疑主义出发，让过去的深井发出确确实实的“新乐音”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（本文是陆建德为朱利安·巴恩斯《终结的感觉》所撰导言，该书2012年8月由译林出版社出版。）&lt;/p&gt;
    
    </summary>
    
      <category term="林中路" scheme="http://yoursite.com/categories/%E6%9E%97%E4%B8%AD%E8%B7%AF/"/>
    
    
      <category term="回忆" scheme="http://yoursite.com/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="个人历史" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%8E%86%E5%8F%B2/"/>
    
      <category term="自我" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>朱苏力:《自由秩序原理》读书笔记</title>
    <link href="http://yoursite.com/2019/02/14/Hayek-1/"/>
    <id>http://yoursite.com/2019/02/14/Hayek-1/</id>
    <published>2019-02-14T12:20:28.000Z</published>
    <updated>2019-02-15T14:15:50.847Z</updated>
    
    <content type="html"><![CDATA[<p>意志自由理论是统治阶级的一个发明。——尼采[1]</p><a id="more"></a><p>　</p><h3 id="哈耶克的进路"><a href="#哈耶克的进路" class="headerlink" title="哈耶克的进路"></a>哈耶克的进路</h3><p>　　</p><p>许多人曾经以不同的进路（理论的和诗意的）强调自由的重要性。如果仅仅就对促进人们充分理解自由的重要性并为之行动而言，哈耶克的所有著作也许并不比裴多菲的名章“生命诚可贵，爱情价更高，若为自由故，两者皆可抛”对于一个民族或一个普通人具有更大的作用。因为，从根本上看，自由于人之可贵并不在于它有一个重要的很能自圆其说的论证；而在于自由是人的生命的一种需求。自由对于人的意义不在于它是如何阐述出来的，而在于是否为人们以这种或那种方式感受到并得以坚持。无论中国近代以来追求民族独立的志士仁人，还是为了婚姻自由而私奔甚至不怕被沉塘的村姑，我想都是出于一种生命的本能而追求自由，并以自己的行动甚至生命实践着自由。在这个意义上，我认为，哈耶克关于自由主义的论证只是强调自由的进路之一，而不是唯一，它并不具有更本真的特点。世界可能会因为哈耶克关于自由主义的论证而多了几个哈耶克的理论信徒，但是世界不大可能因为哈耶克的论述而增加了对于自由的本能渴求。</p><p>我这样理解哈耶克，并不是贬低哈耶克，而是要使哈耶克获得他应得的地位。我并不否认哈耶克对于自由之阐述是有贡献的。但是这种贡献不过是如哈耶克在《自由秩序原理》的开篇中所言：“旧有的真理若要保有对人之心智的支配，就必须根据当下的语言和概念予以重述。人们在过去对旧真理所做的最为有效的表述，已日渐失用，因而也就不再含有明确的意义。尽管这些旧真理赖以为基础的理念之确当性一如往昔，但其语词（甚至当它们指涉的依旧是我们当下所面临的问题时）却已不再传递其往昔的信念；其论辩的情境也已不为我们所知悉；而且他们对我们所面临的问题亦几乎无力作出直接的回答。”[2]哈耶克无疑是20世纪的一位重要思想家，他为市场经济的辩护无疑是深刻的，同时是影响深远的。然而哈耶克的贡献就在于针对当代的一些问题，从自由主义的传统，以一套新的学术语言和概念对于自由作出了重述。因此，哈耶克为自由的辩护也许只有在自由主义的论述传统之中才是独步20世纪的。</p><p>哈耶克自由论述的独到之处，在我看来，在于他的论证进路是个体主义的知识论，而不是或不限于传统的政治哲学。他的基本命题是，自由使得每个个体都能更充分地运用自己的知识，进行空前的实验和创造，积累对于自己有用的知识，但由于人类具有模仿能力，个体也就是在积累对于人类有用或潜在有用的知识，他人和人类社会可能以此来应付来自各方面的挑战和危险。[3]例如，在一种群居形成习惯的社会中，一个人独居寡处可能会被这个群体的其他人视为怪僻、异端，但是，按照哈耶克的论证逻辑，个体选择的这种生活方式不仅创造了一种替代的生活方式，更重要的是，一旦发生一场人们无法事先预知的迅速传播的瘟疫，仅仅由于这样一种生活方式的存在，不仅这个个体可能得以存活下来，而且他的生活方式有可能为他人效仿（而不是“知道”或“理解”――在哈耶克看来，人的更大能力是效仿，而不是知道），因此可能使这个群体免于灭顶之灾。同样的道理，个体的知识和技术创新有可能为人类改善自己的生存状态而利用。因此，这种逻辑不仅对于一个群体是如此，对于一个社会，甚至对于整个人类均如此。因此，自由在哈耶克那里，不是作为一种抽象的绝对价值出现的，而是从其对于人类的生存价值上分析的；在这一分析框架中，自由永远是人类生存的backup,是一种战略储备。在这个意义上看，哈耶克的自由是功利主义的，而不是形而上学的。这种为自由的论证或辩护的确具有很强的说服力。据我有限的阅读还没有哪一位学者曾经在这一高度上论述过自由对于人类生存和发展的意义，一般只是从自由能带来社会繁荣兴旺这一点上论述（例如密尔），或者强调自由本身对于个体的价值（例如康德）。</p><p>哈耶克的这一基本命题至少有两方面的假定，一方面是关于知识主体的，即不可能有一个全知全能的人，个体的理性总是有限的，即有限理性的假定。这一点已经受到人们的高度重视。但是，在我看来，哈耶克的论述中还隐含了一个关于人类生存状态和环境的假定，即时间和空间都并非一成不变的，我称之为时空非均质化假定。这个假定是非常重要的，在一定意义上，这一假定甚至是前一假定的前设，如果接受了这一假定，甚至必定推出有限理性或理性不及的假定。对于这后一假定，我将在后面论述。</p><p>　　</p><h3 id="迪尔凯姆的进路"><a href="#迪尔凯姆的进路" class="headerlink" title="迪尔凯姆的进路"></a>迪尔凯姆的进路</h3><p>　　</p><p>哈耶克的论证是强有力的。但是，如前面所强调的，强调自由的重要性，这并不是唯一的论证进路。实际上，从其他理论进路，其他学者曾经或者也可以得出同样的结论。据我有限的阅读，我想举两个例子，一个是迪尔凯姆以及其后法国学者，另一个就是我们的常识进路——“情况是不断变化的”。</p><p>迪尔凯姆在《自杀论》和《社会学方法的准则》两书中都提出过与哈耶克相当类似的观点，尽管是从一条与哈耶克相对立的进路――总体主义的（holistic）进路，并且没有直接讨论“自由”的问题。[4]迪尔凯姆认为，所谓违法犯罪不过是对集体形成的一种惯常的行为习惯和道德（集体良知）的违反，这种违反，在每个社会中每天都在发生，并往往受到制裁。但是他认为，其实犯罪“为必要的改革直接作了准备。哪里有犯罪，哪里的集体感情就处于为形成新的形式所必要的可塑状态”；他特别举了苏格拉底为例，认为“尽管按照雅典的法律，苏格拉底就是一个罪犯，对他的判决也完全正确。然而他的罪行，即他的独立的思想，不仅对全人类有益，而且对他的祖国也是有益的……，他的罪刑为雅典人所必须的新的道德和新的信仰的形成作了准备。”因此迪尔凯姆认为，这种犯罪是“社会生活的正常成分。”[5]他还曾指出“如果考虑到社会在同一时期里不仅必须面对各种不同的情况，而不可能保持一成不变，那么这种必要性就更加明显了。……如果现在没有未来的萌芽，那就不可能有未来。”[6]特别要指出的是，哈耶克在强调自由的时候，并不仅仅强调思的自由，而是更强调做的自由，[7]实际也就是强调竞争的自由。因此，在这个关于违背常规对于人类生存和繁荣的意义问题上，迪尔凯姆和哈耶克的论证的实质性要点是一致的。</p><p>当然，迪尔凯姆讨论的是社会生活的规范性与个体创新之间的关系，而不是“自由”。尽管如此，这个问题实际上可以转化成哈耶克笔下的自由问题的讨论。并且，在一定意义上，至少在我看来，迪尔凯姆甚至更为深刻。哈耶克强调自由无疑是对的，他看到个体自由在社会中可能受到限制，个人的创造力可能受到压制，但他不承认这是一个难以避免的两难，而更多倾向于将“自由”在近代社会之丧失视为一种虚假个人主义欺骗的结果，一种思想和观念的结果。他的解决办法是在政治哲学层面提出一个法律下的自由制度。但是这种解决问题的办法实际只是在形而上的层面，无法落实到实践层面；他只能提出一些原则，而无法落实在操作层面。他解决问题的办法是追求自由概念上的包容性。在这个意义上，他的确是、而且也仅仅是18世纪自由主义政治哲学的后人――他的进路限制了他对现代社会科学的更深刻全面的理解和把握。尽管他是经济学家的重镇，但是一旦进入社会理论和法律理论问题时，他基本停留在18世纪。迪尔凯姆的深刻之处在于他发现这种社会有序与个人自由之间的矛盾是一种难以在理智、智识甚或制度层面完全解决的问题，是一种人类的近乎“荒诞”的悖论的或两难的生存状态。这并不是说迪尔凯姆认为社会规范性与个人自由就一定是对立的，迪尔凯姆和哈耶克一样都意识到社会规则会促进自由；但是，哈耶克从传统的自由主义政治哲学进路没有看到的，而迪尔凯姆特别是迪尔凯姆的后代法国学者例如福柯和布迪厄从社会科学研究中看到了的是，社会如果要成为一个社会，事实上不可能在一切方向上发展，无论在社会资源、知识路径、社会结构上都不可能，因此社会即使在促进最大可能的自由时，也必定会有自由的“机会成本”的问题，而且我们无法事先计算这种自由的机会成本。</p><p>迪尔凯姆的这一洞察到了福柯这一代就更为明显了。福柯的大量著作都充满了对那些被压抑的声音的同情，展现出他的知识考古所发现的被埋藏的那些知识，他更展现了现代资本主义社会的自由是如何在征服上建立起来的。这就是福柯的名言所概括的，“启蒙运动发现了自由也发明了训诫”。[8]布迪厄关于社会结构与人的能动性之间的辩证法，所针对的问题也是类似的问题，尽管布迪厄讨论的不再是迪尔凯姆的具体的自杀或犯罪问题，但布迪厄不过是在法国的迪尔凯姆传统中以一种更为理论化的框架重构了迪尔凯姆的问题。[9]</p><p>　　</p><h3 id="常识进路"><a href="#常识进路" class="headerlink" title="常识进路"></a>常识进路</h3><p>我们再转到我所说的“常识进路”，即强调“情况是不断变化的”，当然，这里的“情况变化”不仅是时间上的，也是空间上的。如果从这一进路看，甚至无需假定个体的有限理性，我们也将同样得出自由重要的结论。相反，所谓关于人的理性有限或理性不及，都不过是情况不断变化的结论。在空间上，由于各地的情况不同，因此，对于一地一事知识之了解不能压制他人对于此地此事之了解，在时间上，由于个人生命之有限，前人对于某地某事之做法不能排除后人对于某地某事之做法。如果按照中国人的这种常识，那么所谓理性有限不有限、及与不及的问题几乎可以完全无关。</p><p>事实上，如果在一个更大的文化传统中看，所谓理性有限或理性不及这个概念也许只有在西方传统中才是有意义的，甚至才可能发生。因为，在西方的犹太－基督教文化传统中，一直预设了一个无所不在、无所不能、无所不知的上帝。此后，由于所谓的“人”和“理性”的发现，一个大写的理性或人又先后取代了先前上帝的位置；甚或可以说，人又“按照上帝的面目创造了自己”。因此，只有在这样的文化传统中，进入现代之后，才有必要、同时也才有可能提出理性是否有限或有所不及的问题。而在中国传统中，从来没有构建出来这样全知全能、理性无际的神人，中国传统只有圣人，但这只是道德上的，而不是智识上的，即使是圣人也强调的是“知之为知之，不知为不知，是知也”。正因为中国人这种关于世界“情况不断变化”的前提性判断，这种强调面对“三十年河东，四十年河西”的实践理性，因此，中国人似乎历来不大相信原则（道德原则似乎除外），人们总是强调自己去面对现实，解决问题，获得真知，获得创新。这种思路就是具体问题具体分析、具体解决的思路，就是所谓“普遍真理与具体实践相结合”的思路，这就是“实事求是”的原则。事实上，这也是中国近二十年来改革之所以取得相当成果的一条基本经验，用中国人的话来说，“尊重人民群众的首创精神”（这近乎哈耶克的“自发秩序”）。尽管其论证方式完全不是哈耶克的自由主义进路，完全不需要有限理性的假定。</p><p>因此，哈耶克对于自由的论述很难说是一种“最正确的”“最真实的“进路，因为并不存在这样的进路。“太阳底下无新事”，“条条大路通罗马”。</p><p>　　</p><h3 id="自由的两难"><a href="#自由的两难" class="headerlink" title="自由的两难"></a>自由的两难</h3><p>但是，在我看来，哈耶克并没有充分回答为什么自由会被“遗忘”，为什么“传统的语词和表述会无力对当下的问题作出直接回答”。对于这个问题，哈耶克的基本观点是，由于一种虚假的个人主义，一种欧陆理性主义的个人主义偷梁换柱篡改了真正的自由主义。这种分析有真确的成分，但仅仅从思想传统上辨析，不能令人信服，而且也违背了哈耶克自己关于制度是行动的产物的命题。我们可以沿着哈耶克的逻辑来分析哈耶克，我们可以发现其在理论上难以自恰或有不少虚构。哈耶克认为，在英美的自由主义传统中，人们有更多的自由，可以产生更具生命力和活力的自发秩序，保持社会的高度自由状态。但是哈耶克所批判的福利国家、“社会主义”和国家干预的因素也同样在英美发展起来了，这很难说是为一种虚假个人主义所蒙骗的结果，如果哈耶克坚持自己的理论，他就应当承认，这种所谓的“奴役之路”也是一种“自发秩序”。在这里，不分析社会历史条件的演变，而仅仅分析观念或学说的演变，哈耶克对历史难题选择的是一个最为小儿科但未必能令人信服的答案，他的进路仍然是18世纪政治哲学家的进路，尽管他是一位重要的经济学家，但是他对19和20世纪的社会科学研究成果显然是缺乏了解或缺乏重视的。</p><p>如果仅仅从逻辑上看，自由之所以被“遗忘”（其实未必会被遗忘），就是因为自由有一个内在的两难。简单地说，自由对于一个个体来说就是可以不断创新，不断竞争，按照自己的意愿进行社会交往。但是一旦要进行社会交往，就必须要有一些起码的规则，也就是要形成哈耶克也不得不认可的那种法律下的自由（freedomunderlaw）。规则并不等同于剥夺自由，相反，规则往往是自由得以构成的条件之一；即“有所不为才能有所为”，但是，它也毕竟要求“有所不为”。因此，不可否认，规则对于自由创新是有限制作用的。如果要写诗，就不能像写小说那样写；用中文交流就必须不能夹带太多英文单词同时使用俄文语法。并且这种规则必须具有一定的稳定性和持久性。而稳定性和持久性实际上就是要限制创新，排除创新。而且，由于事先人们并不知道什么样的创新是对未来有意义的，这种限制和排除也未必就是不正当的、恶意的或毫无道理的。因此，即使是一种起初自由的制度，如果没有外来的刺激，没有异端，长期下去，也会逐步僵化起来，缺乏新的包容性，对某些创新变得不自由。因此，就现实生活来说，不可能存在一种各种创新创意层出不穷永远竞争的自由状态，这种状态如果有，也是人们无法忍受的。因此在人的生命对于未来之预期中，蕴含着一种深刻的保守即希望相对简单、稳定和稳步发展的倾向。而这种倾向本身是对自由和创新的一种潜在的威胁。</p><p>哈耶克似乎没有看到现实生活中这一两难问题；或者看到了，也没有真正理解这个问题。他只是提出了法律下的自由这一概念，因此在思辩层面“回答了”这一问题。但是，这种思辨式的答案无法回答现实中的具体难题。因此在这一点上，我认为迪尔凯姆的思想要比哈耶克更为深刻。在迪尔凯姆看来，个体的创造力往往会被一个社会视为某种异端，甚至是犯罪，而且社会也的确有理由这样认为；但恰恰是这种创造力是未来的种子，是社会变迁的开始，是对社会的重塑。而哈耶克在《自由秩序原理》的第二部分中，并没有展示人类自由的这种无法避免的两难，而是试图用法律下的自由、自由秩序、自由的原则这样一些大的原则来描述一个自由的乌托邦同时也是一个法律的乌托邦。事实上，这也是哈耶克为什么在这一部分总是言不及义，无法讨论具体的法律问题，而只能限于重述一些永远正确的“大词”（波普尔语）或原则，一些法理学的常识或理想的根本所在。[10]在我看来，这第二部分是缺少份量、最缺少干货的一部分。[11]</p><p>当然，有人可能会反驳我说，哈耶克并不要对法律下的自由作出详尽分析，他只是提出一个自由的理想，一个自由的乌托邦，以鼓舞人们为此努力。这种反驳是无力的，是偏袒的，是无原则的。如果仅仅是想提一个乌托邦，我不知道柏拉图的理想国或孟子的“老吾老及他人之老，幼吾幼及他人之幼”或基督教的天国，甚至哈耶克批评的社会主义计划经济有什么地方弱于哈耶克。固然，作为理论应当具有独立于现实的一面，但是，如果一个理论完全不考虑实际操作问题或者实际上无法操作和实现，那将无非是一种煽情，和“若为自由故，两者皆可抛”，与“人生来自由，却无往不在枷锁之中”之类的命题毫无两样。</p><p>　　</p><h3 id="法治"><a href="#法治" class="headerlink" title="法治"></a>法治</h3><p>哈耶克在第二部分中集中讨论了自由与法律。其中有不少重要的、富有启发性的然而是自我重复的思想，例如法律与立法的区别，自发秩序等等。然而，令人不满意的是，恰恰是在法律和法治问题上，他并没有什么新的可以称之为他的贡献的。他基本是重述了到20世纪末已经成为常识然而未必真确的一些原则。特别是在第10章中，他似乎要界定法律的特性或者是法治的特性，然而，他的分析就总体说来，没有任何独到之处。</p><p>他列举了“真正的法律”的一些特性：抽象的一般性规则，具有公开性、可预测性，法律面前人人平等，不溯及即往。然而这几点不仅为受哈耶克批评的戴雪等人早就系统指出，[12]而且这些特点若要仔细分析起来，实际就是一点，强调规则的统治，其目的和功能都是为了和使得人们可以根据规则作出合理预期和安排，并在规则的制约下，同时也是在规则的促成下充分运用个体的知识。[13]</p><p>例如，法律的抽象性和一般性或普遍性原则，就是说一个法律不能是对个具体问题的决定，而必须是针对所有人的某一类问题。事实上，只有在这个意义上的法律，才可能称之为规则。如果总是针对一个具体事件或某个具体个人，这样的“法律”就是一个行为（act），就是哈耶克所说的命令，而无法成为规则。又如法律公开的原则，即制定法必须颁布，法律必须为人们所知晓。[14]但是法律为什么必须公开，必须为人们所知晓，这里的核心问题也许并不在于法律是否“颁布”本身这个行为，重要的在于颁布在理论上可以说是使人们了解法律的最便捷的途径，尤其是在一个以文字作为基本的交流手段的社会中。因此，我们可以看到无论强调的是普遍性还是公开性或可预知性，实际上真正重要的都是法律便于人们掌握、预测和利用。而只有法律作为规则时，才是便利的。</p><p>法律面前人人平等原则实际是法律普遍性的另一种表述形式，因为只有对人们同等适用的法律，才有可能并便利人们了解和预测，人们才可以从他人如此行为的得失中预测自己的类似行为的后果，从而了解规则。否则的话，人们就会因不了解法律对自己的要求是什么、自己应如何行为，而陷于无所适从的境地。又如法律不溯及即往的原则，也正是因为人们无法依据尚未形成的法律规则来决定自己的行为。而司法独立则被视为规则性得以真正贯彻、落实的保障。从这一方面看，所有这些特点都可以用信息经济学中的信息费用来解释：规则性是节约信息费用的，规则是有效率的。如果从这一角度看，我们也还可以进一步理解，号称不成文法的普通法国家，为什么可以没有法律颁布的问题，以及在小型社会之中，也没有成文法，为什么仍然可能有法律下的自由。这就是因为，在这里，尽管没有成文法，人们也仍然可以依据他们的习惯行为和一般智识、根据他人的行为后果预测法律将如何要求。事实上，现代各国的法律实践也总是认为，任何个人不能以不了解法律而作为违法的借口。因此，法律的所有这些特点以及法治的这些标准，都是为保障人们预期、运用个体知识的不同说法而已，而并非什么可以分解的特点。这种分析本来应当成为哈耶克的知识论进路研究自由与法律的自然延伸，然而，哈耶克不知是放弃了还是并不理解从他自己的知识论进路研究法治的巨大可能性。</p><p>由于放弃了这一可能性，哈耶克实际上就只能回到传统的政治法律哲学，在法律概念或特性上兜圈子了，并试图依据这些所谓的原则来规定法律或评价。由于不熟悉法律问题，他甚至得出一些荒唐的结论。例如他批评霍姆斯关于一般性法律命题并不决定具体案件的观点，[15]认为这是进步党人（在某种意义上，这是社会主义思潮在美国的一种表现形态）的观点。这种将法官从长期司法实践中获得的真知灼见意识形态化的做法充分反映了一个脱离法律实践的人可能会有什么样的偏见，并且会堕落到何等程度。在哈耶克看来，一般性规则似乎是永远是明确的，所有的案件也总是齐整地落入这个或那个众口称是的规则之内，因此必定可以用一般性法律命题来裁定具体案件。但是事实并不如此，每个案件都可能涉及到诸多规则，或者因为当事人各方在规则指导下利用他们个体的知识而不得不涉及到诸多规则，甚至有许多案件是两可的。例如商家完全可以以保护私有产权的法律而反对知假买假的做法，王海这样的消费者也完全可以诉诸同一规则和消费者权益保护法而声称自己的权利。在这种境况下，一般性的抽象法律命题就很难解决具体问题。解决具体纠纷时究竟运用哪个规则，因此，就无法与审判者的判断相分离。空谈法律的基本特点和一般原则至少在很多时候并不能解决任何实际问题，就如同仅仅懂得保持平衡之原理的人未必能骑好自行车一样。世界不会因为有更多的人在理论层面懂得了某个原则而变得更好。在这一点上，哈耶克似乎完全忘记了自己几十年前研究得出的并在此书中多次重复的结论：市场、法律、语言和国家都是人们行动的产物，而不是对原则思考的产物。[16]</p><p>由于对于自由原则的高度重视，哈耶克得出的另一个重大的然而又是有重大问题的结论，这就是他对程序的轻视，以及逻辑上的一系列自我矛盾。哈耶克在许多地方主张要区分形式合法和实质合法，强调法律必须坚持自由的原则，并引述了亚里士多德的法治是良法之治的观点。如果仅仅在思辨层面，这并不成问题，但是哈耶克将这种观点延伸到司法实践中，这就造成了依据以自由为核心的“高级法”对立法进行实质性审查可以保证法律不出差错的观点。当然，这也许还不是一个问题，如果有一个真正了解高级法的全知全能且没有偏私的法官或法院的话。问题在于哈耶克将美国最高法院当成了这样一个具有神奇才智的范例。这如果不是无知，那么就是欺骗。因为美国最高法院的大法官们也是一些“人”组成的，他们大多是由历届总统从自己党派中挑选的，其中一些人往往会为了党派的利益而决一死战。[17]在许多重大问题上，最高法院都是分裂的，甚至是严重分裂的。例如受哈耶克批评的罗斯福新政的“社会主义”措施，为最高法院之否决仅仅是以4：5票之差，而此后不久近乎同一的法案在罗斯福“重新包装最高法院”的威胁之下又以5：4获得通过。这就表明哈耶克所主张的以自由的基本原则、以高级法来审查法律并不像哈耶克所描绘的那样可以信赖。另一个典型的例子则是DredScott案件，此案中联邦最高法院，在审查美国联邦政府立法之后，竟然肯定了一个因来到北方而成为自由人的黑人返回南方后仍然是奴隶，并因此认定联邦的有关废除奴隶制的立法（密苏里合约）违宪。此外，尽管哈耶克大力批评法律仅仅重视程序性合法或形式合法，而事实上，他所强调的“真正的法律”的那些特点本身都是一些形式化的特点，并且他所赞美的司法审查制度本身也是一种程序化的制度。</p><p>在第二部分中，诸如此类的事实、分析上的问题以及自我矛盾之处相当多。</p><p>　　</p><h3 id="哈耶克的失足之处"><a href="#哈耶克的失足之处" class="headerlink" title="哈耶克的失足之处"></a>哈耶克的失足之处</h3><p>这个小标题本身也许就有问题：也许哈耶克根本就没有失足，因此谈不上失足之处。尽管有这种可能，我还是认为哈耶克在这本著作中违背了他的知识论的要点。尽管哈耶克认为人的理性是有限的，有些问题是无法言说的，但是哈耶克在许多问题上似乎表现出一种“致命的自负”（借用他自己的一本书名），即认为自己发现了社会发展的真理，关于自由的真理，这最典型地（或之一）表现在他第一章中对作为单数的自由与复数自由的辨析上。这种辨析是需要的，也是有一定道理的，但是字里行间，他充分展示了那种霸气，即只有自己所理解的自由才是真正的自由，是自由的精髓，而其他都是假的或误解。他相信天才，过分地不相信所谓的即时民主，都是这种智识上的精英观念的体现。我当然承认人的智识上有差别，也不大相信民主可以解决一切问题；但是，如果有一点休谟传统的怀疑主义（这是哈耶克尊敬的传统），那么在这些问题上，我们同样应当有一点自省。</p><p>哈耶克的另一个失足之处可能来自于他对计划经济的正确批判。由于在这一方面判断的正确，很可能导致他对自己判断所依赖的某些思想根据统统确信无疑。事实上，一个正确的判断完全可能是一个系列错误的结果。一个人相信气功有疗效并且确实在气功锻炼中病愈的人也许“证明了”他关于自己的病会好的判断是正确的，但并不因此证明了他关于气功治病的确信和推理是正确的。人们常常因为而且完全可能因为自己某个判断得到“证实”而误认为自己的理论资源都是正确的。哈耶克关于计划经济的判断可能是来自他的理论，但未必如此；在我看来，更可能是洞察在先，而论证在后。在这个意义上，任何证实都是可疑的，都不具有终结性；也正是看到了一点，波普尔反对证实论，而主张证伪论，尽管在另一个意义上证伪也仍然是证实。</p><p>上述分析，并不是要贬低哈耶克。而是要将哈耶克放在一个知识传统和脉络中来理解哈耶克，从而看到他的贡献和他缺陷。同时这也是坚持哈耶克以及上面所提到的其他进路的基本命题，即关于自由重要性的论证并非只有一条进路，而是可以并且也应当有竞争的。人们对于自由之理论论证之接受，如前所说，很大程度上不取决于该理论的论证是否周密、详尽，而在于他们当下的欲求；并且取决于理论范式的简洁和畅销（这在科学上常常如此），并因此也取决于理论的路径依赖。如果我们在获知哈耶克对自由的出色分析之后，误以为这就是对自由的唯一论证进路，我们就很可能会忘记哈耶克关于自由之真谛，而成为一个哈耶克教条主义者。</p><p>为了强化这一点，我们还必须注意，哈耶克关于自由的理论和论证之所以获得了世界的重视在很大程度上是因为他深刻地看到了、预见了计划经济的失败。这当然是了不起的。但是，正是由于这一点，我才认为，并不一定是由于他的理论深刻，最终使得人们最终理解了他的理论的重要，而是因为世界这个大文本改变了他的小文本的意蕴，是一系列非话语的实践改变了其话语的意义，改变了我们对他的理解和解释。</p><p>写到了这里，获得这样的感想，是我自己也未曾料想到的。但是我并不想因此否定哈耶克，哈耶克的许多洞见仍然是深刻的，但是，就到目前为止我的一些阅读来看，他最有独创意义的并可以称之为贡献的是他的知识论，而不是他的政治哲学和法律哲学。</p><p>　　</p><p>　　1998年2月25－26日于北大蔚秀园</p><p>　　*原载于《中国社会科学季刊》（香港），1998年春季号。</p><p>　　[1]FriedrichNietzsche,TheWandererandHisShadow,inHuman,AllTooHuman,trans.byR.J.Holli<br>ngdale,CambridgeUniversityPress,1986,no.9,p.305.</p><p>　　[2]《自由秩序原理》，邓正来译，三联书店，1997年，页1－2。</p><p>　　[3]《自由秩序原理》，第2－4章。</p><p>　　[4]迪尔凯姆，《自杀论》，冯韵文译，商务印书馆，1996年；《社会学方法的准则》，狄玉明译，商务印书馆，1995年。</p><p>　　[5]《社会学方法的准则》，页88，89。</p><p>　　[6]《自杀论》，页346。</p><p>　　[7]《自由秩序原理》，页34。</p><p>　　<br>         [8]MichelFoucault,DisciplineandPunish,theBirthofthePrison,transl.ByAlanSheridan,VintageBooks,1978,pp.222.</p><p>　　[9]当然这一传统甚至可以追溯到更早期，追溯到卢梭的名言“人生而自由，却无往不在枷锁之中”。这里的枷锁，据萨拜因，实际是指社会的风俗习惯、传统文化，但并不一定具有贬义。见，《政治学说史》下册，刘山等译，商务印书馆，1986年，第29章。</p><p>　　[10]“我们由此进入了法理学领域的探讨，但我们将从历史的角度去关照其间的问题。然而需要强调指出的是，我们对保障个人自由的各种制度的进化过程所持的认识，主要依凭的既非法律家的观点，亦非历史家的观点。我们所关注的乃是一种理想的发展，然而必须指出的是，在过去的历史长河中（除个别时期以外），人们只是模糊地认识到了这一理想或者说不尽完善地实现了这一理想”。《自由秩序原理》，页7。</p><p>　　[11]不尽如此，哈耶克的这一部分甚至使我怀疑他对法学研究是否有足够的能力和真诚。这两点指责是严厉的，但并不是苛刻的。哈耶克根本没有理解法理学的一些基本问题，还是停留在前法学阶段的阶段；例如关于法律的基本特点的分析，所谓普遍性、一般性、公开性、可预知性，法律面前人人平等，法律不溯及即往等。他对霍姆斯、戴雪的批评都是“站着说话不腰疼”，不着边际的批评。他所引用的学者或语言显然太随意和太selective。他对约翰·马歇尔大法官的赞美和引用完全无视马歇尔的所作所为。他甚至隐含地默认了以司法审查方式肯定美国南方奴隶制的DredScott案件，但又不提出自己的理论论证。他完全无视美国最高法院是一个由不同意识形态和政治倾向的人组成的机构，而将它视为一个有集体意志的人格，这也完全违反了他的个体主义研究进路。这种例子太多了。在这里，我并不是仅仅因某些问题质疑哈耶克，而是使我对这一部分所体现的哈耶克的学术品格产生根本怀疑――我更倾向认为他是自由主义的辩护士，而不是自由主义的思想家。</p><p>　　[12]A.V.Dicey,IntroductiontotheStudyoftheLawoftheConstitution,Macmillan,1968,pp.188-196，提出的法治三原则，大致是，法律必须事先确立，法律面前人人平等，司法决定法律适用;LonFuller,TheMoralityofLaw,rev.ed.,YaleUniversityPress,1969，提出了8项原则：法律的一般性、公布、不溯及即往、确定、不自相矛盾、可行、稳定和实际落实；JohnFinnis,NaturalLawandNaturalRights,ClarendonPress,1980,基本重复了富勒的原则，增加了规则限制的裁量和官员守法两点</p><p>　　[13]因此，美国最高法院大法官斯葛利亚经过多年司法之后得出的结论是：法治就是规则之法（theruleoflawasalawofrules）。见，AntoninScalia,“TheRuleofLawasaLawofRules”,UniversityofChicagoLawReview,vol.56,no.4,1989,pp.1175。</p><p>　　[14]这一点，如今――由于法律太多――已经为法律必须可能为人们所知晓所替代。大量的立法，实际上包括律师都不可能完全在不查阅法律的情况下知晓（因此现代社会需要律师，甚至律师也需要律师），更不用说常人了。</p><p>　　[15]《自由秩序原理》，页194。</p><p>　　[16]哈耶克，《个人主义与经济秩序》，贾湛、文跃然等译，北京经济学院出版社，1991年，页7以下。</p><p>　　[17]最典型的例子就是哈耶克赞扬过的Marburyv.Madison案件；关于此案的背景，请参见，苏力，“制度是如何形成的”，《比较法研究》，1998年1期。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;意志自由理论是统治阶级的一个发明。——尼采[1]&lt;/p&gt;
    
    </summary>
    
      <category term="哈耶克" scheme="http://yoursite.com/categories/%E5%93%88%E8%80%B6%E5%85%8B/"/>
    
    
      <category term="自由" scheme="http://yoursite.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="法治" scheme="http://yoursite.com/tags/%E6%B3%95%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>宗白华：歌德之人生启示</title>
    <link href="http://yoursite.com/2019/02/10/Holzwege-4/"/>
    <id>http://yoursite.com/2019/02/10/Holzwege-4/</id>
    <published>2019-02-10T12:20:28.000Z</published>
    <updated>2019-02-13T15:12:49.634Z</updated>
    
    <content type="html"><![CDATA[<p>人生是什么？人生的真相如何？人生的意义何在？人生的目的是何？这些人生最重大最中心的问题，不只是古来一切大宗教家哲学家所殚精竭虑以求解答的。</p><p>世界上第一流的大诗人凝神冥想，深入灵魂的幽邃，或纵身大化中，于一朵花中窥见天国，一滴露水参悟生命，然后用他们的生花之笔，幻现层层世界，幕幕人生，归根也不外乎启示这生命的真相与意义。宗教家对这些问题的方法与态度是预言的和说教的，哲学家是解释的和说明的，诗人文豪是表现的启示的。</p><a id="more"></a><p>荷马的长歌启示了希腊艺术文明幻美的人生与理想，但丁的神曲启示了中古基督教文化心灵的生活与信仰，莎士比亚的剧本表现了文艺复兴时人们的生活矛盾与权力意志。</p><p>至于近代的，建筑于这三种文明精神之上而同时开展一个新时代，所谓近代人生，则由伟大的歌德以他的人格、生活、作品表现出它的特殊意义与内在的问题。</p><p>歌德对人生的启示有几层意义，几种方面。就人类全体讲，他的人格与生活可谓极尽了人类的可能性。他同时是诗人、科学家、政治家、思想家，他也是近代泛神论信仰的一个伟大的代表。他表现了西方文明自强不息的精神，又同时具有东方乐天知命宁静致远的智慧。</p><p>德国哲学家齐美尔（Simmel）说：“歌德的人生所以给我们以无穷兴奋与深沉的安慰的，他只是一个人，他只是极尽了人性，但却如此伟大，使我们对人类感到有希望，鼓动我们努力向前做一个人。”我们可以说歌德是世界一扇明窗，我们由他窥见了人生生命永恒幽邃奇丽广大的天空！</p><p>再缩小范围，就欧洲文化的观点说，歌德确是代表文艺复兴以后近代人的心灵生活及其内在的问题。近代人失去了希腊文化中人与宇宙的谐和，又失去了基督教对一超越上帝虔诚的信仰。人类精神上获得了解放，得着了自由；但也就同时失所依傍，彷徨、摸索、苦闷、追求，欲在生活本身的努力中寻得人生的意义与价值。歌德是这时代精神伟大的代表，他的主著《浮士德》是这人生全部的反映与其问题的解决（现代哲学家斯宾格勒 Spengler 在他名著《西方文化之衰落》中名近代文化为浮士德文化）。歌德与其替身浮士德一生生活的内容就是尽量体验这近代人生特殊的精神意义，了解其悲剧而努力以解决其问题，指出解救之道。所以有人称他的浮士德是近代人的《圣经》。</p><p>但歌德与但丁、莎士比亚不同的地方，就是他不单是由作品里启示我们人生真相，尤其在他自己的人格与生活中表现了人生广大精微的义谛。所以我们也就从两方面去接受歌德对于人类的贡献：</p><p>一、从他的人格与生活，了解人生之意义；<br>二、从他的文艺作品，欣赏人生真相之表现。</p><h3 id="一、歌德人格与生活之意义"><a href="#一、歌德人格与生活之意义" class="headerlink" title="一、歌德人格与生活之意义"></a>一、歌德人格与生活之意义</h3><p>比学斯基（Bielschowsky)在《歌德传记•导论》中分析歌德人格的特性，描述他生活的丰富与矛盾，最为详尽（见拙译《歌德论》）。但这个矛盾丰富的人格终是一个谜。所谓谜，就是这些矛盾中似乎潜伏着一个道理，由这个道理我们可以解释这个迷，而这个道理也就是构成这个谜的原因。我们获得这个道理解释了这个谜，也就可说是懂了那谜的意义。</p><p>歌德生活中之矛盾复杂最使人有无穷的兴趣去探索他人格与生活的意义，所以人们关于歌德生活的研究与播述异常丰富，超过世界任何文豪。近代德国哲学家努力于歌德人生意义的探索者尤多，如齐美尔（Simmel)［Georg Simmel, 1858-1918. 通译齐美尔。德国哲学家，社会学家，生命哲学代表人物之一。主要著作有《论社会的区别》、《伦理学导论》、《历史哲学问题》、《叔本华和尼采》、《社会学的根本问题》、《人生观》等］、李凯尔特（Rickert)［Heinrich Rickert, 1863-1936. 德国哲学家，新康德主义西南德学派主要代表人物。主要著作有《自然科学概念形式的界限》、《文化科学和自然科学》、《历史哲学问题》、《哲学体系》、《现代文化人康德》等］、龚多夫（Gundolf)、寇乃曼（Küehnemann)、可尔夫（Korff)等等，尤以可尔夫的研究颇多新解。我们现在根据他们的发挥，略参个人的意见，叙述于后。</p><p>我们先再认清这歌德之谜的真面目：第一个印象就是歌德生活全体的无穷丰冨；第二个印象是他一生生活中一种奇异的谐和；第三个印象是许多不可思议的矛盾。这三种相反的印象却是互相依赖，但也使我们表面看来，没有一个整个的歌德而呈现无数歌德的图画。</p><p>首先有少年歌德与老年歌德之分。细看起来，可以说有一个莱布齐希大学学生的歌德，有一个少年维特的歌德，有一个魏玛朝廷的歌德，有一个意大利旅行中的歌德，与席勒交友时的歌德，艾克曼谈话中的哲人歌德。这就是说歌德的人生是永恒变迁的，他当时朋友都有此感，他与朋友爱人间的种种误会与负心皆由于此。</p><p>人类的生活本都是变迁的，但歌德每一次生活上的变迁就启示一次人生生活上重大的意义，而留下了伟大的成绩，为人生永久的象征。这是什么原故？因歌德在他每一种生活的新倾向中，无论是文艺政治科学或恋爱，他都是以全副精神整个人格浸沉其中；每一种生活的过程里都是一个整个的歌德在内。维特时代的歌德完全是一个多情善感热爱自然的青年，著《伊菲格尼》（Iphigenie〕的歌德完全是个清明懦雅，徘徊于罗马古墟中希腊的人。他从人性之南极走到北极，从极端主观主义的少年维特走到极端客观主义的伊菲格尼，似乎完全两个人。然而每个人都是新鲜活泼原版的人。所以他的生平给与我们一种永久青春永远矛盾的感觉。</p><p>歌德的一生并非真是从迷途错误走到真理，乃是继续地经历全人生各式的形态。他在《浮士德》中说：</p><blockquote><p>“我要在内在的自我中深深领略，领略全人类所赋有的一切。最崇高的最深远的我都要了解。我要把全人类的苦乐堆积在我的胸心，我的小我、便扩大成为全人类的大我。我愿和全人类一样，最后归于消灭。”</p></blockquote><p>这样伟大勇敢的生命肯定，使他穿历人生的各阶段，而每阶段都成为人生深远的象征。他不只是经过少年诗人时期，中年政治家时期，老年思想家、科学家时期，就在文学上他也是从最初罗可可（Rococo）式的纤巧到少年维特的自然流露，再从意大利游后古典风格的写实到老年时浮士德第二部象征的描写。</p><p>他少年时反抗一切传统道德势力的缚束，他的口号“情感是一切！”老年时尊重社会的秩序与礼法，重视克制的道德。他的口号“事业是一切！”在对人接物方面，少年歌德是开诚坦率热情倾倒的待人。在老年时则严肃令人难以亲近。在政治方面，少年的大作中“瞿支” (Goetz)临死时口中喊着“自由”，而老年歌德对法国大革命中的残暴深为厌恶，赞美拿破仑重给欧洲以秩序。</p><p>在恋爱方面，因各时期之心灵需要，舍弃最知心、最有文化的十年女友石坦因夫人而娶一个无知识、无教育纯朴自然的扎花女子。歌德生活是努力不息，但又似乎毫无预计，听机缘与命运之驱使。所以有些人悼惜歌德荒废太多时间做许多不相干的事，像绘画，政治事务，研究科学，尤其是数十年不断的颜色学研究。但他知道这些“迷途”、“错道”是他完成他伟大人性所必经的。人在“迷途中努力，终会寻着他的正道”。</p><p>歌德在生活中所经历的“迷途”与“正道”表现于一个最可令人注意的现象。这现象就是他生活中历次的“逃走”。他的逃走是他浸沉于一种生活方向将要失去了自己时，猛然的回头，突然的退却，再返于自己的中心。他从莱布齐希大学身心破产后逃回故乡，他历次逃开他的情人弗利德利克，绿蒂，丽莉等，他逃到魏玛，又逃脱魏玛政务的压迫走入意大利艺术之宫。他又从意大利逃回德国。他从文学逃入政治，从政治逃入科学。老年时且由西方文明逃往东方，借中国印度波斯的幻美热情以重振他的少年心。每一次逃走，他新生一次，他开辟了生活的新领域，他对人生有了新创造新启示。他重新发现了自己，而他在“迷途”中的经历已丰富了深化了自己。他说：“各种生活皆可以过，只要不失去了自己。”</p><p>歌德之所以敢于全心倾注于任何一种人生方面，尽量发挥，以致有伟大的成就，就是因为他自知不会完全失去了自己，他能在紧要关头逃走退回他自己的中心。这是歌德一生生活的最大的秘密。但在这个秘密背后伏有更深的意义。我们再进一步研究之。</p><p>歌德在近代文化史上的意义可以说，他带给近代人生一个新的生命情绪。他在少年时他已自觉是个新的人生宗教的预言者。他早期文艺的题目大都是人类的大教主如普罗美修斯(Prometheus)［希腊神话中创造人类和造福于人类的受人尊崇的神，提坦神伊阿佩托斯的儿子］，苏格拉底，基督与摩哈默德。</p><p>这新的人生情绪是什么呢？就是“生命本身价值的肯定”。基督教以为人类的灵魂必须赖救主的恩惠始能得救，获得意义与价值。近代启蒙运动的理性主义则以为人生须服从理性的规范，理智的指导，始能达到高明的合理的生活。歌德少年时即反抗十八世纪一切人为的规范与法律。他的《瞿支》是反抗一切传统政治的缚束；他的维特是反抗一切社会人为的礼法，而热烈崇拜生命的自然流露。</p><p>一言蔽之，一切真实的，新鲜的，如火如荼的生命，未受理性文明矫揉造作的原版生活，对于他是世界上最可宝贵的东西。而这种天真活泼的生命他发现于许多绚漫而朴质如花的女性。他作品中所描写的绿蒂，玛甘泪，玛丽亚等，他自身所迷恋的弗利德丽克，丽莉，绿蒂等，都灿烂如鲜花而天真活泼，朴素温柔，如枝头的翠鸟。而他少年作品中这种新鲜活跃的描写，将妩媚生命的本体熠烁在读者眼前，真是在他以前的徳国文学所未尝梦见的，而为世界文学中的粒粒晶珠。</p><p>这种崇拜真实生命的态度也表现于他对自然的顶礼。他1782年的《自然赞歌》可为代表。译其大意如下：</p><blockquote><p>自然，我们被他包围，被他环抱；无法从他走出，也无法向他深入。他未得请求，又未加警告，就携带我们加人他跳舞的圈子，带着我们动，直待我们疲倦极了，从他臂中落下。他永远创造新的形体，去者不复返，来者永远新，一切都是新创，但一切也仍旧是老的。他的中间是永恒的生命演进，活动。但他自己并未曾移走。他变化无穷，没有一刻的停止。他没有留恋的意思，停留是他的诅咒，生命是他最美的发明，死亡是他的手段，以多得生命。</p></blockquote><p>歌德这时的生命情绪完全是浸沉于理性精神之下层的永恒活跃的生命本体。</p><p>但说到这里，在我们的心影上会涌现出另一个歌德来。而这歌德的特征是谐和的形式，是创造形式的意志。歌德生活中一切矛盾之最后的矛盾，就是他对流动不居的生命与圆满谐和的形式有同样强烈的情感。他在哲学上固然受斯宾诺莎泛神论的影响；但斯宾诺莎所给予他的仍是偏于生活上道德上的受用，使他紊乱烦恼的心灵得以入于清明。</p><p>以大宇宙中永恒谐和的秩序整理内心的秩序，化冲动的私欲为清明合理的意志。但歌德从自己的活跃生命所体验的能动的创造的宇宙人生，则与斯宾诺莎倾向机械论与几何学的宇宙观迥然不同。所以歌德自己的生活与人格却是实现了德国大哲学家莱布尼茨［德国著名哲学家、科学家。著有《形而上学谈话》、《人类理智论》、《单子论》、《神正论》等］的宇宙论。宇宙是无数活跃的精神原子，每一个原子顺着内在的定律，向着前定的形式永恒不息的活动发展，以完成实现他内潜的可能性，而每一个精神原子是一个独立的小宇宙，在他里面像一面镜子反映着大宇宙生命的全体。歌德的生活与人格不是这样一个精神原子么？</p><p>生命与形式，流动与定律，向外的扩张与向内的收缩，这是人生的两极，这是一切生活的原理。歌德曾名之宇宙生命的一呼一吸。而歌德自己的生活实在象征了这个原则。他的一生，他的矛盾，他的种种逃走，都可以用这个原理来了解。当他纵身于宇宙生命的大海时，他的小我扩张而为大我，他自己就是自然，就是世界，与万物为一体。他或者是柔软地像少年维特，一花一草一树一石都与他的心灵合而为一，森林里的飞禽走兽都是他的同胞兄弟。他或者刚强地察觉着自己就是大自然创造生命之一体，他可以和地神唱道：</p><blockquote><p>生潮中，业浪里， 淘上或淘下， 浮来又浮去！ 生而死，死而葬， 一个永恒的大洋， 一个连续的波浪， 一个有光辉的生长， 我架起时辰的机杼， 替神性制造生动的衣裳。 ——郭沫若译《浮士德》</p></blockquote><p>但这生活片面的扩张奔放是不能维持的，一个个体的小生命更是会紧张极度而趋于毁灭的。所以浮士德见地神现形那样的庞大，觉得自己好像侏儒一般，他的狂妄完全消失：</p><blockquote><p>我，自以力超过了火焰天使， 已把自由的力量使自然甦生， 满以为创造的生活可以俨然如神！ 啊，我现在是受了个怎样的处分！ 一声霹雳把我推堕了万丈深坑。 …… 哦，我们努力自身，如同我们的烦闷， 一样地阻碍着我们生长的前程。 ——郭沫若译《浮士德》</p></blockquote><p>生命片面的努力伸张反要使生命受阻碍，所以生命同时要求秩序，形式，定律，轨道。生命要谦虚，克制，收缩，遵循那支配有主持一切的定律，然后才能完成，才能使生命有形式，而形式在生命之中。</p><blockquote><p>依着永恒的，正直的 伟大的定律， 完成着 我们生命的圈。 ——摘《神性》<br>一个有限的圈子 范围着我们的人生， 世世代代 排列在无尽的生命底链上。 ——摘《人类之界限》</p></blockquote><p>生命是要发扬，前逬，但也要收缩，循轨。一部生命的历史就是生活形式的创造与破坏。生命在永恒的变化之中、形式也在永恒的变化之中。所以一切无常，一切无住，我们的心，我们的情，也息息生灭，逝同流水。向之所欣，俯仰之间，已成陈迹。这是人生真正的悲剧，这悲剧的源泉就是这追求不已的自心。</p><p>人生在各方面都要求着永久；但我们的自心的变迁使没有一景一物可以得暂时的停留，人生飘堕在滚滚流转的生命海中，大力推移，欲罢不能，欲留不许。这是一个何等的重负，何等的悲哀烦恼。所以浮士德情愿拿他的灵魂底毁灭与魔鬼打赌，他只希望能有一个瞬间的真正的满足，俾他可以对那瞬间说：“请你暂停，你是何等的美呀！”</p><p>由这话看来，一切无常的主因是在我们自心的无常，心的无休止的前进追求，不肯暂停留恋。人生的悲剧正是在我们恒变的心情中，歌德是人类的代表，他感到这人生的悲剧特别深刻，他的一生真是息息不停的追求前进，变向无穷。这心的变迁使他最感到苦痛负疚的就是他恋爱心情的变迁，他一生最热烈的恋爱都不能久住，他对每一个恋人都是负心，这种负心的忏悔自诉是他许多最大作品的动机与内容。剧本《瞿支》中，魏斯林根背弃玛利亚；剧本《浮士德》中，浮士德遗弃垂死的玛甘泪于狱中，是歌德最明显最沉痛的自诉。但他的生活情绪不停留的前进使他不能不负心，使他不能安于一范围，狭于一境界而不向前开辟生活的新领域。所以歌德无往而不负心，他弃掉法律投入文学，弃掉文学投入政治，又逃脱政治走入艺术科学，他若不负心，他不能尝遍全人生的各境地，完成一个最人性的人格。他说：</p><blockquote><p>你想走向无尽么？ 你要在有限里面往各方面走！</p></blockquote><p>然而这个负心现象，这个生活矛盾，终是他生活里内在的悲剧与问题，使他不能不努力求解决的。这矛盾的调解，心灵负咎的解脱，是歌德一生生活之意义与努力。</p><p>再总结一句，歌德的人生问题，就是如何从生活的无尽流动中获得谐和的形式，但又不要让僵固的形式阻碍生命前进的发展。这个一切生命现象中内在的矛盾，在歌德的生活里表现得最为深刻。他的一切大作品也就是这个经历的供状。我们现在再从歌德的文艺创作中去寻歌德的人生启示与这问题最后的解答。</p><h3 id="二、歌德文艺作品中所表现的人生与人生问题"><a href="#二、歌德文艺作品中所表现的人生与人生问题" class="headerlink" title="二、歌德文艺作品中所表现的人生与人生问题"></a>二、歌德文艺作品中所表现的人生与人生问题</h3><p>我们说过，歌德启示给我们的人生是扩张与收缩，流动与形式，变化与定律；是情感的奔放与秩序的严整，是纵身大化中与宇宙同流，但也是反抗一切的阻碍压迫以自成一个独立的人格形式。他能忘怀自己，倾心于自然，于事业，于恋爱；但他又能主张自己，贯彻自己，逃开一切的包围。歌德心中这两个方面表现于他生平一切的作品中。</p><p>他的剧本《瞿支》、《塔索》，他的小说《少年维特之烦恼》，是表现生命的奔放与倾注，破坏一切传统的秩序与形式。他的《伊菲格尼》与叙事诗《赫尔曼与多罗蒂》等，则内容外形都表现最高的谐和节制，以圆融高朗的优美的形式调解心灵的纠纷冲突。在抒情诗中他的《卜罗米陀斯》是主张人类由他自己的力量创造他的生活的领域，不需要神的援助，否认神的支配，是近代人生思想中最伟人的一首革命诗。但他在《人类之界限》、《神性》等诗中、则又承认宇宙间含有创造一切的定律与形式，人生当在永恒的定律与前进的形式中完成他自己；但人生不息的前进追求，所获得的形式终不能满足，生活的苦闷由此而生。这个与歌德生活中心相终始的问题则表现于他毕生的大作《浮士德》中。《浮士德》是歌德全部生活意义的反映，歌德生命中最深的问题于此表现，也于此解决。我们特别提出研究之。</p><p>浮士德是歌德人生情绪最纯粹的代表。《浮士德》戏剧最初本，所谓“原始浮士德”的基本意念是什么？在他下面的两句诗：</p><blockquote><p>我有敢于入世的胆量， 下界的苦乐我要一概担当。</p></blockquote><p>浮士德人格的中心是无尽的生活欲与无尽的知识欲。他欲呼召生命的本体，所以先用符咒呼召宇宙与行为的神。神出现后，被神呵斥其狂妄，他认识了个体生命在宇宙大生命面前的渺小。于是乃欲投身生命的海洋中体验人生的一切。他肯定这生命的本身，不管他是苦是乐，超越一切利害的计较，是有生活的价值的，是应当在他的中间努力寻得意义的。这是歌德的悲壮的人生观，也是他《浮士德》诗中的中心思想。</p><p>浮士德因知识追求的无结果，投身于现实生活，而生活的顶点，表现于恋爱，但这恋爱生活成了悲剧。生活的前进不停，使恋爱离弃了浮士德，而浮士德离弃了玛甘泪，生活成了罪恶与苦痛。《浮士德》的剧本从原始本经过1790年的残篇以至第一部完成，他的内容是肯定人生为最髙的价值，最高的欲望，但同时也是最大的问题。初期的《浮士德》剧本之结局，窥歌德之意是倾向纯悲剧的。人生是将由他内在的矛盾，即欲望的无尽与能力的有限，自趋于毁灭，浮士德也将由生活的罪过趋于灭亡，生活并不是理想而是诅咒。但歌德自己生活的发展使问题大变，他在意大利获得了生命的新途径，而剧本中的浮士德也将得救。在 1797 年的《浮士德》中的天上序曲里，魔鬼梅菲斯特诅咒人生真如歌德自己原始的意思，但现在则上帝反对梅菲斯特的话，他指出那生活中问题最多最严重的浮士德将终于得救。这个歌德人生思想的大变化最值得注意，是我们了解浮士德与歌德自己的生活最重要的钥匙。</p><p>我们知道“原始浮士德”的生活悲剧，他的苦痛，他的罪过，就是他自己心的恒变，使他对一切不能满足，对一切都负心。人生是个不能息肩的重负，是个不能驻足的前奔。这个可诅咒的人生在歌德生活的进展中忽然得找价值的重新估定。人生最可诅咒的永恒流变一跃而为人生最高贵的意义与价值。人生之得以解救，浮士德之得以升天，正赖这永恒的努力与追求。浮士德将死前说出他生活的意义是永远的前进：</p><blockquote><p>在前进中他获得苦痛与幸福， 他这没有一瞬间能满足的。 而拥着他升天的天使们也唱道： 惟有不断的努力者 我扪可以解脱之！</p></blockquote><p>原本是人生的诅咒，那不停息的追求，现在却变成了人生最高贵的印记。人生的矛盾苦痛罪过在其中，人生之得救也由于此。</p><p>我们看浮士德和魔鬼梅菲斯特订契约的时候，他是何等骄傲于他的苦闷与他的不满足。他说他愿毁灭自己，假使人生能使他有一瞬间的满足而愿意暂停留恋。梅菲斯特起初拿浅薄的人世享乐来诱惑他，徒然使他冷笑。</p><p>以前他愿意毁灭，因为人生无价值；现在他宁愿毀灭，假使人生能有价值。这是很大的一个差别，前者是消极的悲观，后者是积极的悲壮主义。前者是在心理方面认识，一切美境之必然消逝；后者是在伦理方面肯定，这不停息的追求是人生之意义与价值。将心理的必然变迁改造成意义丰富的人生进化，将每一段的变化经历包含于后一段的演进里，生活愈益丰富深厚，愈益广大高超，像歌德从科学艺术政治文学以及各种人生经历以完成他最后博大的人格。歌德的象征浮士德也是如此，他经过知识追求的幻灭走进恋爱的罪过，又从真美的憧憬走回实际的事业。每一次的经历并不是消磨于无形，乃是人格演进完成必要的阶石：</p><blockquote><p>你想走向无尽么？ 你要在有限里面往各方面走！</p></blockquote><p>有限里就含着无尽，每一段生活里潜状着生命的整个与永久。每一刹那都须消逝，每一刹那即是无尽，即是永久。我们懂了这个意思，我们任何一种生活都可以过，因为我们可以由自己给与它深沉永久的意义。《浮士德》全书最后的智慧即是：</p><blockquote><p>一切生灭者 皆是一象征。</p></blockquote><p>在这些如梦如幻流变无常的象征背后潜伏着生命与宇宙永久深沉的意义。</p><p>现在我们更可以了解人生中的形式问题。形式是生活在流动进展中每一阶段的综合组织，他包含过去的一切，成一音乐的和谐。生活愈丰富，形式也愈重要。形式不但不阻碍生活，限制生活，乃是组织生活，集合生活的力量。老年时歌德因他生活内容过分的丰富，所以格外要求形式，定律，克制，宁静，以免生活的分崩而求谐和的保持。这谐和的人格是中年以后的歌德所兢兢努力惟恐或失的。他的诗句：</p><p>人类孩儿最高的幸福 就是他的人格！<br>流动的生活演进而为人格，还有一层意义，就是人生的清明与自觉的进展。人在世界经历中认识了世界，也认识了自己，世界与人生渐趋于最高的和谐；世界给予人生以丰富的内容，人生给予世界以深沉的意义。这不是人生问题可能的最高的解决么？这不是文艺复兴以来，人类失了上帝，失了宇宙，从自己的生活的努力所能寻到的人生意义么？</p><p>浮士德最初欲在书本中求智慧，终于在人生的航行中获得清明。他人生问题的解决我们可以说：</p><blockquote><p>人当完成人格的形式而不失去生命的流动！生命是无尽的，形式也是无尽的，我们当从更丰富的生命去实现更高一层的生活形式。</p></blockquote><p>这样的生活不是人生所能达到的最高的境地么？我们还能说人生无意义无目的么？歌德说：</p><blockquote><p>人生，无论怎样，他是好的！</p></blockquote><p>歌德的人生启示固然以《浮士德》为中心，但他的其他创作都是这种生活之无限肯定的表现。尤其是他的抒情诗，完全证实了我们前面所说的歌德生活的特点：</p><blockquote><p>他一切诗歌的源泉，就是他那鲜艳活泼，如火如荼的生命本体。而他诗歌的效用与目的却是他那流动追求的生命中所产生的矛盾苦痛之解脱。他的诗，一方面是他生命的表白，自然的流露，灵魂的呼喊，苦闷的象征。他像鸟儿在叫，泉水在流。 他说：“不是我做诗，是诗在我心中歌唱。”所以他诗句的节律里跳动着他自己的脉搏，活跃如波澜。他在生活憧憬中陷入苦闷纠缠，不能自拔时，他要求上帝给他一支歌，唱出他心灵的沉痛，在歌唱时他心里的冲突的情调，矛盾的意欲，都醇化而升入节奏，形式，组合成音乐的谐和。混乱浑沌的太空化为秩序井然的宇宙，迷途苦恼的人生获得清明的自觉。因为诗能将他纷扰的生活与刺激他生活的世界，描绘成一幅境界清朗，意义深沉的图画（《浮士德》就是这样一辐入生图画）。 这图画纠正了他生活的错误，解脱了他心灵的迷茫，他重新得到宁静与清明。但若没有热烈的人生，何取乎这髙明的形式。所以我们还是从动的方面去了解他诗的特色。</p></blockquote><p>歌德以外的诗人的写诗，大概是这样：一个景物，一个境界，一种人事的经历，触动了诗人的心。诗人用文字，音调，节奏，形式，写出这景物在心情里所引起的澜漪。他们很能描绘出历历如画的境界，也能表现极其强烈动人的情感。但他们一面写景，一面叙情，往往情景成了对待。且依人类心理的倾向，喜欢写景如画，这就是将意境景物描摹得线清条楚，轮廓宛然，恍如目睹的对象。</p><p>人类之诉说内心，也喜欢缕缕细述，说出心情的动机原委。虽莎士比亚、但丁的抒情诗，尽管他们描绘的能力与情感的白热，有时超过歌德，但他们仍未能完全脱离这种态度。</p><p>歌德在人类抒情诗上的特点，就是根本打破心与境的对待，取消歌咏者与被歌咏者中间的隔离。他不去描绘一个景，而景物历落飘摇，浮沉隐显在他的词句中间。他不愿直说他的情意；而他的情意缠绵，婉转流露于音韵节奏的起落里面。他激昂时，文字境界节律音调无不激越兴起；他低徊留恋时，他的歌辞如泣如诉，如怨如慕，令人一往情深，不能自已，忘怀于诗人与读者之分。</p><p>王国维先生说诗有隔与不隔的差别，歌德的抒情诗真可谓最为不隔的。他的诗中的情绪与景物完全融合无间，他的情与景又同词句音节完全融合无间，所以他的诗也可以同我们读者的心情完全融合无间，极尽浑然不隔的能事。然而这个心灵与世界浑然合一的情绪是流动的，飘渺的，绚缦的，音乐的；因世界是动，人心也是动，诗是这动与动接触会合时的交响曲。所以歌德诗人的任务首先是努力改造社会传统的，用旧了的文字词句，以求能表现出这新的动的人生与世界。</p><p>原来我们人类的名词概念文字，是我们把捉这流动世界万事万象的心之构造物；但流动不居者难以捉摸，我们人类的思想语言天然的倾向于静止的形态与轮廓的描绘，历时愈久，文字愈抽象，并这描绘轮廓的能力也将失去，遑论做心与景合一的直接表现。</p><p>歌德是文艺复兴以来近代的流动追求的人生最伟大的代表（所谓浮士德精神)。他的生命，他的世界是激越的动，所以他格外感到传统文字不足以写这纯动的世界。于是他这位世界最伟大的语言创造的天才，在德国文字中创造了不可计数的新字眼，新句法，以写出他这新的动的人生情绪。（歌德他不仅是德国文学上最大诗人，而且是马丁•路德以后创新德国文字最重大的人物。现代继起努力创新与美化德国文字的大诗人是斯特凡•格奥尔格［Stefan George，1868－1933. 德国诗人，受法国象征主义诗歌的影响，主张“为艺术而艺术”。“曾创办《艺术篇页》杂志，发表他的艺术理论和创作。诗集主要有《灵魂之年》、《第七环》、《新国》等”］。他变化无数的名词为动词，又化此动词为形容词，以形容这流动不居的世界。例如“塔堆的巨人”（形容大树），“塔层的远”，“影阴着的湾”，“成熟中的果”等等，不胜枚举，且不能译。</p><p>他又熔情入景，化景为情，融合不同的感官铸成新字以写难状之景，难摹之情。因为他是以一整个的心灵体验这整个的世界，(新字如“领袖的步”“云路”“星眼”“梦的幸福”“花梦”等等也是不能有确切的中译，虽然诗意发达极高的中囯文词颇富于这类字眼），所以他的每一首小诗都荡漾在一种浩瀚流动的气氛中，像宋元画中的山水。不过西方的心灵更倾向于活动而巳。我们举他一首《湖上》诗为例。歌德的诗是不能译的，但又不能不勉强译出，力求忠于原诗，供未能读原文者参考。</p><p>湖上 </p><p>［1775年瑞士湖上作，时方逃出丽莉（Lili）姑娘的情网。（按：姑娘原名 Elise von Schlussmann，嫁TÜV Kheim 氏）］ </p><p>并且新鲜的粮食，新鲜的血<br>我吸取自自由的世界：<br>自然何等温柔，何等的好，<br>将我拥在怀抱。<br>波澜摇荡着小船<br>在击桨声中上前，<br>山峰，高插云霄，<br>迎着我们的水道。</p><p>眼睛，我的眼睛，你为何沉下了？<br>金黄色的梦，你又来了？</p><p>去罢，你这梦，虽然是黄金，<br>此地也有生命与爱情。</p><p>在波上辉映着<br>千万飘浮的星，<br>柔软的雾吸饮着<br>四围塔层的远。<br>晓风翼覆了<br>影阴着的湾，<br>渐中影映着<br>成熟中的果。</p><p>开头一句“并且新鲜的粮食，新鲜的血，我吸取自自由的世界。……”就突然地拖着我们走进一个碧草绿烟柔波如语的瑞士湖上。开义一字用“并且”（德文Und即英文And）将我们读者一下子就放在一个整个的自然与人生的全景中间。“自然何等温柔，何等的好，将我拥在怀抱”。写大自然生命的柔静而自由，反观人在社会生活中受种种人事的缚束与苦闷，歌德自己在丽莉小姐家庭中礼仪的拘束与恋爱的包围，但“自然”是人类原来的故乡，我们离开了自然，关闭在城市文明中烦闷的人生，常常怀着“乡愁”想逃回自然慈母的怀抱，恢复心灵的自由。“波澜摇荡着小船，在击桨声中上前……”两句进一步写我们的状况。动荡的湖光中动荡的波澜，摇动着我们的小船，使我们身内身外的一切都成动象，而击桨的声音给与这流动以谐和的节奏。“上前”遥指那“山峰，高插云霄，迎着我们的水道……”自然景物的柔媚，勾引心头温馨旖旎的回忆。眼睛低低沉下，金黄色的情梦又浮在眼帘。但过去的情景，转眼成空，不堪回首，且享受新获着的自由罢！自然的丽景展布在我们的面前：“在波上辉映着千万飘浮的星……”短短的几句写尽了归舟近岸时的烟树风光。</p><p>全篇荡漾着波澜的闪耀，烟景的飘渺，心情的旖旎，自然与人生谐和的节奏。但歌德的生活仍是以动为主体，个体生命的动热烈地要求着与自然造物主的动相接触，相融合。这种向上追求的激动及与宇宙创造力相拥抱的情绪表现在《格丽曼》 (Ganymed)一诗中（慧田哲学注：希腊神话中，格丽曼为一绝美的少年王子。天父爱惜之，遣神鹰攫去天空，送至阿林比亚神人之居)。</p><p>格丽曼 你在晓光灿烂中， 怎么这样向我闪烁， 亲爱的春天！ 你永恒的温暖中， 神圣的情绪， 以一千倍的热爱 压向我的心， 你这无尽的美！ 我想用我的臂， 拥抱着你！ 啊，我睡在你的胸脯， 我焦渴欲燃， 你的花，你的草， 压在我的心前。 亲爱的晓风， 吹凉我胸中的热， 夜莺从雾谷里， 向我呼唤！ 我来了，我来了， 到那里？到那里？ 向上，向上去， 云彩飘流下来， 飘流下来， 俯向我热烈相思的爱！ 向我，向我， 我在你的怀中上升！ 拥抱着被捆抱着！ 升上你的胸脯！ 爱护一切的天父！</p><p>这首诗充分表现了歌德热情主义唯动主义的泛神思想。但因动感的激越，放弃了谐和的形式而流露为生命表现的自由诗句，为近代自由诗句的先驱。然而这狂热活动的人生，虽然灿烂，虽然壮阔，但激动久了，则和平宁狰的要求油然而生。这个在生活中倥偬不停的“游行者”也曾急迫地渴求着休息与和平。</p><p>游行者之夜歌（二首） 一 你这从天上来的 宁息一切颂恼与苦痛的； 给与这双倍的受难者 以双倍的新鲜的， 啊，我已倦于人事之倥偬! 一切的苦乐皆何为？ 甜蜜的和平！ 来，啊，来到我的胸里！ 二 一切山峰上 是寂静， 一切树杪中 感不到 些微的风； 森林中众鸟无音。 等着罢，你不久 也将得着安宁。<br>歌德是个诗人，他的诗是给与他自己心灵的烦扰以和平以宁静的。但他这位近代人生与宇宙动象的代表，虽在极端的静中仍潜示着何等的鸢飞鱼跃！大自然的山川在虼然峙立里周流着不舍昼夜的消息。</p><p>海上的寂静 深沉的寂静停在水上。 大海微波不兴。 船夫瞅着眼， 愁视着四面的平镜。 空气里没有微风！ 可怕的死的寂静！ 在无边寥廓里， 不摇一个波影。<br>这是歌德所写意境最静寂的一首诗。但在这天空海阔晴波无际的境界里绝不真是死，不是真寂灭。他是大自然创造生命里“一刹那倾静的假象”。一切宁宙万象里有秩序，有轨道，所以也启示着我们静的假象。</p><p>歌德生平最好的诗，都含蕴着这大宇宙潜在的音乐。宇宙的气息，宇宙的神韵，往往包含在他一首小小的诗里。但他也有几首人生的悲歌，如《威廉传》中《弦琴师》与《迷娘》（Mignon）的歌曲，也深深启示着人生的沉痛，永久相思的哀感：</p><p>弦琴师（歌曲） 谁居寂寞中？ 嗟彼将孤独。 生人皆欢笑， 留彼独自苦。 嗟乎，请君让我独自苦! 我果能孤独， 我将非无侣。 情人偷来听， 所欢是否孤无侣？ 日夜偷来寻我者， 只是我之忧， 只是我之苦。 一旦我在坟墓中， 彼始让我真无侣！ 迷娘（歌曲） 谁人识相思？ 乃解侬心苦， 寂寞而无欢， 望彼天一方， 爱我知我人。 呜呼在远方， 我头昏欲眩， 五脏焦欲燃， 谁解相思苦， 乃识侬心煎。</p><p>歌德的诗歌真如长虹在天，表现了人生沉痛而美丽的永久生命，他们也要求着永久的生存：</p><p>你知道，诗人的词句 飘摇在天堂的门前， 轻轻的叩着 请求永久的生存。<br>而歌德自己一生的猛勇精进，周历人生的全景，实现人生最高的形式、也自知他“生活的遗迹不致消磨于无形”。而他永恒前进的灵魂将走进天堂最高的境域，他想像他死后将对天门的守者说：</p><p>请你不必多言， 尽管让我进去！ 因为我做了一个人， 这就说曾是一个战士！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生是什么？人生的真相如何？人生的意义何在？人生的目的是何？这些人生最重大最中心的问题，不只是古来一切大宗教家哲学家所殚精竭虑以求解答的。&lt;/p&gt;
&lt;p&gt;世界上第一流的大诗人凝神冥想，深入灵魂的幽邃，或纵身大化中，于一朵花中窥见天国，一滴露水参悟生命，然后用他们的生花之笔，幻现层层世界，幕幕人生，归根也不外乎启示这生命的真相与意义。宗教家对这些问题的方法与态度是预言的和说教的，哲学家是解释的和说明的，诗人文豪是表现的启示的。&lt;/p&gt;
    
    </summary>
    
      <category term="林中路" scheme="http://yoursite.com/categories/%E6%9E%97%E4%B8%AD%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>齐美尔：大城市与精神生活</title>
    <link href="http://yoursite.com/2019/01/27/Holzwege-3/"/>
    <id>http://yoursite.com/2019/01/27/Holzwege-3/</id>
    <published>2019-01-27T12:20:28.000Z</published>
    <updated>2019-01-27T03:41:21.251Z</updated>
    
    <content type="html"><![CDATA[<p>大城市人的个性特点所赖以建立的心理基础，是表面和内心印象的接连不断地迅速变化而引起的精神生活的紧张。</p><a id="more"></a><p>首先要理解大城市精神生活的理性主义特点，大城市的精神生活跟小城市的不一样，确切地说，后者的精神生活是建立在情感和直觉的关系之上的。直觉的关系扎根于无意识的情感土壤之中，所以很容易在一贯习惯的稳定均衡中生长。相反，当外界环境的潮流和矛盾使大城市人感到有失去依靠的威胁时，他们——当然是许许多多个性不同的人——就会建立防卫机构来对付这种威胁、他们不是用情感来对这些外界环境的潮流和矛盾作出反应，主要的是理智，意识的加强使其获得精神特权的理智。</p><p>典型的大城市人的相互关系和各种事务往往是各种各样的，复杂的。这使得现代的聪明才智越来越变成一种计算智慧。首先，这么多人聚居在一起，利害关系千差万别，他们的各种来往和活动相互间有多方面的有机联系，如果在约好的事情上和工作中没有准确的时间观念，那就会全都乱了套，</p><p>大城市生活的复杂性和广泛性迫使生活要遵守时间，要精打细算，要准确，这不仅与它的货币经济和理性主义的特点有密切的关系，而且也使生活的内容富有色彩，有利于克服那种要由自己来决定生活方式、拒不接受被认为是普普通通千篇一律的外界生活方式的非理性的、本能的、主观独断的性格特点和冲动。</p><p>另一方面，准确地一分钟一分钟地规定生活方式而形成最无个性的同样的因素也在谋求最有个性的东西。当主体必须完全接受这种存在形式的同时，他们要面对大城市进行自卫，这就要求他们表现出社会性的消极行为。大城市人相互之间的这种心理状态一般可以叫做矜持。在小城市里人人都几乎认识他所遇到的每一个人，而且跟每一个人都有积极的关系。在大城市里，如果跟如此众多的人的不断表面接触中都要像小城市里的人那样作出内心反应．那么他除非要会分身术，否则将陷于完全不可没想的心理状态。这种心理状态，或者说我们面对在短暂的接触中瞬息即逝的大城市生活特点所拥有的怀疑权利，迫使我们矜持起来，于是，我们跟多年的老邻居往往也互不相见，互不认识，往往教小城市里的人以为我们冷漠，毫无感情。</p><p>为什么偏偏只有大城市才会引起最独特的个人存在的欲望呢(不管它是否总有道理，也不管它是否都能成功)?我认为最根本的原因是：通过那种可以称之为客观精神的东西对主观精神的优势，现代文明的发展形成了自己的特点，即在诸如语言和法律、生产技术和艺术、科学和家庭环境问题上体现出了一种总体精神，这种总体精神日渐发展，结果是主观的精神发展很不完善，距离越拉越大。如果我们纵观一下一百年来由于各种事物和知识、由于教育和舒适的条件而形成的文明，用它来跟同一时期的人的文明进步比较一下(哪怕跟最高的水平比较)，就可以发现，两者之间的发展差异是令人吃惊的。在某些方面，如教养、关心体贴人和献身精神，人的文明与过去相比反而有所倒退。这种差异的主要原因是分工的越来越细。因为分工越来越细，对人的工作要求也越来越单一化。这种情况发展到极点时，往往就使作为整体的人的个性丧失殆尽，至少也是越来越无法跟客观文明的蓬勃发展相媲美。人被贬低到徽不足道的地步，在庞大的雇佣和权力组织面前成了一粒小小的灰尘。</p><p>还需要指出的是，大城市是超越于一切个性的文明的舞台。在大城市里，雄伟舒适的公寓建筑、学校的集体生活方式和明确的校服制度，都说明大城市充满着具体的无个性特点的思想。可以说，这种情况不能使个人保持自己的特点。一方面，个人的生活变得极为简单，个人的行动、兴趣、时间的度过以及意识都要由各方面来决定，他们似乎被放到河面上托着，几乎不需要自己游泳。可是另一方面，生活却越来越由无个性特点的内容和现象组成，而这些无个性特点的内容和现象要排斥本来有个性的色彩和特点，这就刚好使得这种必定能产生最大特点的个性丧失了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大城市人的个性特点所赖以建立的心理基础，是表面和内心印象的接连不断地迅速变化而引起的精神生活的紧张。&lt;/p&gt;
    
    </summary>
    
      <category term="林中路" scheme="http://yoursite.com/categories/%E6%9E%97%E4%B8%AD%E8%B7%AF/"/>
    
    
      <category term="精神紧张" scheme="http://yoursite.com/tags/%E7%B2%BE%E7%A5%9E%E7%B4%A7%E5%BC%A0/"/>
    
      <category term="主体文化" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BD%93%E6%96%87%E5%8C%96/"/>
    
      <category term="客体文化" scheme="http://yoursite.com/tags/%E5%AE%A2%E4%BD%93%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>杨祖陶：康德哲学体系问题</title>
    <link href="http://yoursite.com/2019/01/22/Holzwege-2/"/>
    <id>http://yoursite.com/2019/01/22/Holzwege-2/</id>
    <published>2019-01-22T12:20:28.000Z</published>
    <updated>2019-01-26T11:28:26.868Z</updated>
    
    <content type="html"><![CDATA[<p>康德的哲学体系是什么，由哪些部分组成，其根本性质是什么，这些问题远比最初想到的要复杂得多。问题在于康德的哲学思想，不仅从前批判时期到批判时期是一个复杂的变化发展的过程，而且在批判时期里也仍然处在变化发展之中。正是这种情况决定了，即使批判时期的康德哲学体系问题，也必须予以具体的考察，不容作出简单的回答。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>康德是近代哲学、也是整个哲学史上最伟大的改革家之一。他在18世纪末，经过长达十余年的酝酿准备，发动了一场推翻传统形而上学，即所谓旧形而上学的革命。这种形而上学源自柏拉图和亚里士多德，在近代为笛卡儿、斯宾诺莎和莱布尼兹所复兴和发扬，到18世纪末虽已趋于没落，但仍以莱布尼兹—沃尔夫体系的形式统治着学院讲坛。康德创始的哲学革命并不是像怀疑主义那样要从根本上抛弃或否定形而上学，而是要挽救它，改造它，革新它，使它获得新的生命和形式，走上科学的坦途，成为一种作为科学的形而上学。由于这种形而上学当时还不存在；所以康德也把它称为未来形而上学。</p><p>在康德看来，形而上学乃是来自纯粹理性的哲学知识的体系，旧形而上学之所以陷于非科学或假科学的境地，是由于没有预先批判研究人类理性本身而盲目地、武断地、自以为是地从理性的先天概念和原理出发进行分析和推论，以回答世界的终极实在的问题、建立起所谓终极真理的形而上学体系的结果。针对这种情况，康德提出，为了使形而上学摆脱困境，纯粹理性哲学，即形而上学必须从研究程序和内容上区分为性质不同的前后两个部分。前一部分是：批判人类一般认识能力、即“纯粹理性”，或如康德所说，“从理性的一切纯粹的先天知识着眼研究理性能力”[①]，判定各种先天知识的来源和限度，以确定形而上学是可能还是不可能及其所以可能的源泉、条件和范围，从而把形而上学的前提一劳永逸、坚如磐石地确立起来。康德把这一部分称为纯粹理性的“批判”，而由于“批判”的使命仅在于“清除和平整杂草丛生的土地”，“深入勘探形而上学的地基”，为建立这样的大厦做好必要的准备，所以康德就把这一部分看作是形而上学的“导论”、“预备阶段”、“入门”或“初阶”等等。随后的一部分是：系统地阐述从已经判定的纯粹理性的概念和原理中引申或派生出来的全部纯粹理性的哲学知识，这即是在业已准备就绪的地基上建构起科学的形而上学体系。康德把这一部分看作是纯粹理性的“体系”，并把它称为“形而上学”。把哲学这样地区分为纯粹理性的“批判”和“体系”，或形而上学的“导论”和“形而上学”两部分，是康德在其整个哲学革命过程中贯彻始终、坚定不移、最重要、最基本的指导思想。</p><p>哲学的这两个部分虽然就其性质、内容、使命、地位、意义等等而言是彼此不同的，但它们又是内在联系、不可分离的。第一部分，即纯粹理性的“批判”，由于已经判明了纯粹理性的概念和原理的全部财富，因而也就含有“使形而上学成为科学的、经过充分研究和证实的整个方案”，以至可以说其中已经孕育着了形而上学的“幼芽”或“胚胎”[②]，而第二部分的形而上学无非就是这一完整方案的实施或这个幼芽之发育成长为一棵枝叶扶疏的大树。第一部分所揭示的纯粹理性的概念和原理既然是科学的形而上学的基础，即形而上学由以出发的基本概念和基本原理，因而这一部分就远比第二部分重要；但由于这些概念和原理在这里尚且是作为单纯的思想形式，其内容尚未展开，因而显得抽象而空洞。第二部分，即纯粹理性的体系或形而上学虽然就重要性而言次于第一部分，但它却包含了由纯粹理性的原理和概念派生的全部概念和原理，因而就内容而言要比第一部分无比丰富；而且它还通过提出例证(具体情况)，把“意思和意义赋予了”作为单纯思想形式的那些概念和原理，使它们成为真正现实的概念和原理，这就证实了第一部分、即纯粹理性的批判的正确性，从而“对一般的形而上学作出了卓越的不可缺少的贡献”[③]。由于这两部分的这种有机的联系和统一，因此康德认为，”形而上学’这个名称也可以指全部的纯粹哲学，包括批判在内”[④]。这就是说，在康德看来，最广义的、即一般形而上学乃是由形而上学的导论(纯粹理性的批判)和形而上学本身(纯粹理性的体系)这样两个部分构成的统一整体。</p><p>由上所述，我们可以看到，在康德那里，形而上学的对象即是纯粹理性，即人类理性中能够独立于经验、先天地认识和实践的那一部分。照康德看来，人类理性并不是消极被动地接受印象和冲动的容器，而是一种独立自主的、能动的、立法的主体，它通过理性的思辨(理论)的使用向自然立法，以确立自然的规律和关于一切实有事物的知识；通过理性的实践使用而向自由立法，以确定自由，即道德的规律和原理以及关于一切应有的事物的知识。与此相应，形而上学首先就区分为纯粹理性思辨使用的形而上学，即自然形而上学和纯粹理性实践使用的形而上学，即道德形而上学。这两者首先都自成体系。但在这两种形而上学中，道德形而上学是关于人的整个职责、关于人类理性的主要目的和最后目的科学，而理性的一切知识、使用、主要目的都必须作为手段从属于理性的最后目的，这就决定了自然形而上学应当从属于道德形而上学以构成一个单一的、完整的、纯粹理性的目的论的形而上学体系。这样，在康德那里，与纯粹理性的“批判”相并立的纯粹理性的“体系”或与形而上学的“导论”相并立的“形而上学”，也即是一种较广意义的形而上学，指的就是这样一种包括自然形而上学和道德形而上学在内的“自然—道德(或道德—自然)形而上学体系”。</p><p>康德认为，道德哲学虽然是哲学史上早已有的东西，其地位也优越于理性的包括思辨自然哲学在内的一切其他工作，但是过去的道德哲学一般说来都是以经验原理为依据的经验哲学，而不是以理性的先天概念为依据的纯粹哲学，因而与思辨自然哲学不同，就还不曾占有形而上学的名称，真正的道德形而上学是一种尚待(康德本人)建立的东西。这样，在康德看来，严格意义或狭义的形而上学就仅仅是形而上学中“从先天的概念出发考虑一切就其为实有(而非应有)的事物”的那一部分，即思辨理性的形而上学或自然形而上学。接着康德又依据理性的系统统一性原理对自然形而上学进行了三个层次的二分：首先将它区分为“只论究在与一般对象相关的一切概念及原理的系统中的知性和理性本身”的先验哲学或本体论(Ontologia，更恰当的译名是“存在论”)和论究所予对象(无论是给予感官或给予其他种类的直观)的总和的纯粹理性的“自然学”(physiologie)；进而又将后者区分为以感官对象的总和为对象的内在自然学和以经验对象的超经验联系为对象的超越自然学；复次，内在的自然学又区分为以外感对象的总和为对象的理性物理学或有形自然形而上学和以内感对象、即心灵为对象的理性心理学或思维自然形而上学，而超越的自然学则区分为论究自然全体的理性宇宙论和论究自然全体与自然之上的一个存在者，即上帝的关系的理性神学。康德最后总括起来说：“这样，形而上学的全部体系就是由四个主要部分构成的：(1)本体论；(2)理性自然学(包含理性物理学和理性心理学两类。——引者)；(3)理性宇宙论；(4)理性神学。”[⑤]</p><p>我们可以把康德在《纯粹理性批判》的《纯粹理性的建筑术》一节中所详细发挥的形而上学的理念，或他所规划的哲学的体系及其构成列表如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzhrhpqv91j30lz0d3dhc.jpg" alt=""><br>康德所规划的哲学的体系及其构成，是对于西方哲学史上的传统观念的一种继承和改造。</p><p>首先，康德显然是继承了西方自亚里士多德以来把哲学划分为理论(自然)哲学和实践(道德)哲学的传统，但对它作了重大的改造和发展。这明显地表现在：</p><ul><li>(1)以对认识能力的批判(理性批判)作为全部哲学的导论；</li><li>(2)要求把道德(实践)哲学从经验哲学提升成为纯粹哲学，即形而上学，并和自然(理论)形而上学融合成为一个单一的形而上学体系；</li><li>(3)全部哲学或形而上学的对象都是人类理性自身，——纯粹理性批判的对象即是理性自身，无论自然形而上学或道德形而上学所探讨的都是纯粹理性批判所揭示的理性自身的原理在自然领域或自由领域的应用，所谓哲学或形而上学无非就是这样从理性自身的先天原理和概念中引申出来的全部纯粹理性知识的体系。</li></ul><p>其次，我们看到，康德关于自然形而上学的划分同近代早期形而上学(从笛卡儿到莱布尼兹)的系统化者沃尔夫关于形而上学区分为本体论、理性宇宙论、理性心理学和理性神学的划分之间有着明显的继承关系，以至连埃·阿迪凯斯、诺·康·斯密等康德专家都认为，康德的划分“绝大部分不是康德的独创，而是从沃尔夫体系那里抄来的”，它们“不是对科学，而是对想了解康德性格的人有意义”[⑥]。但是，我以为我们无论如何不能囿于他们的看法，而是必须还要看到康德和沃尔夫的划分之间的本质区别，或者说，必须着眼于康德在这里的改造和发展。从外表上来看，他们两人的划分之间的细微区别仅在于：康德所规划的自然形而上学的第二部分是由理性心理学(思维自然形而上学)和理性物理学(有形自然形而上学)两者构成的理性的内在自然学，而沃尔夫形而上学体系的第二部分”[⑦]仅仅是理性心理学。为了理解这一微小区别的本质意义，我们有必要把(1)康德关于自然形而上学的划分，(2)沃尔夫关于形而上学的划分，(3)《纯粹理性批判》中以批判沃尔夫形而上学体系各组成部分为目标或背景的先验分析论和先验辩证论的内容划分作一对照和比较：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzhrowmruzj30lx096wfu.jpg" alt=""></p><p>《纯粹理性批判》中以知性的先天概念和先天原理为研究对象的先验分析论，是对沃尔夫形而上学本体论的批判，也是它的代替物，因而实际上也就成了康德所规划的自然形而上学的第一部分或先验部分——本体论。关于这点康德是这样说的：“一种自负以系统学说的形式提供一般事物的先天综合知识(例如因果性原理)的本体论的夸耀名称，必须让位于一种纯粹知性的单纯分析论这个谦逊的名称。”[⑧]《纯粹理性批判》中以理性的先验理念和先验原理为对象的先验辩证论的三个部分(纯粹理性的谬误推论、二律背反和理想)是依次对沃尔夫形而上学理性心理学、理性宇宙论和理性神学的批判，它们证明了旧形而上学的这些学科作为超出人类理性能力之外的科学是不能成立的。但是，康德并不因此主张从根本上否定或抛弃这些学科，而是认为，只要把它们当作对纯粹理性的“辩证推论”的批判研究，它们就会具有“相当大的消极价值”，即可以起到一种锻炼(训练)理性、使之自觉地限制自己、从而避免或防止超出理性自身能力之外的错误的作用。先验辩证论的上述三个部分就是对纯粹理性的三种不同类型的“辩证推论”的批判研究，因而它们实际上也就是康德所规划的自然形而上学中的理性心理学、理性宇宙论和理性神学，或者至少是它们具体而微的雏型。这样一来，康德关于自然形而上学的划分中，就只剩下理性物理学这一部分是在《纯粹理性批判》中没有其相应物的，而这个部分也正好是沃尔夫形而上学体系所缺少的。[⑨]在康德看来，理性物理学不仅不同于理性宇宙论和理性神学这类超越的自然学，而且也不同于和它同属内在的自然学的理性心理学。虽然理性物理学作为外感对象的学科和理性心理学作为内感对象的学科，都同样有一个有关其对象的经验概念(某种物质[广延而不可入的存在物]或能思维的存在者〔在经验的内部表象“我思”里〕的概念)为基础，但是只有理性物理学才能先天地从单纯的物质概念综合地知道外感对象的总和即有形自然的许多东西，而理性心理学却不能先天地从能思维的存在者的概念综合地知道内感对象即灵魂、我或思维自然的任何东西，因为内感的形式——时间不像外感的形式——空间那样有常住的东西可以作为转瞬即逝的种种感知印象的确定的基础，因而不可能提供确定的对象来认识，而经验的内在表象里的那个常住的“我”又只是伴随我的一切表象的意识的单纯形式，而不是一种直观，因而不能提供认识一个表象的对象所必需的质料。所以，理性物理学作为一种对于应用于自然的纯粹知性的先天知识(知性的先天概念和原理)的批判，不像理性心理学(以及理性宇宙论和理性神学)那样只具有“锻炼”理性的“消极价值”，而是具有仅在物质这唯一一个经验概念的基础上就能提供关于有形自然的许多先天综合知识的“积极价值”，是一种积极的或肯定的自然哲学。因而只有理性物理学或有形自然形而上学才是康德所规划的除本体论外的整个自然形而上学的主体和核心，而康德在这门学科上的成果实际上也构成了往后德国古典哲学的自然哲学发展的开端。正是由于这种情况，它就和道德形而上学一起，成了康德构造其“纯粹理性体系”即较广意义的形而上学体系的两个支点。</p><p>在《纯粹理性批判》于1781年发表后，康德除了为使学术界注意、理解这部著作和消除人们对它的误解而写作《未来形而上学导论)(1783年)和一些小的论文外，可以说是集中主要精力来建设他的形而上学体系。1785年发表的《道德形而上学原理》为道德形而上学体系准备了基础，而次年发表的《自然科学的形而上学基础》，则为系统的理性物理学或有形自然形而上学奠定了基本原理。在为1787年出版的《纯粹理性批判》第二版所写的序言中康德说：“……我的年事已高(本月就进入64岁)，我如果要完成我的计划，提供出自然形而上学和道德形而上学，作为思辨理性批判和实践理性批判的正确性的证实，我就必须节约地使用我的时间。”[⑩]在这里，康德力图完成他所规划的形而上学体系的急迫心情，真是溢于言表。在《判断力批判》问世的前夕，康德在1789年5月26日致马库斯·赫茨的信中说，他已经是66岁的人了，但还担负着他计划中须待完成的工作，其中除上书的出版准备以外，就是“按照批判哲学的要求，撰写一个自然形而上学和道德形而上学的体系”[11]。在1790年发表的《判断力批判》的序中康德表示：“我以此结束我的全部的批判工作。我将毫不迟疑地着手学说的(doktrinal)工作”，而“构成学说工作的将是自然形而上学和道德形而上学”[12]。高龄的康德按照道德哲学优越于理性的一切其他工作的原则依然首先致力于道德形而上学的建设。直到1797年，康德才正式出版了《道德形而上学》，这部著作所体现的完整体系是由先后发表的《法权论的形而上学原理》和《德性论的形而上学原理》两大部分组成的。在以道德形而上学体系证实实践理性批判的正确性以后，康德的注意力立即转向解决以自然形而上学体系证实思辨理性批判的正确性的任务。1798年，在发表《实用人类学》的同时，他在致伽尔韦的信(1789年9月21日)中语重心长地写道：“我现在正在解决的任务涉及‘从自然科学的形而上学原理[基础〕向物理学的过渡’。这个任务必须解决，若不然，批判哲学的体系中就会留下一个漏洞。”[13]随后又在致基塞维特尔的信(1789年10月19日)中说到“弥补留下来的漏洞”的重要性，他说：“从自然科学的形而上学原理向物理学的过渡”“是philosophia naturalis(自然哲学)的一个独特部分。在体系中，它是不可缺少的”[14]。但是，风烛残年的康德已不可能完成这部他定名为《从自然科学的形而上学原理向物理学的过渡》的重要著作，他只留下一堆零散的笔记，一些或长或短、互不联系的片断，就与世长辞了。</p><p>　　总起来说，康德整个批判时期所追求的“科学形而上学”或“纯粹理性体系”并没有完全建立起来。这种情况当然不是偶然的。因为在康德看来，批判理性是建立起科学形而上学体系的前提，因而也更为关键、更为重要；这是一项前无古人的开创性工作，当时只有他一人洞见到了哲学发展的这种迫切需要；因此，一旦“批判工作”有了需要，他就应当自觉地放下其他一切工作，集中全部的时间和精力来完成这项历史赋予他的重任，至于建立体系或学说的工作尚可交给他人或等待来者去做。同时，康德对于理性批判的内涵的广度和深度、所涉及的问题的复杂和困难，是他在完成第一部批判著作时始料不及的，以致理性批判工作的结束不像他最初以为的那样是1781年发表的{纯粹理性批判》，而是如他后来所宣称的那样是1790年问世的《判断力批判》。这就是说，为了及时地、全面地完成理性批判的工作，康德不得不中断他在80年代就已经开始了的建立道德—自然形而上学体系的工作几近十年之久。再者，在批判工作和体系工作两相比较时，康德的确认为前者更困难些，后者要轻松些，但就体系工作本身而言却也是困难的，而且其困难的程度也是康德始料不及的。这就是为什么康德在《纯粹理性批判，第一版序言中关于建立形而上学体系只消“以微小而集中的努力，而且在短时期内即可达一种后人……在内容上不能有所增益的完备性”这类性质的话，在后来就再也见不到了的原因所在。当然，归根到底，最根本的原因还是在于，康德用来作为其全部哲学或形而上学的出发点的“纯粹理性”，虽然具有不同方面和不同程度的能动性和主动性，但终究是形式的、静态的、脱离人的实践活动和历史发展的，本身没有内在发展的动力和源泉，没有通过否定自身以实现自身、上升到自身的更高形态和阶段的辩证发展的必然性和规律性，因而说到底还是被动的和不自主的。不借助于某种经验的东西(如物质和运动的经验概念)，要从这样的“纯粹理性”逻辑地引申出关于自然和自由的全部哲学知识的体系是绝不可能的。甚至即使在作为体系的“导论”的“纯粹理性批判”中，就连知性(理性)的范畴(先天概念)也不是从纯粹理性自身必然地引申、发展而来，而是外在地从形式逻辑关于判断的分类，即从经验中假借来的，又遑论从它那里引申、发展出一个完整的哲学体系了。康德没有建成这样的体系，这并不重要。他的伟大和功绩正在于他比同时代人都站得高、看得远、想得深，而以极大的勇气提出了这样的设想，即以理性批判为前导，从纯粹理性中引申出既是认识论和逻辑学，又是本体论的范畴(概念和原理)系统和作为这个范畴系统之应用的自然哲学以及自由(精神)哲学这样三个部分构成的哲学体系，并为此做了在当时条件下所可能做到的、必不可少的、开创性的奠基工作。这个宏伟的设想的实现，本来就不是一代人的事，而是需要几代人连续不断、呕心沥血的创造和劳动。我们知道，在康德之后，经过费希特和谢林，直到黑格尔，这个设想才成为现实，而这时的纯粹理性及其体系同康德最初所设想的相比，可真是面目全非了。然而，不管两者的差别、乃至对立多么的大，但它们之间从少儿到成人的生长轨迹依然是清晰可辨，不容置疑的。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>在康德看来，科学的形而上学或哲学一定是一个科学的系统，没有系统的统一性就没有哲学。这是康德提出和始终坚持的一个重要思想。但是，他认为真正科学的哲学又不能单讲系统性、科学性、知识性或逻辑性。如果这样，哲学所关注的就只是少数学院人士关切的东西，哲学就会沦为一种理性的技巧的学问，康德认为沃尔夫的哲学就属于这种哲学。在他看来，对于哲学更为重要、而且任何时候都成为哲学的“实在基础”的，是哲学的“有用性(Nützlichkeit)”。所谓哲学的有用性是说哲学所关注的是“人人都必然对之关切的东西”，这就是能够指明人的一切知识和理性使用同人类理性的最终目的之间的内在联系，从而能够促使人们向着人类理性的最终目的接近。哲学由于这种有用性才会具有绝对的价值和无上的尊严。这当然并不意味着哲学的系统性或科学性与哲学的有用性或目的性是对立的，因为有用的哲学也必须是科学，是一个以人类最终目的为根据的系统统一的整体，不然它就会成为一种空洞的幻影。在康德看来，他所规划的由纯粹理性的“批判’’和“体系”所构成的形而上学就应该是这样一个系统性和有用性，科学性和目的性相结合的哲学体系。</p><p>正因为这样，康德在《纯粹理性批判》里，在讨论“纯粹理性的建筑术”之前，首先讨论了“至善这个理想作为纯粹理性最终目的的规定根据”，对“人人都必然对之关切的东西”从哲学的层面上进行了概括和阐述。他说：“我的理性所关切的一切(思辨的和实践的)结合为以下三个问题：</p><ul><li>1．我能够知道什么?</li><li>2．我应当做什么? </li><li>3．我可以希望什么?”[15]</li></ul><p>康德认为，第一个问题纯是思辨的或理论的问题，即关于实有事物的知识问题。人能够通过经验认识由自然必然性决定其实存的一切自然事物，其中包括作为自然一分子的人在内，从而获得对于自然的科学知识，这是一个不容否认的经验事实。除此以外，凡不是实有的事物或不能成为现象或经验对象的事物，如人有没有不受自然必然性决定的自由意志，特别是有没有不死的灵魂(来生)和上帝是否存在，都是人类理性所不知的，不能进入人的知识范围的。为了彻底解决什么是人能够知道或认识的，什么是人不能够知道或认识的，哲学首先就要研究人的一切知识的源泉，一切理性使用的范围，从而确定人类理性的界限。划界问题特别重要，它的解决一方面为自然科学的可能性奠定了理论基础，二方面论证了上帝等等不可知，从而为人超出自然必然性的自由意志，以及来生和上帝的存在留下了地盘。康德坚决反对旧形而上学把认识自由意志、来生和上帝存在看作是人类理性的最高或最后目的，他认为关于它们，特别是来生和上帝存在的问题，我们是不能得到任何知识的，而且即使获得了这样的知识，对于认识自然事物、取得科学的自然知识也毫无意义。再退一万步说，就算有来生和上帝存在，也还有一个“我应当做什么”的问题需要解决。这第二个问题纯是一个实践的问题，即关于通过自由而可能的东西的表象问题。在康德那里，实有的事物是依照自然必然性而发生的，应有的事物则是不依赖自然必然性而通过意志的自由决定才可能发生的。人的意志只有不顾欲望、爱好和外界的支配，完全依照理性的先天道德原理，做到自律、即真正的自由或独立自主时，才有道德性，而人也才真正成为人。意志自由不仅是道德的必要条件或基础，而且就是道德本身。照康德看来，理性的最高目的不是知识、科学、自然必然性，而是使意志实现自由，成为一个自由的、道德的、善的意志，这也就是人类理性的整个使命或天职。但是，人类理性关切的东西并不就此完结了，因为我做了所应当做的，就还有一个“我可以希望什么”的问题。这是一个既是实践的同时又是理论的问题。在康德看来，“一切希望都指向幸福”，而“幸福是我们一切愿望的满足”。虽然对幸福的追求绝对不能像法国唯物主义者主张的那样是道德的基础，但是人类实践理性希望得到幸福也是必然的，合理的。因此，问题只能是把道德作为配享幸福的条件，从而把道德与幸福统一起来，使幸福能够按照道德以精确的比例进行分配。这种“理想”的境界才是最高的和最完全的善，是“至善”，因而也才是人类理性真正的最终目的。但是，这个“至善”理想的实现不仅要假定自由意志，而且更为重要的是要在来生和上帝存在的条件下才可能。这样，实践的问题就作为三种引线而引到理论问题的答案那里去了。就是说，“至善”理想应当实现的问题为思辨理性所想解决而不能解决的上帝存在等问题顺理成章地提供了一种来自实践理性的“信仰”的答案。因此，我们可以看到，当康德经过这样三个问题而把“至善”这个理想规定为人类理性的最终目的时，他已经把哲学看作是对于人在世界中占的位置、人的职责和最终命运的探究了。</p><p>康德提出的三个问题表明康德在纯粹哲学领域内探讨的主要问题不是来自书本，而是来自人的现实生活，是现实的人所面临的现实问题的哲学升华。对这三个问题的研究和回答构成了康德哲学的真实内容方面，而“纯粹理性的建筑术”中所规划的体系及其构成则属于表达这种内容的形式方面。在康德看来，这个形式是适合于表达它所要表达的内容的，因为在他的构想中，自然哲学应从属于道德哲学，从而溶合成为一个以人类理性的终极目的为基础的单一哲学体系。</p><p>可是，到了90年代，康德关于哲学问题的内容和观点都有了新的发展。他在致司徒林的信(1793年5月4日)中说，长久以来，他在纯粹哲学领域里的研究计划，就是要解决上面的三个问题，接着他令人注目地在这三个问题之后，补充了“第四个，也是最后一个问题：人是什么?”[16]大约与此同时，康德在其逻辑学讲义(后来于1800年由耶什整理出版)中把这四个问题作为一个整体提出来，认为它们一起构成了“世界公民意义上的哲学的领域”，并且指出：“形而上学回答第一个问题，道德学回答第二个问题，宗教学回答第三个问题，人类学回答第四个问题。但从根本上说，可以把这一切都看成是人类学，因为前三个问题都与最后一个问题有联系。”[17]在这里，比起在致司徒林的信中来，不仅更明确地说明了研究和回答这四个问题的各个学科，而且更为重要的是表达了一个前所未有的新思想：把前三个问题同人是什么这个问题联系起来，把它们全都看作人类学的问题，从而研究和回答这三个问题的各学科也都可以看作是人类学或从属于人类学。这样一来，人是什么这个问题就成了康德提出的四个哲学问题中的总问题，而人类学则成了统率和囊括其余学科的总学科。就此而言，我们的确可以而且应当认为，这是康德哲学思想中一种十分值得注意的新变化。因为在提出前三个问题和规划哲学的体系及其构成时，康德原本不是这么看的。在对自然形而上学的理性心理学中是否应当包括经验心理学在内这个问题的讨论中，他明确地表示，经验心理学虽然可以暂时留在理性心理学内，但长远地看，它却应定居在“一种与经验性的自然学配对的详尽的人类学中”[18]。这就是说，康德在这时是把人类学作为一种经验性的学说而排斥在他的纯粹理性的体系、即道德—自然形而上学体系之外的。由此也可以推断出，康德当时是说不上把他提出的三个问题归结到人是什么这个人类学的问题上来的。</p><p>当然，90年代康德哲学思想中的这个新变化或新发展并不是突如其来的。正如康德在上述致司徒林的信中提出人是什么这个问题时所注明的那样，这是一个人类学的问题，而20多年来，他每年都要讲授一遍人类学。由此可见，人是什么的问题虽然是他现在才明确提出来的，但这个问题本身从前批判时期起(康德从1772年起开始讲授人类学)就一直蕴藏在他的心里，并潜在地支配着他的思想。但是，由于康德始终认为，人类学作为一种经验性的学说必须放在经验性的自然学所在的同一个地方，所以他在提出哲学研究的三个问题和哲学体系的构架时，就理所当然地把人类学排除在形而上学体系之外。那么，到了90年代，他又为什么会提出人是什么这个人类学问题作为其他三个问题都与之相关联的总问题，而把回答其他问题的学科都看成是人类学呢?这也许是康德（1）关于人类学的长期思考，(2)关于建立纯粹理性的“体系”，即道德—自然形而上学体系的长期计划，(3)回答我能够知道什么等三大问题的研究计划，(4)纯粹理性的“批判”的扩展、深入和完成等四大要素或方面的进程在一定阶段上相互交汇和碰撞所必然产生的结果。在《纯粹理性批判》回答了我能够知道什么这个问题之后，为了彻底解决我应当做什么这个问题，康德继《道德形而上学原理》后又写了《实践理性批判》。在这以后，康德没有立即去回答我可以希望什么的问题，而是不得不着手解决由于前面两大批判著作所造成的理论理性和实践理性、自然必然性和自由、科学和道德的对立问题，因为只有解决了这个问题，一方面，才能为康德所最关心的哲学或形而上学的两大部分，即自然形而上学和道德形而上学之联结为一个统一整体提供可能性，另方面，才能为解决纯粹理性所追求的最终目的在感性世界里实现的可能性问题提供思路。这时，人类学中关于人的心灵具有知、情、意三种能力的经验性考察和先验哲学对人类高级认识能力中知性、判断力、理性三种成分的划分之间的对比，终于使康德在山穷水尽时看到了出路，去从事于判断力的批判，以发现情感能力的先天原理。在这里，特别明显地显示出来，人类学对于康德来说不仅是他始终立足的经验基地，而且还具有一种他在先验哲学中进行探索和求得正确答案的指南的意义。正如康德自己在谈到他如何走上第三批判的道路时所说的那样：“如果我有时不能正确地确定某个对象的研究方法，那么，只要我能够回顾一下认识和与此相关的心灵能力各要素的全貌，就能找到我所期待的答案。”[19]另方面，对于判断力的批判反过来又使他认识到了，人生活的世界是以人的创造文化的活动为基础的，人的一切，包括人自身，都是通过人的自觉的、有目的的、自由创造文化的活动的产物，而人类理性的最终理想或目的的实现，即人的最终命运或前途，也必须联系到人的创造文化的活动来考虑。这样，人的认识(科学和自然必然性)的问题，人的道德和自由的问题，人的希望或最终命运的问题，都不能离开人是什么这个问题而得到单独的、至少是圆满的解决，而勿宁说，它们都只是人是什么这个总问题中的应有之义或其不同的成分或方面的表现，因而这个总问题的解决也必然地蕴含着那些问题的解决或为那些问题的真正彻底解决提供了现实的可能性。</p><p>因此，根据康德把人是什么这个问题看作是一切其他问题归宗的根本问题，把人类学看作回答这一根本问题的学科，我们可以说，他在这里实际上(不管他自觉与否)已经超出了他1781年提出三个问题时所设计的纯粹理性体系，即道德—自然形而上学体系，而构想出了一种新的哲学体系，即接近于我们今天称之为哲学人类学的那样一种哲学体系。现在我们就来看看康德以回答四大问题为基本内容，以建构某种类似哲学人类学的体系为宗旨的长期研究计划完成的情况。在康德看来，第一批判，即《纯粹理性批判》，是这个计划的第一部分，在这部分里他“已经穷尽了”我能够知道什么“这个问题的一切可能的答案，而且最后找到了理性必然对之感到满意的那个答案”[20]。第二批判，即《实践理性批判》，回答了我应当做什么这个问题，它是这个计划的第二部分。值得注意的是，由于在康德心目中，回答我可以希望什么这个问题的应是宗教学，因此，构成这个计划的第三部分的就不是像通常有的人所想的那样是第三批判，即《判断力批判》，而是如康德自己指明的那样是后来于1793年出版的《单纯理性范围内的宗教》(Die Religion innerhalb der Grenzen der biopen Vernunft)。康德非常自信地认为，他在这部著作中已经认识到了，“基督教与最纯粹的实践理性的结合是可能的”[21]。在他看来，人们为了实现具有一个善良意志，不仅需要个人道德修养上的努力，而且必须生活在力求意志善良的人们组成的某种“伦理团体”或“神秘团体”里，而历史中产生的宗教就是把人们结合成为这样的团体的必不可少的手段。不过能真正实现其道德使命的不是同神做交易的、有个人打算的侍奉神灵的宗教，而是理性信仰的宗教。这种宗教所唯一要求的是：要按照理性的道德命令来生活，在善良生活方式中通过内心善与恶的斗争，克服人性的劣根性，达到道德上的最高完善，好像有来生在等待着你，有上帝在君临着尘世似的。这种情况，在实践理性看来，是完全必要的和可能的。因为在这里，人们对自己道德力量的信仰也就是对神的信仰，只是人们虽然有力量使自己道德上完善，却无力使道德与幸福统一起来，因而必须承认，也就是假设有来生和全知全能全善的上帝作为这个世界的统治者。我们看到，尽管康德的道德思想和宗教思想渗入了值得注意的社会性和历史性的因素，但人类理性的最终理想—道德与幸福的统一仍然像过去一样被推到了彼岸。也许康德本人也觉察到了，而且也不满意于这种情况，所以他并不是在回答第三个问题后，就立即去回答第四个，也是最后一个“人是什么”的问题，而是把目光首先转向探索人们除去寄希望于自己和宗教信仰外，是否还要以及如何寄希望于社会、政治、法及其制度的问题，陆续发表了《永久和平论》(1795年)，《法学的形而上学原理》(《道德形而上学》的先行发表的部分，1797年)等著作。直到1798年，康德才在长期讲授人类学的基础上，出版了《实用人类学》，这也是他的全部哲学著述活动中最后一部由他自己撰写和发表的著作。康德没有改变他关于人类学是一门经验性科学的一贯立场，先验论(先天的知识原理、先天的道德原理、先天的自然合目的性原理以及先验自我意识等等)在这里至多也只是一个背景，而没有被强调和作为解决问题的手段。康德人类学的出发点是“根据他(人)的类，把他作为具有天赋理性的地球生物来认识”，“研究的是人作为自由行动的生物由自身作出的东西，或能够和应该作出的东西”[22]。所谓自由行动，是指人因为赋有理性而能自由地选择目的和采取相应的手段使之得以实现的这样一种行动。人由于他的这种自由行动而具有了一种把他同地球上其他动物或生物区别开来的自己创造自己、发展自己、完善自己的特性。关于这点，康德是这样说的：“人具有一种自己创造自己的特性，因为他有能力根据他自己所采取的目的来使自己完善化，他因此可以作为天赋有理性能力的动物而自己把自己造成为一个理性的动物。”[23]这就是说，在康德看来，人是这样一种地球生物，他能够通过自己的创造行动使自己从潜在的理性动物变为现实的理性动物。但是，人的这种本质的规定性不能在个体那里，而只能在类里得到完整的体现，这也是由于人因其理性而被规定为与人们处在一个社会中使然的。因此，人自己创造自己的过程或从一个仅具理性潜能的动物变为一个真正现实的理性动物的过程，也就只能在类的世代延续的无穷系列的进步中实现。康德就是从这样一点出发，在这部著作的第二部分“人类学的特性”中，依据经验和历史，通过概括和推论，力图表明：人如何作为一个类，虽然由于自私自利而彼此不和、从而造成了巨大牺牲和浪费，但通过社会中的劳动、社会交往中的纪律(社会的、政治的、法的制度)、包括科学和艺术在内的整个文化的进步，而把自己创造成为一个日益接近有高度道德意识的、幸福的和永久和平相处的世界公民组织的。康德人类学的这一基本思想显然具有某些接近于现代文化哲学人类学的特征，在它里面蕴含着这样一个必然的推论：既然人的一切都是在人创造自身的进程里发生发展起来而同人本身的存在和发展统一而不可分的，那么人的一切就都不可能离开这个完整的人创造自身的过程而单独地得到理解，因此，人类学就应当成为关于人的任何一个方面，如认识、道德、艺术、宗教等等的研究的基础。然而，就康德的时代而论，由于当时经验科学提供的关于人的知识(如关于人的起源的生物进化论的知识、人种学和民族学的知识等)还是如此的稀少和残缺不全，以致还没有必要的前提，在对它们进行哲学的解释的基础上建立起某种形态的完整的哲学人类学。因此，康德本人还不可能真正把他的人类学作为基础来重新考察他所提出的有关人的重大问题(我能够知道什么，我应当做什么和我可以希望什么)，使对这些问题的解答能同其人类学的基础相协调一致，又何况耄龄的康德很快就虚弱到丧失了工作和思考的能力了呢。</p><p>总之，康德以人是什么为总问题的，包括其他三个问题在内的某种哲学人类学体系，虽然每个问题都有相应的著作来解决，因而他计划中的各个组成部分都已有了，但就作为一个内部协调的完整的体系而言，依然没有真正完成。这是不足为奇的。相反地，值得大书特书的倒是，在早期理性主义和经验主义的唯科学主义统治的情况下，能率先提出人是什么及人在世界中的地位、职责、命运等问题来作为哲学研究的主要问题，并首次把“人类学”作为哲学的科目来研究并试图建立起某种哲学人类学体系，这应当看作是康德在哲学上高瞻远瞩和另辟蹊径的丰功伟绩，其影响巨大而深远。这首先表现在它为康德自己所开创的德国古典哲学的传人从费希特到黑格尔的精神发展提供了一个崭新的视角，即要从人创造自己的现实活动及其实际的发展出发，在人同社会、历史的相互联系中考察人类理性，从而把康德提出作为“纯粹理性体系”的“未来形而上学”在新的基础上建立起来，同时也预示了费尔巴哈的以人类学代替神学，以完整的人代替黑格尔的“绝对精神”、甚至笛卡儿和康德本人的“人类理性”作为哲学出发点的“未来哲学”。康德哲学的人类学方面对现代西方哲学的影响尤为深刻，它为许多流派如存在哲学，特别是哲学人类学启示了一种全新的哲学出发点。正是海德格尔、雅斯贝尔斯和舍勒等人把康德提出的人是什么的问题，甚至包括这个问题在内的四大问题作为自己哲学思考的引线和中心，他们由此出发建立了不同形态的存在哲学和哲学人类学，从而也把康德提出的人是什么等问题从长期受忽视的状态推到前沿，使人们对康德哲学的认识进到一个全新的境界。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>这样，在康德那里，真正完成了的哲学体系就只有由三大批判著作构成的“批判哲学”体系，这也就是我们通常所说的康德哲学体系。照康德的看法，这个哲学体系实际上是作为科学形而上学之导论的“纯粹理性的‘批判’”体系。</p><p>　　康德多次指出，1781年的《纯粹理性批判》是他12年期间精心思索成果的总结，而从《纯粹理性批判》到1790年的《判断力批判》又经过了9年。因此，康德的批判哲学体系的建成是他20多年来不断探索的结果，是他的哲学思想持续发展的产物。如果我们把1781年前的12年称为“纯粹理性批判”的前史，那么17’81至1790年则应看作“纯粹理性批判”本身发展完成的过程。现在我们就来鸟瞰一下这个过程。</p><p>　　康德在1781年发表的第一部批判著作《纯粹理性批判》里，把“纯粹理性批判”规定为一门以批判考察人类先天认识能力，即基于先天原理的认识能力为对象的科学，这门科学的主要任务就是要确定人类认识能力有哪些先天要素以及这些先天要素的来源、功能、条件、范围和界限。康德认为人类认识能力首先区分为：作为低级认识能力的感性和作为高级认识能力的理性。感性通过先天的直观形式时间和空间接受由于物自体对感官的刺激而产生的感觉，从而为高级认识能力提供对象和质料。感性直观是认识的开始，同时也是人类认识的不可超越的范围，因为失去了感性直观，高级认识能力也就没有了认识的对象和质料。康德把高级认识能力区分为知性、判断力和理性三种。他确定，只有知性的先天原理(由先天范畴体现的规律性)是构成性的，就是说，是使经验(科学知识)和经验对象(科学认识的对象)——作为现象全体的合乎规律的自然界成为可能的原理，因而也就是知性向人类认识能力颁定的先天法则或规律。判断力则运用知性的先天原理去统摄或规定特殊的感性现象，以形成关于对象的经验知识，康德后来称这里的判断力为规定的判断力，以别于作为“判断力批判”之对象的反思的判断力。理性则通过它的先验的理念和原理来指导和推动经验或科学认识的最大可能的系统化、继续和扩大。知性的范畴必须同感性质料结合才能形成知识和知识对象，离开了感性质料它们只不过是空洞的思维形式。理性的迷误正在于不知道它的理念和原理只是一种指导经验如何进行的范导性原理，而不是把仅适用于感性世界的范畴扩大到一切可能经验之外，即扩大到经验所能提供的对象之外的对象去的构成性原理，从而运用范畴去规定那超经验、超感性的本体，其结果产生的不是关于本体的知识，而是形形色色旧形而上学的谬误推论和自相矛盾的假知识或伪科学。既然只有现象可知，本体不可知，这就限制了理性的理论使用，即知识的，范围，而正因为如此，也就为人的摆脱自然必然性的意志自由、道德、对来生和神的信仰，一句话，为理性的实践使用留下了余地。这就从理论上为作为科学出现的未来形而上学(内在的自然形而上学和超验的道德形而上学)的可能性进行了充分的论证。</p><p>　　正因为《纯粹理性批判》已经确定了人类认识能力的先天原理，弄清楚了各种认识能力在认识总体中各自所能做出的那一份贡献，为理性的实践使用准备好了地盘，所以康德认为他对一般认识能力，即纯粹理性的批判已经完成了。这时，无论在《纯粹理性批判》中，还是在其他地方，康德都从没有提到过实践理性批判，即所谓第二批判的问题，而是计划如何建立道德—自然形而上学体系。甚至在1785年发表的作为道德形而上学之“导言”的《道德形而上学原理))中，虽然康德肯定除去纯粹实践理性批判以外，道德形而上学照理说就没有任何别的原理，正如已发表的纯粹思辨理性批判就是[自然〕形而上学的原理一样，并且还认为他在这部著作的第三章(从道德形而上学过渡到纯粹实践理性批判)已经提出了这样一个批判的足够当时需要的主要线索，但是他仍然认为对实践理性进行批判并没有像对理论理性进行批判那样必要，“因为在道德方面，人类理性就是连最普通的知性也容易达到较大的正确性和完满性”[24]。因此，在本书中康德并没有显示出任何撰写一部“实践理性批判”著作的打算，而是鲜明地表示要完成一部《道德形而上学》。尽管这样，康德在这里已经明确地提出了，在道德形而上学的范围内是不能解决道德的最高原理，即道德律如何先天的可能，为什么它是普遍必然的课题的，为此就必须对实践理性进行一番批判，而在完成这种批判的同时还有必要说明实践理性“在一个共同原理上”同理论理性的统一或一致，因为归根到底只有一个理性，只是在运用方面有所不同罢了。[25]这就是说，对实践理性进行批判，乃是“纯粹理性批判”作为一门具有系统统一性的完整科学和一种为形而上学奠基的系统工程的内在需要。不过’，只是在《道德形而上学原理》问世引起许多关于康德的道德哲学及其同《纯粹理性批判》的关系的批评和责难以后，康德意识到同批评者和论敌进行零敲碎打式的争论是不行的，必须对自己的道德原理的必然性和可能性进行深入的、系统的科学论证，就是说，对实践理性进行一番类似第一批判那样的批判考察，才能彻底解决问题。他在1786年4月7日致贝林的信里谈到他正在修订《纯粹理性批判》，但不打算对它作重大的改动，因为所有属于“这个体系”的命题都是合适的，然后谈到他在这项工作之后的进一步打算：“我将继续把自己关于形而上学的研究抛开，为的是争取时间，构建实践哲学的体系。这个体系与前一个体系是姊妹篇，需要加以类似的处理，但尽管如此，却不会遇到前一个体系那样大的困难。”[26]显然，这里所说的“实践哲学的体系(das System der praktischen Weltweisheit)”即是指“实践理性批判的体系”。起初，康德曾计划把实践理性批判合并到《纯粹理性批判》第二版里去，后来他放弃了这个打算。1787年4月《批判》第二版发表，6月他在通信中告诉友人“《实践理性批判》已经大功告成”[27]，即将付印。这部著作在出版商那里一直延误到1788年才正式出版。</p><p>　　《实践理性批判》的任务是：完整地确定实践理性(或理性的实践使用)的先天原理的可能性、范围和界限。康德的出发点是：纯粹理性自身就是实践的，因而具有先天的实践原理，这就是由道德律体现的最后目的。这个原理是使意志的自由、道德成为可能的构成性原理，因而也就是纯粹理性向人心的高级欲求能力(意志)颁定的先天法则或规律，意志应当做的就是以道德律为根据自立规律，敬重和遵从自立的规律，从而实现由道德律所体现或交给的那个最后目的——成为一个自由的、道德的意志。不过，先天实践原理不能用于现象，而只能用于超感性的本体，就是说，它不能用来从理论上认识、解释和推断一切的实有、自然事物、经验对象、包含作为现象，即自然之一分子的人在内的现象界或自然界的存在、性质和规律，而只能用来“从实践上”认识、解释和推断一切应有的事物，首先是自由、道德(善)、目的国、至善等等，从而对它们的存在、性质和规律得到一种实践的体会和信念，它涉及的只是“应当如此”，而不是“事实如此”或“必然如此”。</p><p>　　康德在撰写和结束《实践理性批判》时，很可能认为他对理性批判的任务已经实现了，因为他通过两大批判已把人的心灵的两个主要能力——认识能力和欲求能力的先天原理的来源、内容和界限揭示出来了，而同时通过实践理性和理论理性在同一认识中只有在实践理性占优先地位的条件下才能必然地先天地结合起来的原理又已解决了它们两者的统一问题，自然(理论)—道德(实践)形而上学的奠基工程也就似乎完成了。正如他在《实践理性批判》的序中说的那样：“因此，在这种方式下(指先分析地研究各个部分、然后进到综览全局的方法。——引者)，心灵的两种能力，即认识能力和欲求能力的先天原理就会被发现出来，并且就它们应用的条件、范围和限度而言也都被确定了，这样就给作为科学的系统的(理论的和实践的)哲学打下了牢固的基础。”[28]不过，这只是康德思想的一个方面。另一方面，也是更为重要的一个方面，是他深深地意识到，在作为主体的人里面有两种不同的立法——知性在认识中的立法和理性在自由中的立法——虽然并不矛盾，但这样两种立法的后果却导致了作为主体的人的巨大分裂，使之分属于两个绝对不可跨越、互不影响的领域：一个是可以认识的、受自然必然性支配的、作为感性现象的自然界，一个是不可认识的、可以自由自决的、作为超感性的本体的道德界(自由界)。在康德看来，所谓理论理性和实践理性在实践理性占优先地位下的统一并不足以消除自然领域和自由领域之间的这种巨大的鸿沟，因为在这里还缺少一种从前一领域到后一领域之间的过渡，一座由此及彼的桥梁，一个把两者联结起来的中间环节。这样的过渡、桥梁或中间环节是应该有的，因为自然领域虽然绝对不能对自由领域施加影响，但自由领域却应该对自然领域有影响，就是说道德律所体现的最后目的应该在自然界、即感性现象世界里实现出来，为此自然界的合规律性就必须和道德律所体现的最后目的应该在自然界里实现的可能性互相和谐一致。现在的问题只是应该到哪里去寻找这样的过渡、桥梁或中间环节。当然、按照康德关于“纯粹理性批判”的观点，只能到人类心灵的判断能力中去寻找，而人心除去关于真的判断能力和关于善的判断能力以外，就还剩下关于美的判断能力，即鉴赏力或审美力。于是，康德在1787年6月25日致许茨的信中宣称《实践理性批判》已经大功告成的同时，又申明自己“必须马上转向《鉴赏力批判基础》”[29]，试图探索鉴赏判断是否也从属于先天的理性原理或规律的问题。两个多月以后，康德似乎已经有了肯定的答案，因此在9月11日致雅可布的信中说：“目前，我径直地转入撰写《鉴赏力批判》，我将用它结束我的批判工作”[30]。到了年底，他的新思想在致莱因霍尔德的著名书信(1787年12月28日)中就耀眼地涌现出来了：“我现在正忙于鉴赏力的批判。在这里，将揭示一种新的先天原则，它与过去所揭示的不同。因为心灵具有三种能力：认识能力，愉快与不快的感觉，欲望能力。我在纯粹(理论)理性的批判里发现了第一种能力的先天原则，在实践理性的批判里发现了第三种能力的先天原则。现在，我试图发现第二种能力的先天原则，虽然过去我曾认为，这种原则是不能发现的。”[31]同时，康德还在信中指出，知、情、意三种心灵能力构成的体系性的东西；使他改变了哲学二分为理论哲学和实践哲学的观点，而认识到哲学有三个部分——理论哲学，目的论，实践哲学，每个部分都有它自己的先天原理，三者当中自然是目的论“最缺乏先天规定根据”[32]。在这里似乎表明康德已经萌发了一种想要系统地研究自然界中的合目的性问题或自然目的论的“先天规定根据”的倾向，而这种倾向在与此信一并寄给莱因霍尔德即将在《德意志信使》上发表的同福尔斯特( J.G．Forster)论战的文稿《论目的论原则在哲学中的运用》(1788年1月刊出)中还见不到，虽然文章有针对性地讨论了生物有机体和自然史的科学研究必须以目的论原则作为指导原理的问题，而且还提出了把自然和艺术品同等地看作有机整体的思想。尽管这样，直到1788年春季，康德仍然没有把对美学的先天原理的研究和对有机体自然科学及自然目的论的先天规定根据的研究综合统一起来，因而在致莱因霍尔德的信(1788年3月7日)中他把计划在半年内完成的第三部批判著作照旧称作《鉴赏力批判》，就是说它研究的只是美学问题。[33]只是又经过了一年多的深入思索之后，康德的新思想才完全成熟和定型下来，他终于在高级认识能力中介于知性和理性之间的判断力里找到了一种把看来漠不相干的美学问题和有机体自然科学—自然目的论问题都统摄包容起来的根本原理。这样他就依然回到了他过去一贯坚持的哲学只有两个部分(理论哲学和实践哲学)的观点，认为(自然)目的论在必要时可隶属于理论哲学，而其原理则属于“纯粹理性批判”的范围。因而，康德在致莱因霍尔德的信(1789年5月12日)中就把他正在撰写的第三批判称为“判断力批判”，并注明“《鉴赏力批判》是其中的一部分”[34]。这一部分后来正式定名为“审美判断力批判”，而信中所没有提到的《判断力批判》的另一部分则是“目的论判断力批判”。全书于1790年春出版，并于1792年再版，1799年出第三版。</p><p>　　《判断力批判》的任务是，确定介于知性和理性之间的判断力的先天原理，这个原理是构成性的还是范导性的，它是否是判断力对介于认识能力和欲求能力之间的愉快和不快的情感能力颁布的先天规律，它是否真正能够充当从纯粹认识能力到纯粹欲求能力、即从自然领域到自由领域过渡的桥梁或中间环节。</p><p>　　康德认为，这里所说的判断力已不是《纯粹理性批判》中讨论的那种把特殊从属于给定的普遍的规定的判断力，而是为给定的特殊寻找、发现那可以统摄它的普遍的反思的判断力。反思判断力的先天原理不可能是规定判断力所遵循的知性范畴所体现的规律性(主要是因果必然性)，因为它所面对的特殊的经验事实或规律(例如有机体和艺术作品的各个部分之间的关系)就不是知性的因果性原理所能规定和包摄的。那么，反思判断力需要一条什么样的先天原理才能使多样性的特殊事实和规律得到统一呢?康德从人类技艺和道德中表现出来的“实践的合目的性”类推到，在自然的多样性的经验事实中也应表现出一种合目的性，这就是“自然的合目的性”的概念：“自然通过这个概念就被这样地表象着，好像有一个知性包含着自然的经验规律的多样性的统一的根据。”[35]这个知性当然不是我们人的知性(因为人的知性的先天概念是自然的因果性而不是自然的合目的性)，至于是否真有这样的知性也是无法确定的。所以，“自然的合目的性”是一个特殊的先天概念，它只是在反思判断力里有它的根源，就是说，它是反思判断力为了反思的需要而自己提供给自己的，是人用来从当前特殊的经验对象出发反思作为其基础或根据的超验本体、反思人的超验本体、暗示人的自由、道德、最后目的的前景的反思判断力的先天原理。</p><p>　　这个原理首先在人的审美和艺术活动中起作用。在这里，它是一个使直接同愉快和不快的情感相联系的审美判断和审美对象(美)成为可能的构成性原理，因而也就表明它是反思判断力对愉快和不快的情感能力颁立的先天法则或规律。在进行审美鉴赏时，人们着眼于一个自然对象的无目的的合目的性形式，使自己的想象力和知性能力好像趋于一个目的那样处于自由协调的活动(游戏)之中，从而无须任何概念而产生出人类共同的、无利害关系的愉快感，这就使审美对象、美在人们眼中成为了“道德的象征”，从而促进人心对于道德情绪的感受性。与审美鉴赏不同，艺术创造是带有艺术家的目的和概念的，但真正天才的艺术家并不是按照目的和概念来创造，而是好像无目的地绝对自由地进行创造，以致创造品显得好像是大自然本身的产品，但同时却又体现着天才艺术家的道德目的和理想。总之，在审美和艺术创造活动中，通过反思、象征和类比的方式，而使自然界和道德界、现象和本体、必然和自由达到了一种主观形式上的统一。</p><p>　　其次，反思判断力的先天原理在人们对自然的认识活动中也有其应用，不过在这里它只是作为认识能力的范导性原理而同愉快和不快的情感没有直接的关系。人们除了按照因果律等等对自然界加以认识之外，还总是倾向于对自然有机物作目的论判断。人们把有机物和无机物区别开来，把无机物视为有机物的手段，而把有机物或有机体判定为一个以自身为目的(内在目的)的统一整体，并由此而扩大到把整个自然界看作一个从低级趋向于高级的自然目的系统，其顶点则是以遵守道德律的(自由的)人为最后目的。这就使人有理由猜测到整个自然界都是从必然向自由生成的过程，从而暗示了现象和本体、认识和道德在客观质料上也是统一的。</p><p>　　此外，康德还从上述自然目的论进一步引申出所谓“伦理学神学”，即把整个世界看作向道德和幸福相统一的人这一最后目的前进，以实现上帝的“天意”的历程，从而为实践理性的利益展示诱人的前景。经过这样的批判考察，康德认为反思判断力的先天原理的确在分裂的自然领域和自由领域之间架起了一座由此及彼的桥梁：“判断力以其自然合目的性概念提供了自然概念和自由概念之间的中介概念，它使从纯粹理论的到纯粹实践的、从按照前者的规律性到按照后者的最后目的的过渡成为可能；因为这样一来，那只有在自然里并同自然的规律相一致才能成为现实的最终目的的可能性就被认识到了。”[36]</p><p>　　在这样的基础上，康德对他的全部理性批判工作进行了总结，充实、丰富、发展和完善了“纯粹理性批判”的概念。康德认为，人类心灵的一切能力都可以归结为来自我们所不知的同一根源的知、情、意这样三种能力(认识能力、愉快和不快的情感能力、欲求能力)。人作为天赋理性能力、即具有依照原理进行判断和行动的能动性的生物，他的三种心灵能力也都应该有它们必须遵循的理性先天原理或规律，为了发现它们就必须对理性能力进行批判的研究。作为理性(或知性)能力的高级认识能力的总体是由知性、判断力、理性这样的次序排列的三种能力构成的。《纯粹理性批判》确定，对于认识能力来说，只有知性是立法的，即是说知性包含着认识能力领域(科学认识和自然领域)的构成性原理。《实践理性批判》确定，对于高级欲求能力来说，只有理性是立法的，即是说理性包含着欲求能力领域(道德、自由领域)的构成性原理。现在，《判断力批判》确定，对于愉快和不快的情感能力来说，只有判断力是立法的，即是说它包含着对于审美和艺术活动中愉快和不快的情感的构成性原理，从而使自然领域和自由领域的过渡和联结成为可能。因此，康德把《判断力批判》看作完成和结束他的全部理性批判工作的最后一部著作，是他的纯粹理性批判体系中必不可少的部分，没有这一部分，对于纯粹理性的批判就是残缺不全和半途而废的。正如他在《判断力批判》里说的那样：“纯粹理性的，即依照先天原理进行判断的能力的批判将会是不完备的，如果那作为认识能力自身也要求着批判的判断力的批判不当作它的一个特殊部分来处理”；“尽管哲学只能区分为理论的和实践的两个主要部分，……可是那必须在哲学体系研究工作之前为着体系的可能性而解决一切问题的纯粹理性批判却是由三个部分构成的：纯粹知性的批判，纯粹判断力的批判和纯粹理性的批判，这些能力之所以称为纯粹，因为它们是先天立法着的。”[37]由这样三个部分构成的“纯粹理性批判”的整体也就是康德最终建成了的、完备的哲学体系，即批判哲学体系。关于这个体系的对象、任务、组成和它与诸高级心灵能力及其先天原理和原理应用范围的系统统一性可以表示如下[38]：</p><p>　　</p><p>　　在康德看来，这个批判哲学体系既然已经穷尽了人类各个高级心灵能力的先天原理，解决了哲学的可能性的全部问题，它也就为纯粹理性的全部哲学知识的体系打下了深入到达原始地层的基础，从而能够保证这座哲学大厦不致因地基某一部分下陷而坍塌。它首先为康德所说的作为科学的未来形而上学体系，即由自然形而上学(理论哲学)和道德形而上学(实践哲学)两部分构成的纯粹理性体系打好了基础，因为它既提供了自然领域的先天原理和自由领域的先天原理，又为这两大部分联结为一个整体提供了可能性。它也为康德以解决关于人的四大问题为构成部分的某种哲学人类学体系提供了基础，因为不仅第一批判和第二批判由于回答了我能知道什么和我应做什么而为解决整个人的问题提供了地盘和目标，而且第三批判也为回答我可以希望什么和人是什么提供了思路和前景。因此，在这种意义上，康德的批判哲学体系也就只是他所规划的未来形而上学或哲学的一个“导论”。在以第三批判结束“批判工作”以后，康德建立自然—道德形而上学和某种哲学人类学的一系列著述活动也证明了这点。</p><p>　　但是，批判哲学体系虽说是哲学或形而上学的“导论”，然而正如康德在区分纯粹理性的“批判”和“体系”时也把“批判”包含在最广义的形而上学中一样，它作为“导论”无非就是形而上学的最普遍或最一般的原理的体系。这些原理在康德那里尽管是纯粹理性的先天原理，它们只涉及先天的认识的形式、道德的形式和审美的形式，而不是关于对象(对象应是形式和质料的统一)的知识。但是，它们作为这样的先天形式却是对象(认识的、道德的和审美的)成为可能的构成性原理，因而也是支配这些对象的根本特性的最普遍的规律，或者说，是一切可能的这些对象之成为实际存在的条件或规律。因此，在这种意义上，正如康德曾经在《纯粹理性批判》中把纯粹知性论称为存在论(本体论)那样，现在的批判哲学体系也就可以看作是完成了的存在论或本体论，只不过这里的存在不是指独立于人的意识的对象的存在，也不仅是作为认识对象的自然事物的存在，而是与人的意识不可分离的、包括认识、道德(意志)和审美的对象在内的一切对象的存在。正因为这样，批判哲学就不能只归结为单纯的认识论或逻辑学体系(像某些新康德主义者认为的那样)，也不能归结为认识论、逻辑学与存在论相统一的单纯自然的(仅仅关于真的)形而上学体系(康德在《纯粹理性批判》中曾这么看“批判”)，而应当看作是认识论、逻辑学、本体论相一致的关于真(自然)、善(自由)、美(艺术)的统一的形而上学体系。</p><p>　　同时，由于康德的批判哲学体系的任务是揭示人类知、情、意三种高级心灵能力的先天原理，而这种研究又是以阐明人类理性的最后目的在自然界里实现的可能性和条件为宗旨，所有这些都表明批判哲学是围绕着人在世界里的地位、职责和前景这个中心旋转，因而是指向“人是什么”这个人类学的根本问题的，更何况知、情、意三种能力本来也就是康德《实用人类学》的研究对象，这部著作的第一部分“人类学教授法”就是对于这三种能力的经验性的和心理学的描述。从这个角度出发，国内外一些康德哲学专家认为，批判哲学本身就具有人类学的性质，并对它进行了人类学的注释和破译。在国内，据我所知，最先把这个问题鲜明地提出来加以讨论的是康德《实用人类学》的译者邓晓芒教授。他发表了这样一种独创的观点：在康德那里有两种“人类学”，即由三大批判构成的先验人类学和经验性的实用人类学，由于康德的不可知论和批判主义最终是导向一种现象主义和实用主义，因而他就未能真正建立起一个完整的先验人类学体系，而只能以实用人类学作为其先验人类学的真正“归宿”。[39]</p><p>　　由此可见，康德的批判哲学体系具有多重性质的特点：就其本来的意义说，它是纯粹理性的系统批判，因而是未来形而上学的“导论”；作为“导论”，它不能不同时具有它为之奠基的由自然形而上学和道德形而上学两个部分(美学和自然目的论在康德看来不能成为哲学的一个独立的部分，而是在必要情况下临时附加在上述两个部分中的任何一个部分)构成的形而上学体系的性质；而作为以解决关于人的四大问题为构成部分的某种哲学人类学的基础或前提，它又具有哲学人类学体系的性质。</p><p>　　总起来说，康德发起德国哲学革命的批判时期的哲学思想是一个复杂的、矛盾的发展过程。这种复杂性和矛盾性首先表现在：在这个过程里产生和出现了三个不同的康德哲学体系：已经完成了的作为纯粹理性批判的哲学“导论”——批判哲学体系，尚未完成的作为纯粹理性体系的自然—道德形而上学体系和也没有真正完成的以回答关于人的四个问题为内容的哲学人类学体系。其次还表现在已经完成的批判哲学体系本身又具有三重不同的性质：批判主义、形而上学和人类学。康德哲学思想的这种复杂性和多重性，恰好说明了它是它那个无论在经济、政治和文化、哲学等等方面都处于新旧交替的过渡时代的产儿，也表明了它在解决哲学应走什么新的道路，应研究什么新的问题，应采取什么新的形态等等与哲学生死攸关的重大问题中的探索性和创始性。康德哲学思想的伟大历史意义和永恒历史魅力，正在于它把这种放射着探索性和创始性光辉的智慧作为最宝贵的哲学遗产传给了后世。</p><p>　　</p><p>　　原载《德国哲学论文集》第16辑，北京大学出版社，1997年版，第74-108页。</p><p>　　————————————————————————————————————————</p><p>　　[①] 《纯粹理性批判》A841＝B869(根据《哲学丛书，第37a卷，汉堡费利克斯·迈耶出版社1976版，下同)，参见蓝公武译本，商务印书馆1957年版，第570—571页。<br>　　[②]《未来形而上学导论》，庞景仁译，商务印书馆1978年版，第160—161、164页。<br>　　[③]《自然科学的形而上学基础》，邓晓芒译，三联书店1988年版，第18页。<br>　　[④]《纯粹理性批判》，A841=B869，参见蓝译本，第571页。<br>　　[⑤]《纯粹理性批判》，A846—847=B874—875，参见蓝译本，第574页。<br>　　[⑥] 见E．Adickes出版的《纯粹理性批判》一书，1889年柏林版，第631页。诺·康·斯密在其《康德&lt;纯粹理性批判)释义》中几乎逐字逐句引用了阿迪凯斯的观点，见该书，商务印书馆’1961年版，第594页。<br>　　[⑦] 按沃尔夫形而上学体系各部分排列的次序，第二部分应为理性宇宙论，第三部分为理性心理学，这里是按康德《纯粹理性批判，中的次序排的，以便对照。<br>　　[⑧]《纯粹理性批判》，A247=B303，参阅蓝译本，第213页。<br>　　[⑨] 这当然不是说物理学不属于沃尔夫包罗万象和一切知识部门的哲学体系，而是说在他那里始终没有一门作为形而上学的物理学或自然哲学。沃尔夫把上帝、人的心灵(灵魂)和物体世界看作理论哲学的对象，也就相应地把神学、心理学和物理学看作理论哲学的三个学科，而物理学又被区分为四个分枝：(1)一般物理学或关于一切物体和主要物类所共有的特性的学说；(2)宇宙论或关于世界全体的学说；(3)特殊的自然科学，如气象学、矿物学、水文学、植物学、生理学等；(4)目的论或关于自然物的目的的学说。沃尔夫把宇宙论从其他物理学分枝中抽离出来，使之与心理学、自然神学并列而为形而上学的继本体论之后的三个组成学科。(参见E. Zeller, Die Geschichte derdeutschen Philosophie seit Leibniz，München l873，S．219．)不过，沃尔夫关于物理学的意见往往是动摇或含糊不清的。他虽然认为形而上学应在物理学之先，但有时又认为形而上学的成就要以物理学为前提，因而物理学又应在形而上学之先；而在其宇宙论中却又包含有一般物体学说，即一般物理学的某些内容。(同上书，第222页)康德也许正是针对沃尔夫，强调绝不能把他所说的以外感对象的总和为对象的理性物理学理解为一般物理学，后者与其说是自然哲学，不如说是数学。(见《纯粹理性批判》，A847＝B875注。)康德认为，在一般物理学中，形而上学的建构和数学的建构是互相渗透的，为了科学的进步，有必要把形而上学的建构分离出来，连同其概念的建构原则一起，呈现在一个体系里。这个特殊的形而上学体系就是理性物理学。(参见康德：《自然科学的形而上学基础》，邓晓芒译，三联书店1988年版，第10页。)<br>　　[⑩]《纯粹理性批判》，Bxlii，参见蓝译本，第25页。<br>　　[11]《康德书信百封》，李秋零编译，上海人民出版社1992年版，第137页。<br>　　[12]《哲学丛书》第39a卷，汉堡费利克斯·迈耶出版社1974年版，第5页。参见《判断力批判》上卷，宗译本，商务印书馆1964年版，第6—7页。<br>　　[13]《康德书信百封》，第243．245页。<br>　　[14]《康德书信百封》，第243．245页。<br>　　[15]《纯粹理性批判》，A804—805=B832—833，参见蓝译本，第549—550页。<br>　　[16]《康德书信百封》，第200页。<br>　　[17]《哲学丛书》第43卷，莱比锡1920年版，第27页。参见《逻辑学讲义)，许景行译，商务印书馆1991年版，第15页。<br>　　[18]《纯粹理性批判》A849＝B877，参见蓝译本，第575页。<br>　　[19]《康德书信百封》，第110页。<br>　　[20]《纯粹理性批判》，A805=B833。参见蓝译本，第550页。<br>　　[21]《康德书信百封》，第201页。<br>　　[22]《实用人类学》，邓晓芒译，重庆出版社1987年版，第1页。<br>　　[23] 同上书，第232页。<br>　　[24]《道德形而上学原理》，苗力田译，上海人民出版社1986年版，第40页。<br>　　[25] 参见上书，第99、40页。<br>　　[26]《康德书信百封》，第104页。<br>　　[27] 同上书，第106页。<br>　　[28]《哲学丛书》，第38卷，汉堡1974年版，第12页，参见《实践理性批判》，关文运译，商务印书馆1960年版，第19页。<br>　　[29]《康德书信百封》，第106页。<br>　　[30] 同上书，第107页。<br>　　[31]《康德书信百封》，第110页。康德在《纯粹理性批判》第一版(A21=B36的注)里明确地认为“使对美的东西的批判的评判从属于理性的原理，从而把这种评判的规则提高为科学’是不可能的，因为“所想到的规则或标准就其来源而论都是单纯经验的，因而不能用作鉴赏判断必须依照的先天规律”。第二版在“来源”之前增加了“最主要的”，在“先天规律’之前增加了“确定的”，语气有所缓和，但意思没变。至于鉴赏判断没有先天原理或规律可依照的根本原因则在于它同愉快和不快的情感有直接的联系，正如康德在同一著作(A801=B820的注)中所指出的：“因为情感不是表象事物的能力，而是处于全部认识能力以外的，所以凡是和愉快和不快相联系的判断的要素……都不属于只同先天纯粹知识有关系的先验哲学的主体。”现在，他的这些观点都变了。<br>　　[32]《康德书信百封》，第110页。<br>　　[33] 同上书，第113页。<br>　　[34] 同上书，第126—127页。<br>　　[35]《哲学丛书》第39a卷，汉堡1974年版，第17页，参见《判断力批判》上卷，宗白华译，商务印书馆，1964年版，第18页。<br>　　[36]《哲学丛书》，第39a卷，第34页，参见《判断力批判，上卷，宗译本，第35页。<br>　　[37]《哲学丛书》，第39a卷，第2、5页，参见《判断力批判》上卷，宗译本，第4、16页。<br>　　[38] 参见《判断力批判》上卷，宗译本，第36页。<br>　　[39] 邓晓芒：《“批判哲学”的归宿》，载《德国哲学》第2辑，北京大学出版社1986年版，第44—45、33等页。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;康德的哲学体系是什么，由哪些部分组成，其根本性质是什么，这些问题远比最初想到的要复杂得多。问题在于康德的哲学思想，不仅从前批判时期到批判时期是一个复杂的变化发展的过程，而且在批判时期里也仍然处在变化发展之中。正是这种情况决定了，即使批判时期的康德哲学体系问题，也必须予以具体的考察，不容作出简单的回答。&lt;/p&gt;
    
    </summary>
    
      <category term="林中路" scheme="http://yoursite.com/categories/%E6%9E%97%E4%B8%AD%E8%B7%AF/"/>
    
    
      <category term="康德" scheme="http://yoursite.com/tags/%E5%BA%B7%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>康德：答复这个问题：“什么是启蒙运动？”</title>
    <link href="http://yoursite.com/2019/01/22/Holzwege-1/"/>
    <id>http://yoursite.com/2019/01/22/Holzwege-1/</id>
    <published>2019-01-22T12:20:28.000Z</published>
    <updated>2019-01-24T01:53:42.140Z</updated>
    
    <content type="html"><![CDATA[<p>启蒙运动就是人类脱离自己所加之于自己的不成熟状态。不成熟状态就是不经别人的引导，就对运用自己的理智无能为力。当其原因不在于缺乏理智，而在于不经别人的引导就缺乏勇气与决心去加以运用时，那么这种不成熟状态就是自己所加于自己的了。Sapere aude！ [2] 要有勇气运用你自己的理智，这就是启蒙运动 [3] 的口号。</p><a id="more"></a><p>懒惰和怯懦乃是何以有如此大量的人，当大自然早以把他们从外界的引导之下释放出来以后(naturaliter maiorennes [4] )，却仍然愿意终身处于不成熟状态之中，以及别人何以那么轻而易举地就悍然以他们的保护人自居的原因所在。处于不成熟状态是那么安逸。如果有一部书能替我有理解，有一位牧师能替我有良心，有一位医生能替我规定食谱，等等；那么我自己就不用那么操心了。只要能对我合算，我就无需去思想；自有别人会替我去思考这类伤脑筋的事情。</p><p>绝大部分人（其中包括全部女性）都把步入成熟状态认为除了是非常之艰辛而外并且还是非常之危险；这一点老早就被每一个一片好心在从事监护他们的保护人关注到了。保护人首先是使他们的牲口愚蠢，并且小心提防着这些温驯的畜牲不要竟敢冒险从锁着他们的摇车里面迈出一步，然后就向他们指出他们企图单独行走时会威胁他们的那种危险，可是这种危险实际上并不那么大，因为他们跌过几次交之后就终于能学会走路的；然而只有有过一次这类事情，就会使人心惊胆战并且往往吓得完全不敢再去尝试了。</p><p>任何一个人要从几乎已经成为自己天性的那种不成熟状态之中奋斗出来，都是很艰难的，他甚至于已经爱好它了，并且确实暂时还不能运用他自己的理智，因为人们从来都不允许他去做这种尝试。条例和公式这类他那天分的合理运用，或者不如说误用的机械产物，就是对终古长存的不成熟状态的一副脚镣。谁要是抛开他，也就不过是在极狭窄的沟渠上做了一次不可靠的跳跃而已，因为他并不习惯于这类自由的运动，因此就只有很少数的人才能通过自己精神的奋斗而摆脱不成熟的状态，并且从而迈出切实的步伐来。</p><p>然而公众要启蒙自己，确是很可能的，只有允许他们自由，这还确实几乎是无可避免的。因为哪怕是在为广大人群所设立的保护者们中间，也总会发现一些有独立思想的人；他们自己在抛却了不成熟状态的羁绊之后，就会传播合理地估计自己的价值以及每个人的本分在于思想其自身的那种精神。这里面特别值得注意的是，公众本来是被他们套上了这种羁绊的，但当他们的保护者（其本身是不可能有任何启蒙的）中竞有一些人鼓动他们的时候，此后却强迫保护者们自身也处于其中了；种下偏见是那么有害，因为他们终于报复了本来是他们的教唆这或者是他们教唆者的先行者的那些人。因而公众只能是很缓慢地获得启蒙。通过一场革命或许很可以实现推翻个人专制以及贪婪心和权利欲的压迫，但却绝不能实现思想方式的真正改革，而新的偏见也正如旧的一样，将会成为驾驭缺少思想的广大人群的圈套。</p><p>然而，这一启蒙运动除了自由而外并不需要任何别的东西，而且还确乎是一切可以称之为自由的东西之中最无害的东西，那就是在一切事情上都有公开运用自己理性的自由。 [5] 可是我却听到从四面八方发出这样的叫喊：不许争辩！军官说：不许争辩，只许操练！税吏说：不许争辩，只许纳税。神甫说：不许争辩，只许信仰。（举世只有一位君主 [6] 说：可以争辩，随便争多少，随便争什么，但是要听话）到处都有对自由的限制。</p><p>然则，哪些限制是有碍启蒙的，哪些不是，反而是足以促进它的呢？━━我回答说：必须永远有公开运用自己理性的自由，并且唯有它才能带来人类的启蒙。私下运用自己的理性往往会被限制得很狭隘，虽则不致因此而特别妨碍启蒙运动的进步。而我所理解的对自己理性的公开运用，则是指任何人作为学者在全部听众面前所能做的那种运用。一个人在其所受任的一定公职岗位或者职务上所能运用的自己的理性，我就称之为私下的运用。</p><p>就涉及共同体利益的许多事物而言，则我们必须有一定的机器，共同体的一些成员必须靠它来保持纯粹的消极态度，以便他们由于一种人为的一致性而由政府引向公共的目的，或者至少也是防止破坏这一目的。在这上面确实是不容许有争辩的；而是人们必须服从。但是就该机器的这一部分同时也作为整个共同体的、乃至于作为世界公民社会的成员而论，从而也就是以一个学者的资格通过写作面向严格意义上的公众时，则他是绝对可以争辩的，而不致因此就有损于他作为一个消极的成员所从事的那种事业。因此，一个服务的军官在接受他的上级交下来的某项命令时，竞抗声争辩这项命令的合目的性或者有用性，那就会非常坏事；他必须服从。但是他作为学者而对军事业务上的错误进行评论并把他提交给公众来作判断时，就不能公开地加以禁止了。公民不能拒绝缴纳规定于他的税额；对所加给他的这类赋税惹事生非的擅行责难，甚至可以当作诽谤(这可能引起普遍的反抗)而加以惩处。然而这同一个人作为一个学者公开发表自己的见解，抗议这种课税的不适应与不正当不一样，他的行动并没有违背公民的义务。同样地，一个牧师也有义务按照他们所服务的那个教会的教义向他的教义问答班上的同学们和他的会众们作报告，因为他是根据这一条件才被批准的。但是作为一个学者，他却有充分自由、甚至于有责任，把他经过深思熟虑有关那种教义的缺点的全部善意的意见以及关于更好的组织宗教团体的建议传达给公众。这里面并没有任何可以给他的良心增添负担的东西，因为他把作为一个教会工作者由于自己职务的关系而讲授的东西，当作是某种他自己并没有自由的权利可以按照自己的心意进行讲授的东西：他是受命根据别人的指示并以别人的名义进行讲述的。他将要说：我们的教会教导这些或那些；这里就是他们所引用的论据。于是，他就从他自己不会以完全的信服而赞同、虽则他很可以使自己负责进行宣讲的那些条文中━━因为并非是完全不可能其中也隐藏着真理，而且无论如何至少其中不会发现有任何与内心宗教相违背的东西，━━为他的听众引绎出全部的实用价值来。因为如果他相信其中可以发现任何与内心宗教相违背的东西，那么他就不能根据良心而尽自己的职务了，他就必须辞职。一个就任的宣教师之向他的会众运用自己的理性，纯粹是一种私下的运用；因为那往往只是一种家庭式的聚会，不管是多大的聚会；而在这方面他作为一个牧师是并不自由的，而且也不能是自由的，因为他是在传达别人的委托。反之，作为一个学者通过自己的著作而向真正的公众亦即向全世界讲话时，则牧师在公开运用他的理性上便享有无限的自由可以使用他自己的理性，并以他自己本人的名义发言。因为人民（在精神事务上）的保护者而其本身居然也不成熟，那便可以归结为一种荒谬性，一种永世长存的荒谬性了。</p><p>然则一种牧师团体、一种教会会议或者一种可敬的教门法院（就象他们在荷兰人中间所自称的那样），是不是有权宣誓他们自己之间对某种不变的教义负有义务，以便对其每一个成员并且由此也就是对全体人民进行永不中辍的监护，甚至于使之永恒化呢？我要说：这是完全不可能的。这样一项向人类永远封锁了任何进一步启蒙的契约乃是绝对无效的，哪怕它被最高权力、被国会和最庄严的和平条约所确认。一个时代决不能使自己负有义务并从而发誓，要把后来的时代置于一种决没有可能扩大自己的（尤其是十分迫切的）认识、清除错误以及一般地在启蒙中继续进步的状态之中。这会是一种违反人性的犯罪行为，人性本来的天职恰好就在于这种进步；因此后世就完全有权拒绝这种以毫无根据而且是犯罪的方式所采取的规定。</p><p>凡是一个民族可以总结为法律的任何东西，其试金石都在于这样一个问题：一个民族是不是可以把这样一种法律加之于其自身？它可能在一个有限的短时期之内就好象是在期待着另一种更好的似的，为的是好实行一种制度，使得每一个公民而尤其是牧师都能有自由以学者的身份公开地，也就是通过著作，对现行组织的缺点发表自己的言论。这种新实行的制度将要一直延续下去，直到对这类事情性质的洞见已经是那么公开地到来并且得到了证实，以致于通过他们的联合（即使是并不一致）的呼声而可以向王位提出建议，以便对这一依据他们更好的洞见的概念而结合成另一种已经改变了的宗教组织加以保护，而又不致于妨碍那些仍愿保留在旧组织之中的人们。但是统一成一个固定不变的、没有人能够（哪怕在一个人的整个一生中）公开加以怀疑的宗教体制，从而也就犹如消灭了人类朝着改善前进的整整一个时代那样，并由此给后代造成损害，使得他们毫无所获，━━这却是绝对不能容许的。一个人确实可以为了他本人并且也只是在一段时间之内，推迟对自己有义务加以认识的事物的启蒙；然而逆行放弃它，那就无论是他本人，而更其是对于后代，都可以说是违反而且践踏人类的神圣权利 [7] 了。</p><p>而人民对于他们本身都不能规定的事，一个君主就更加不可以对他的人民规定了；因为他的立法威望全靠他把全体人民的意志结合为他自己的意志。只要他注意使一切真正的或号称的改善都与公民秩序结合在一起，那么此外他就可以把他的臣民发觉对自己灵魂得救所必须做的事情留给他们自己去做；这与他无关，虽则他必须防范任何人以强力防碍别人根据自己的全部才能去做出这种决定并促进这种得救。如果他干预这种事，要以政府的监督来评判他的臣民借以亮明他们自己的见识的那些作品；以及如果他凭自己的最高观点来这样做，而使自己受到“Caesar non est supra grammaticos” [8] 的这种责难；那就会有损于他的威严。如果他把自己的最高权力降低到竟至去支持自己国内的一些暴君对他其余的臣民实行精神专制主义的时候，那就更加每况愈下了。</p><p>如果现在有人问：“我们目前是不是生活在一个启蒙了的时代？”那么回答就是：“并不是，但确实是在一个启蒙运动的时代” [9] 。目前的情形是，要说人类总的说来已经处于，或者是仅仅说已经被置于，一种不需别人引导就能够在宗教的事情上确切地而又很好地使用自己的理智的状态了，则那里面还缺乏许多东西。可是现在领域已经对他们开放了，他们可以自由地在这上面工作了，而且对普遍启蒙的、或者说对摆脱自己所加给自己的不成熟状态的障碍也逐渐地减少了；关于这些我们都有着明确的信号。就这方面考虑，这个时代乃是启蒙的时代，或者说乃是腓德烈 [10] 的世纪。</p><p>一个不以如下说法为与自己不相称的国君：他认为自己的义务就是要在宗教事务方面决不对人们加以任何规定，而是让他们有充分的自由，但他又甚至谢绝宽容这个高傲的名称；这位国君本人就是启蒙了的 [11] ，并且配得上被天下后世满怀感激之忱尊之为率先使得人类，至少从政权方面而言，脱离了不成熟状态，并使每个人在任何有关良心的事务上都能自由地运用自身所固有的理性。在他的统治下，可敬的牧师们可以以学者的身份自由并且公开地把自己在这里或那里偏离了既定教义的各种判断和见解都提供给全世界来检验，而又无损于自己的职责；至于另外那些不受任何职责约束的人，那就更加是如此了。这种自由精神也要向外扩展，甚至于扩展到必然会和误解了其自身的那种政权这一外部阻碍发生冲突的地步。因为它对这种政权树立了一个范例，即自由并不是一点也不关怀公共的安宁和共同体的团结一致的。只有当人们不再有意地想方设法要把人类保持在野蛮状态的时候，人类才会由于自己的努力而使自己从其中慢慢地走出来。</p><p>我把启蒙运动的重点，亦即人类摆脱他们所加之于其自身的不成熟状态，主要是放在宗教事务方面，因为我们的统治者在艺术和科学方面并没有向他们的臣民尽监护之责的兴趣；何况这一不成熟状态既是一切之中最有害的而又是最可耻的一种。但是，一个庇护艺术与科学的国家首领，他的思想方式就要更进一步了，他洞察到：即使是在他的立法方面，容许他的臣民公开运用他们自身的理性，公开向世上提出他们对于更好地编篆法律、甚至于是直言无讳地批评现行法律的各种见解，那也不会有危险的。在这方面，我们有着一个光辉的典范，我们所尊敬的这位君主 [12] 就是没有别的君主能够超越的。</p><p>但是只有那位其本身是启蒙了的、不怕幽灵的而同时手中又掌握着训练精良的大量军队可以保障公共安宁的君主，才能够说出一个自由国家所不敢说的这种话：可以争辩，随便争多少，随便争什么；但是必须听话。这就标志着人间事务的一种可惊异的、不能意料的进程；正犹如当我们对它从整体上加以观察时，其中就几乎一切都是悖论那样。程度更大的公民自由仿佛是有利于人民精神的自由似的，然而它却设下了不可逾越的限度；反之，程度较小的公民自由却为每个人发挥自己的才能开辟了余地，因为当大自然在这种坚硬的外壳之下打开了为她所极为精心照料着的幼芽时，也就是要求思想自由的倾向与任务时，它也就要逐步地反作用于人民的心灵面貌（从而他们慢慢地就能掌握自由）；并且终于还会反作用于政权原则，使之发见按照人的尊严━━人并不仅仅是机器而已 [13] ━━去看待人，也是有利于政权本身的 [14] 。</p><p>　　1784年9月30日，于普鲁士哥尼斯堡。</p><h2 id=""><a href="#" class="headerlink" title="　　"></a>　　</h2><p>　　[1] 本文写于1784年(康德60岁) ，最初刊载于《柏林月刊》1784年，第4卷，第481-494页。译文据普鲁士皇家科学院编《康德全集》(柏林，格·雷麦版，1912年) ，第8卷，第33-42页译出。━━译注</p><p>　　[2] [要敢于认识！] 语出诗人贺拉士(Horace，即Q. Horatius Flaccus，公元前65-8)《诗论》，I，2，40；德国启蒙运动的重要组织之一“真理之友社” 于1736年采用这句话作为该社的口号。━━译注</p><p>　　[3] 按启蒙运动(Aufkl?rung) 亦称“启蒙时代”或“理性时代”；这篇为当时的启蒙运动辩护的文章，发表在当时德国启蒙运动的主要刊物《柏林月刊》上。━━译注</p><p>　　[4] [由于自然方式而成熟] 。━━译注</p><p>　　[5] 此处“公开运用自己理性的自由”即指言论自由；康德在这个问题上曾和当时的普鲁士官方检查制度发生冲突。可参看本书《论一个常见的说法：这在理论上可能是正确的，但在实践上是行不通的》。━━译注</p><p>　　[6] 指普鲁士腓德烈大王(Frederick II，der Grosse，1740-1786) 。━━译注</p><p>　　[7] 按“权利”一词原文为Recht；此词相当于法文的droit，英文的right，中文的“权利”、“权”、“法律”、“法”或“正义”。一般或译作“法”，下同。━━译注</p><p>　　[8] [凯撒并不高于文法学家]按，此处这句话可能是针对传说中普鲁士的腓德烈大王回答伏尔泰(Voltaire，1718-1778) 的一句话：“凯撒高于文法学家”。又，传说神圣罗马帝国皇帝西吉斯蒙(Sigismund，1411-1437) 在1414年的康斯坦司会议上说过：“我是罗马皇帝并且高于文法学家”。━━译注</p><p>　　[9] 康德《纯粹理性批判》第1版序言：“我们的时代是一个批判的时代，一切事物都必须接受批判”。━━译注</p><p>　　[10] 指普鲁士腓德烈大王。━━译注</p><p>　　[11] “启蒙了的” 即“开明的”。━━译注</p><p>　　[12] 指普鲁士腓德烈大王。━━译注</p><p>　　[13] “人并不仅仅是机器而已”这一命题为针对拉梅特利(Julien Offray de la Mettrie，1709-1751年) 《人是机器》(1748年) 的反题。━━译注</p><p>　　[14] 今天我在9月13日的《布兴每周通讯》(布兴，Anton Friedrich Büsching，1724-1793年，地理学家，格廷根大学教授，当时主编《地图、地理、统计与历史新书每周通讯》━━译注) 上读到本月30日《柏林月刊》的预告，其中介绍了门德尔松先生(Moses Mendelsohn，1729-1786年，德国启蒙运动哲学家。《论“什么叫作启蒙运动”这一问题》一文刊载于《柏林月刊》1784年第4卷第9期，康德本文刊载于该刊同年同卷第12期。康德撰写本文时尚未读到门德尔松的文章，所以只在本文末尾附加了这条注释━━译注) 对于本问题的答复。我手头尚未收到该刊，否则就会扣发本文了；现在本文就只在于检验一下偶然性究竟在多大程度上能带来两个人的思想一致。</p><p>　　</p><p>　　选自《历史理性批判文集》</p><p>　　康德著 何兆武译</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;启蒙运动就是人类脱离自己所加之于自己的不成熟状态。不成熟状态就是不经别人的引导，就对运用自己的理智无能为力。当其原因不在于缺乏理智，而在于不经别人的引导就缺乏勇气与决心去加以运用时，那么这种不成熟状态就是自己所加于自己的了。Sapere aude！ [2] 要有勇气运用你自己的理智，这就是启蒙运动 [3] 的口号。&lt;/p&gt;
    
    </summary>
    
      <category term="林中路" scheme="http://yoursite.com/categories/%E6%9E%97%E4%B8%AD%E8%B7%AF/"/>
    
    
      <category term="启蒙运动" scheme="http://yoursite.com/tags/%E5%90%AF%E8%92%99%E8%BF%90%E5%8A%A8/"/>
    
      <category term="公开运用理智" scheme="http://yoursite.com/tags/%E5%85%AC%E5%BC%80%E8%BF%90%E7%94%A8%E7%90%86%E6%99%BA/"/>
    
      <category term="脱离不成熟状态" scheme="http://yoursite.com/tags/%E8%84%B1%E7%A6%BB%E4%B8%8D%E6%88%90%E7%86%9F%E7%8A%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>人大应统部落（4）：2019年中国人民大学应用统计专业课真题与解析</title>
    <link href="http://yoursite.com/2018/12/24/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD%EF%BC%884%EF%BC%89%EF%BC%9A2019%E5%B9%B4%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%B0%91%E5%A4%A7%E5%AD%A6%E5%BA%94%E7%94%A8%E7%BB%9F%E8%AE%A1%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%9C%9F%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/24/人大应统部落（4）：2019年中国人民大学应用统计专业课真题与解析/</id>
    <published>2018-12-24T02:19:10.000Z</published>
    <updated>2018-12-24T13:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019年中国人民大学应用统计初试专业课真题，之后会更新详细解答。</p><p>如有疑问或建议，可添加微信：zhanghua63170140</p><a id="more"></a><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>当检验统计量没有落入拒绝域时，可不可以说“接受原假设”，请说明理由。</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>在时间序列中，请说明严平稳和宽平稳的定义是什么？二者之间有什么联系？并说明如何判断数据的平稳性。</p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>某研究小组想要研究某城市中A、B两种疾病的发病率，其中A疾病的发病率为0.2，B疾病的发病率为0.1，为了使抽样的绝对误差不超过1%，则需要随机抽取的样本是多少？并分析简单随机抽样的可行性和效率，如果你来设计试验，你会怎样设计？</p><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>在回归分析中，说明如何判别是否存在异方差？</p><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>在多元统计分析中，$\sigma ^2$和$\sum$的用处非常多，请用至少三种不同的多元分析方法来说明$\sigma ^2$和$\sum$的应用（文字+公式）</p><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>设X服从P维正态分布，即$X - N_p(\mu,\sum)$，其中$\sum$是对角矩阵，对角元素分别为$\sigma_{11} ,\sigma_{22} ,······\sigma_{pp} $，从p维正态总体中抽取一个样本量为n的样本$x_1,x_2,x_3,·····,x_n$，试估计$\mu$和$\sigma$的极大似然估计。</p><h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>设A、B、C、D为4个随机事件，其中$P(BC)≠0$</p><p>（1）证明，$P(A|BC) = P(A|C)$与$P(AB|C) = P(A|C)·P(B|C)$是等价的<br>（2）如果$P(ABC|D) = P(A|D)·P(BC|D)$,证明$P(AB|D)=P(A|D)·P(B|D)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年中国人民大学应用统计初试专业课真题，之后会更新详细解答。&lt;/p&gt;
&lt;p&gt;如有疑问或建议，可添加微信：zhanghua63170140&lt;/p&gt;
    
    </summary>
    
      <category term="人大应统部落" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD/"/>
    
    
      <category term="人大应统" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F/"/>
    
      <category term="考研真题" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客（3）：如何用增长黑客思维从0到1做一个公众号？</title>
    <link href="http://yoursite.com/2018/11/25/Growth-Hack-3/"/>
    <id>http://yoursite.com/2018/11/25/Growth-Hack-3/</id>
    <published>2018-11-25T15:14:45.000Z</published>
    <updated>2018-12-24T10:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://growthbox.net/growthhack/" target="_blank" rel="noopener">Growthbox</a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>没有预算，只有两人，如何用增长黑客思维从0到1做一个公众号？这篇文章中，Alan&amp;Yolo会抛砖引玉，用万字长文完整复盘我们的众号《增长黑盒》2018年一季度的增长过程。</p><p>简单的介绍一下：《增长黑盒》是Alan&amp;Yolo折腾了大半年的一个公众号，我们俩2018年年初才下定决心全职做这个媒体，专注研究“增长黑客”。鉴于《增长黑盒》是一个专注研究“增长”的媒体，除了写别人的案例，我们自己做到增长才有说服力。所以，我们在一季度给自己定下了不花任何预算，跑通增长黑客转化漏斗的“增长真人秀”任务。</p><p>一季度已经结束，是时候交作业了，先来关注一下一季度的粉丝数和营收（虽然我们之前一直视其为虚荣指标）：</p><ul><li>粉丝数从4000增加到17500，增长300%以上。</li><li>不接广告，两人仅靠几篇文章，一季度被动收入在30万元左右。</li></ul><a id="more"></a><h2 id="二、发现问题"><a href="#二、发现问题" class="headerlink" title="二、发现问题"></a>二、发现问题</h2><p>根据艾媒报告2017年第一季度的数据，微信公众号数量的增量已经逐渐放缓，野蛮生长的年代似乎已经过了。这意味公众号越来越难做，你没有优质的内容，基本就可以放弃了。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxlthamzehj30fs0bumxc.jpg" alt=""></p><p>毕竟作为媒体，内容才是核心产品，而微信公众号只不过是一个内容分发渠道。在我们决定做公众号之前，就很清楚地意识到了这个渠道的诸多问题。</p><p>我们来根据增长黑客惯用的AARRR转化漏斗来诊断一下每个环节的核心难点：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxlti11y4mj30kx0cfq3r.jpg" alt=""></p><ul><li>冷启动获客难：</li></ul><p>公众号是订阅式的，没有粉丝就没有阅读。即使有好的内容，如何冷启动一个公众号也是个难点。而信息流就不用考虑粉丝数，只要内容够好就可以根据算法推荐出去，这也是很多信息流APP挤压到微信公众号的一个原因。</p><ul><li>激活读者困难</li></ul><p>激活已订阅的读者去阅读文章也很难。据行业人士透露，微信公众号文章的平均阅读率也就5%，打开率约为2%。不夸张的说，这个文章打开率甚至不如垃圾邮件的打开率。而且订阅号每天只能群发一波，这也减少了很多可能性。</p><ul><li>留存读者困难：</li></ul><p>国外的订阅阅读很多还是基于邮件或者RSS的，而中国似乎已经跨越这个阶段。但这中间的核心问题就在于，有邮件的情况下，你可以主动向读者出击，而在微信生态里你是无法主动和读者对话的。也就是说订阅号没有CRM系统，也做不到用户和线索的培育（lead nurturing），自然留存也就难做。尽管服务号有一定的推送培育用户的功能，但从直观上说，不少服务号的推送还是推式营销（outbound marketing）的一种，类似陌拜电话、垃圾短信，打开率也不会太高。</p><ul><li>变现方式有限：</li></ul><p>微信官方提供的变现思路就是广告，不过新号小号也是很难参与的，而公众号植入硬广软广对于读者来说也是比较糟糕的体验。</p><ul><li>推荐环节有限：</li></ul><p>微信自身首先是非常克制的，诱导分享是不合规的。目前大家惯用的微信裂变虽然涨粉比较有效，但是大部分的微信裂变事实上是绑架用户的一种行为，对于用户来说体验不会太好，如何做出真正的口碑营销是个难点。</p><h2 id="三、Pre-Launch"><a href="#三、Pre-Launch" class="headerlink" title="三、Pre-Launch"></a>三、Pre-Launch</h2><p>先说一下我们为什么选择做增长黑客媒体这个创业方向，没有好的选题，自媒体自然做不起来，解决再多问题也没有用。</p><h3 id="3-1-选择垂直细分领域"><a href="#3-1-选择垂直细分领域" class="headerlink" title="3.1 选择垂直细分领域"></a>3.1 选择垂直细分领域</h3><p>李开复在《创业就是要细分垄断》一书中，给出选择创业机会的4个基本条件：</p><ul><li>风口</li><li>细分领域</li><li>社会大变</li><li>人口基数大的国家</li></ul><p>为什么选择做增长黑客媒体，以下是具体的判断：</p><p>1) 专注增长是企业趋势：增长黑客这个概念首先由Sean Ellis在2010提出，在2015年由范冰创作同名书《增长黑客》从而正式引入中国。</p><p>在2017年的3月底，可口可乐突然宣布将取消CMO（首席营销官）一职，取而代之的是CGO（首席增长官）【1】，这也预示着公司架构变革的趋势。并且，从增长黑客的职位设置上来看，增长黑客=产品+运营+技术+营销。也就是说传统的产品经理、营销人、技术人都是被降维打击的对象，或者说以上这些职业都需要全面地补充自己的技能以应对新的竞争环境。</p><p>同时，虽然增长黑客在国外的互联网公司可以说是标配了，但国内只有少数互联网公司掌握了其中的奥秘，那就是增长其实是一门实验科学。以今日头条系为例，其增长团队有200多人，统一为旗下产品矩阵制定增长策略。而结果也很显著，今日头条、内涵段子、火山小视频、抖音APP等产品都完成了指数级的增长。</p><p>2） “增长”是被低估的垂直细分市场：《哈佛商业评论》曾写过一篇文章名叫“Every Company Needs a Growth Manager”（所有公司都需要个增长经理）【2】。事实上也是这样，增长黑客（Growth hacker）在国外已经是个Buzzword（时髦词）了，但国内却鲜有媒体报道和研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://growthbox.net/growthhack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Growthbox&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;没有预算，只有两人，如何用增长黑客思维从0到1做一个公众号？这篇文章中，Alan&amp;amp;Yolo会抛砖引玉，用万字长文完整复盘我们的众号《增长黑盒》2018年一季度的增长过程。&lt;/p&gt;
&lt;p&gt;简单的介绍一下：《增长黑盒》是Alan&amp;amp;Yolo折腾了大半年的一个公众号，我们俩2018年年初才下定决心全职做这个媒体，专注研究“增长黑客”。鉴于《增长黑盒》是一个专注研究“增长”的媒体，除了写别人的案例，我们自己做到增长才有说服力。所以，我们在一季度给自己定下了不花任何预算，跑通增长黑客转化漏斗的“增长真人秀”任务。&lt;/p&gt;
&lt;p&gt;一季度已经结束，是时候交作业了，先来关注一下一季度的粉丝数和营收（虽然我们之前一直视其为虚荣指标）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;粉丝数从4000增加到17500，增长300%以上。&lt;/li&gt;
&lt;li&gt;不接广告，两人仅靠几篇文章，一季度被动收入在30万元左右。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="拌网策略" scheme="http://yoursite.com/tags/%E6%8B%8C%E7%BD%91%E7%AD%96%E7%95%A5/"/>
    
      <category term="用户分层" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E5%88%86%E5%B1%82/"/>
    
      <category term="用户生命周期" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="交叉销售" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E9%94%80%E5%94%AE/"/>
    
      <category term="A/B测试" scheme="http://yoursite.com/tags/A-B%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客（2）：10个月时间，CMO如何挽救这家破产的电商巨头？</title>
    <link href="http://yoursite.com/2018/11/24/Growth-Hack-2/"/>
    <id>http://yoursite.com/2018/11/24/Growth-Hack-2/</id>
    <published>2018-11-24T15:14:45.000Z</published>
    <updated>2018-12-24T10:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://growthbox.net/growthhack/712/" target="_blank" rel="noopener">Growthbox</a></p><p>大家好，这里是yolo@增长黑盒。很久没跟大家见面了，所以这次我来讲一个比较长的故事：美国潮牌电商巨头Karmaloop由于扩张过度，不幸破产。电商老将扛起CMO大旗，借助数据驱动实现了绝地逆转。现在，我们就一起来学习下失败的教训和增长的经验。</p><a id="more"></a><h2 id="一、巨头陨落"><a href="#一、巨头陨落" class="headerlink" title="一、巨头陨落"></a>一、巨头陨落</h2><p>1999年，25岁的格雷格.赛尔克（Greg Selkoe）还没有意识到，自己即将改变美国的潮流产业。</p><p>这个患有多动症、爱好街舞和涂鸦的小伙子生活并不如意，在大学里主修了非常冷门的人类学专业，还跟父母住在波士顿的房子里【1】。这一年，互联网泡沫空前繁荣，他突然意识到自己该做点什么了。于是，他拉上自己的小伙伴，在家中的地下室成立了一个电商平台：karmaloop。格雷格的初衷很简单：提供一个便捷的通道，让所有年轻人都可以买到非常酷的衣服 – 即使身边没有潮牌店，也可以从网上订购。那个时候，“从网站上买东西”还是一件比较罕见的事。格雷格的商业模式也很简单，从当地采购街头潮流服饰（streetwear），把资料挂到网站上，然后邮寄给下单的客户【2】。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxkldr9885j30g20apjsd.jpg" alt="">（Karmaloop创始人格雷格.赛尔克）</p><p>没想到，这生意一干就是4年 – 直到29岁，他还跟妻子在地下室发货。不过，长期对“边缘文化”的推崇，让Karmaloop在嘻哈、DJ、滑板等圈子里声名鹊起。</p><p>Karmaloop不断壮大，在2007年进入了鼎盛时期，每年的营收都是成倍增长，连嘻哈巨星Kanye West都为其站台点赞。2013年，Karmaloop终于登上顶峰 – 营业额突破1.27亿美金，远远甩开其它潮牌电商，稳居行业第一，成为了美国最大的潮牌经销平台。2014年，Karmaloop更是在“互联网零售500强”中排名134位。但是，看似一片繁荣的背后，却是1亿美元的银行债务【3】。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxklhznmo0j30k60c0aam.jpg" alt="">（Karmaloop官网）</p><p>Karmaloop的街头王国已经显现出崩塌的预兆。从2008年起，从来没有接受过风投的格雷格获得了Comvest等私募机构一大笔融资，有了花不完的钱。被荣誉冲昏头脑的格雷格开始大肆扩张，先后建立了PLNDR（快闪电商）、Brick Harbor（滑板电商）、MissKL（女性高端潮牌）、Boylston Trading Co（男性高端潮牌）等独立的Niche站。更让人无法理解的是，他不顾高管们的反对，筹划了一档名为KarmaloopTV的电视节目，进一步强化自己在潮流界的地位【3】。</p><p>另一方面，公司推崇张扬的嘻哈文化，所以允许员工在办公室喝酒、放音乐、养狗。但糟糕的是，这最后演变成大家经常开派对，吸大麻，在办公桌上啪啪啪 – 作为CEO，格雷格却毫不知情。</p><p>慢慢的，公司赚钱的速度已经远远赶不上烧钱的速度了。结果，Karmaloop所有扩张计划均以失败而告终，仅KarmaloopTV就烧掉了1400万美金，节目竟然没上线过。太平盛世下混乱的员工管理，也让公司经不起逆境的考验。</p><p>投资人逐渐对Karmaloop丧失了信心，公司没有了新的资金。为了偿还贷款，Karmaloop不得不采取大降价策略以清理库存，很多高端品牌经常能看到40%以上的折扣！不料，这次壮士断臂不仅没有挽回收入，还激起了众多品牌商的不满，纷纷撤出Karmaloop。</p><p>2014年末，Karmaloop背水一战，决定采用成本更低的Drop-shipping模式（即直发模式，自己不囤货，顾客下单后由品牌商直接发货）。理论上，这种模式有很大希望挽回败局，扭亏为盈。万万没想到，由于客服和物流跟不上，顾客们经常收不到货，退不了款。这下可好了，老客户们大失所望，骂声一片，Karmaloop把客户和商家两头都得罪了一遍。</p><p>2015年，局面彻底失控，Karmaloop的营业额缩水到原来的一半。一切挽救行动均宣告失败，曾经放出消息要收购Karmaloop的Kanye West也没了声音。格雷格的雄心壮志不得不画上句号 – Karmaloop正式宣告破产。Karmaloop也由此获得了一个十分尴尬的“殊荣”：美国历史上第一大破产电商【3】，仅是欠供应商的货款就高达1900万美元！格雷格本人也因欠款500万美元，至今官司缠身。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxklje5axvj30h70c374s.jpg" alt=""></p><p>最终，投资过Karmaloop的私募机构Comvest花费1300万美元，买下了这个烂摊子 – 昔日的巨头被迫以一个月的营业额把自己卖了！</p><h2 id="二、新官上任"><a href="#二、新官上任" class="headerlink" title="二、新官上任"></a>二、新官上任</h2><p>Comvest接手后，第一件事就是踢掉格雷格这个CEO，并迅速邀请了时尚行业资深人士赛斯.哈勃（Seth Haber）掌管公司大权。但是，作为一家电商公司，营销的重要性自然不用多说 – Karmaloop需要一名给力的CMO，帮助他们穿过泥泞。</p><p>很快，Comvest物色到了绝佳人选：今天故事的主角杜鲁.萨诺科齐（Drew Sanocki）。他在电商零售行业也是一位传奇人物：2003年，杜鲁成立了自己的平台Design Public，以纯Dropship的形式出售高档家具，并在第一年就做到了百万美金的营收。2011年，当Karmaloop还在茁壮成长的时候，杜鲁就将自己的公司高价卖给了一家私募公司。从此之后，财务自由的他决定退居二线，成为了一家私募的合伙人 – 主要负责评估零售电商项目，以及投后顾问。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxklp5de4fj30p00dw3z0.jpg" alt=""><br>他对零售业营销有着深刻的见解。在Design Public成立之初，他就敏锐地意识到搜索引擎将成为互联网流量的入口，着手打造了一套自动化的SEO体系，成功抢占先机。面对竞争对手的追击，他竟然雇了一名喜剧作家为自己的产品撰写说明书 – 每篇出价高达数百美金！这些高质量的内容打的同行们措手不及【4】。</p><p>在Comvest的盛情邀请下，杜鲁决定接受这个挑战- 临危受命，出任Karmaloop的CMO。</p><p>Karmaloop一直拥有着顶尖的营销能力。10年前，在“增长黑客0成本指数增长”的策略。那时纸媒还占据着市场的话语权，而Karmaloop却创作了大量街头艺术家、嘻哈音乐人的专访，并通过博客、邮件推送等方式进行分发，几乎没有花钱就获得了大量用户，营收直线上升。</p><p>但是，杜鲁开始着手公司业务时，Karmaloop每个月正在流失近百万美金 。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxklx7j02yj30ch03r745.jpg" alt=""><br>（Karmaloop的流量和营收曲线急剧下滑【5】）</p><p>他发现，公司遭遇困境的主要原因就是错误地理解了“增长黑客”的体系：只关注用户获取，而不重视留存和变现 – 大批的用户点水而过，没有给公司创造任何价值。</p><p>2008年拿了一大笔投资之后，VC急切渴望看到成绩。因此，格雷格决定抄捷径：花钱买流量。正如前文提到的，不论是做电视节目还是开设新的分支品牌，都是为了占据流量入口。除此之外，Karmaloop还投入大量人力物力去做Google Adwords、PR、线下店、纸媒等等。这个时候，没人意识到虚荣的流量其实未曾带来收入。</p><p>不过，由于用力过猛，钱都烧光了，公司开始负债。银行还在天天催着还钱，Karmaloop才被迫想办法提升留存，促进变现。</p><p>但是，心急的格雷格干脆一刀切：使用打折促销作为激活用户的手段，直接推动留存和变现。这其实是完全错误的，因为用打折的方式吸引的用户必然是消费能力不高、生命周期价值很低。这让本来就不理想的留存率进一步恶化，获得的营收根本抵不上广告投入，还把供应商得罪了。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxklzmz0xbj30p00dwdg2.jpg" alt=""></p><p>最后, 为了节约开支，提高变现环节的利润，Karmaloop才决定采用Dropship直发模式。不过，这也是反其道而行之 – 大批高价值的老客户流失，原本固定的收入来源也惨遭冲击。</p><p>这让Karmloop陷入了恶性循环 – 不断烧钱，低质量的新客户在增加，高质量的老客户在减少，越来越亏。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxkm0a4bzlj30kf0bht8y.jpg" alt=""></p><p>杜鲁意识到，要想扭转局势，就必须获取更多高价值的客户，并且留住他们，最终让他们带来足够的收入。</p><h2 id="三、用户获取"><a href="#三、用户获取" class="headerlink" title="三、用户获取"></a>三、用户获取</h2><p>面对一团乱麻，杜鲁遭遇的一个问题就是：高价值的客户从哪里来？</p><h3 id="3-1-转化低价值用户"><a href="#3-1-转化低价值用户" class="headerlink" title="3.1 转化低价值用户"></a>3.1 转化低价值用户</h3><p>很显然，最实际的方案就是把之前的低价值用户转化为高价值用户（或者说筛选出潜在的高价值用户）。为此，他尝试了自己践行多年的“拌网策略”【10】-这分为三个步骤：</p><blockquote><p>1.对高价值客户行为进行数据建模<br>2.找到实际数据与理想数据的偏差（即“拌网”）<br>3.集中营销工作的时间和精力，纠正这些偏差</p></blockquote><p>杜鲁自己举过一个例子：</p><p>他每个周五都要去一家名叫Slow Burn的健身房锻炼身体 – 对于健身房来说，他就是理想客户，“每周五都来健身”就是所谓的标准模型。</p><p>但是，过了几个月，他不想去了。可能的原因有三个：</p><ul><li>自己找到了另一家更好的健身房</li><li>觉得价格太高了（可能性比较低）</li><li>自己变懒了（可能性比较高）</li></ul><p>“停止去健身”就是所谓的偏差（拌网）。</p><p>Slow Burn注意到了这个情况，开始一系列营销活动：提醒他克制懒惰，并送了优惠券给他！他收到了优惠券，并为自己的懒惰感到惭愧，于是又重新回到了健身房 – 偏差就这样被纠正了。</p><p>这个理论的核心就是， _<em>公司不应该在所有用户上投入相同的营销成本，而是找到那些阻碍普通用户成为高价值用户的“拌网”，然后投入最大精力去解决这个障碍。</em>_</p><p>从入职第一天起，他就花费了整整一个月去研究Karmaloop近10年的交易数据，并利用RFM模型进行了分析。按照他的理论，首先要找出这些“高价值”的用户行为，然后不断鼓励这些行为，就可以把低价值的用户转化为高价值的用户。</p><p>他创建了两个简单的用户分层【6】：</p><ul><li>鲸鱼：多次复购，消费额高，很少退货。代表高价值、高LTV的用户层。</li><li>鲦鱼：仅购买一次，只买便宜的商品，而且退货率高。代表低质量、低LTV的用户层，如果算上各种成本，这个分层其实在给公司亏钱。</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxkm4r2cvgj30k1062dfs.jpg" alt=""><br>杜鲁惊讶的发现，“鲸鱼”们只占了1.3%的访问量，却贡献了43%的收入！这些历史数据让Karmaloop的问题暴露无遗：鲦鱼太多而鲸鱼太少，所以才一直亏钱。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxkm55ka2gj30sg09mdgv.jpg" alt=""><br>接下来，就是寻找“鲸鱼”们的共性行为了 – 他非常想知道这些高价值用户究竟花多久来完成第二次购买。杜鲁用两个简单的步骤分析近期订单数据：</p><ul><li>选中所有满足“鲸鱼”特征的用户；</li><li>计算第一次和第二次购买之间平均间隔天数。</li></ul><p>分析结果如下图，绿色的条即是杜鲁想要观察的指标。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxkm5l7ucrj30m80gowez.jpg" alt=""><br>（X轴代表间隔时长，Y轴代表该有多少用户花费了这个间隔去复购）</p><p>他发现， _80%的情况下，如果一个用户要下单两次，他们都会在第一个订单之后的30天内完成第二单。_</p><p>没错，这就是杜鲁找到的“拌网“ – 大多数“鲦鱼”并不会在30天的周期内产生复购行为。前面的数据分析表明，如果一个用户在第一天下了单，但后续的30天内没有下第二单，那他就越来越不可能成为“鲸鱼”了。但是，如果他们在30内下了单（符合理想用户行为），那就有很大机会成为“鲸鱼”。</p><p>_Karmaloop需要做的就是使用合理的营销方式与这些”鲦鱼“用户层进行沟通，引导他们在30天下第二个订单，逐步让他们转变为“鲸鱼”。_</p><p>根据上一步的分析，他制定了两种营销策略：</p><blockquote><p>1.在30天内 -&gt; 用户有机会完成二次复购 -&gt;给用户推销原价（高利润）的产品<br>2.在30天之后-&gt;用户越来越难完成二次复购-&gt;用大额优惠（低利润）刺激用户</p></blockquote><p>看到这里，大家不难理解为何Karmaloop为何会亏损了：既然30天之内用户有很大概率会复购，那为何还要给他们优惠呢？不重视精细化运营的代价是惨重的。</p><p>作为CMO， _杜鲁的第一项行动就是不再给30天周期内的用户发送优惠券。_ 另一方面，超过30天后，用户复购的几率依旧随着时间的延长而衰减。因此，杜鲁给优惠券设定了一个梯度 – _间隔时间越长，优惠额度越大_</p><ol><li>用户首次购买后若处于30天周期内，则给他推送原价商品；</li><li>在30天之后还未复购，则给用户推送10%折扣券；</li><li>如果超过了45天，给用户推送20%折扣券；</li><li>如果超过了60天，一律推送30%折扣券；</li><li>如果用户在任意阶段产生了复购行为，则不会触发后续的优惠；</li><li>时间周期和优惠额度会根据数据反馈进行调整。</li></ol><p>计划制定好了，如何把营销信息推送给客户呢？在海外市场，Email的地位相当于国内的公众号，而Karmaloop凭借十几年的积累已经有了数百万Email订阅用户 – 杜鲁决定利用这些先天的优势，将Email作为营销的主战场。在团队的帮助下，他建立起了基于CRM和Klaviyo软件的自动化邮件系统。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxkmcundhvj30p00dwwf4.jpg" alt="">（图中为调整后的优惠梯度邮件）</p><p>当邮件取得良好的效果后，营销团队会迅速把活动更新到网站主页、Facebook定向广告、甚至是邮寄的贺卡中。</p><h3 id="3-2-社交媒体"><a href="#3-2-社交媒体" class="headerlink" title="3.2 社交媒体"></a>3.2 社交媒体</h3><p>现在，一部分有潜力的“鲦鱼”已经能够被转化为“鲸鱼”了。但是，比起之前的损失来说，目前的营收增长还远远不够。</p><p>正如增长黑盒在之前文章中提到的，社交媒体是时尚行业的必争之地。所以，接下来杜鲁开始寻找新的社交媒体渠道，进一步获取高价值客户。</p><p>1）首先是Instagram</p><p>根据杜鲁从Shopify内部得到的消息，在所有营收超过百万美金的Shopify店铺中，90%都在依赖Instagram做营销【7】。因此，杜鲁也想在Karmaloop身上尝试一下。他从团队中挑选了一位十分有干劲的小伙子，专门负责Instagram等平台的运营，不断寻求KOL合作机会。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkmdvaipaj30pu0fd75s.jpg" alt="">（比如这位打call的妹子就有430万Ins粉丝！）</p><p>2）其次是Youtube</p><p>在公司倒闭之前，格雷格的KarmaloopTV项目拍摄了大量原创视频，都是放在youtube频道中。但是，现在既然没钱了，这个频道肯定也就开不下去了。于是，杜鲁放弃原创视频的想法，转而借助KOL的力量。在Youtube上，有许多被称为“hauler”的网红：他们经常拍摄潮牌的开箱评测，讲解服饰穿搭 – 自然，这些网红的粉丝一定是Karmaloop的精准客户了。杜鲁立刻安排团队拿下了大批hauler，把Karmaloop售卖的招牌产品交给他们去评测，并且跟他们联合举办抽奖活动 – 关注Instagram，留言送潮牌！</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxkmebouwnj30fp08pdg1.jpg" alt=""><br>（这位花臂小哥也是潮流界名人）</p><h2 id="四、激活留存"><a href="#四、激活留存" class="headerlink" title="四、激活留存"></a>四、激活留存</h2><p>高价值用户的增长仅仅是开端。接下来，还有更重要的一步：激活并留住他们。</p><p>这时，杜鲁应用了生命周期营销策略，即在正确的时间，把正确的信息传递给正确的人。</p><p>经过分析，他构建起了一个客户的生命周期流程：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkmfqh9f5j30p00dwwex.jpg" alt=""></p><p>（可以看到，任何客户都会经历新手期，活跃期到流失期三个阶段）</p><p>借助自动化的邮件系统，杜鲁让营销邮件贯穿每个客户的生命周期。从获取客户开始，5-6个邮件campaign就开始运行了。无论用户进行到哪个时间节点，都能通过邮件接收到最恰当的营销信息：</p><h3 id="4-1-新手期"><a href="#4-1-新手期" class="headerlink" title="4.1 新手期"></a>4.1 新手期</h3><p>这个阶段的营销目标是引导用户产生第一次购买。</p><p>当用户注册/订阅邮件后，立刻启动“欢迎系列邮件” – 即利用5-7封邮件逐步建立品牌信任度、传递Karmaloop的价值、宣传部分招牌产品。</p><p>通过欢迎阶段后，许多用户已经准备好要剁手了。但是，从建立信任到最终付款之间，还有一个“隐形杀手”：放弃购物车（cart abandonment）。2016年的数据显示，全球电商的平均弃车率高达77%！【8】因此，杜鲁特意设定了一系列邮件，唤回那些弃车的用户：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxkmlmpwy2j309m08pwek.jpg" alt=""></p><h3 id="4-2-活跃期"><a href="#4-2-活跃期" class="headerlink" title="4.2 活跃期"></a>4.2 活跃期</h3><p>这个阶段的营销目标是让用户保持活跃，持续消费。</p><p>怎样才能让客户不断来关注Karmaloop呢？杜鲁的团队创建了一个VIP计划：如果某个用户的消费行为接近“鲸鱼”（举例来说，如果他下了单，而且其平均订单价值（AOV）或者平均订单数量超过某个固定值），就把他定义为VIP用户 – 随后会触发相应的营销活动（比如特殊折扣），而且用户会收到一封感谢邮件。</p><h3 id="4-3-流失期"><a href="#4-3-流失期" class="headerlink" title="4.3 流失期"></a>4.3 流失期</h3><p>这个阶段营销目的是唤回流失的老用户。</p><p>事实上，大部分Karmaloop的老用户依然停留在这个阶段。公司在倒闭时的垂死挣扎，很大程度上影响了他们的体验，导致信任度大减。</p><p>既然这些老用户都在邮件订阅列表上，继续用邮件唤回他们不是很简单吗？不过，杜鲁马上意识到自己低估这件事的难度 – 最初的唤回成功率相当低。当你失去一个人的信任之后，就很难争取第二次机会了。</p><p>碰壁之后，杜鲁马上启用了增长黑客的秘诀- A/B测试。他将流失的老用户群划分成许多个10000人的小组，逐步测试不同的方案。</p><p>他们首先尝试了10-30%范围内的折扣，随后又试了下次购买返现金，紧接着是送礼品卡，最后还试了“CEO亲笔信”，甚至是打电话….</p><p>进过不懈的努力，在经历过20多次失败的测试后，杜鲁终于找到了一套最佳组合，老客户们渐渐认可了新生的Karmaloop。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkmn8rhfoj30bh0fut8z.jpg" alt=""></p><p>为了能够在整个生命周期内更好的理解高价值用户的行为，杜鲁的团队还利用SurveyMonkey进行了NPS问卷，即询问用户“你有多大意愿把Karmaloop推荐给朋友（1分到10分）？”另外，问卷还包括几个核心问题：</p><blockquote><p>1.你还在其它什么地方购物？<br>2.哪些商品我们应该卖却没有卖？<br>3.你平时都阅读哪些博客？</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxkmoscw1mj312w0hwwf9.jpg" alt=""></p><p>正是通过不断的学习和理解，杜鲁对客户的需求有了更加精准的把握，大大改进了Karmaloop的用户体验和客户服务。</p><p>在之前的运营中，Karmaloop根本没有进行任何客户生命周期的营销，这无疑是巨大的突破。</p><h2 id="五、提高营收"><a href="#五、提高营收" class="headerlink" title="五、提高营收"></a>五、提高营收</h2><p>在杜鲁的推动下，Karmaloop终于能够把高价值客户留存下来了。不过，要形成完整的增长闭环，还差最后的盈利阶段：把留下来的客户转化为收入。</p><p>由于之前的Dropship模式宣告失败，所以Karmaloop还要回归到传统的备货模式。因此，想通过压缩成本来提高利润的方法是行不通了。所以，杜鲁设法提高每用户平均收入（ARPU）：</p><h3 id="5-1-提高商品单价"><a href="#5-1-提高商品单价" class="headerlink" title="5.1 提高商品单价"></a>5.1 提高商品单价</h3><p>事实上，Karmaloop之前的打折策略是严重违背其商业价值的：潮牌本身并没有太多物质上的价值，更多的是精神/文化层面的追求和认可 – 用时髦点的话来说，就是“共识”。比如Supreme从来不打折，但官网的新品总是在几十秒内售罄。</p><p>他相信，经过一番调整，Karmaloop现有的用户并不是冲着廉价而来的，而是认可潮牌的价值。那么，顾客到底愿意花多少钱买Karmaloop的产品呢？</p><p>杜鲁继续发扬增长黑客的精神，开始了价格实验，针对不同商品供需关系，分组后逐步提价，然后观察用户的购买行为。</p><p>他首先把注意力放到了Karmaloop最热销的打底T恤上。经过一段时间提价，他惊讶的发现：价格提高30%后并不会影响销量！也就是说，这个品类的收入足足增加了30%！</p><h3 id="5-2-交叉销售"><a href="#5-2-交叉销售" class="headerlink" title="5.2 交叉销售"></a>5.2 交叉销售</h3><p>数据显示，亚马逊35%的收入都来自于交叉销售（cross-sell）【9】。在Karmaloop，杜鲁开始实践交叉销售 – 简单来说，就是向购买过本公司A产品的客户推销本公司B产品。从心理学的角度上来说，刚刚完成一次购买的用户正处于“购物期”，心理防线非常薄弱，难以抵抗二次诱惑。借助邮件营销，Karmaloop得以大大提升客户的生命周期价值。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxkmq84i77j30hu0hgjs4.jpg" alt=""></p><h2 id="六、绝地逆转"><a href="#六、绝地逆转" class="headerlink" title="六、绝地逆转"></a>六、绝地逆转</h2><p>不到3个月时间，杜鲁就取得了卓越的成效，把公司营收提高了30%，客户生命周期营销活动的ROI高达500%！</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkmqu2dixj30mq059wem.jpg" alt=""></p><p>最终，仅用了10个月时间，杜鲁就将Karmaloop扭亏为盈。</p><p>1年半后，Karmaloop以数千万美金的价格出售给了美国球鞋零售商Shiekh Shoes【11】 – 本该从历史上抹去的巨头再次焕发了活力，实现了真正的绝地逆转。</p><p>当然，功劳不仅是杜鲁一人的。这个过程中，Karmaloop的CEO也起到了重要作用，包括与品牌方谈判，整顿公司管理，调整供应链等等。另外，杜鲁手下还有一票得力干将，包括一名邮件营销的工程师，一个设计创意团队 – 以及整个产品部门的支援。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个案例为我们清晰地展示了一位CMO如何利用数据来做决策，科学推动公司的增长和提高。总结一下，杜鲁究竟做了哪些事让Karmaloop起死回生：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkmrmq1xoj31a00u00u9.jpg" alt=""></p><p>当然，我们能够从Karmaloop的身上吸取不少教训：</p><ul><li>精细化运营决定成败。我们可以发现，Karmaloop之前从来不做客户分层，不分析客户生命周期，也没有自动化营销的概念。因为它依靠着互联网早期的红利起家，不懂得流量的珍贵 – 这与国内目前的形势相似，红利褪去后，野蛮生长需要转变成数据驱动。</li><li>增长是一个完整的体系。获客、留存、变现是不可割裂的。Karmaloop只关注获客，追求短期的爆发，而忽视了长期的价值积累，必然导致雪崩式的效应。</li><li>靠打折增长用户是不可取的。不得不说，利用人们贪便宜的心理是一个捷径。但是这必然导致用户本身的质量很低，难以导入后续的留存和变现环节。更重要的是，一旦你开始打折，你就再也无法回头，陷入恶性循环。</li><li>把一件事做到最好。Karmaloop失败的很大原因就是精力过于分散，急于建设各种周边品牌。说到底，都是为了增加品牌的影响力，但过于“曲线救国”。不如实际一点，比如把潮牌的SEO都做到第一位，或者把Instagram粉丝做到100万。</li><li>Dropship坑太多，没有经验不要轻易尝试。作为一个过来人，这是我个人的建议。</li></ul><p>同时，我们也能从这位CMO身上学到很多东西：</p><ul><li>增长是整个团队配合的结果。国外有调查显示，增长黑客们的主要阻力来自老板。所以，增长永远都是自上而下的，全员all in的。试想一下，杜鲁就算水平再高，如果CEO不支持，员工很懒惰，还能取得这样的成绩吗？</li><li>勇于试错。公司的管理层往往都有存量的顾虑。但对于危在旦夕的Karmaloop来说，杜鲁刚好能够抛弃这种负担，从营销活动到产品价格，大胆进行各种实验 – 这也是增长黑客的精神所在。</li><li>重视VIP用户的运营。二八效应在电商行业体现的尤为明显 – 20%的人贡献了80%的收入。然而，我们大多数时候却把这20%的“金主”当做普通人来对待，这显然是不科学的。我们必须甄别出这些高价值用户，用不同的策略加以培养，从他们身上挖掘更多潜在消费价值。</li><li>重视数据和技术。如果说数据是灵魂，那么技术就是肉体。在运营Karmaloop的过程中，他都是亲自对数据进行整理和计算，而不是让手下人送个报表过来。另一方面，他非常注重自动化营销 – Karmaloop所有邮件营销都是根据客户行为自动触发的。如果没有这套系统，杜鲁的想法恐怕很难实现。</li></ul><p>参考资料：</p><p>【1】<a href="http://nextshark.com/karmaloop-ceo-greg-selkoe-interview/" target="_blank" rel="noopener">http://nextshark.com/karmaloop-ceo-greg-selkoe-interview/</a><br>【2】<a href="https://harvardmagazine.com/2012/12/karmaloop" target="_blank" rel="noopener">https://harvardmagazine.com/2012/12/karmaloop</a><br>【3】<a href="http://www.complex.com/style/the-rise-and-fall-of-karmaloop" target="_blank" rel="noopener">http://www.complex.com/style/the-rise-and-fall-of-karmaloop</a><br>【4】<a href="https://growtheverywhere.com/growth-everywhere-interview/drew-sanocki-nerd-marketing/" target="_blank" rel="noopener">https://growtheverywhere.com/growth-everywhere-interview/drew-sanocki-nerd-marketing/</a><br>【5】<a href="https://www.appcues.com/blog/growing-a-company-with-rapid-growth-strategies" target="_blank" rel="noopener">https://www.appcues.com/blog/growing-a-company-with-rapid-growth-strategies</a><br>【6】<a href="https://speakerdeck.com/wooconf/drew-sanocki-the-top-growth-secrets-of-9-figure-ecommerce-retailers-all-of-which-you-can-steal" target="_blank" rel="noopener">https://speakerdeck.com/wooconf/drew-sanocki-the-top-growth-secrets-of-9-figure-ecommerce-retailers-all-of-which-you-can-steal</a><br>【7】<a href="http://rejoiner.com/resources/data-driven-marketing-helped-karmaloop-com-claw-way-back-bankruptcy/" target="_blank" rel="noopener">http://rejoiner.com/resources/data-driven-marketing-helped-karmaloop-com-claw-way-back-bankruptcy/</a><br>【8】<a href="https://www.barilliance.com/cart-abandonment-rate-statistics/" target="_blank" rel="noopener">https://www.barilliance.com/cart-abandonment-rate-statistics/</a><br>【9】<a href="https://www.forbes.com/sites/chuckcohn/2015/05/15/a-beginners-guide-to-upselling-and-cross-selling" target="_blank" rel="noopener">https://www.forbes.com/sites/chuckcohn/2015/05/15/a-beginners-guide-to-upselling-and-cross-selling</a><br>【10】<a href="https://conversionxl.com/blog/tripwire-marketing/" target="_blank" rel="noopener">https://conversionxl.com/blog/tripwire-marketing/</a><br>【11】<a href="https://www.bostonglobe.com/business/2016/03/23/karmaloop-acquired-california-retailer" target="_blank" rel="noopener">https://www.bostonglobe.com/business/2016/03/23/karmaloop-acquired-california-retailer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://growthbox.net/growthhack/712/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Growthbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家好，这里是yolo@增长黑盒。很久没跟大家见面了，所以这次我来讲一个比较长的故事：美国潮牌电商巨头Karmaloop由于扩张过度，不幸破产。电商老将扛起CMO大旗，借助数据驱动实现了绝地逆转。现在，我们就一起来学习下失败的教训和增长的经验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="拌网策略" scheme="http://yoursite.com/tags/%E6%8B%8C%E7%BD%91%E7%AD%96%E7%95%A5/"/>
    
      <category term="用户分层" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E5%88%86%E5%B1%82/"/>
    
      <category term="用户生命周期" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="交叉销售" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E9%94%80%E5%94%AE/"/>
    
      <category term="A/B测试" scheme="http://yoursite.com/tags/A-B%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客（1）：Google关键词挖掘细分市场实战案例</title>
    <link href="http://yoursite.com/2018/11/23/Growth-Hack-1/"/>
    <id>http://yoursite.com/2018/11/23/Growth-Hack-1/</id>
    <published>2018-11-23T15:14:45.000Z</published>
    <updated>2018-12-24T10:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://mp.weixin.qq.com/s/cXa6Rwiet5gN8bSe-h4QNw?scene=25#wechat_redirect" target="_blank" rel="noopener">亦无所知</a>公众号</p><p>理论上来说，如果我们仅仅是想赚点小钱，而不是想像马云爸爸一样通过一款产品去改变世界，那么任意一个关键词，都有机会通过Google挖掘出一个可以赚钱的细分市场。而事实上，也确实可以做到这一点，下文我会一步步向大家阐述如何利用Google这个强大的工具来挖掘痛点，实现推广，在细分市场占领一席之地，进而赚点小钱（未必真的小，如果运气足够好，实现别人口中的小目标也说不定）。</p><p>受益于Google这么多年，不得不感慨Google是我最好的老师，总能在我需要的时候为我指明方向，并一步步用他的博学和细致引领我到达想去的地方。</p><p><strong>如果说不懂编程的运营或产品有什么核心竞争力，这种信息的挖掘与整合能力便是核心竞争力之一，而对我而言，Google就是获取这种能力最重要的工具。</strong></p><a id="more"></a><p>在细分市场里，由信息部队称造成的信息壁垒可以让我们有较长远的生存和盈利空间。反之，在一个人人都知道是巨大机会的市场中，大量的资本和明星团队进入，前期靠信息不对称造成的壁垒消失，赢得战争，得靠一场又一场硬仗，如彼时的百团大战，此时的共享单车。</p><p>在前篇文章里面分享了如何打造一台每月赚10000美元的赚钱机器，这次想在结合一个具体的案例分享一些细节，也是我通过Google挖掘细分市场思路的整理，希望能给一小部分读者带来一些价值。</p><p>今天分享的这个案例中提到的市场极不起眼，但每个月能贡献10万美元左右的利润。如果我们做出来的产品只拿到1%的市场和利润，每个月也能有1000美元的收入，对于一个自由职业者，还算不错的收入。</p><h3 id="第一步：通过Google挖掘痛点"><a href="#第一步：通过Google挖掘痛点" class="headerlink" title="第一步：通过Google挖掘痛点"></a>第一步：通过Google挖掘痛点</h3><p>痛点挖掘有很多种方式：从自身实际需求出发，从自己所在行业或者所关心话题出发，从互联网巨头周边出发等。</p><p>在资源有限的情况下，我常用的挖掘痛点方式是从互联网巨头产品周边挖掘出一些痛点，对于任何一个大的互联网茶农，都有很多产品需求点。</p><ol><li>巨头考虑后不做，比如微信公众号的数据服务（新榜），微信小程序的导航（爱范儿）</li><li>巨头没考虑到，一些很小众的需求，巨头没关注到，即使关注到也不太会为了1%的人的需求去影响99%人的体验，比如允许同时在手机上开两个微信APP。</li></ol><p>而这些被有意或者无意忽视的需求却是真实存在的，满足这些用户需求，就能获得这部分用户，体量并不一定小。 而几乎每一个互联网巨头周边都有若干产品和创业公司活的很好，甚至有一些上市公司。这次分享的是如何从Instagram上找到真实痛点和产品机会，同样的思路可以用在Facebook、WhatsApp、Bitcoin、Snapchat、微信、微博上。 </p><h4 id="1-挖掘痛点"><a href="#1-挖掘痛点" class="headerlink" title="1.挖掘痛点"></a>1.挖掘痛点</h4><p>我们先Google搜索『Instagram』，在Google的下拉框和推荐搜索词提示了下面几组词</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkgbmfewoj30wy0bi40r.jpg" alt=""></p><p>除了『instagram download』其他词看起来都很普通。</p><p>Google这个词看看有什么机会，搜索发现有以下几组关键词</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxkgchd60oj30x60do0wb.jpg" alt=""></p><p>除了最后两个词『instagram download video』、『 instagram download pictures』，其余的搜索官方都已经满足了需求。</p><h4 id="2-确认痛点"><a href="#2-确认痛点" class="headerlink" title="2.确认痛点"></a>2.确认痛点</h4><p>难道在Instagram上下载图片和视频有什么需求未被满足吗？ </p><p>果然，在网页Instagram上确实无法右键保存别人上传的图片，右键另存为的功能被限制了。这个限制其实很常见，很多网站包括知乎，出于版权保护或者其他目的，限制了直接在站内复制文本或者保存图片。 这就像， 使用微信时，收到朋友发来的语音，想转发给其他人，却发现不被支持。</p><p>Instagram的这一设置，也许就难倒了90%以上的普通用户。但事实上确实会有这样下载图片和视频的需求，这个痛点真实、有效，围绕这个痛点有没有好的解决方案？能不能赚到钱？还不清晰，继续往下Google。</p><h4 id="3-挖掘现有的产品"><a href="#3-挖掘现有的产品" class="headerlink" title="3. 挖掘现有的产品"></a>3. 挖掘现有的产品</h4><p>继续Google『instagram download pictures』，在搜索结果的第一页出现了6个解决此痛点的小工具。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxkgo8xeb0j30u00v4wno.jpg" alt=""></p><h4 id="4-商业模式研究"><a href="#4-商业模式研究" class="headerlink" title="4.  商业模式研究"></a>4.  商业模式研究</h4><p>点开排名第一的网站，功能和模式都比较简单，直接通过输入Instagram图片的链接就可以将图片直接下载下来，盈利方式是Google Adsense广告系统。 </p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkgp0a1c5j311a0gygny.jpg" alt=""></p><p>用SimilarWeb（网站流量数据统计插件）查一下，每月120万访问量，每日4万访问量。 按照千次访问2美元的收入来估算，此网站估计每天收入80美元，每个月收入2400美元，每年收入28800美元，约人民币20万元。 不错，相当于一个白领一年的收入了！</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkgqg281gj313a0jmgq3.jpg" alt=""></p><p>挖掘到此，痛点真实且需求量不小，有成熟的产品上线了，不错的机会，那么继续往下考虑产品的问题。 </p><h3 id="第二步：模仿的基础上创新"><a href="#第二步：模仿的基础上创新" class="headerlink" title="第二步：模仿的基础上创新"></a>第二步：模仿的基础上创新</h3><blockquote><p>『我不盲目创新，微软、谷歌做的都是别人做过的东西。最聪明的方法肯定是学习最佳案例，然后再超越』。</p></blockquote><p>吴晓波新出的《腾讯传》一书中，在评价到腾讯游戏与联众游戏、《泡泡堂》和《QQ堂》的早期产品相似问题时，马化腾说了上面的话。</p><blockquote><p>『紧盯市场新热点，快速跟进优化，利用自己的流量优势实现整体替代』。</p></blockquote><p>腾讯在新产品开发上的逻辑可以为我们很多人借鉴，特别是小创业团队、 自由职业者、兼职创业者。</p><p>有些人在产品设计阶段会掉进一个坑，认为既然是做产品，一定要有创新的地方。 这并非不对，但既然我们的定位就是希望赚点小钱，而不是做出一款让用户尖叫的产品，那么我 _建议收起完美主义，拿出实用主义。_</p><p>在进行这种工具类型的产品设计时，我会重点考虑这三点</p><ol><li>综合比较现有竞争对手，梳理它们已经呈现出来全部的功能点，根据自身能力和用户的需求做出功能点的取舍，设计产品。只需要体验好一点点就够了，比如界面上更清爽些，或者功能点上更贴心一点；</li><li>提前思考流量获取方法和流量变现方法，并在产品上体现出来。前置商业模式和流量的思考，这一点很重要，一个有运营思维的产品经理和没有运营思维的的产品经理在这里会有很大的差距；</li><li>一定不要重复造轮子。能在github上找到开源的代码的尽量用现成的。</li></ol><p>在这个案例中，我将关键词排名前两页的工具站进行了梳理，通过下面的表格， 发现Instagram pictures download这个极其细分的市场每个月能贡献10万美元左右的利润！</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxkgw2y5daj312s0a6n2k.jpg" alt=""></p><p>结合这个具体的案例，我思考后觉得产品的设计应初步覆盖以下点</p><ol><li>免费的基础功能点。 基于单个账号以及单个链接的图片、音频、视频下载功能，在github上搜索了下，发现已经有几百个现成的代码了，直接拿来用。</li><li>收费的增值功能点。从我的过往经验来看，在同样的流量下，一个设计的比较好的付费服务的收入是广告收入的10倍以上。基于『Instagram pictures download』付费服务有付费批量下载、付费基于关键词下载、付费基于动态提醒，付费下载年度top并生成拼图等，最终选择哪一个模式是一个需要不断去试错的过程；</li><li>增长黑客点。考虑哪些功能点可能引爆产品？ 激励功能比如分享网站到社交平台可以免费使用网站的付费功能，自动生成年度最热拼图并分享到社交网站等。这些潜在的增长黑客点在设计产品的时候一起考虑进去。 </li></ol><p>通过以上产品的系统思考后，业务逻辑、产品功能点已经基本理顺，接下来可以进入开发阶段</p><ol><li>如果懂技术的话，尽快开发完成上线验证最重要。</li><li>如果是非程序员（我猜有很大的比例不是）</li></ol><blockquote><p>这个过程就是一个从真实的场景出发，带着明确的目的去学习编程的过程：如何爬取数据，如何设计数据库，如果设计前端，如何接入支付系统， 如何做分享功能等，这个过程一定是一个非常有意思、非常有动力的过程。 </p></blockquote><p>最近李笑来老师的新生大学开了一个全栈训练营，已经报名的人不妨考虑通过这篇文章提到的痛点挖掘方式，找到一个真实的需求和细分市场，做一个产品出来，也许一不小心就把2万块的学费赚到了！</p><h3 id="第三步：自增长"><a href="#第三步：自增长" class="headerlink" title="第三步：自增长"></a>第三步：自增长</h3><p>痛点真实且可赚钱，产品精益开发完成，接下来怎么办呢？ 冷启动的方法有非常多，针对此类型的工具站提供一个思路。</p><p>网络上会有大量评测类型的网站以及how-to网站，类似于国内创投领域的36kr，小众软件。这些网站关注用户在使用大网站过程中的痛点，并对解决此痛点的工具性产品进行评测，导入流量。如果能将咱们的网站在这些评测类型的大网站上被评测到，就会引入大量的初始流量。</p><p>我在ahrefs.com(外链查询网站）分析了下一个竞争对手 <a href="https://vibbi.com/instaport/，" target="_blank" rel="noopener">https://vibbi.com/instaport/，</a> 在top referring content这个页面</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxkj0tx2kdj311o0luq98.jpg" alt=""></p><p>我们发现mashable.com、lifehacker.com、makeuseof.com、pcmag.com等流量巨头都推荐这个小工具网站，给这个网站导入了巨大流量。</p><p>显然，这些流量巨头也发现了Instagram pictures download这个真实的用户痛点，不过他们是用了更轻的方式，用内容而不是产品，来为用户解决这个问题。通过评测这些工具类型的网站，他们给用户做出指引，而用户最终被指引到这些工具类型的网站。</p><p>所以到这一步，要做的事情很清晰，梳理出报道竞争对手的网站，联系他们并请求评测。 这就像启动一个开关，一旦有一些大网站接受了评测的需求，流量就会持续进来，后面就会启动自增长，即使什么工作也不做， 过一段时间也会发现很多评测网站主动的链向我们的工具站了。</p><p>到此，基本就实现了用户需求、产品设计、运营变现从0到1的迭代。 类似的， 不少热门关键词都有不错的可盈利的细分市场，有兴趣的试试看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;https://mp.weixin.qq.com/s/cXa6Rwiet5gN8bSe-h4QNw?scene=25#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;亦无所知&lt;/a&gt;公众号&lt;/p&gt;
&lt;p&gt;理论上来说，如果我们仅仅是想赚点小钱，而不是想像马云爸爸一样通过一款产品去改变世界，那么任意一个关键词，都有机会通过Google挖掘出一个可以赚钱的细分市场。而事实上，也确实可以做到这一点，下文我会一步步向大家阐述如何利用Google这个强大的工具来挖掘痛点，实现推广，在细分市场占领一席之地，进而赚点小钱（未必真的小，如果运气足够好，实现别人口中的小目标也说不定）。&lt;/p&gt;
&lt;p&gt;受益于Google这么多年，不得不感慨Google是我最好的老师，总能在我需要的时候为我指明方向，并一步步用他的博学和细致引领我到达想去的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果说不懂编程的运营或产品有什么核心竞争力，这种信息的挖掘与整合能力便是核心竞争力之一，而对我而言，Google就是获取这种能力最重要的工具。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/tags/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（6）：常用的HIVE函数</title>
    <link href="http://yoursite.com/2018/08/26/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84HIVE%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/26/数据分析系列（6）：常用的HIVE函数/</id>
    <published>2018-08-26T15:14:45.000Z</published>
    <updated>2019-02-13T14:51:18.686Z</updated>
    
    <content type="html"><![CDATA[<p>常用的HIVE函数总结</p><a id="more"></a><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="dateadd"><a href="#dateadd" class="headerlink" title="dateadd()"></a>dateadd()</h3><ul><li>函数名称： dateadd</li><li>命令格式： datetime dateadd(datetime date, bigint delta, string datepart)</li><li>用　　途： 日期加减计算</li><li>参数说明： </li></ul><p>date：Datetime类型，日期值。若输入为string类型会隐式转换为datetime类型后参与运算，其它类型抛异常。。 </p><p>delta：Bigint类型，修改幅度。若输入为string类型或double型会隐式转换到bigint类型后参与运算，其他类型会引发异常。若delta大于0，加；否则减。 </p><p>datepart：String类型常量。此字段的取值遵循string与datetime类型转换的约定，即””yyyy””表示年，””mm””表示月…. 关于类型转换的规则请参考 String类型与Datetime类型之间的转换 。此外也支持扩展的日期格式：年-“”year””，月-“”month””或””mon””，日-“”day””， 小时-“”hour””。非常量、不支持的格式会或其它类型抛异常。 </p><p>返回值：Datetime类型。若任一输入参数为NULL，返回NULL。</p><h3 id="datediff"><a href="#datediff" class="headerlink" title="datediff()"></a>datediff()</h3><ul><li>函数名称： datediff</li><li>命令格式： bigint datediff(datetime date1, datetime date2, string datepart)</li><li>用　　途： 计算两个日期差值</li><li>参数说明： </li></ul><p>date1 date2：Datetime类型，被减数和减数，若输入为string类型会隐式转换为datetime类型后参与运算，其它类型抛异常。<br>datepart：String类型常量。支持扩展的日期格式。若datepart不符合指定格式或者其它类型则会发生异常。<br>返回值：Bigint类型。任一输入参数是NULL，返回NULL。<br>备注: 计算时会按照datepart切掉低单位部分，然后再计算结果。</p><h3 id="datepart"><a href="#datepart" class="headerlink" title="datepart()"></a>datepart()</h3><ul><li>函数名称： datepart</li><li>命令格式： bigint datepart(datetime date, string datepart)</li><li>用　　途： 提取日期date中指定的时间单位datepart的值</li><li>参数说明： </li></ul><p>date：Datetime类型，若输入为string类型会隐式转换为datetime类型后参与运算，其它类型抛异常。 </p><p>datepart：String类型常量。支持扩展的日期格式。若datepart不符合指定格式或者其它类型则会发生异常。 </p><p>返回值：Bigint类型。若任一输入参数为NULL，返回NULL。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p><a href="https://www.zybuluo.com/bdap/note/337472" target="_blank" rel="noopener">https://www.zybuluo.com/bdap/note/337472</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的HIVE函数总结&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HIVE" scheme="http://yoursite.com/tags/HIVE/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（5）：窗口函数</title>
    <link href="http://yoursite.com/2018/08/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9A%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/25/数据分析系列（5）：窗口函数/</id>
    <published>2018-08-25T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章梳理了几个关于分组排序的SQL语句，在查询的时候常会遇到分组排序的场景，比如找出每个群体中中排名前十的用户，找出某一类商品销量最高的几个商品等等。它们分别是：</p><ul><li>row_number() over()</li><li>rank( ) over( )</li><li>dense_rank( ) over( )</li></ul><p>由此引申开来，讲述一下窗口函数的功用。</p><a id="more"></a><h2 id="一、row-number-over-排序功能："><a href="#一、row-number-over-排序功能：" class="headerlink" title="一、row_number() over()排序功能："></a>一、row_number() over()排序功能：</h2><h3 id="1-1-row-number-over-无分组排序"><a href="#1-1-row-number-over-无分组排序" class="headerlink" title="1.1 row_number( ) over( )无分组排序"></a>1.1 row_number( ) over( )无分组排序</h3><p>若不对其进行分组，则此时row_number() over()的功能与rownum一致，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SELECT </div><div class="line">    empno,</div><div class="line">    WORKDEPT,</div><div class="line">    SALARY, </div><div class="line">    Row_Number() OVER (ORDER BY salary desc) rank </div><div class="line">FROM </div><div class="line">    employee   </div><div class="line">--------------------------------------  </div><div class="line">000010  A00 152750  1  </div><div class="line">000030  C01 98250   2  </div><div class="line">000070  D21 96170   3  </div><div class="line">000020  B01 94250   4  </div><div class="line">000090  E11 89750   5  </div><div class="line">000100  E21 86150   6  </div><div class="line">000050  E01 80175   7  </div><div class="line">000130  C01 73800   8  </div><div class="line">000060  D11 72250   9</div></pre></td></tr></table></figure><p>但row_number() over()更强大的地方在于可以进行分组排序。</p><h3 id="1-2-row-number-over-分组排序"><a href="#1-2-row-number-over-分组排序" class="headerlink" title="1.2 row_number( ) over( )分组排序"></a>1.2 row_number( ) over( )分组排序</h3><ul><li>partition by <em> ： 根据</em>字段进行分组</li><li>order by <em>  desc：在分组后的各组内根据</em>字段进行降序排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">SELECT </div><div class="line">    empno,</div><div class="line">    WORKDEPT,</div><div class="line">    SALARY, </div><div class="line">    Row_Number() OVER (partition by workdept ORDER BY salary desc) rank </div><div class="line">FROM</div><div class="line">    employee   </div><div class="line">--------------------------------------  </div><div class="line">000010  A00 152750  1  </div><div class="line">000110  A00 66500   2  </div><div class="line">000120  A00 49250   3  </div><div class="line">200010  A00 46500   4  </div><div class="line">200120  A00 39250   5  </div><div class="line">000020  B01 94250   1  </div><div class="line">000030  C01 98250   1  </div><div class="line">000130  C01 73800   2</div></pre></td></tr></table></figure><ul><li><p>注意：使用 row_number() over()函数时候，over()里头的分组以及排序的执行晚于 where group by  order by 的执行</p></li><li><p>如果没有指定partition by，那么它把整个结果集作为一个分组，与聚合函数不同的地方在于它能够返回一个分组中的多条记录，而聚合函数一般只有一个反映统计值的记录</p></li><li><p>row_number() over()返回的排名是没有重复值的，也就是即使遇到相同的值其排名也有先后，但具体哪个在前，具有不确定性，详细可见该<a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/user-defined-functions/deterministic-and-nondeterministic-functions?view=sql-server-2017" target="_blank" rel="noopener">链接1</a>和<a href="https://docs.microsoft.com/zh-cn/sql/t-sql/functions/row-number-transact-sql?view=sql-server-2017" target="_blank" rel="noopener">链接2</a>，具体的例子可以看文末的对比。</p></li></ul><h3 id="1-3-使用row-number-over-去重"><a href="#1-3-使用row-number-over-去重" class="headerlink" title="1.3 使用row_number( ) over( )去重"></a>1.3 使用row_number( ) over( )去重</h3><p>假设表TAB中有a,b,c三列，可以使用下列语句删除a,b,c都相同的重复行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">select </div><div class="line">    year,</div><div class="line">    QUARTER,</div><div class="line">    RESULTS,</div><div class="line">    row_number() over(partition by YEAR,QUARTER,RESULTS order by YEAR,QUARTER,RESULTS) AS ROW_NO </div><div class="line">FROM </div><div class="line">    SALE </div><div class="line">WHERE </div><div class="line">    ROW_NO=1</div></pre></td></tr></table></figure><p>所以除了使用distinct进行去重，还可以用row_number( ) over( )去重。需要注意的有以下几点：</p><ul><li>使用关键字 distinct 去重，其作用于单个字段和多个字段的时候是不同的，作用于单个字段时，其“去重”的是表中所有该字段值重复的数据；作用于多个字段的时候，其“去重”的表中所有字段值都相同的数据。</li><li>在使用函数 row_number() over() 的时候，其是按先分组排序后，再取出每组的第一条记录来进行“去重”的</li></ul><h2 id="二、rank-over"><a href="#二、rank-over" class="headerlink" title="二、rank( ) over( )"></a>二、rank( ) over( )</h2><p>这是跳跃排序，在同一个分组内，若有两个第一名时接下来就是第三名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">select </div><div class="line">    workdept,</div><div class="line">    salary,</div><div class="line">    rank() over(partition by workdept order by salary) as dense_rank_order </div><div class="line">from </div><div class="line">    emp </div><div class="line">order by </div><div class="line">    workdept</div><div class="line">------------------  </div><div class="line">A00 39250   1  </div><div class="line">A00 46500   2  </div><div class="line">A00 49250   3  </div><div class="line">A00 66500   4  </div><div class="line">A00 152750  5  </div><div class="line">B01 94250   1  </div><div class="line">C01 68420   1  </div><div class="line">C01 68420   1  </div><div class="line">C01 73800   3</div></pre></td></tr></table></figure><h2 id="三、dense-rank-over"><a href="#三、dense-rank-over" class="headerlink" title="三、dense_rank( ) over( )"></a>三、dense_rank( ) over( )</h2><p>这是连续排序，在同一个分组内，有两个第一名时仍然跟着第二名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">select </div><div class="line">    workdept,</div><div class="line">    salary,</div><div class="line">    dense_rank() over(partition by workdept order by salary) as dense_rank_order </div><div class="line">from </div><div class="line">    emp </div><div class="line">order by </div><div class="line">    workdept</div><div class="line">------------------  </div><div class="line">A00 39250   1  </div><div class="line">A00 46500   2  </div><div class="line">A00 49250   3  </div><div class="line">A00 66500   4  </div><div class="line">A00 152750  5  </div><div class="line">B01 94250   1  </div><div class="line">C01 68420   1  </div><div class="line">C01 68420   1  </div><div class="line">C01 73800   2  </div><div class="line">C01 98250   3</div></pre></td></tr></table></figure><h2 id="四、三者对比"><a href="#四、三者对比" class="headerlink" title="四、三者对比"></a>四、三者对比</h2><p>这个例子可以直观地看到，rank() over()是跳跃排序，dense_rank() over()是连续排序，row_number() over()是非重复排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">select </div><div class="line">    region_id, </div><div class="line">    customer_id, </div><div class="line">    sum(customer_sales) total,</div><div class="line">    rank() over(order by sum(customer_sales) desc) rank,</div><div class="line">    dense_rank() over(order by sum(customer_sales) desc) dense_rank,</div><div class="line">    row_number() over(order by sum(customer_sales) desc) row_number</div><div class="line">from </div><div class="line">    user_order</div><div class="line">group by </div><div class="line">    region_id, customer_id;</div><div class="line"></div><div class="line"> REGION_ID CUSTOMER_ID      TOTAL       RANK DENSE_RANK ROW_NUMBER</div><div class="line">---------- ----------- ---------- ---------- ---------- ----------</div><div class="line">            </div><div class="line">8          18           1253840         11         11         11</div><div class="line">5          2            1224992         12         12         12</div><div class="line">9          23           1224992         12         12         13</div><div class="line">9          24           1224992         12         12         14</div><div class="line">10         30           1216858         15         13         15</div></pre></td></tr></table></figure><ul><li>在这个例子中也可以看到order by 的关键字可以是group by之后的聚合函数。</li></ul><h2 id="五、窗口函数"><a href="#五、窗口函数" class="headerlink" title="五、窗口函数"></a>五、窗口函数</h2><p>以上我们介绍了RANK、DENSE_RANK、ROW_NUMBER这几个函数，其实在数据库中，它们被称为窗口函数，窗口函数可以进行排序、生成序列号等一般的聚合函数无法完成的操作。它也称为OLAP函数。OLAP是OnLine Analytical Processing的简称，意思是对数据库进行实时分析处理。窗口函数就是为了实现OLAP而添加的标准SQL功能。</p><p>它的基本语法是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;窗口函数&gt; OVER ( [PARTITION BY &lt;列清单&gt;]</div><div class="line">                       ORDER BY &lt;排序用列清单&gt;)</div></pre></td></tr></table></figure><p>其中重要的关键字是PARTITON BY 和ORDER BY，理解这两个关键字的作用是帮助我们理解窗口函数的关键。</p><p>窗口函数大致可以分为两种：</p><ul><li>RANK、DENSE_RANK、ROW_NUMBER等专用窗口函数</li><li>能够作为窗口函数的聚合函数 （SUM, AVG,COUNT,MAX,MIN）</li></ul><p>我们上面已经介绍过RANK、DENSE_RANK、ROW_NUMBER，可以看到它们兼具了GROUP BY子句的分组功能以及ORDER BY子句的排序功能。但是PARTITION BY不具备GROUP BY子句的汇总功能。所以使用RANK函数不会减少原表中记录的行数。</p><p>通过PARTITION BY分组后的记录集合称为窗口。此处的窗口表示范围。</p><p>目前为止我们学过的函数大多数都没有使用位置的限制，最多也就是在WHERE子句不能使用聚合函数。但是，使用窗口函数的位置却有很大的限制，确切的说，窗口函数只能在SELECT子句中使用。</p><p>所有的聚合函数都能用作窗口函数，且使用语法与专用窗口函数完全相同。</p><h3 id="5-1-窗口函数——SUM"><a href="#5-1-窗口函数——SUM" class="headerlink" title="5.1 窗口函数——SUM"></a>5.1 窗口函数——SUM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--将SUM函数作为窗口函数使用</div><div class="line"> SELECT </div><div class="line">    product_id, </div><div class="line">    product_name, </div><div class="line">    sale_price,        </div><div class="line">    SUM(sale_price) OVER (ORDER BY product_id) AS current_sum   </div><div class="line">FROM </div><div class="line">    Product;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">product_id | product_name | sale_price | current_sum------------+--------------+------------+-------------</div><div class="line"> 0001       | T衫          |       1000 |        1000</div><div class="line"> 0002       | 打孔器       |        500 |        1500</div><div class="line"> 0003       | 运动T衫      |       4000 |        5500</div><div class="line"> 0004       | 菜刀         |       3000 |        8500</div><div class="line"> 0005       | 高压锅       |       6800 |       15300</div><div class="line"> 0006       | 叉子         |        500 |       15800</div><div class="line"> 0007       | 擦菜板       |        880 |       16680</div><div class="line"> 0008       | 圆珠笔       |        100 |       16780</div><div class="line">(8 行记录)</div></pre></td></tr></table></figure><p>使用聚合函数作为窗口函数时，需要在其括号内指定相应的列。像上例中，使用sale_price(销售单价)作为累加的对象, current_sum的结果为在它之前的销售单价的合计。这种统计方法称为累计。</p><h3 id="5-2-窗口函数——AVG"><a href="#5-2-窗口函数——AVG" class="headerlink" title="5.2 窗口函数——AVG"></a>5.2 窗口函数——AVG</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--将AVG函数作为窗口函数使用</div><div class="line">SELECT </div><div class="line">    product_id, </div><div class="line">    product_name, </div><div class="line">    sale_price,        </div><div class="line">    AVG(sale_price) OVER (ORDER BY product_id) AS current_avg   </div><div class="line">FROM </div><div class="line">    Product;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">product_id | product_name | sale_price |      current_avg------------+--------------+------------+-----------------------</div><div class="line"> 0001       | T衫          |       1000 | 1000.0000000000000000</div><div class="line"> 0002       | 打孔器       |        500 |  750.0000000000000000</div><div class="line"> 0003       | 运动T衫      |       4000 | 1833.3333333333333333</div><div class="line"> 0004       | 菜刀         |       3000 | 2125.0000000000000000</div><div class="line"> 0005       | 高压锅       |       6800 | 3060.0000000000000000</div><div class="line"> 0006       | 叉子         |        500 | 2633.3333333333333333</div><div class="line"> 0007       | 擦菜板       |        880 | 2382.8571428571428571</div><div class="line"> 0008       | 圆珠笔       |        100 | 2097.5000000000000000</div><div class="line">(8 行记录)</div></pre></td></tr></table></figure><p>current_avg的结果为在它之前的销售单价的平均值。像这样以“自身记录”（当前记录）作为基准进行统计，就是将聚合函数作为窗口函数使用时的最大特征。</p><h3 id="5-2-移动平均"><a href="#5-2-移动平均" class="headerlink" title="5.2 移动平均"></a>5.2 移动平均</h3><p>窗口函数就是将表以窗口为单位进行分割，并在其中进行排序的函数。其中还包含在窗口中指定更详细的汇总范围的备选功能，这种备选功能中的汇总范围称为框架。</p><p>例如，指定“最靠近的3行”作为汇总对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--指定“最靠近的3行”作为汇总对象</div><div class="line"> SELECT </div><div class="line">    product_id, </div><div class="line">    product_name, </div><div class="line">    sale_price,        </div><div class="line">    AVG(sale_price) OVER (ORDER BY product_id  ROWS 2 PRECEDING) AS moving_avg   </div><div class="line">FROM </div><div class="line">    Product;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">product_id | product_name | sale_price |      moving_avg------------+--------------+------------+-----------------------</div><div class="line"> 0001       | T衫          |       1000 | 1000.0000000000000000</div><div class="line"> 0002       | 打孔器       |        500 |  750.0000000000000000</div><div class="line"> 0003       | 运动T衫      |       4000 | 1833.3333333333333333</div><div class="line"> 0004       | 菜刀         |       3000 | 2500.0000000000000000</div><div class="line"> 0005       | 高压锅       |       6800 | 4600.0000000000000000</div><div class="line"> 0006       | 叉子         |        500 | 3433.3333333333333333</div><div class="line"> 0007       | 擦菜板       |        880 | 2726.6666666666666667</div><div class="line"> 0008       | 圆珠笔       |        100 |  493.3333333333333333</div><div class="line">(8 行记录)</div></pre></td></tr></table></figure><p>上例中，我们使用了ROWS（行）和PRECEDING(之前)两个关键字，将框架指定为“截止到之前~行”，因此，“ ROWS 2 PRECEDING”意思就是将框架指定为“截止到之前2行”，也就是“最靠近的3行”。如果将条件中的数字改为“ROWS 5 PRECEDING”，就是“截止到之前5行”（最靠近的6行）的意思。这样的统计方法称为移动平均。</p><p>使用关键字FOLLOWING(之后)替换PRECEDING，就可以指定“截止到之后~行”作为框架。</p><p>如果希望将当前记录的前后行作为汇总对象，可以同时使用PRECEDING(之前)和FOLLOWING（之后）关键字来实现。<br>例，将当前记录的前后行作为汇总对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> --将当前记录的前后行作为汇总对象</div><div class="line">SELECT </div><div class="line">    product_id, </div><div class="line">    product_name, </div><div class="line">    sale_price,       </div><div class="line">    AVG(sale_price) OVER (ORDER BY product_id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS moving_avg   </div><div class="line">FROM </div><div class="line">    Product;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">product_id | product_name | sale_price |      moving_avg------------+--------------+------------+-----------------------</div><div class="line"> 0001       | T衫          |       1000 |  750.0000000000000000</div><div class="line"> 0002       | 打孔器       |        500 | 1833.3333333333333333</div><div class="line"> 0003       | 运动T衫      |       4000 | 2500.0000000000000000</div><div class="line"> 0004       | 菜刀         |       3000 | 4600.0000000000000000</div><div class="line"> 0005       | 高压锅       |       6800 | 3433.3333333333333333</div><div class="line"> 0006       | 叉子         |        500 | 2726.6666666666666667</div><div class="line"> 0007       | 擦菜板       |        880 |  493.3333333333333333</div><div class="line"> 0008       | 圆珠笔       |        100 |  490.0000000000000000</div><div class="line">(8 行记录)</div></pre></td></tr></table></figure><p>当前记录的前后行的具体含义就是：</p><ul><li>之前1行的记录</li><li>自身（当前记录）</li><li>之后1行的记录</li></ul><p>如果能够熟练掌握框架功能，就可以称为窗口函数高手了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章梳理了几个关于分组排序的SQL语句，在查询的时候常会遇到分组排序的场景，比如找出每个群体中中排名前十的用户，找出某一类商品销量最高的几个商品等等。它们分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row_number() over()&lt;/li&gt;
&lt;li&gt;rank( ) over( )&lt;/li&gt;
&lt;li&gt;dense_rank( ) over( )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此引申开来，讲述一下窗口函数的功用。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="row_number( ) over( )" scheme="http://yoursite.com/tags/row-number-over/"/>
    
      <category term="rank() over()" scheme="http://yoursite.com/tags/rank-over/"/>
    
      <category term="dense_rank() over()" scheme="http://yoursite.com/tags/dense-rank-over/"/>
    
      <category term="distinct" scheme="http://yoursite.com/tags/distinct/"/>
    
      <category term="窗口函数" scheme="http://yoursite.com/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（4）：基于ARMA模型的资金渠道流入流出预测</title>
    <link href="http://yoursite.com/2018/05/23/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EARMA%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%B5%84%E9%87%91%E6%B8%A0%E9%81%93%E6%B5%81%E5%85%A5%E6%B5%81%E5%87%BA%E9%A2%84%E6%B5%8B/"/>
    <id>http://yoursite.com/2018/05/23/数据分析系列（4）：基于ARMA模型的资金渠道流入流出预测/</id>
    <published>2018-05-23T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>该数据为某资金渠道从2017/01/01至2017/07/29这段时间内的清算金额汇总信息，每5分钟按流入流出汇总交易数据，type为SE表示流入，type为RE表示流出，其中2017/01/01至2017/07/23这段时间的每天各时段的流入流出汇总数据是齐全的，而2017/07/24至2017/07/29这六天时间只有0点到早上10点的数据。现在要求我们根据这些数据来预测这六天每天从当日0点到24点的流入流出轧差值（总流入-总流出）。</p><a id="more"></a><p>通过观察我们可以得知这些资金流入流出数据是各时间点上形成的数值序列，而时间序列分析就是通过观察历史数据预测未来的值，适用于我们这次预测。</p><p>自回归移动平均模型(ARMA(p，q))是时间序列中最为重要的模型之一，它主要由两部分组成： AR代表p阶自回归过程，MA代表q阶移动平均过程，其公式如下：</p><script type="math/tex; mode=display">Z_t=\varphi _1z_{t-1}+\varphi _2z_{t-2 }+···+\varphi _pz_{t-p}+a_t-\theta_1a_{t-1}-···-\theta_qa_{t-q}</script><p>可以对其简化：</p><script type="math/tex; mode=display">\varphi_p(B)z_t=\theta_q(B)a_t\\其中\varphi_p(B)=1-\varphi_1B-\varphi_2B^2-···-\varphi_pB^p\\\theta_q(B)=1-\theta_1B-\theta_2B^2-···-\theta_qB^p</script><h2 id="一、分析过程"><a href="#一、分析过程" class="headerlink" title="一、分析过程"></a>一、分析过程</h2><h3 id="1-1-数据预处理"><a href="#1-1-数据预处理" class="headerlink" title="1.1 数据预处理"></a>1.1 数据预处理</h3><p>首先要对数据进行转换处理，type为SE的amount保持不变，type为RE的amount取负数，对缺失值记为0，这样可以方便之后处理，将数据存入字典中，key为时间，value为资金（有正负）。处理脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data_Process</span><span class="params">(input_file,header= True)</span>:</span></div><div class="line">    amount_dict=&#123;&#125;</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(input_file):</div><div class="line">        term = line.strip().split(<span class="string">','</span>)   </div><div class="line">        <span class="keyword">if</span> header:</div><div class="line">            header =<span class="keyword">False</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> term[<span class="number">1</span>]==<span class="string">'SE'</span>: </div><div class="line">            <span class="keyword">if</span> term[<span class="number">2</span>] ==<span class="string">''</span>:</div><div class="line">                amount =<span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                amount = float(term[<span class="number">2</span>])</div><div class="line">        <span class="keyword">elif</span> term[<span class="number">1</span>]==<span class="string">'RE'</span>:</div><div class="line">            <span class="keyword">if</span> term[<span class="number">2</span>] ==<span class="string">''</span>:</div><div class="line">                amount =<span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                amount = <span class="number">-1</span>*float(term[<span class="number">2</span>])</div><div class="line">        time = datetime.strftime(datetime.strptime(term[<span class="number">0</span>],<span class="string">'%Y/%m/%d %H:%M'</span>),<span class="string">'%Y/%m/%d %H:%M'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> time <span class="keyword">in</span> amount_dict:</div><div class="line">            amount_dict[time] = round(amount,<span class="number">2</span>)</div><div class="line">        <span class="keyword">elif</span> time <span class="keyword">in</span> amount_dict:</div><div class="line">            amount_dict[time]+=round(amount,<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span>  amount_dict</div></pre></td></tr></table></figure><p>因为我们要对天级别的数据进行预测，可以对资金按天进行聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataframe_trans_series</span><span class="params">(amount_dict,freq=<span class="string">'D'</span>)</span>:</span></div><div class="line">    data_dict=&#123;&#125;</div><div class="line">    data_dict[<span class="string">'amount'</span>] = amount_dict</div><div class="line">    data = pd.DataFrame(data_dict)</div><div class="line">    data.index = pd.to_datetime(data.index) </div><div class="line">    df = pd.DataFrame(data[<span class="string">'amount'</span>].resample(freq).sum())</div><div class="line">    time_series =  df[<span class="string">'amount'</span>]</div><div class="line">    <span class="keyword">return</span> time_series</div></pre></td></tr></table></figure><p>得到的中间数据如下所示，每一天对应一条数据，表示这一天的流入流出轧差值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>    <span class="number">123081.02</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">150143.02</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>    <span class="number">161112.42</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>    <span class="number">138823.62</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>    <span class="number">130364.32</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>     <span class="number">85308.56</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-07</span>     <span class="number">77484.16</span></div><div class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-08</span>     <span class="number">93860.22</span></div><div class="line">······</div></pre></td></tr></table></figure><h3 id="1-2-绘制时序图"><a href="#1-2-绘制时序图" class="headerlink" title="1.2 绘制时序图"></a>1.2 绘制时序图</h3><p>按天聚合之后，我们可以简单看一下时序图、移动平均时序图和加权移动平均时序图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_trend</span><span class="params">(timeSeries, size)</span>:</span></div><div class="line">    f = plt.figure(facecolor=<span class="string">'white'</span>)</div><div class="line">    </div><div class="line">    rol_mean = timeSeries.rolling(window=size).mean()</div><div class="line">    rol_weighted_mean = pd.ewma(timeSeries, span=size)</div><div class="line">    timeSeries.plot(color=<span class="string">'blue'</span>, label=<span class="string">'Original'</span>)</div><div class="line">    plt.legend(loc=<span class="string">'best'</span>)</div><div class="line">    plt.title(<span class="string">'Original'</span>)    </div><div class="line">    rol_mean.plot(color=<span class="string">'red'</span>, label=<span class="string">'Rolling Mean'</span>)</div><div class="line">    plt.legend(loc=<span class="string">'best'</span>)</div><div class="line">    plt.title(<span class="string">'Rolling Mean'</span>)    </div><div class="line">    rol_weighted_mean.plot(color=<span class="string">'black'</span>, label=<span class="string">'Weighted Rolling Mean'</span>)</div><div class="line">    plt.legend(loc=<span class="string">'best'</span>)</div><div class="line">    plt.title(<span class="string">'Weighted Rolling Mean'</span>)    </div><div class="line">    plt.show()</div></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0q1d0dij30kc0dp0v0.jpg" alt=""></p><p>可以从时序图看出，该时间序列存在着波动，尚无法确定是否平稳，需要进一步的统计检验。</p><h3 id="1-3-平稳性检验"><a href="#1-3-平稳性检验" class="headerlink" title="1.3 平稳性检验"></a>1.3 平稳性检验</h3><p>序列的平稳性是进行时间序列分析的前提条件，单位根检验（ADF）是一种常用的平稳性检验方法，他的原假设为序列具有单位根，即非平稳，对于一个平稳的时序数据，就需要在给定的置信水平上显著，拒绝原假设。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_Stationarity</span><span class="params">(ts)</span>:</span></div><div class="line">    test = adfuller(ts)</div><div class="line">    output = pd.Series(test[<span class="number">0</span>:<span class="number">4</span>], index=[<span class="string">'Test Statistic'</span>,<span class="string">'p-value'</span>,<span class="string">'Lags Used'</span>,<span class="string">'Number of Observations Used'</span>])</div><div class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> test[<span class="number">4</span>].items():</div><div class="line">        output[<span class="string">'Critical Value (%s)'</span>%key] = value</div><div class="line">    <span class="keyword">return</span> output</div></pre></td></tr></table></figure><p>以下为检验结果，其p值小于0.01，说明拒绝原假设，得出此序列具有平稳性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Test Statistic                  <span class="number">-3.779937</span></div><div class="line">p-value                          <span class="number">0.003119</span></div><div class="line">Lags Used                        <span class="number">2.000000</span></div><div class="line">Number of Observations Used    <span class="number">201.000000</span></div><div class="line">Critical Value (<span class="number">5</span>%)             <span class="number">-2.876029</span></div><div class="line">Critical Value (<span class="number">1</span>%)             <span class="number">-3.463309</span></div><div class="line">Critical Value (<span class="number">10</span>%)            <span class="number">-2.574493</span></div></pre></td></tr></table></figure><p>当然也可以观察其自相关图，可以看到，其自相关图快速衰减，体现了平稳性序列的特点，可认为他是平稳序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_acf_pacf</span><span class="params">(ts, lags=<span class="number">31</span>)</span>:</span></div><div class="line">    f = plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>),facecolor=<span class="string">'white'</span>)</div><div class="line">    ax1 = f.add_subplot(<span class="number">211</span>)</div><div class="line">    plot_acf(ts, lags=<span class="number">31</span>, ax=ax1)</div><div class="line">    ax2 = f.add_subplot(<span class="number">212</span>)</div><div class="line">    plot_pacf(ts, lags=<span class="number">31</span>, ax=ax2)</div><div class="line">    plt.show()</div></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0q29qnrj30jy0jf3zu.jpg" alt=""></p><h3 id="1-4-对数处理"><a href="#1-4-对数处理" class="headerlink" title="1.4 对数处理"></a>1.4 对数处理</h3><p>对数变换主要是为了减小数据的振动幅度，使其线性规律更加明显。对数变换相当于增加了一个惩罚机制，数据越大其惩罚越大，数据越小惩罚越小。虽然上一步我们验证了序列是平稳的，取对数也可以在该数据集上使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Log_Process</span><span class="params">(time_series)</span>:</span></div><div class="line">    <span class="keyword">return</span> np.log(time_series+<span class="number">1</span>)</div></pre></td></tr></table></figure><h3 id="1-5-纯随机性检验"><a href="#1-5-纯随机性检验" class="headerlink" title="1.5 纯随机性检验"></a>1.5 纯随机性检验</h3><p>经过平稳性检验之后，我们得到该序列为平稳性序列，接下来对其进行纯随机性检验，只有当时间序列不是一个白噪声即纯随机序列的时候，我们才可以对该序列做进一步的分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_stochastic</span><span class="params">(ts)</span>:</span></div><div class="line">    p_value = acorr_ljungbox(ts, lags=<span class="number">1</span>)[<span class="number">1</span>] </div><div class="line">    <span class="keyword">return</span> p_value</div></pre></td></tr></table></figure><p>得到的p值如下，可知，该序列为非白噪声序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">6.09097901e-21</span></div></pre></td></tr></table></figure><h3 id="1-6-确定ARMA的阶数"><a href="#1-6-确定ARMA的阶数" class="headerlink" title="1.6 确定ARMA的阶数"></a>1.6 确定ARMA的阶数</h3><p>由前面的平稳性检验和纯随机性检验可知，该序列为平稳序列且非白噪声序列，我们可以用ARMA(p,q)模型对其建模，这里关键的是p和q的定阶，我们可以通过观察自相关图ACF和偏自相关图PACF来识别，也可以借助AIC、BIC统计量来确定。</p><h4 id="1-6-1-BIC识别"><a href="#1-6-1-BIC识别" class="headerlink" title="1.6.1 BIC识别"></a>1.6.1 BIC识别</h4><p>以下是根据设定的maxlag，循环对p、q赋值，选出拟合BIC最小的p、q值作为模型的参数，并输出BIC最小的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_better_model</span><span class="params">(time_series, maxLag=<span class="number">5</span>)</span>:</span></div><div class="line">    init_bic = sys.maxint</div><div class="line">    init_p = <span class="number">0</span></div><div class="line">    init_q = <span class="number">0</span></div><div class="line">    init_properModel = <span class="keyword">None</span></div><div class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> np.arange(maxLag):</div><div class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> np.arange(maxLag):</div><div class="line">            model = ARMA(time_series, order=(p, q))</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                results_ARMA = model.fit(disp=<span class="number">-1</span>, method=<span class="string">'css'</span>)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            bic = results_ARMA.bic</div><div class="line">            <span class="keyword">if</span> bic &lt; init_bic:</div><div class="line">                init_p = p</div><div class="line">                init_q = q</div><div class="line">                init_properModel = results_ARMA</div><div class="line">                init_bic = bic</div><div class="line">    <span class="keyword">return</span> init_bic, init_p, init_q, init_properModel</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init_bic = <span class="number">33.0754219416592</span>  init_p = <span class="number">1</span>  init_q = <span class="number">1</span></div></pre></td></tr></table></figure><p>得到使BIC最小的模型，bic = 33.1，p、q分别为1。</p><h4 id="1-6-2-ACF、BCF识别"><a href="#1-6-2-ACF、BCF识别" class="headerlink" title="1.6.2 ACF、BCF识别"></a>1.6.2 ACF、BCF识别</h4><p>通过观察自相关图ACF和偏自相关图PACF来识别。观察下图，发现自相关和偏相系数都存在拖尾的特点，并且他们都具有明显的一阶相关性，所以我们设定p=1, q=1。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0q2thrrj30jy0jf3zu.jpg" alt=""></p><h3 id="1-7-拟合ARAM模型"><a href="#1-7-拟合ARAM模型" class="headerlink" title="1.7 拟合ARAM模型"></a>1.7 拟合ARAM模型</h3><p>选出BIC最小的模型，对训练集进行拟合。这里添加了一步将对数处理和差分处理还原的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bic, p, q, properModel = choose_better_model(time_series_diff)    </div><div class="line">predict_time_series = properModel.predict()</div><div class="line">predict_time_series = recover(predict_time_series, time_series_train, best_diff)</div></pre></td></tr></table></figure><h3 id="1-8-训练集的拟合优度"><a href="#1-8-训练集的拟合优度" class="headerlink" title="1.8 训练集的拟合优度"></a>1.8 训练集的拟合优度</h3><p>用拟合好的模型对训练集进行预测，并使用均方根误差对效果进行衡量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">original_time_series = time_series[predict_time_series.index]  </div><div class="line">plt.figure(facecolor=<span class="string">'white'</span>)</div><div class="line">predict_time_series.plot(color=<span class="string">'blue'</span>, label=<span class="string">'Predict'</span>)</div><div class="line">original_time_series.plot(color=<span class="string">'red'</span>, label=<span class="string">'Original'</span>)    </div><div class="line">RMSE = np.sqrt(sum((predict_time_series-original_time_series)**<span class="number">2</span>)/original_time_series.size)</div><div class="line">plt.title(<span class="string">'RMSE: %.4f'</span>% RMSE)</div><div class="line">plt.show()</div><div class="line">print(<span class="string">"训练集的RMSE为："</span>+str(RMSE))</div></pre></td></tr></table></figure><p>训练集预测值和真实值拟合图如下：<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0q372ucj30kc0dp40m.jpg" alt="">训练集的均方根误差为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">训练集的RMSE为：<span class="number">40024.97</span></div></pre></td></tr></table></figure><h3 id="1-9-预测结果"><a href="#1-9-预测结果" class="headerlink" title="1.9 预测结果"></a>1.9 预测结果</h3><p>用拟合好的模型对测试集进行预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test_predict = properModel.predict(start=<span class="string">'2017-07-24'</span>, end=<span class="string">'2017-07-29'</span>)</div><div class="line">test_predict = recover(test_predict, time_series_train, best_diff)</div><div class="line"><span class="keyword">print</span> test_predict</div></pre></td></tr></table></figure><p>得到最终的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-24</span>    <span class="number">244854.689637</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-25</span>    <span class="number">222634.079094</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-26</span>    <span class="number">206351.989143</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-27</span>    <span class="number">194213.093708</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-28</span>    <span class="number">185037.296689</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-29</span>    <span class="number">178024.480144</span></div></pre></td></tr></table></figure><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><h3 id="2-1-请给出你的分析过程、预测结果、建模脚本（要求可复现），包含必要的说明以及截图"><a href="#2-1-请给出你的分析过程、预测结果、建模脚本（要求可复现），包含必要的说明以及截图" class="headerlink" title="2.1 请给出你的分析过程、预测结果、建模脚本（要求可复现），包含必要的说明以及截图"></a>2.1 请给出你的分析过程、预测结果、建模脚本（要求可复现），包含必要的说明以及截图</h3><p>分析过程和预测结果如上所示，建模脚本见<a href="https://pan.baidu.com/s/1zPYrhyxNjVmlwht27ot01w" target="_blank" rel="noopener">百度网盘</a>，密码：9okf，包括两个文件，一个为jupyter notebook【SERE_PREDICT.ipynb】，一个为python脚本【SERE_PREDICT.py】，两者均可复现。实验环境为python2.7，实验所依赖的package包括：</p><ul><li>pandas</li><li>numpy</li><li>datetime</li><li>matplotlib</li><li>statsmodels</li></ul><h3 id="2-2-你认为你的模型预测结果如何，附上关键说明和截图"><a href="#2-2-你认为你的模型预测结果如何，附上关键说明和截图" class="headerlink" title="2.2 你认为你的模型预测结果如何，附上关键说明和截图"></a>2.2 你认为你的模型预测结果如何，附上关键说明和截图</h3><p>在本实验中，我使用均方根误差来评价模型预测效果，得到在训练集上的训练集的均方根误差为：40024.97。因为该数据集的数值均较大，日流入流出均达到了十万级别，这样的均方根误差相对来说效果较好，但有较大的提升空间。在分析过程中已有具体的呈现和说明。</p><h3 id="2-3-如果需要提高预测准确率，可以从哪些方面入手，简单列举即可"><a href="#2-3-如果需要提高预测准确率，可以从哪些方面入手，简单列举即可" class="headerlink" title="2.3 如果需要提高预测准确率，可以从哪些方面入手，简单列举即可"></a>2.3 如果需要提高预测准确率，可以从哪些方面入手，简单列举即可</h3><ol><li><p>在时间序列中存在的噪声，会干扰序列中每个点的波动，给预测造成难度，可以使用卡尔曼滤波来过滤这个噪声。将卡尔曼滤波算法与ARMA模型结合时，卡尔曼滤波算法可以在当获得一个新的数据点时，递归地更新状态变量（预测值）的信息，可以起到对ARMA模型的修正作用，在一定程度上提高ARMA模型的预测精度。</p></li><li><p>注意到我们需要预测的那几天在0点至10点是存在资金流动数据的，我们可以将这一部分数据作为我们预测全天数据的先验信息，提高预测精度。</p></li><li><p>如果我们具有有关资金流动的其他信息，诸如资金流动的来源、股市波动信息、宏观政策的变动、市场波动的信息等等，就可以构建一个特征集，用LSTM（长短时循环神经网络）来对序列进行建模。当然要是没有这些信息，也可以直接用历史记录 $[y_{t-1}, y_{t-2},…]$ 以及他们的各种统计量如均值、最大最小值、一阶差分、二阶差分等对 $x_t$ 做特征工程，以此丰富其维度，再使用LSTM对其进行建模。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该数据为某资金渠道从2017/01/01至2017/07/29这段时间内的清算金额汇总信息，每5分钟按流入流出汇总交易数据，type为SE表示流入，type为RE表示流出，其中2017/01/01至2017/07/23这段时间的每天各时段的流入流出汇总数据是齐全的，而2017/07/24至2017/07/29这六天时间只有0点到早上10点的数据。现在要求我们根据这些数据来预测这六天每天从当日0点到24点的流入流出轧差值（总流入-总流出）。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="时间序列" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
      <category term="ARMA" scheme="http://yoursite.com/tags/ARMA/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（10）：自然语言处理的发展与趋势</title>
    <link href="http://yoursite.com/2018/05/02/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E8%B6%8B%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/05/02/自然语言处理系列（10）：自然语言处理的发展与趋势/</id>
    <published>2018-05-02T15:14:45.000Z</published>
    <updated>2018-11-03T11:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自<a href="https://tryolabs.com/blog/2017/12/12/deep-learning-for-nlp-advancements-and-trends-in-2017/" target="_blank" rel="noopener">Deep Learning for Natural Language Processing (NLP): Advancements &amp; Trends</a></p><p>在过去的几年里，<a href="https://en.wikipedia.org/wiki/Deep_learning" target="_blank" rel="noopener">深度学习(DL)</a>架构和算法在<a href="https://en.wikipedia.org/wiki/Computer_vision#Recognition" target="_blank" rel="noopener">图像识别</a>和<a href="https://en.wikipedia.org/wiki/Speech_processing" target="_blank" rel="noopener">语音处理</a>等领域取得了令人瞩目的进展。</p><p>起初，他们在<a href="https://en.wikipedia.org/wiki/Natural_language_processing" target="_blank" rel="noopener">自然语言处理(NLP)</a>上的应用起初并没有那么令人印象深刻，但现在已经被证明能够为一些常见的NLP任务提供最先进的结果。在<a href="https://en.wikipedia.org/wiki/Named-entity_recognition" target="_blank" rel="noopener">命名实体识别(NER)</a>，<a href="https://en.wikipedia.org/wiki/Part-of-speech_tagging" target="_blank" rel="noopener">语音(POS)标记</a>或<a href="https://en.wikipedia.org/wiki/Sentiment_analysis" target="_blank" rel="noopener">情绪分析</a>等领域，<a href="https://en.wikipedia.org/wiki/Artificial_neural_network" target="_blank" rel="noopener">神经网络模型</a>表现优于传统方法。<a href="https://en.wikipedia.org/wiki/Machine_translation" target="_blank" rel="noopener">机器翻译</a>的进步也许是最显著的。</p><a id="more"></a><p>在本文中，我将介绍一些依赖于深度学习技术的自然语言处理领域的最新进展。我并不是在装模作样:考虑到有大量的科学论文、框架和工具，这是不可能的。我只想和大家分享一些我最喜欢的作品。我认为过去的几个月对我们的领域非常有利。深度学习在NLP中的使用不断扩大，在某些情况下产生惊人的结果，所有迹象都表明这一趋势不会停止。</p><h2 id="From-training-word2vec-to-using-pre-trained-models"><a href="#From-training-word2vec-to-using-pre-trained-models" class="headerlink" title="From training word2vec to using pre-trained models"></a>From training word2vec to using pre-trained models</h2><p>可以说，<a href="https://en.wikipedia.org/wiki/Word_embedding" target="_blank" rel="noopener">词嵌入</a>是最广为人知的与深度学习相关的技术。他们遵循了Harris (1954)的<a href="https://en.wikipedia.org/wiki/Distributional_semantics" target="_blank" rel="noopener">分布假设</a>，根据这一理论，具有相似意义的词通常出现在类似的语境中。我建议你读一下Gabriel Mordecki的<a href="https://monkeylearn.com/blog/word-embeddings-transform-text-numbers/" target="_blank" rel="noopener">这篇文章</a>。</p><ul><li><a href="https://veredshwartz.blogspot.com.uy/2016/01/representing-words.html" target="_blank" rel="noopener">Example of distributional vectors of words</a>.</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0jhs69jj30kd05k74g.jpg" alt=""></p><p>像<a href="https://www.aclweb.org/anthology/N13-1090" target="_blank" rel="noopener">word2vec(Mikolov et al .,2013)</a>和<a href="http://www.aclweb.org/anthology/D14-1162" target="_blank" rel="noopener">GloVe(Pennington et al .,2014)</a>已经是这个领域的先驱，尽管他们不能被视为深度学习(word2vec中的神经网络是浅层的而GloVe实现了基于计数的方法)，作为模型训练得到的中间产物，他们在很多的深度学习 NLP的方法中作为输入数据。在我们的领域使用词嵌入现在普遍认为是一种不错的实践。</p><p>一开始，对于一个给定的NLP问题，需要词嵌入，我们倾向于从一个与领域相关的大型语料库中训练我们自己的模型。当然，这并不是普遍使用词嵌入的最好方法，所以预先训练的模型开始慢慢地出现。在维基百科、推特、谷歌新闻、网络爬虫等数据集上进行了训练，这些模型允许你很容易地将词嵌入与你的深度学习算法结合起来。</p><p>最新的发展证实，预先训练的词嵌入模型仍然是NLP的一个关键问题。例如，来自<a href="https://research.fb.com/category/facebook-ai-research-fair/" target="_blank" rel="noopener">Facebook人工智能研究(FAIR)实验室</a>的<a href="https://fasttext.cc/" target="_blank" rel="noopener">fastText</a>发布了<a href="https://fasttext.cc/blog/2017/05/02/blog-post.html" target="_blank" rel="noopener">294种语言的预先训练的向量</a>，它对我们领域做出了巨大贡献。除了大量的不同语言之外，因为fastText使用字符级别的n-grams作为特征，这是非常有用的。这使得fastText可以避免OOV(脱离词汇)问题，因为即使是非常罕见的单词(例如特定的领域术语)，也可能会与更常见的单词共享某些字符n-grams。从这个意义上说，fastText的性能优于word2vec和GloVe，并优于小型数据集。</p><p>然而尽管我们可以看到一些进展，但在这方面还有很多工作要做。例如，很棒的 NLP框架<a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a>将词嵌入和DL模型集成到诸如NER和依赖性解析等任务中，允许用户更新模型或使用他们自己的模型。</p><p>我认为这是一种会不断发展的方法。将来，在NLP框架中使用易于使用的特定领域(如生物学、文学、经济等)的预先训练的模型将是非常棒的。锦上添花的是，用最简单的方法，对我们的用例进行微调。同时，词嵌入的方法也开始出现。</p><h2 id="Adapting-generic-embeddings-to-specific-use-cases"><a href="#Adapting-generic-embeddings-to-specific-use-cases" class="headerlink" title="Adapting generic embeddings to specific use cases"></a>Adapting generic embeddings to specific use cases</h2><p>也许使用预先训练的词嵌入的主要缺点是，训练数据与实际问题的数据之间存在分布的差异。假设你有一份生物学论文，食物食谱或者经济学研究论文。更有可能的是，通用的词嵌入会帮助你提高结果，因为你可能没有足够大的语料库来训练好的嵌入。但如果您可以将通用的词嵌入应用到特定的用例中呢?</p><p>这些类型的适应通常被称为NLP中的跨域或<a href="https://en.wikipedia.org/wiki/Domain_adaptation" target="_blank" rel="noopener">域适应技术</a>，并且非常接近<a href="https://en.wikipedia.org/wiki/Transfer_learning" target="_blank" rel="noopener">转移学习</a>。<a href="http://aclweb.org/anthology/D17-1312" target="_blank" rel="noopener">Yang等人</a>提出了一项非常有趣的研究。考虑到源域的词嵌入，他们提供了一个正则化的skip-gram模型，用于学习针对目标领域的词嵌入。</p><p>关键思想简单而有效。假设我们知道在源域中的单词$word_w$的词嵌入为$w_s$。为了计算$w_t$(目标域)的词嵌入，作者在两个域之间添加了一定的传输量。基本上，如果两个域中的单词都是频繁的，那就意味着它的语义不依赖于域。在这种情况下，传输量是很高的，因此在这两个域中所产生的嵌入往往是相似的。但是由于特定领域的单词在一个域中比另一个更频繁，所以传输量很小。基本上，如果两个域中的单词都是频繁的，那就意味着它的语义不依赖于域。在这种情况下，传输量是很高的，因此在这两个域中所产生的词嵌入往往是相似的。但是如果由于特定领域的单词在一个域中比另一个更频繁，则传输量很小。</p><p>这是一个关于词嵌入的研究课题，并没有得到广泛的研究，我认为它将在不久的将来得到更多的关注。</p><h2 id="Sentiment-analysis-as-an-incredible-side-effect"><a href="#Sentiment-analysis-as-an-incredible-side-effect" class="headerlink" title="Sentiment analysis as an incredible side effect"></a>Sentiment analysis as an incredible side effect</h2><p>盘尼西林，x光，甚至是post-it都是出乎意料的发现。</p><p><a href="https://arxiv.org/abs/1704.01444" target="_blank" rel="noopener">Radford等人</a>正在研究字节级循环语言模型的特点，目标是预测亚马逊评论文本中的下一个字符，当他们发现经过训练的模型中的单个神经元对情绪价值的预测非常准确。</p><ul><li><a href="https://blog.openai.com/unsupervised-sentiment-neuron/" target="_blank" rel="noopener">Review polarity vs Value of the neuron.</a></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4f26zxej30vd0n5t9d.jpg" alt=""><br>在注意到这一表现之后，作者决定在<a href="https://nlp.stanford.edu/sentiment/treebank.html" target="_blank" rel="noopener">斯坦福情绪树数据集</a>上对模型进行测试，发现其准确性为91.8%，而之前最好的是90.2%。这意味着，使用明显较少的例子，他们的模型，以无监督的方式训练，至少在一个特定但广泛研究的数据集上达到了最优的情绪分析效果，。</p><h3 id="The-sentiment-neuron-at-work"><a href="#The-sentiment-neuron-at-work" class="headerlink" title="The sentiment neuron at work"></a>The sentiment neuron at work</h3><p>由于该模型在作用在字符级之上，所以神经元在文本中改变每个字符的状态，看到它的行为如何运作是非常惊人的。</p><ul><li><a href="https://blog.openai.com/unsupervised-sentiment-neuron/" target="_blank" rel="noopener">Behavior of the sentiment neuron.</a></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4fbc8s6j30m805y75c.jpg" alt=""></p><p>例如，在单词best之后，神经元的值变得非常积极。然而，这个效应随着“可怕”这个词的出现而消失了，这是有道理的。</p><h3 id="Generating-polarity-biased-text"><a href="#Generating-polarity-biased-text" class="headerlink" title="Generating polarity biased text"></a>Generating polarity biased text</h3><p>当然，经过训练的模型仍然是一个有效的生成模型，因此它可以用来生成类似于Amazon评论的文本。但我发现，你可以通过简单地改写情绪神经元的值来选择生成的文本的极性。</p><ul><li>Examples of generated texts (<a href="https://blog.openai.com/unsupervised-sentiment-neuron/" target="_blank" rel="noopener">source</a>).<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4fk3eqxj30jx07u74u.jpg" alt=""></li></ul><p>作者选择的NN模型是由<a href="https://arxiv.org/abs/1609.07959" target="_blank" rel="noopener">Krause等人(2016)</a>提出的一种<a href="https://arxiv.org/abs/1609.07959" target="_blank" rel="noopener">multiplicative LSTM</a>，主要是因为他们观察到，对于他们所探索的超参数设置，它比普通的LSTMs收敛速度快更快。它拥有4096个单元，并接受了8200万亚马逊评论的训练。</p><p>为什么受过训练的模特如此精确地捕捉到情感的概念仍然是一个开放而迷人的问题。同时，你可以试着训练你自己的模型和实验。如果你有时间和gpu，当然这个特定模型通过四个NVIDIA Pascal gpu用了一个月的时间来进行训练。</p><h2 id="Sentiment-Analysis-in-Twitter"><a href="#Sentiment-Analysis-in-Twitter" class="headerlink" title="Sentiment Analysis in Twitter"></a>Sentiment Analysis in Twitter</h2><p>无论是去了解人们对你的商业品牌的看法，还是去了解分析营销活动的影响或者在最后一场竞选活动中评估全球对希拉里•克林顿(Hillary Clinton)和唐纳德•特朗普(Donald Trump)的感觉，Twitter的情绪分析是一个非常有力的工具。</p><ul><li><a href="https://monkeylearn.com/blog/donald-trump-vs-hillary-clinton-sentiment-analysis-twitter-mentions/" target="_blank" rel="noopener">Donald Trump vs Hillary Clinton: sentiment analysis on Twitter.</a></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0jiqo4aj30rw095gmc.jpg" alt=""></p><h3 id="SemEval-2017"><a href="#SemEval-2017" class="headerlink" title="SemEval 2017"></a>SemEval 2017</h3><p>在Twitter上的情绪分析引起了NLP研究人员的广泛关注，同时也引起了政治和社会科学的关注。这就是自2013年以来，<a href="https://en.wikipedia.org/wiki/SemEval" target="_blank" rel="noopener">SemEval</a>提出了一个具体的任务的原因。</p><p>在2017年，共有48个团队参与了评估，这体现了它产生了多大的兴趣。为了让您了解<a href="http://www.aclweb.org/anthology/S17-2088" target="_blank" rel="noopener">对于Twitter数据SemEval是如何评估的</a>，让我们来看看今年提出的五个子任务。</p><ul><li>子任务 A：发一条推文，决定它表达的是积极的、消极的还是中性的情绪。</li><li>子任务 B：给定一条推文和一个主题，将对这个主题的情绪分成两部分:积极的和消极的。</li><li>子任务 C：给定一条推文和一个主题，将推文中传达的情绪分类为5个点:强阳性、弱阳性、中性、弱阴性和强阴性。</li><li>子任务 D：给定一组关于主题的tweet，估计在正和负类上的tweet的分布。</li><li>子任务 E：给定一组关于主题的推文，估计5个类的推文的分布:强阳性、弱阳性、中性、弱阴性和强阴性。</li></ul><p>如您所见，子任务A是最常见的任务，有38个团队参与其中，但其他任务更具挑战性。组织者注意到，深度学习方法的使用非常突出，并且不断增加，今年有20个团队使用了像<a href="https://en.wikipedia.org/wiki/Convolutional_neural_network" target="_blank" rel="noopener">卷积神经网络(CNN)</a>和<a href="https://en.wikipedia.org/wiki/Long_short-term_memory" target="_blank" rel="noopener">长短期记忆网络(LSTM)</a>这样的模型。此外，因为<a href="https://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="noopener">SVM</a>模型仍然非常流行，一些参与者将它们与神经网络方法或使用的词嵌入特性结合起来。</p><h3 id="The-BB-twtr-system"><a href="#The-BB-twtr-system" class="headerlink" title="The BB_twtr system"></a>The BB_twtr system</h3><p>值得注意的是，一个纯粹的深度学习系统，即<a href="https://arxiv.org/abs/1704.06125" target="_blank" rel="noopener">_BB_twtr_系统(Cliche，2017)</a>，在英语5个子任务中排名第一。作者结合了10个CNNs和10个biLSTMs的合集，采用不同的超参数和不同的预训练策略。您可以在本文中看到网络结构的详细信息。</p><p>为了训练模型,作者用人类标注的tweets数据(子任务A达到了49693的数量级)，并构建一个由1亿条无标注tweets组成的数据集，他提取一个distant dataset，通过将存在积极正面的表情符号如 :-) 标记为正类，反之亦然。这些推文中，小写的、标记化的、url和表情符号等等被特定的标记替换，并统一重复字符，例如，“niiice”和“niiiiiice”都变成了“niice”。</p><p>使用之前的SemEval数据集的实验表明，使用Glove会降低性能，而且对于所有的黄金标准数据集，并没有唯一的最佳模型。然后作者将所有的模型与软投票策略结合起来。结果模型比之前的2014年和2016年的最佳历史成绩要好，而且在其他年份非常接近。最后，它在2017年的5个英语子任务中排名第一。</p><p>即使组合不是以一种有机的方式进行，而是使用简单的软投票策略，这项工作显示了结合深度学习模型的潜力，同时也说明了端到端方法(输入必须预先处理)可以在Twitter的情绪分析中胜过监督学习的方法。</p><h2 id="An-exciting-abstractive-summarization-system"><a href="#An-exciting-abstractive-summarization-system" class="headerlink" title="An exciting abstractive summarization system"></a>An exciting abstractive summarization system</h2><p><a href="https://en.wikipedia.org/wiki/Automatic_summarization" target="_blank" rel="noopener">自动摘要</a>，<a href="https://en.wikipedia.org/wiki/Machine_translation" target="_blank" rel="noopener">自动翻译</a>，是NLP首要任务之一。有两种主要的方法: 基于抽取的方法，它通过从源文本中提取最重要的部分来构建摘要；基于抽象的方法，通过生成文本来构建摘要。从历史上看，基于抽取的方法是最常见的，因为它们的简单性超过了抽象的方法。</p><p>在过去的几年里，基于RNN的模型在文本生成方面取得了惊人的成果。它们在短文本的输入和输出中表现得非常好，但对于长文本来说，它们往往是不连贯和重复的。在他们的研究中，<a href="https://arxiv.org/abs/1705.04304" target="_blank" rel="noopener">Paulus等</a>提出了一种新的神经网络模型来克服这一局限性。结果是令人兴奋的，正如您在下图所看到的。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0jju0ikg30hs05u7dh.gif" alt="2018-05-06 10_49_16"></p><p>作者使用一个bi-LSTM编码器读取输入和一个LSTM解码器来生成输出。它们的主要贡献是一种新的内部注意力机制，即对输入和连续生成的输出进行单独的处理，以及一种新的训练方法，它结合了标准的监督词预测和强化学习。</p><h3 id="Intra-attention-strategy"><a href="#Intra-attention-strategy" class="headerlink" title="Intra-attention strategy"></a>Intra-attention strategy</h3><p>提出的内部注意力机制的目标是避免输出重复。为了实现这一目标，他们在解码之前对输入文本的前半部分进行解码，然后再决定下一个词的生成。这迫使模型在生成过程中使用不同的输入部分。它们还允许模型从解码器访问以前的隐藏状态。然后将这两个函数组合起来，为输出摘要选择最佳的下一个单词。</p><h3 id="Reinforcement-learning"><a href="#Reinforcement-learning" class="headerlink" title="Reinforcement learning"></a>Reinforcement learning</h3><p>为了生成一个摘要，两个不同的人将使用不同的单词和句子顺序，这两个摘要都可能被认为是有效的。因此，一个好的摘要并不一定必须是一组序列单词来尽可能地匹配训练数据集的序列。知道了这一点，作者就避免了标准的teacher forcing 算法，这使得每个解码步骤(即每个生成的单词)的损失最小化，并且他们依赖于一个强化学习策略，这证明是一个很好的选择。</p><h3 id="Great-results-for-an-almost-end-to-end-model"><a href="#Great-results-for-an-almost-end-to-end-model" class="headerlink" title="Great results for an almost end-to-end model"></a>Great results for an almost end-to-end model</h3><p>该模型在<a href="https://github.com/abisee/cnn-dailymail" target="_blank" rel="noopener">CNN/Daily Mail数据集</a>上进行了测试，并取得了最好的结果。此外，人类评估者的一项具体实验表明，对于人类的可读性和质量也有所提高。此外，基本的预处理的结果令人印象深刻:输入文本被标记，小写，数字被替换为“0”，数据集的某些特定实体被删除。</p><h2 id="A-first-step-towards-fully-unsupervised-machine-translation"><a href="#A-first-step-towards-fully-unsupervised-machine-translation" class="headerlink" title="A first step towards fully unsupervised machine translation?"></a>A first step towards fully unsupervised machine translation?</h2><p>双语词典构建是一项古老的NLP任务，即在两种语言中使用源和目标的单语语料库来识别词翻译匹配对。自动构建的双语词典对其他NLP任务有所帮助，如<a href="https://en.wikipedia.org/wiki/Information_retrieval" target="_blank" rel="noopener">信息检索</a>和<a href="https://en.wikipedia.org/wiki/Statistical_machine_translation" target="_blank" rel="noopener">统计机器翻译</a>。然而，这些方法大部分时间都依赖于某种资源，通常是最初的双语词典，它并不总是可用，也不容易构建。</p><p>随着词嵌入的成功，跨语言词嵌入的思想出现了，目的是将嵌入空间而不是词汇图标对齐。不幸的是，第一种方法也依赖于双语词汇或平行语料库。在他们的研究中，<a href="https://arxiv.org/abs/1710.04087" target="_blank" rel="noopener">Conneau等人(2018)</a>提出了一种非常有前途的方法，它不依赖于任何特定的资源，并且对于单词翻译、句子翻译检索和跨语言单词相似性的任务，在几个语言的pairs数据上优于最先进的监督方法。</p><p>作者所开发的方法是输入两套在单语数据上单独训练的词嵌入，并在它们之间学习一种映射，这样翻译在公共空间中就很接近了。他们使用未经监督的单词向量，在维基百科上用fastText训练。下面的图片说明了这个关键的想法。</p><ul><li><a href="https://arxiv.org/abs/1710.04087" target="_blank" rel="noopener">Building the mapping between two word embedding spaces.</a></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4gb1whvj30xu083wf5.jpg" alt=""><br>红色的X分布是英语单词的嵌入，蓝色的Y分布是意大利语词的嵌入。</p><p>首先，他们使用<a href="https://en.wikipedia.org/wiki/Adversarial_machine_learning" target="_blank" rel="noopener">对抗学习</a>来学习一个旋转矩阵W，它将执行第一个原始的对齐。他们主要训练一个<a href="https://en.wikipedia.org/wiki/Generative_adversarial_network" target="_blank" rel="noopener">生成对抗网络(GAN)</a>，遵循<a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">Goodfellow等人(2014)</a>的主张。为了直观地了解甘斯的工作方式，我向您推荐<a href="https://tryolabs.com/blog/2016/12/06/major-advancements-deep-learning-2016/" target="_blank" rel="noopener">巴勃罗·索托的这篇优秀文章</a>。</p><p>为了从对抗性学习的角度对问题进行建模，他们定义了discriminator来决定，给定一些从WX和Y中随机取样的元素(见上图中的第二列)，每种语言都属于哪一种语言。然后他们训练W，以防止discriminator做出正确的预测。这在我看来是非常聪明和优雅的，最终的结果是相当不错的。</p><p>在此之后，他们再应用两个步骤来完善映射。一是避免在映射计算中引入稀疏的噪声。另一个是建立实际的翻译，主要是利用学习的映射和距离度量。</p><p>在某些情况下，结果令人印象深刻的是最先进的。例如，在英语-意大利语单词翻译的例子中，在P@10的案例中，它们的平均精度超过了1.500个源单词的最佳平均精度。</p><ul><li><a href="https://arxiv.org/abs/1710.04087" target="_blank" rel="noopener">English-Italian word translation average precisions.</a></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0jn1z20j30q90fb100.jpg" alt=""></p><p>作者声称，他们的方法可以作为无监督机器翻译的第一步。如果真是这样，那就太好了。同时，让我们看看这个新的有希望的方法能走多远。</p><h2 id="Specialized-frameworks-and-tools"><a href="#Specialized-frameworks-and-tools" class="headerlink" title="Specialized frameworks and tools"></a>Specialized frameworks and tools</h2><p>有很多通用的深度学习框架和工具，其中一些被广泛使用，比如<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow</a>、<a href="https://github.com/fchollet/keras" target="_blank" rel="noopener">Keras</a>或<a href="http://pytorch.org/" target="_blank" rel="noopener">PyTorch</a>。然而，特定的开源NLP导向的深度学习框架和工具刚刚出现。对于我们来说，这是一个好年头，因为一些非常有用的开源框架已经向社区开放了。其中三个特别引起了我的注意，你可能也会觉得有趣。</p><h3 id="AllenNLP"><a href="#AllenNLP" class="headerlink" title="AllenNLP"></a>AllenNLP</h3><p><a href="http://allennlp.org/papers/AllenNLP_white_paper.pdf" target="_blank" rel="noopener">AllenNLP</a>框架是建立在PyTorch之上的一个平台，它可以在语义NLP任务中轻松使用DL方法。它的目标是让研究人员设计和评估新的模型。它包括用于常见语义NLP任务的模型的参考实现，如语义角色标记、文本蕴涵和相关解析。</p><h3 id="ParlAI"><a href="#ParlAI" class="headerlink" title="ParlAI"></a>ParlAI</h3><p><a href="https://arxiv.org/abs/1705.06476" target="_blank" rel="noopener">ParlAI</a>框架是一个用于对话研究的开源软件平台。它是在Python中实现的，其目标是为对话模型的共享、训练和测试提供一个统一的框架。ParlAI提供了一种与Amazon Mechanical Turk轻松集成的机制。它还提供了该领域的流行数据集，并支持多种模型，包括神经模型，如内存网络、seq2seq和专注的LSTMs。</p><p>ParlAI框架是一个用于对话研究的开源软件平台。它是在Python中实现的，其目标是为对话模型的共享、训练和测试提供一个统一的框架。ParlAI提供了一种与Amazon Mechanical Turk轻松集成的机制。它还提供了该领域的流行数据集，并支持多种模型，包括神经模型，如记忆网络、seq2seq和基于注意力机制的LSTMs。</p><h3 id="OpenNMT"><a href="#OpenNMT" class="headerlink" title="OpenNMT"></a>OpenNMT</h3><p><a href="https://arxiv.org/abs/1701.02810" target="_blank" rel="noopener">OpenNMT</a>工具包是一个专门用于序列到序列模型的通用框架。它可以用来执行诸如机器翻译、摘要、图像到文本、语音识别等任务。</p><h2 id="Final-thoughts"><a href="#Final-thoughts" class="headerlink" title="Final thoughts"></a>Final thoughts</h2><p>用于NLP问题的DL技术的持续增长是不可否认的。一个很好的指标是，在过去的几年里，<a href="https://www.aclweb.org/" target="_blank" rel="noopener">ACL</a>、<a href="https://www.aclweb.org/portal/emnlp" target="_blank" rel="noopener">EMNLP</a>、<a href="http://www.eacl.org/" target="_blank" rel="noopener">EACL</a>和<a href="http://naacl.org/" target="_blank" rel="noopener">NAACL</a>等关键NLP会议的深度学习论文百分比的变化。</p><ul><li><a href="https://arxiv.org/abs/1708.02709" target="_blank" rel="noopener">Percentage of deep learning papers.</a><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv0jnx1d2j30jk0d40v0.jpg" alt=""></li></ul><p>然而，真正的端到端学习才刚刚开始。我们仍在处理一些典型的NLP任务，以准备数据集，例如清理、标记或统一某些实体(例如url、数字、电子邮件地址等)。我们还使用了通用的嵌入，缺点是它们未能捕捉到特定领域术语的重要性，而且它们在多字表达式中表现不佳，这是我在我所研究的项目中反复发现的一个关键问题。</p><p>最新的进展对DL应用于NLP来说非常好。我希望未来能够带来更多的端到端学习的工作，并且特定的开放源码框架得到了更大的发展。请在评论部分与我们分享您对这些作品和框架的看法，以及您今年喜欢的和我在这里没有提到的。</p><h2 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h2><p>关于NLP研究中深度学习方法的更多信息，我强烈推荐你在Young等人的<a href="https://arxiv.org/abs/1708.02709" target="_blank" rel="noopener">“Recent Trends in Deep Learning Based Natural Language Processing”</a>这篇优秀论文。</p><p>另一个有趣的阅读报告是Blunsom等人的<a href="http://drops.dagstuhl.de/opus/volltexte/2017/7248/pdf/dagrep_v007_i001_p129_s17042.pdf" target="_blank" rel="noopener">“From Characters to Understanding Natural Language (C2NLU): Robust End-to-End Deep Learning for NLP”(2017)</a>，研究人员在NLP，计算语言学、深度学习和通用机器学习所讨论的优势和挑战为深度学习模型使用字符作为输入而不是特定的语言符号。</p><p>为了在模型之间有一个比较的视角，我可以给你推荐一个非常有趣的<a href="https://arxiv.org/abs/1702.01923" target="_blank" rel="noopener">CNN和RNN的比较研究</a>，由Yin等人(2017)进行。</p><p>为了直观地了解GANs的工作原理，你可以阅读<a href="https://tryolabs.com/blog/2016/12/06/major-advancements-deep-learning-2016/" target="_blank" rel="noopener">巴勃罗·索托(Pablo Soto)的这篇出色的文章</a>，它展示了2016年深度学习的重大进展。</p><p>我建议你读一下<a href="https://monkeylearn.com/blog/word-embeddings-transform-text-numbers/" target="_blank" rel="noopener">加布里埃尔·莫德基的这篇文章</a>。它以一种说教和娱乐的方式写成，解释了不同的方法，甚至是一些关于词嵌入的传说。</p><p>最后，Sebastian Ruder在2017年写了一篇关于词嵌入的很好的文章，你可能会觉得很有用:关于2017年的词汇嵌入:<a href="http://ruder.io/word-embeddings-2017/" target="_blank" rel="noopener"> About Word embeddings in 2017: Trends and future directions</a></p><h2 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h2><ul><li>From Characters to Understanding Natural Language (C2NLU): Robust End-to-End Deep Learning for NLP Phil Blunsom, Kyunghyun Cho, Chris Dyer and Hinrich Schütze (2017)</li><li>From Characters to Understanding Natural Language (C2NLU): Robust End-to-End Deep Learning for NLP Phil Blunsom, Kyunghyun Cho, Chris Dyer and Hinrich Schütze (2017)</li><li>BB_twtr at SemEval-2017 Task 4: Twitter Sentiment Analysis with CNNs and LSTMs Mathieu Cliche (2017)</li><li>Word Translation without Parallel Data Alexis Conneau, Guillaume Lample, Marc’Aurelio Ranzato, Ludovic Denoyer, Hervé Jégou (2018)</li><li>Generative adversarial nets Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville and Yoshua Bengio (2014)</li><li>Distributional structure Zellig Harris (1954)</li><li>OpenNMT: Open-source toolkit for neural machine translation Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart and Alexander M Rush. (2017)</li><li>Multiplicative lstm for sequence modelling Ben Krause, Liang Lu, Iain Murray and Steve Renals (2016)</li><li>Parlai: A dialog research software platform Alexander H Miller, Will Feng, Adam Fisch, Jiasen Lu, Dhruv Batra, Antoine Bordes, Devi Parikh and Jason Weston (2017)</li><li>Linguistic Regularities in Continuous Space Word Representations Tomas Mikolov, Scott Wen-tau Yih and Geoffrey Zweig (2013)</li><li>Glove: Global vectors for word representation Jeffrey Pennington, Richard Socher and Christopher D. Manning (2014)</li><li>Learning to Generate Reviews and Discovering Sentiment Alec Radford, Rafal Jozefowicz and Ilya Sutskever (2017)</li><li>A Simple Regularization-based Algorithm for Learning Cross-Domain Word Embeddings Wei Yang, Wei Lu, Vincent Zheng (2017)</li><li>Comparative study of CNN and RNN for Natural Language Processing Wenpeng Yin, Katharina Kann, Mo Yu and Hinrich Schütze (2017)</li><li>Recent Trends in Deep Learning Based Natural Language Processing Tom Younga, Devamanyu Hazarikab, Soujanya Poriac and Erik Cambriad (2017)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自&lt;a href=&quot;https://tryolabs.com/blog/2017/12/12/deep-learning-for-nlp-advancements-and-trends-in-2017/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deep Learning for Natural Language Processing (NLP): Advancements &amp;amp; Trends&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在过去的几年里，&lt;a href=&quot;https://en.wikipedia.org/wiki/Deep_learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深度学习(DL)&lt;/a&gt;架构和算法在&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_vision#Recognition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图像识别&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Speech_processing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语音处理&lt;/a&gt;等领域取得了令人瞩目的进展。&lt;/p&gt;
&lt;p&gt;起初，他们在&lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_language_processing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自然语言处理(NLP)&lt;/a&gt;上的应用起初并没有那么令人印象深刻，但现在已经被证明能够为一些常见的NLP任务提供最先进的结果。在&lt;a href=&quot;https://en.wikipedia.org/wiki/Named-entity_recognition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;命名实体识别(NER)&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Part-of-speech_tagging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语音(POS)标记&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Sentiment_analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;情绪分析&lt;/a&gt;等领域，&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;神经网络模型&lt;/a&gt;表现优于传统方法。&lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_translation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;机器翻译&lt;/a&gt;的进步也许是最显著的。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="Sentiment Analysis" scheme="http://yoursite.com/tags/Sentiment-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（13）：QCon北京2018 深度学习分享总结</title>
    <link href="http://yoursite.com/2018/04/24/2018-04-24/"/>
    <id>http://yoursite.com/2018/04/24/2018-04-24/</id>
    <published>2018-04-24T13:14:45.000Z</published>
    <updated>2018-11-03T11:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>参加了历时三天的QCon北京的技术分享大会，一个码农云集的盛会，各大厂拿出自己的看家技术，真的是干货满满。特别感谢金主爸爸给的免费通票和树苗苗姐姐的联络，让我这样的小白加穷学生可以有机会参加这样规模的大会，还加了很多业界大佬的微信，见到了之前膜拜已久的洪强宁老师和张俊林老师，技术交流真的获益匪浅，扩宽了眼界，看到了自己的不足，有很多不懂的地方需要自己慢慢去补课。</p><p>下面是一些个人收获比较大的分享内容记录和整理，之后还会慢慢更新。</p><a id="more"></a><h2 id="一、达观数据-陈运文-《文本智能处理的深度学习技术》"><a href="#一、达观数据-陈运文-《文本智能处理的深度学习技术》" class="headerlink" title="一、达观数据 陈运文 《文本智能处理的深度学习技术》"></a>一、达观数据 陈运文 《文本智能处理的深度学习技术》</h2><p>人工智能目前的三个主要细分领域为图像、语音和文本，老师分享的是达观数据所专注的文本智能处理领域。文本智能处理，亦即自然语言处理，试图让机器来理解人类的语言，而语言是人类认知发展过程中产生的高层次抽象实体，不像图像、语音可以直接转化为计算机可理解的对象，它的主要应用主要是在智能问答，机器翻译，文本分类，文本摘要，标签提取，情感分析，主题模型等等方面。</p><p>自然语言的发展历程经历了以下几个阶段。这里值得一提的是，关于语言模型，早在2000年，百度IDL的徐伟博士提出了使用神经网络来训练二元语言模型，随后Bengio等人在2001年发表在NIPS上的文章《A Neural Probabilistic Language Model》，正式提出神经网络语言模型（NNLM），在训练模型的过程中也能得到词向量。2007年，Mnih和Hinton在神经网络语言模型（NNLM）的基础上提出了log双线性语言模型（Log-Bilinear Language Model，LBL），同时，Hinton在2007年发表在 ICML 上的《Three new graphical models for statistical language modelling》初见其将深度学习搬入NLP的决心。2008年，Ronan Collobert等人 在ICML 上发表了《A Unified Architecture for Natural Language Processing: Deep Neural Networks with Multitask Learning》，其中的模型名字叫C&amp;W模型，这是第一个直接以生成词向量为目标的模型。LBL与NNLM的区别正如它们的名字所示，LBL的模型结构是一个log双线性结构；而NNLM的模型结构为神经网络结构。这些积淀也成就了Mikolov创造了实用高效的Word2Vec工具，起初，他用循环神经网络RNNLM来做语言模型，发表paper《Recurrent neural network based language model》，之后就是各种改进，博士论文研究的也是用循环神经网络来做语言模型，《Statistical Language Models based on Neural Networks》。2013年，Mikolov等人同时提出了CBOW和Skip-gram模型。使用了Hierarchial Softmax和Negative Sampling两种trick来高效获取词向量。当然这个模型不是一蹴而就的，而是对于前人在NNLM、RNNLM和C&amp;W模型上的经验，简化现有模型，保留核心部分而得到的。同时开源了Word2Vec词向量生成工具，深度学习才在NLP领域遍地开花结果。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv47qbll9j30sr0a9js7.jpg" alt=""><br>一般地，文本挖掘各种类型应用的处理框架如下所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv47w1qj7j30ui0ciwez.jpg" alt=""><br>文本数据经过清洗、分词等预处理之后，传统方法通过提取诸如词频、TF-IDF、互信息、信息增益等特征形成高维稀疏的特征集合，而现在则基本对词进行embedding形成低维稠密的词向量，作为深度学习模型的输入，这样的框架可用于文本分类、情感分析、机器翻译等等应用场景，直接端到端的解决问题，也无需大量的特征工程，无监督训练词向量作为输入可带来效果的极大提升。</p><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><p>对于文本分类，以下列出了几种典型的深度学习模型：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv485p6wwj30wq0ajwf1.jpg" alt=""></p><h3 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h3><p>序列标注的任务就是给每个汉字打上一个标签，对于分词任务来说，我们可以定义标签集合为：$LabelSet=\{ B,M,E,S\}$。B代表这个汉字是词汇的开始字符，M代表这个汉字是词汇的中间字符，E代表这个汉字是词汇的结束字符，而S代表单字词。下图为中文分词序列标注过程：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv48bl9ezj30g00a03yo.jpg" alt=""><br>中文分词转换为对汉字的序列标注问题，假设我们已经训练好了序列标注模型，那么分别给每个汉字打上标签集合中的某个标签，这就算是分词结束了，因为这种形式不方便人来查看，所以可以增加一个后处理步骤，把B开头，后面跟着M的汉字拼接在一起，直到碰见E标签为止，这样就等于分出了一个单词，而打上S标签的汉字就可以看做是一个单字词。于是我们的例子就通过序列标注，被分词成如下形式：{跟着  Tfboys 学 左手 右手 一个 慢动作}</p><p>对于序列标注，传统的方法基本是使用大量的特征工程，进入CRF模型，但不同的领域需要进行相应的调整，无法做到通用。而深度学习模型，例如Bi-LSTM+CRF则避免了这样的情况，可以通用于不同的领域，且直接采用词向量作为输入，提高了泛化能力，使用LSTM和GRU等循环神经网络还可以学习到一些较远的上下文特征和一些非线性特征。</p><p>经典的Bi-LSTM+CRF模型如下所示：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv48lhxugj30ou0dhjsl.jpg" alt=""></p><h3 id="生成式摘要"><a href="#生成式摘要" class="headerlink" title="生成式摘要"></a>生成式摘要</h3><p>对于生成式摘要，采用Encode-Decoder模型结构，两者都为神经网络结构，输入原文经过编码器编码为向量，解码器从向量中提取关键信息，组合成生成式摘要。当然，还会在解码器中引入注意力机制，以解决在长序列摘要的生成时，个别字词重复出现的问题。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv48u37ovj30na07ajrp.jpg" alt=""><br>此外，在生成式摘要中，采用强化学习与深度学习相结合的学习方式，通过最优化词的联合概率分布，即MLE(最大似然)，有监督进行学习，在这里生成候选的摘要集。模型图如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv491xofqj30wp0fvgmk.jpg" alt=""><br>模型图中的ROUGE指标评价是不可导的，所以无法采用梯度下降的方式训练，这样我们就考虑强化学习，鼓励reward高的模型，通过给予反馈来更新模型。最终训练得到表现最好的模型。</p><h3 id="知识图谱关系抽取"><a href="#知识图谱关系抽取" class="headerlink" title="知识图谱关系抽取"></a>知识图谱关系抽取</h3><p>对于知识图谱的关系抽取，主要有两种方法，一个是基于参数共享的方法，对于输入句子通过共用的 word embedding 层，然后接双向的 LSTM 层来对输入进行编码。然后分别使用一个 LSTM 来进行命名实体识别 (NER)和一个 CNN 来进行关系分类(RC)；另一个是基于联合标注的方法，把原来涉及到序列标注任务和分类任务的关系抽取完全变成了一个序列标注问题。然后通过一个端对端的神经网络模型直接得到关系实体三元组。</p><p>如下图所示，我们有三类标签，分别是 ①单词在实体中的位置{B(begin),I(inside),E(end),S(single)}、②关系类型{CF,CP,…}和③关系角色{1(entity1),2(entity2)}，根据标签序列，将同样关系类型的实体合并成一个三元组作为最后的结果，如果一个句子包含一个以上同一类型的关系，那么就采用就近原则来进行配对。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv49cvihmj30t006v0th.jpg" alt=""></h2><h2 id="二、爱奇艺-方非-《爱奇艺视频信息流推荐的深度学习之路》"><a href="#二、爱奇艺-方非-《爱奇艺视频信息流推荐的深度学习之路》" class="headerlink" title="二、爱奇艺 方非 《爱奇艺视频信息流推荐的深度学习之路》"></a>二、爱奇艺 方非 《爱奇艺视频信息流推荐的深度学习之路》</h2><p>爱奇艺的短视频内容生态主要由OGC（Occupationally-generated Content，职业生产内容）、PGC（Professionally-generated Content，专业生产内容）、UGC（User-generated Content，用户生产内容），布局到PC端、移动端、TV端和VR，通过个性化推荐并使用feed流或者多列瀑布流进行高效内容分发，它的整个内容平台如下所示：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv49k53gaj30jp0860t5.jpg" alt=""><br>爱奇艺的深度学习架构设计主要分为深度召回模型和深度排序模型，</p><h3 id="深度召回模型"><a href="#深度召回模型" class="headerlink" title="深度召回模型"></a>深度召回模型</h3><p>召回，即给定上下文{ User， Context }，从所有推荐集合中过滤出具备推荐价值的内容{ Item List }，推荐价值使用兴趣相关性、热门、好友都在看、关注、LBS等等来定义。</p><p>协同过滤方法是基于用户行为来 预测/推荐 的一类算法，它基于这样一种假设：相似的视频更大概率会被同一个用户(相似的用户)看过；相似兴趣的用户会更大概率看同一个视频(相似的视频)；历史会重复发生。</p><p>基于近邻的协同过滤方法有Item-based CF和User-based CF，虽然实现简单，不依赖内容本身，能得到基本稳定可靠的结果，可解释性强；但是对稀疏性非常敏感，没有考虑行为顺序和上下文变化，难以加入其它特征，高维空间建模，难以和其他模型结合。</p><p>基于协同过滤思想的还有其他很多模型，分别如下</p><ul><li>Matrix Factorization ：SVD &amp; ALS</li><li>Bayesian Model</li><li>Classification &amp; Clustering</li><li>Embedding：Item2Vec、Neural CF</li><li>Deep Learning：RBM、MLP、LSTM、Attention</li></ul><p>概括一下基于Embedding和基于Deep Learning的协同过滤模型</p><h4 id="Item2Vec"><a href="#Item2Vec" class="headerlink" title="Item2Vec"></a>Item2Vec</h4><p>由Barkan O和Koenigstein N于2016年在论文《Item2Vec: Neural Item Embedding for Collaborative Filtering》中提出， 作者受nlp中运用embedding算法学习word的latent representation的启发，特别是参考了google发布的的word2vec（Skip-gram with Negative Sampling，SGNS），利用item-based CF 学习item在低维 latent space的 embedding representation，优化 item2item的计算。其模型结构如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv49uxdy9j30hp07uglu.jpg" alt=""><br>Item2vec中把用户浏览的商品集合等价于word2vec中的word的序列，即句子（忽略了商品序列空间信息spatial information） ，出现在同一个集合的商品对视为 positive。对于集合$w_{1}, w_{2}, …,w_{K}$，模型的目标函数是最大化平均的log概率：</p><script type="math/tex; mode=display">\frac{1}{K}\sum_{i=1}^{K}\sum_{j≠i}^K logp(w_j|w_i)</script><p>同word2vec，利用负采样，将$p(w_{j}|w_{j})$定义为：<script type="math/tex">P(I_j|I_i)=\sigma (\mu_i^T v_j) \prod _{k=1}^N\sigma (-\mu_i^Tv_k)</script><br>subsample的方式也类似于word2vec，丢弃某一个集合$w_i$的概率为：</p><script type="math/tex; mode=display">P(discard|w_i)=1-\sqrt{\frac{t}{f(w_i)}}</script><p>最终，利用SGD方法学习参数最大化目标函数，任意Item都能 得到U和V两个一定维度的向量，这样我们得到每个商品的embedding representation，商品之间可以两两计算cosine相似度，即为商品的相似度。这个模型的缺点是相似度的计算只利用到了item的共现信息，忽略了user行为序列信息，且没有建模用户对不同item的喜欢程度高低。</p><h4 id="Neural-CF"><a href="#Neural-CF" class="headerlink" title="Neural CF"></a>Neural CF</h4><p>Xiangnan He , Lizi Liao , Hanwang Zhang , Liqiang Nie , Xia Hu , Tat-Seng Chua, Neural Collaborative Filtering, Proceedings of the 26th International Conference on World Wide Web, April 03-07, 2017, Perth, Australia</p><p>基于MLP的协同过滤模型<br>模型结构如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4a6wvlij30gu0a874o.jpg" alt=""><br>这个模型增加了网络深度，但缺乏时序性考虑，没有其他的特征信息。</p><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>基于LSTM的协同过滤模型，加入时序性的考虑，但缺乏对历史项重要性的学习，且没有其他的特征信息。模型结构如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4ad06w9j30kk0cat9j.jpg" alt=""></p><h4 id="LSTM-Attention"><a href="#LSTM-Attention" class="headerlink" title="LSTM + Attention"></a>LSTM + Attention</h4><p>基于LSTM + Attention的协同过滤模型加入时序性考虑，且在LSTM的基础上加入对历史项Attention的学习，但还是存在没有其他的特征信息的问题。模型结构如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4al7sboj30l50e7dgz.jpg" alt=""></p><h4 id="深度召回模型-1"><a href="#深度召回模型-1" class="headerlink" title="深度召回模型"></a>深度召回模型</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4asbbugj30nm09pq3q.jpg" alt=""></p><h3 id="深度排序模型"><a href="#深度排序模型" class="headerlink" title="深度排序模型"></a>深度排序模型</h3><p>排序算法，即从召回算法选取的内容集合中，找到最符合推荐预定目标的K个结果。主要有三种，分别是Pointwise、Pairwise、Listwise。<br>排序模型的四个要素：目标、样本、特征和模型。</p><ul><li>目标</li></ul><p>最终的最大化目标有以下这些，目标有长期与短期之分，也有主次之分，每一个目标都有各自的优化偏重：</p><div class="table-container"><table><thead><tr><th>目标</th><th>特点</th></tr></thead><tbody><tr><td>点击率</td><td>简单直接，偏短时长</td></tr><tr><td>时长</td><td>更能反应用户的兴趣，偏长时长</td></tr><tr><td>互动</td><td>社交属性，稀疏</td></tr><tr><td>关注订阅</td><td>社交属性，内容生态，稀疏</td></tr><tr><td>留存</td><td>最接近用户满意度，直接优化难度高</td></tr></tbody></table></div><p>当然还会受到许多约束，诸如内容价值观、多样性、时效性、长尾分发、标题党、反作弊等</p><ul><li>样本</li></ul><p>然后根据目标仔细设计样本，将点击、点赞、评论、转发、关注、留存等定义为正样本，把展示不点击、不喜欢、负面评论等定义为负样本，并根据播放时长、反馈类型、样本有效性对样本进行加权。此外，处于样本有效性的考虑，会将无效样本判断过滤掉</p><ul><li>特征</li></ul><p>关于特征，根据特征向量的特点可分为三种：稠密特征、稀疏特征和Embedding特征。</p><div class="table-container"><table><thead><tr><th>稠密特征</th><th>稀疏特征</th><th>Embedding特征</th></tr></thead><tbody><tr><td>点击率</td><td>视频 ID</td><td>标题 Embedding</td></tr><tr><td>播放量</td><td>视频标签</td><td>Item2Vec Embedding</td></tr><tr><td>播放时长</td><td>用户标签</td><td>图片 Embedding</td></tr><tr><td>年龄</td><td>订阅作者 ID</td><td>社交 Embedding</td></tr><tr><td>性别</td><td>LBS</td><td>End2End Embedding</td></tr></tbody></table></div><ul><li>模型</li></ul><p>关于模型这一块，已经有很成熟的模型可以使用，主要有以下几种：LR、FM、GBDT、GBDT + FM(LR)、DNN+FM<br>（DeepFM: A Factorization-Machine based Neural Network for CTR Prediction）</p><p>这里使用的是基于Wide And Deep思想的多目标分类，模型结构如下：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4b7au90j30s40f30ts.jpg" alt=""></p><p>最后是整个排序服务平台的搭建，其组成部分如下所示：</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4bdpg5pj30yw09mt9t.jpg" alt=""></h2><h2 id="三、优酷-刘尚堃-《深度学习在视频搜索中的应用》"><a href="#三、优酷-刘尚堃-《深度学习在视频搜索中的应用》" class="headerlink" title="三、优酷   刘尚堃 《深度学习在视频搜索中的应用》"></a>三、优酷   刘尚堃 《深度学习在视频搜索中的应用》</h2><h3 id="视频搜索的挑战"><a href="#视频搜索的挑战" class="headerlink" title="视频搜索的挑战"></a>视频搜索的挑战</h3><p>视频搜索中存在以下这些挑战：</p><ul><li>非结构化、无组织，这就提升了召回难度</li><li>短文本、信息不充分，带来语义上的困难</li><li>海量短视频，给用户选择带来困难</li></ul><p>针对这些挑战，提出了一些利用深度学习来解决问题的对策，分别是</p><ul><li>基于视频内容理解的召回</li><li>语义模型、语义表征</li><li>个性化表征</li></ul><h3 id="视频内容理解—召回"><a href="#视频内容理解—召回" class="headerlink" title="视频内容理解—召回"></a>视频内容理解—召回</h3><h4 id="基于类目标签的召回"><a href="#基于类目标签的召回" class="headerlink" title="基于类目标签的召回"></a>基于类目标签的召回</h4><p>输入任意的视频，通过内容理解的方法对视频进行类目和标签的预测。采用的方法是CNN+LSTM的端到端预测方法。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4bnse3lj30j104g74d.jpg" alt=""></p><h4 id="基于事件-场景的召回"><a href="#基于事件-场景的召回" class="headerlink" title="基于事件/场景的召回"></a>基于事件/场景的召回</h4><p>给定不定长视频，定位感兴趣行为发生的时间段并给出对应行为类标。采用的方法是Convolution 3D+Gated Recurrent Unit(GRU)算法，结合Single Shot Detector（SSD）框架实现行为检测功能。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4btl0sfj30hz04l0sx.jpg" alt=""></p><h4 id="基于物体-人物的召回"><a href="#基于物体-人物的召回" class="headerlink" title="基于物体/人物的召回"></a>基于物体/人物的召回</h4><p>定位和识别视频中的特定目标，并在目标生命周期内进行跟踪。采用的方法是Region fully convolution network（R-FCN）的深度学习框架，对于小物体在feature map进行了优化；跟踪采用DCF框架，结合颜色模型，并使用BACF进行候选区域扩充。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4c8h61hj30ho05574j.jpg" alt=""></p><h4 id="视频智能封面图"><a href="#视频智能封面图" class="headerlink" title="视频智能封面图"></a>视频智能封面图</h4><p>UGC视频智能缩略图，目的是通过对视频进行结构化分析，对关键帧、视频镜头进行筛选和排序，选择最优的关键帧、关键片段来作为视频的展示。采用的方法是用关键帧提取+MMR优化+美学评分等方法，选择视频中最优关键帧作为该视频的首图。</p><h3 id="语义搜索—语义表征"><a href="#语义搜索—语义表征" class="headerlink" title="语义搜索—语义表征"></a>语义搜索—语义表征</h3><p>人工审核标注ground truth，训练集测试集比例为7：3，加入语义特征后，NDCG提升1%的绝对值。</p><ul><li>固定数据尝试不同的模型</li></ul><div class="table-container"><table><thead><tr><th>模型</th><th>NDCG</th></tr></thead><tbody><tr><td>双向LSTM+Attention</td><td>达到0.9以上</td></tr><tr><td>BiGRU dropout</td><td>达到0.8以上</td></tr></tbody></table></div><ul><li>固定模型尝试term embedding初始化方式</li></ul><div class="table-container"><table><thead><tr><th>模型</th><th>初始化方式</th><th>长尾query NDCG</th></tr></thead><tbody><tr><td>Bi-LSTM+Attention</td><td>随机</td><td>baseline</td></tr><tr><td>Bi-LSTM+Attention</td><td>embedding</td><td>低于baseline 1%</td></tr><tr><td>Bi-LSTM+Attention</td><td>UC/豆瓣的FastText Embedding</td><td>高于baseline 1%</td></tr></tbody></table></div><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4cjtimvj30gk0ai74s.jpg" alt=""></p><ul><li><p>用户体验优化：</p><ul><li>在长尾query和语义层面实现了特征增益，在长尾query相关性上有较大改善</li><li>ground truth测试集NDCG提升了1%</li></ul></li><li><p>技术创新突破</p><ul><li>基于FastText无监督embedding</li><li>细粒度+字切分 优酷title语料覆盖度99%</li><li>训练数据集 billion级别，模型参数量千万级别</li><li>Bi-LSTM+Attention</li><li>基于pai-tensorflow的分布式训练</li></ul></li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4cska39j30ha0hyt9t.jpg" alt="">  </p><h3 id="排序—个性化表征"><a href="#排序—个性化表征" class="headerlink" title="排序—个性化表征"></a>排序—个性化表征</h3><p>特征按照field进行组织，按照特征重要性和关联性进行分域，分为query field、user field、video field、id field、统计field、用户观看序列、标签兴趣、文本等，形成超高维的稀疏编码来表征独立个体，使得深度特征的组合表达能力达到极致，其模型结构如下：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4d6ulivj30t80fgq3p.jpg" alt=""></p><p>但这样对在线计算形成了挑战，特征维度高，模型存储空间大，离线训练计算时间成本高，在线实现资源占用高，前向网络计算不能满足RT的要求。就用了一系列的技术，诸如随机编码、挂靠编码、抽样技术等。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4ddxquaj30io0ejgmk.jpg" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4dj8jdbj30qr0hqwfi.jpg" alt=""></p><h2 id="百度-孙宇-《神经网络语义匹配技术及其百度搜索实践》"><a href="#百度-孙宇-《神经网络语义匹配技术及其百度搜索实践》" class="headerlink" title="百度 孙宇 《神经网络语义匹配技术及其百度搜索实践》"></a>百度 孙宇 《神经网络语义匹配技术及其百度搜索实践》</h2><h2 id="腾讯-苏函晶-《深度学习在广告投放中的应用》"><a href="#腾讯-苏函晶-《深度学习在广告投放中的应用》" class="headerlink" title="腾讯 苏函晶 《深度学习在广告投放中的应用》"></a>腾讯 苏函晶 《深度学习在广告投放中的应用》</h2><h2 id="PayPal-张彭善-《构建高效的风控机器学习平台》"><a href="#PayPal-张彭善-《构建高效的风控机器学习平台》" class="headerlink" title="PayPal 张彭善 《构建高效的风控机器学习平台》"></a>PayPal 张彭善 《构建高效的风控机器学习平台》</h2><h2 id="新浪微博-刘博-《深度学习在微博信息流排序的应用》"><a href="#新浪微博-刘博-《深度学习在微博信息流排序的应用》" class="headerlink" title="新浪微博 刘博 《深度学习在微博信息流排序的应用》"></a>新浪微博 刘博 《深度学习在微博信息流排序的应用》</h2><h2 id="腾讯-王辉-《小Q机器人的诞生之路》"><a href="#腾讯-王辉-《小Q机器人的诞生之路》" class="headerlink" title="腾讯 王辉 《小Q机器人的诞生之路》"></a>腾讯 王辉 《小Q机器人的诞生之路》</h2><h2 id="爱因互动-吴金龙-《深度学习在对话机器人中的应用》"><a href="#爱因互动-吴金龙-《深度学习在对话机器人中的应用》" class="headerlink" title="爱因互动 吴金龙 《深度学习在对话机器人中的应用》"></a>爱因互动 吴金龙 《深度学习在对话机器人中的应用》</h2><h2 id="阿里-黄丕培-《万物皆向量—双十一淘宝首页个性化推荐的秘密》"><a href="#阿里-黄丕培-《万物皆向量—双十一淘宝首页个性化推荐的秘密》" class="headerlink" title="阿里 黄丕培 《万物皆向量—双十一淘宝首页个性化推荐的秘密》"></a>阿里 黄丕培 《万物皆向量—双十一淘宝首页个性化推荐的秘密》</h2><h2 id="商汤科技-陈宇恒-《未来都市—智慧城市与基于深度学习的机器视觉》"><a href="#商汤科技-陈宇恒-《未来都市—智慧城市与基于深度学习的机器视觉》" class="headerlink" title="商汤科技 陈宇恒 《未来都市—智慧城市与基于深度学习的机器视觉》"></a>商汤科技 陈宇恒 《未来都市—智慧城市与基于深度学习的机器视觉》</h2><h2 id="百分点-黄伟-《AI认知技术帮助公共安全行业》"><a href="#百分点-黄伟-《AI认知技术帮助公共安全行业》" class="headerlink" title="百分点 黄伟 《AI认知技术帮助公共安全行业》"></a>百分点 黄伟 《AI认知技术帮助公共安全行业》</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参加了历时三天的QCon北京的技术分享大会，一个码农云集的盛会，各大厂拿出自己的看家技术，真的是干货满满。特别感谢金主爸爸给的免费通票和树苗苗姐姐的联络，让我这样的小白加穷学生可以有机会参加这样规模的大会，还加了很多业界大佬的微信，见到了之前膜拜已久的洪强宁老师和张俊林老师，技术交流真的获益匪浅，扩宽了眼界，看到了自己的不足，有很多不懂的地方需要自己慢慢去补课。&lt;/p&gt;
&lt;p&gt;下面是一些个人收获比较大的分享内容记录和整理，之后还会慢慢更新。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="自然语言处理" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="视频推荐" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8E%A8%E8%8D%90/"/>
    
      <category term="视频搜索" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%90%9C%E7%B4%A2/"/>
    
      <category term="语义匹配" scheme="http://yoursite.com/tags/%E8%AF%AD%E4%B9%89%E5%8C%B9%E9%85%8D/"/>
    
      <category term="广告投放" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A%E6%8A%95%E6%94%BE/"/>
    
      <category term="风险控制" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6/"/>
    
      <category term="信息流排序" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E6%B5%81%E6%8E%92%E5%BA%8F/"/>
    
      <category term="对话机器人" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%AF%9D%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
      <category term="机器视觉" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
      <category term="公共安全" scheme="http://yoursite.com/tags/%E5%85%AC%E5%85%B1%E5%AE%89%E5%85%A8/"/>
    
      <category term="个性化推荐" scheme="http://yoursite.com/tags/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>人大应统部落（3）：2018年中国人民大学应用统计专业课真题与解析</title>
    <link href="http://yoursite.com/2018/04/05/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD%EF%BC%883%EF%BC%89%EF%BC%9A2018%E5%B9%B4%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%94%A8%E7%BB%9F%E8%AE%A1%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%9C%9F%E9%A2%98%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/05/人大应统部落（3）：2018年人大应用统计专业课真题及解析/</id>
    <published>2018-04-05T02:19:10.000Z</published>
    <updated>2018-11-03T16:08:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年中国人民大学应用统计初试专业课真题及详细解答，文末附专业课复试笔试真题回忆版。</p><p>如有疑问或建议，可添加微信：zhanghua63170140</p><a id="more"></a><h3 id="第一题【10分】"><a href="#第一题【10分】" class="headerlink" title="第一题【10分】"></a>第一题【10分】</h3><p>1.1 请说明雷达图和箱线图的基本要点。<br>1.2 下面的数据集为8个同学的数学、语文和英语的成绩，如何利用雷达图和箱线图来描述这个数据集？</p><div class="table-container"><table><thead><tr><th>姓名</th><th>数学</th><th>语文</th><th>英语</th></tr></thead><tbody><tr><td>甲</td><td>83</td><td>86</td><td>82</td></tr><tr><td>乙</td><td>93</td><td>89</td><td>93</td></tr><tr><td>丙</td><td>85</td><td>79</td><td>90</td></tr><tr><td>丁</td><td>79</td><td>81</td><td>75</td></tr><tr><td>戊</td><td>79</td><td>81</td><td>75</td></tr><tr><td>己</td><td>75</td><td>70</td><td>94</td></tr><tr><td>庚</td><td>69</td><td>62</td><td>94</td></tr><tr><td>辛</td><td>67</td><td>62</td><td>94</td></tr></tbody></table></div><hr><p>【解答】</p><blockquote><p>1.1 </p></blockquote><p>箱线图由一组数据的最大值、最小值、中位数、上下四分位数这五个特征值绘制而成。不仅反映一组数据分布的特征，如分布是否对称、是否存在离群点等，还可以对多组数据的分布特征进行比较。</p><p>雷达图，也称为蜘蛛图，是展示多个变量的常用方法，主要用于比较研究多个样本的相似程度。</p><blockquote><p>1.2 </p></blockquote><p>以数学组数据为例绘制箱线图，步骤如下：</p><ol><li><p>画一只箱子，箱子两端分别位于上四分位数和下四分位数。四分位数是指一组数据排序后（67 69 75 79 79 83 85 93）处于$25\%$和$75\%$位置上的值，对于数学组数据来说,下四分位数$Q_1 = 69$以及上四分位数$Q_3 = 83$。这个箱子包括中间$50\%$的数据。</p></li><li><p>在箱子中位数的位置画一条垂直线，中位数是指一组数据排序后处于中间位置上的变量值。对于数学组数据来说，中位数$M_e=79$。</p></li><li><p>用四分位数全距$IQR = Q_3 − Q_1$，确定限制线的位置。箱线图的上、下限制线分别在比$Q_1$低$1.5×IQR$和比$Q_3$高$1.5×IQR$的位置上。对于数学组数据来说，$IQR = Q_3 − Q_1 = 83-69 = 14$。因此，限制线的位置在$69− 1.5×14 = 48$和$83 + 1.5×14 =104$处。两条限制线以外的数据可以认为是异常值。但一般限制线不绘制在图上。</p></li><li><p>绘制触须线。触须线从箱子两端开始绘制，直至最小值和最大值。因此，数学组数据的触须线分别在67和93处结束。</p></li><li><p>绘制异常值。即处于内限以外位置的点。</p></li></ol><p>以此类推，绘制语文组和英语组的箱线图，得到的箱线图如下：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3acrk14j30a906zmx9.jpg" alt=""></p><p>其中中位数位置代表平均水平；箱子长短代表离散程度；分布形状可以看出是否对称。既可以研究单独分析组内数据，也可以对语文、数学、英语三组进行比较研究。我们可以看到，八位同学的英语成绩平均水平最高，数学和语文成绩的离散程度较高，三组成绩都不存在异常值。</p><p>雷达图从一个点出发，找到八条射线分别代表八位同学。八个变量的数据点链接起来，围成一个区域，三门课程围成三个区域，研究语文、数学、英语三组成绩的相关比较。从图中可知，多位同学英语成绩的高于其他两门，数学和语文成绩都比较接近。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvbo12p5rj30bo08aq2y.jpg" alt=""><br>也可以找三条射线，分别代表数学英语和语文三个变量，比较每个学生三门课的成绩。乙同学的三门成绩都比较高，辛同学的三门成绩都较低，需要加倍努力哦。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvbomltmmj30bo08d0sp.jpg" alt=""></p><h3 id="第二题【20分】"><a href="#第二题【20分】" class="headerlink" title="第二题【20分】"></a>第二题【20分】</h3><p>2.1 说明在方差已知的条件下，正态总体均值区间估计的宽度与样本量的关系。</p><p>2.2 现在有一组来自正态总体的随机样本，可以由此得到在方差已知和方差未知两种条件下的置信区间，请分析这两个置信区间的中点和宽度的异同。</p><p>【解答】</p><blockquote><p>2.1 </p></blockquote><p>在方差已知的条件下，正态总体均值区间估计的宽度随样本量增大而减小。</p><p>在方差已知的条件下，总体分布为正态分布的均值区间估计(无论是大样本还是小样本)为</p><script type="math/tex; mode=display">\bar {x}±z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}</script><p>其中$\bar {x}-z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}$称为置信下限，$\bar {x}+z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}} $称为置信上限;$a$是事先所确定的一个概率值，也被称为风险值，是总体均值不包括在置信区间的概率;$1-a$称为置信水平; 是标准正态分布右侧面积为$\frac{a}{2}$的 Z 值;$z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}$是估计总体均值的估计误差。 总体均值的置信区间由两部分组成:点估计值和描述估计量精度的±值，这个±值称为估计误差。</p><p>由估计的区间可知，当样本量$n$增大时，区间估计的宽度减小。</p><blockquote><p>2.2 </p></blockquote><p> 如果是大样本的情况下，方差已知的公式为$\bar {x}±z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}$ ，方差未知的公式为$\bar {x}±z_{\frac{a}{2}}\frac{s}{\sqrt{n}}$ 。两个置信区间的中点相同，但是方差未知的情况下是用样本方差替代总体方差，宽度存在差异。</p><p> 如果在小样本的情况下，方差已知的公式为$\bar {x}±z_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}$，方差未知的公式为$\bar {x}±t_{\frac{a}{2}}\frac{\sigma}{\sqrt{n}}$ 。两个置信区间的中点相同，但是方差未知的置信区间的宽度会更宽一些。因为选择的t分布与正态分布形状接近，但是两侧的尾端会更宽一些，所构造的置信区间宽度也会更宽。随样本量增大，宽度差异会缩小。</p><h3 id="第三题【20分】"><a href="#第三题【20分】" class="headerlink" title="第三题【20分】"></a>第三题【20分】</h3><p>3.1 给出一个列联表，写出可以描述上述数据的所有的图形，并说明这些图形的用途，<br>3.2 写出可以分析上述数据所有可能的方法，并说明用途。</p><blockquote><p>3.1 </p></blockquote><p>对于分类型数据可以选择以下图形进行描述性统计分析</p><ol><li>复式条形图：用宽度相同的条形来表述数据的多少，观察不同类型数据的分布状况。比条形图更便于比较分析</li><li>帕累托图：按各类别出现的频数多少排序后绘制的条形图，通过排序后，容易看出哪类数据出现的多，哪类出现的少</li><li>复式饼图：用圆形及圆内扇形的角度来表示数值大小的图形，用于表示各类别的频数占全部频数的比例，适用于研究结构性问题。比之饼图更适用于展示两个或者多个类别变量的构成比较。</li><li>环形图：显示多个样本各类别频数所占的相应比例，有利于构成的比较研究</li></ol><blockquote><p>3.2 </p></blockquote><p>因为以上列联表中有两个分类变量，我们关心这两者是否有关联，可以进行独立性检验，也即进行列联分析。独立性检验就是分析列联表中行变量与列变量是否相互独立，也就是检验性别分布与满意度之间是否存在依赖关系。具体分析步骤如下： </p><ol><li>提出原假设和备择假设<br>H0:性别与满意度之间是独立的<br>H1：性别与满意度之间不独立</li><li>计算检验统计量<br>计算$f_o-f)e$，其中$f_e=\frac{RT}{n}×\frac{CT}{n}×n=\frac{RT×CT}{n}$<br>计算$(f_o-f_e)^2$<br>计算$\frac{(f_o-f_e)^2}{f_e}$<br>计算$\sum\frac{(f_o-f_e)^2}{f_e}$</li><li>做出决策<br>若$\chi ^2&gt;\chi_a^2$，则拒绝原假设，认为性别与满意度两者之间存在依赖关系。<br>如果$\chi ^2&lt;\chi_a^2$，则不拒绝原假设，认为两者之间不存在依赖关系。</li></ol><p>若拒绝原假设，可继续使用C相关系数或V相关系数测定两者之间的相关关系到底为多少。 通过上面的方法，可以判断两个分类变量是否独立，而当拒绝原假设后，我们可以接着运用对应分析方法来了解两个分类变量即分类变量各个状态之间的相关关系。对应分析利用降维的思想进行简化数据结构，同时对数据表中的行与列进行处理，可把样本点和变量点同时反映到相同的因子轴上，用低维图形简洁明了地揭示两个分类变量之间及分类变量各状态之间的相关关系。</p><h3 id="第四题【20分】"><a href="#第四题【20分】" class="headerlink" title="第四题【20分】"></a>第四题【20分】</h3><p>设因变量为$y$ ,自变量为$x_1,x_2,x_3·····x_k$，写出建立多元线性回归建模的基本思路。</p><p>【解答】</p><ol><li>提出因变量和自变量：首先根据具体问题选择合适的因变量，然后选择合理的自变量和结合问题的实际意义和专业理论知识，运用逐步回归法等选择自变量。</li><li>收集整理数据：这是一个重要环节，他直接影响模型的质量。 </li><li>做相关分析，构造多元线性理论回归模型：用SPSS软件计算增广相关阵。 </li><li>用软件计算，输出计算结果（参数估计有最小二乘法和极大似然法等方法）：用SPSS软件对原始数据作回归分析。</li><li>回归诊断：（1）诊断基本假定是否成立（2）相关分析：由复相关系数或决定系数判断回归方程是否显著（3）方差分析表：判断回归方程是否显著（4）回归方程系数显著性检验是否显著（5）检验异常值：判断是否符合实际意义 </li><li>若未通过回归诊断，返回第一步，否则可进入回归应用，主要应用于结构分析、预测和控制三个方面。 </li></ol><h3 id="第五题【20分】"><a href="#第五题【20分】" class="headerlink" title="第五题【20分】"></a>第五题【20分】</h3><p>5.1 方差分析有哪些基本假定？</p><p>5.2 简要说明检验这些假定的方法。</p><p>【解答】</p><blockquote><p>5.1 </p></blockquote><p>方差分析有三大假定</p><ol><li>正态性:要求每个处理所对应的总体都应服从正态分布</li><li>方差齐性：要求各处理的总体方差必须想等</li><li>独立性：要求每个样本数据是来自不同处理的独立样本</li></ol><blockquote><p>5.2 </p></blockquote><ol><li><p>正态性检验:检验正态性可以选择图示法去绘制因变量的正态概率图。包括PP图、qq图或者绘制箱线图、直方图、茎叶图。</p><ul><li>其中绘制箱线图、直方图、茎叶图观察与正态曲线是否接近；QQ图是根据观测值的实际分位数与理论的分位数绘制的；PP图是根据观测数据的累积概率与理论分布的累积概率的符合程度绘制的；检验正态性还包括检验法包括Shapiro-Wilk和K-S正态性检验，其中Shapiro-Wilk适用于小样本。K-S既可以用于大样本也可以用于小样本</li></ul></li><li><p>方差齐性检验检验：方差齐性的图示法包括箱线图和残差图。检验法包括Bartlett检验和Levene检验等</p></li><li>独立性检验：独立性可以在实验设计之前予以确定，不需要检验<h3 id="第六题【20分】"><a href="#第六题【20分】" class="headerlink" title="第六题【20分】"></a>第六题【20分】</h3>在同一个概率空间中是否存在三个随机事件$A,B,C$使得同时成立下面三个不等式：<script type="math/tex; mode=display">P(A|B,C)≤P(A|\bar {B},C) \\\ P(A|B,\bar {C})<P(A|\bar {B}, \bar {C})\\\ P(A|B)>P(A|\bar B)</script>如果存在，请列举一个例子；若不存在，证明你的结论。</li></ol><p>【解答】</p><p>存在。该题实际是考察辛普森悖论，大家可以自行了解一下。作如下假设：</p><p>A事件：被录取<br>B事件：是男生<br>C事件：左撇子</p><p> B事件和C事件同时发生，即是男生，左撇子有1人<br> B事件发生，C事件不发生，即是男生，右撇子有4人<br> B事件不发生，C事件发生，即是女生，左撇子的有4人<br> B事件不发生，C事件不发生，即是女生，右撇子的有1人</p><script type="math/tex; mode=display">P(A|BC)=0</script><script type="math/tex; mode=display">P(A|B\bar C)=\frac{3}{4}</script><script type="math/tex; mode=display">P(A|\bar BC)=\frac{1}{4}</script><script type="math/tex; mode=display">P(A|\bar B \bar C)=1</script><div class="table-container"><table><thead><tr><th></th><th>男生B</th><th>女生$\bar B$</th></tr></thead><tbody><tr><td>左撇子C</td><td>1(录取0人)</td><td>4(录取1人)</td></tr><tr><td>右撇子$\bar C$</td><td>4（录取3人）</td><td>1(录取1人)</td></tr></tbody></table></div><p> 那么</p><script type="math/tex; mode=display">P(A|B)=\frac{3}{5}</script><script type="math/tex; mode=display">P(A|\bar B)=\frac {2}{5}</script><p> 所以</p><script type="math/tex; mode=display">P(A|B)>P(A|\bar B)</script><h3 id="第七题【20分】"><a href="#第七题【20分】" class="headerlink" title="第七题【20分】"></a>第七题【20分】</h3><p>设$x_1,x_2······,x_n$为一个来自均值为$\mu$，方差为$\sigma^2$的分布的样本，$\mu$和$\sigma ^2$未知，考虑均值为$\mu$的线性无偏估计类</p><script type="math/tex; mode=display">L=\{T\left(X\right)：T\left(X\right)=\sum_{i=1}^n{x_i}.c_i \}  \\\ 其中c_i是常数</script><p>求出$L$中$T(X)$为$\mu$的无偏估计的充要条件，并求出无偏估计类中方差一致最小的估计。</p><p>【解答】</p><script type="math/tex; mode=display">E[T(X)]=E(\sum_{i=1}^n x_ic_i)\\=\sum_{i=1}^nEx_ic_i=\sum_{i=1}^nc_i Ex_i\\=\mu \sum_{i=1}^nc_i=\mu</script><p>所以$\sum_{i=1}^nc_i=1$</p><script type="math/tex; mode=display">var[T(X)]=\sum_{i=1}^nc_i^2var(x_i)\\=\sigma ^2 \sum_{i=1}^nc_i^2≥\frac{\sigma^2}{n}</script><p>当且仅当$c_i=\frac{1}{n}, \qquad i=1,2，····，n$时,等号成立，即$var[T(X)]=\frac{1}{n}\sigma^2$<br>所以无偏估计类方差一致最小的估计为$T(X)=\frac{1}{n}\sum_{i=1}^n x_i$</p><h3 id="第八题【10分】"><a href="#第八题【10分】" class="headerlink" title="第八题【10分】"></a>第八题【10分】</h3><p>设$X$是一个正值随机变量，方差有界，证明：对于$\forall 0&lt;\lambda &lt;1$, 有</p><script type="math/tex; mode=display">P(X>\lambda EX)\geqslant\left(1-\lambda\right)^2\frac{\left(EX\right)^2}{EX^2}</script><p>【解题】<br>要证明$P(X&gt;\lambda EX)\quad \geqslant\quad { (1-\lambda ) }^{ 2 }\frac { { (EX) }^{ 2 } }{ E{ X }^{ 2 } } $</p><p>即证明$P(X&gt;\lambda EX)·{ EX }^{ 2 }≥\quad { (1-\lambda ) }^{ 2 }·{ (EX) }^{ 2 }$</p><p>不等式左边，根据示性函数$I(X-Y)=\begin{cases} 1\quad X-Y&gt;0 \\ 0\quad X-Y≤0 \end{cases}$和定义$P(X&gt;Y)=E[I(X&gt;Y)]$可得</p><script type="math/tex; mode=display">P(X>\lambda EX)·EX^2 = E[I(X>\lambda EX)]·EX^2 =E[I^2(X>\lambda EX)]·EX^2  \qquad ①</script><p>根据柯西不等式$(EXY)^2≤EX^2·EY^2$，得</p><script type="math/tex; mode=display">①≥{E[X·I(X>\lambda EX)]}^2 \qquad ②</script><p>又因为$X·I(X&gt;\lambda EX)=\begin{cases} X·1\quad X&gt;\lambda EX\quad  \\ X·0\quad X≤\lambda EX \end{cases}≥X-\lambda EX$<br>所以</p><script type="math/tex; mode=display">②≥[E(X-\lambda EX)]^2=(EX-\lambda EX)^2=(1-\lambda)^2(EX)^2  \qquad ③</script><p>综合①和③，得到</p><script type="math/tex; mode=display">P\left\{X>\lambda EX\right\}\geqslant\left(1-\lambda\right)^2\frac{\left(EX\right)^2}{EX^2}</script><h3 id="第九题【10分】"><a href="#第九题【10分】" class="headerlink" title="第九题【10分】"></a>第九题【10分】</h3><p> 设地区生产总之（亿元）为因变量，固定资产投资（亿元）、社会消费品零售总额（亿元）、出口总额（亿美元）、地方财政收入（亿元）、电力消费量（亿千瓦时）、居民消费水平（元）为自变量，根据31个样本数据得到回归结果如下：</p><p>Coefficients </p><div class="table-container"><table><thead><tr><th></th><th>Estimate</th><th>Std. Error</th><th>t value</th><th>Pr(t)</th><th></th></tr></thead><tbody><tr><td></td><td>-2.377 e+03</td><td>1.166 e+03</td><td>-2.038</td><td>0.05270</td><td></td></tr><tr><td>固定资产投资</td><td>4.504 e-01</td><td>8.166 e-02</td><td>5.515</td><td>1.14 e-05</td><td><em>*</em></td></tr><tr><td>社会消费品零售总额</td><td>1.110 e+00</td><td>1.572 e-01</td><td>7.060</td><td>2.68 e-0.7</td><td><em>*</em></td></tr><tr><td>出口总额</td><td>1.887 e+01</td><td>6.379 e+00</td><td>2.958</td><td>0.00686</td><td>**</td></tr><tr><td>地方财政收入</td><td>9.596 e-01</td><td>6.959 e-01</td><td>1.379</td><td>0.18061</td><td></td></tr><tr><td>电力消费量</td><td>6.683 e-01</td><td>5.671 e-01</td><td>1.178</td><td>0.25016</td><td></td></tr><tr><td>居民消费水平</td><td>1.194 e-01</td><td>6.949 e-02</td><td>1.718</td><td>0.09868</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Residual standard error:</th><th>1526</th><th>自由度</th><th>24</th></tr></thead><tbody><tr><td>Multiple R-Squared:</td><td>0.9944</td><td>Adjusted R-squared</td><td>0.993</td></tr><tr><td>F -statistic:</td><td>708.8</td><td>P-Value</td><td>&lt; 2.2 e-16</td></tr></tbody></table></div><p>对该回归模型进行综合分析，评价是否需要改进，并给出思路。【10分】</p><p>【解答】</p><ol><li>写出模型,并对每个回归系数进行解释</li><li>通过了f检验认为因变量与自变量之间线性关系显著</li><li>t检验回归系数是否显著，拒绝原假设时，表明回归系数显著</li><li>调整的多重判定系数R2=0.993，表示在用样本量和模型中自变量的个数调整后，因变量y的总变差中被多个自变量多共同解释的比例为99.3%</li><li>通过回归系数的显著性检验和回归系数的正负号判定可能存在多重共线性。还可以计算容忍度$1-R^2$、方差扩大因子$VIF=\frac{1}{1-R^2}$和特征根进一步判断，容忍度越小，多重共线性越严重，容忍度小于1时，存在严重多重共线性，VIF越大，多重共线性越严重，VIF大于10时，存在严重多重共线性；或者对模型中各对自变量之间的相关系数进行显著性检验，通常认为大于0.8高度相关，0.5-0.8是较强的相关关系</li><li>处理多重共线性可以选择以下方法</li></ol><p>a）增加样本容量<br>b）自变量筛选：根据容忍度和方差因子进行筛选；向前选择；向后剔除；逐步回归</p><ul><li>前进法：  思想是变量由少到多，每次增加一个，直到没有可以引入的变量为止</li><li>后退法：首先用全部m个变量建立一个回归方程，然后在这m个变量中选择一个最不重要的变量，将它从方程中剔除</li><li>逐步回归：思想是有进有出。做法是将变量一个一个引入，每引入一个自变量后，对已选入的变量要进行逐个检验，当原引入的变量优于后面变量的引入而变得不在显著时，要将其剔除</li></ul><p>c）放弃无偏估计选择有偏回归（岭回归；主成分回归；偏最小二乘回归）</p><ul><li>岭回归</li><li>主成分回归: 构造前M个主成分Z1,…,Zm,然后以这些主成分作为预测变量，用最小二乘拟合线性回归模型</li><li>偏最小二乘：将原始变量的线性组合Z1,…,Zm作为新的变量集，然后用这M个新变量拟合最小二乘模型</li></ul><h3 id="专业课复试笔试真题回忆版"><a href="#专业课复试笔试真题回忆版" class="headerlink" title="专业课复试笔试真题回忆版"></a>专业课复试笔试真题回忆版</h3><ol><li>给定30个数值型数据，请问如何检验其正态性？</li><li>给出40个男女生考试分数，其中男生25人，女生15人，问男女生考试分数是否有显著差异，说出检验思路以及该方法的假设条件。</li><li>多元线性回归模型的基本假定。</li><li>从获取数据到得出分析结果的过程中会出现误差和干扰，举例说出几种误差以及解决办法。</li><li>有些统计量中分母会出现总体或样本的方差或标准差，从z检验、t检验和方差分析的角度思考，尽量用文字表述你对这种情况的理解</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年中国人民大学应用统计初试专业课真题及详细解答，文末附专业课复试笔试真题回忆版。&lt;/p&gt;
&lt;p&gt;如有疑问或建议，可添加微信：zhanghua63170140&lt;/p&gt;
    
    </summary>
    
      <category term="人大应统部落" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD/"/>
    
    
      <category term="人大应统" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F/"/>
    
      <category term="考研真题" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>人大应统部落（2）：2018年人大应统专业硕士经验贴合集</title>
    <link href="http://yoursite.com/2018/04/04/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD%EF%BC%882%EF%BC%89%EF%BC%9A2018%E7%BA%A7%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%B0%91%E5%A4%A7%E5%AD%A6%E5%BA%94%E7%94%A8%E7%BB%9F%E8%AE%A1%E4%B8%93%E4%B8%9A%E7%A1%95%E5%A3%AB%E7%BB%8F%E9%AA%8C%E8%B4%B4%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2018/04/04/人大应统部落（2）：2018级中国人民大学应用统计专业硕士经验贴合集/</id>
    <published>2018-04-04T15:14:45.000Z</published>
    <updated>2018-11-04T00:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年中国人民大学应用统计专业硕士经验贴合集</p><a id="more"></a><h2 id="第一篇：2018人大应统排名第三经验贴-by-肖洁琳"><a href="#第一篇：2018人大应统排名第三经验贴-by-肖洁琳" class="headerlink" title="第一篇：2018人大应统排名第三经验贴 by 肖洁琳"></a>第一篇：2018人大应统排名第三经验贴 by 肖洁琳</h2><p>2018年考研终于落下帷幕，如愿被人大应统拟录取，写篇经验贴还愿。背景:一战人大应统，本科应用统计学，初试总分401，政治68，英语89，数学129，专业课115，排名第三。复试后综合排名第三。</p><h3 id="一、复习阶段和时间安排"><a href="#一、复习阶段和时间安排" class="headerlink" title="一、复习阶段和时间安排"></a>一、复习阶段和时间安排</h3><p>2018年考研我准备的时间是是3月-12月，历时10个月。6-7月忙着期末和搬家，复习进度完全打乱了，真正的的复习时间是3-5月和8-12月。总体来说，整个复习跨度分为三个阶段:3-6月基础阶段，8-10月强化阶段，11-12月冲刺阶段。</p><blockquote><p>3-6月:</p></blockquote><p>考研前期准备阶段，我给这个阶段的定位是，消除对考研的恐惧感以及打好数学和英语的基础。主要任务是翻看经验帖，了解考研应该怎样规划(做好心理建设);数学三基础复习(听课+笔记+练习);英语一基础复习(单词+长难句)。这时学校还有课，没课的时候就去图书馆坐着学习，时间不固定，每天学习3-5小时，看看视频做做题，大多数时候有种能捡到分数的满足感。</p><blockquote><p>8-10月:</p></blockquote><p>正式进入严肃备考状态(7月回家了，基本没复习)，掰掰手指还有五个月，有了紧迫感，但还是蜜汁自信。这一阶段我认为以提升自己各科的硬实力为要。主要任务是数学三强化(听课+笔记+习题+真题);英语一练习阅读，巩固单词;专业课复习1~2遍；政治整体复习第一遍。具体时间安排如下:</p><div class="table-container"><table><thead><tr><th>时间</th><th>学科</th><th>备注</th></tr></thead><tbody><tr><td>8:30-11:30</td><td>数学</td><td>听课，看书，做题，改题</td></tr><tr><td>11:30-12:30</td><td>午饭</td><td></td></tr><tr><td>12:30-14:00</td><td>趴桌子上午休</td><td>不午休的话，下午还是会睡着</td></tr><tr><td>14:00-16:00</td><td>英语</td><td>阅读题</td></tr><tr><td>16:00-17:00</td><td>政治</td><td>英语学累了，学学政治放松放松</td></tr><tr><td>17:00-18:00</td><td>晚餐</td><td>去操场上散散步</td></tr><tr><td>18:00-19:00</td><td>政治</td><td></td></tr><tr><td>19:00-22:00</td><td>专业课</td><td>参考书目不少，还是会有危机感~</td></tr></tbody></table></div><p>大概是这么个时间安排，但不会严丝合缝地按照这个来，数学学累了的时候用软件刷刷单词，有时候会扣扣手机看看视频~算下来一天正经学习时间7~10小时。会用forest计时，看到有效学习时间增长很有成就感。</p><blockquote><p>11-12月：</p></blockquote><p>一进入十一月，冲刺阶段开始，需要各科都形成清晰的脉络以供按图索骥;查漏补缺，学过的基础内容丢分岂不是很可惜;做冲刺练习，临阵磨枪，不快也光。主要任务是数学三查漏补缺，做冲刺卷;英语一解决完型，新题型，翻译，作文;政治准备第二轮客观题，准备主观题，准备时政，考前抱佛脚;专业课形成自己的知识脉络，操练解题技巧。具体时间安排:</p><div class="table-container"><table><thead><tr><th>时间</th><th>学科</th><th>备注</th></tr></thead><tbody><tr><td>8:30-11:30</td><td>数学</td><td>刷题，改题，抡笔记</td></tr><tr><td>11:30-12:30</td><td>午饭</td><td></td></tr><tr><td>12:30-14:00</td><td>趴桌子上午休</td><td>午休前会看看整理的数学公式啥的</td></tr><tr><td>14:00-16:00</td><td>英语</td><td></td></tr><tr><td>16:00-17:00</td><td>政治</td><td></td></tr><tr><td>17:00-18:00</td><td>晚餐</td><td>去操场上散散步(改善心情，不过走太久会有负罪感)</td></tr><tr><td>18:00-19:00</td><td>政治</td><td></td></tr><tr><td>19:00-22:00</td><td>专业课</td><td></td></tr><tr><td>22:00-24:00</td><td></td><td>图书馆闭馆了，去教学楼背诵</td></tr></tbody></table></div><p>每天学习9-12小时，背单词也是利用早上图书馆排队或其他科目厌倦了的时间空隙。</p><h3 id="二、数学三"><a href="#二、数学三" class="headerlink" title="二、数学三"></a>二、数学三</h3><p>我本科学的数分高代，理解能力不错，反应能力比较快，计算能力一般，数三129，事实证明我栽在计算上。</p><h4 id="2-1-复习资料和时间安排"><a href="#2-1-复习资料和时间安排" class="headerlink" title="2.1 复习资料和时间安排"></a>2.1 复习资料和时间安排</h4><blockquote><p>参考书</p></blockquote><p>-《李永乐复习全书》(大红皮):</p><p>知识点很全面细致，初次做会有点困难，一定要耐心全部刷完，初次做不要直接看例题答案。刷了三遍。也有人用范培华李正元的粉皮全书，据说比较难，数学基础好的小伙伴可以用这本书。</p><ul><li>李永乐《线代辅导讲义》:</li></ul><p>五星推荐!搞透这本书，线代满分没啥问题。大概刷了两遍。《李永乐660题》:全是选择题和填空题，需要对知识点有深入的掌握和良好的计算能力，把高数部分完整地刷了一遍，线代和概统没写完。</p><ul><li>张宇《高数18讲》:</li></ul><p>有很多很有意思的题，重视解题思路，还蛮好玩的，比较适合思维灵活，基础好的同学。我只写了七八章的内容，配合张宇老师的视频课食用更佳。</p><ul><li>2000-2017年数三真题:</li></ul><p>好像是买啥书送的试卷，解析看的是李正元的历年真题解析汤家凤最后八套卷:计算量巨大张宇最后四套卷:挑战解题思路，计算量比汤家凤八套卷稍小</p><h4 id="2-2-辅导课程"><a href="#2-2-辅导课程" class="headerlink" title="2.2 辅导课程"></a>2.2 辅导课程</h4><p>汤家凤高数基础班，强化班，概统基础班视频张宇高数强化班视频:张宇和汤家凤都是很好的老师，各有侧重，汤家凤讲的内容更细致，注重系统性，适合基础少薄弱的或者思维习惯比较规矩的同学，张宇注重数学思维，适合思维比较跳跃的同学。李永乐线代基础班，强化班视频:虽然讲课有点沉闷，但是思路清晰，内容完整，深入浅出，李永乐老师不愧被称为线代王。</p><div class="table-container"><table><thead><tr><th>阶段</th><th>时间</th><th>书目</th><th>辅导课</th></tr></thead><tbody><tr><td>基础</td><td>3.1-6.30</td><td>李永乐复习全书;本科数分，高代，概统课本</td><td>汤家凤高数基础班，李永乐线代基础班，张宇概统基础班视频</td></tr><tr><td>强化</td><td>7.24-9.30</td><td>李永乐《线代辅导讲义》，张宇《高数18讲》、《660题》、《全书》</td><td>张宇高数强化班(一半)，汤家凤高数强化班，李永乐线代强化班，汤家凤概统强化班视频(挑着看了看)</td></tr><tr><td>真题</td><td>10.1-11.05</td><td>2000-2017年数三真题</td><td>无</td></tr><tr><td>冲刺</td><td>11.05-12.22</td><td>汤家凤8套卷，张宇4套卷</td><td>无</td></tr></tbody></table></div><h4 id="2-3-复习方法"><a href="#2-3-复习方法" class="headerlink" title="2.3 复习方法"></a>2.3 复习方法</h4><blockquote><p>3-6月</p></blockquote><p>花了两个月复习高数，线代和概统各一个月。我是一边听视频课一边自己用笔记本做笔记，每学完一章，把全书上对应的例题都做一遍，有疑问的题做上标记，再刷全书的时候重点关注标记的题。注意，这一阶段不要图快，一定要扎实。我当时要求自己笔记尽量写得美观整齐些，留出一定的空间以备日后补充修正，后来证实这对逐渐形成对每个知识点的全方位的理解以及构建各个模块的联系很有帮助。听视频课的时候，遇到记忆不准确的概念和难以理解的知识点时，暂停视频，参考数学教材和网上的资料，也是为了对知识点有尽量全面的理解。这一阶段下来，全书写完第一遍，写了一本自己的数学笔记，基础阶段就算完结了。(其实概统半个月就够了，但是我六月份要准备期末，所以没太沉得下心来，进度很慢)</p><blockquote><p>8-9月</p></blockquote><p>全书复习完了第一遍，进入攻坚克难期。还是听课，做笔记，写练习题，再加上把新的想法补充到基础阶段写的笔记上去，按照高数-线代-概统的顺序复习。练习，学习思路，总结，再练习。练习的材料是《660》，《张宇高数18讲》，《全书》(二刷)，《线代辅导讲义》。其中二刷《全书》和《线代辅导讲义》是我规定自己必须完成的任务(我是重基础型选手，厌恶风险，宁愿难题只能做出一部分也不能容忍基础知识出错)，后来由于时间来不及了，就只把《660》的高数部分选择填空和线代概统选择题写了一次，《高数18讲》写了七八讲的样子，没有强求。</p><blockquote><p>10-11月</p></blockquote><p>开始真题，两天一个周期，每个周期解决一套试卷，第一天模拟考试写真题并批改打分(时间和时长建议按照考研时间来)，第二天订正错题。养成写试卷的手感。(分数大部分在140+，也有130+或者120+)</p><blockquote><p>11-12月</p></blockquote><p>汤家凤八套卷，张宇四套卷。和真题一样的打法，模拟分数会比真题的分数低，正常(分数一般在110-130)。另外，趁着10-12月，三刷全书(屡次做错的题)，二刷《线代辅导讲义》，进一步完善基础阶段的笔记(让它尽量体现你对知识结构的把我，同时又有全面细致的知识点供查询)。</p><p>18年数三考得比较难，客观题主观题都不是善茬，思考量和计算量都不小。写完客观题，再写完第一个主观题我就有点慌了，还好我有旺盛的求生欲，坚持到最后一秒2333，结果是客观题没扣分，所有主观题我都知道出题意图是啥，该用啥方法。但是有一半主观只写了一半，就是算不出来或者算错最终结果，想来还是没多练难题和计算能力的锅。</p><h3 id="三、英语一"><a href="#三、英语一" class="headerlink" title="三、英语一"></a>三、英语一</h3><h4 id="3-1-总体经验"><a href="#3-1-总体经验" class="headerlink" title="3.1 总体经验"></a>3.1 总体经验</h4><p>我英语基础还行，四级裸考630+，六级裸考530+这样。我一开始的目标是75，冲一下80，一直按照80的预期准备的，考完预期分数80-85，真实分数89，也许有一定运气成分。主要用的参考书是朱伟的《恋练有词》，张剑黄皮书(历年真题)，张剑的黄皮英语作文书(买书送的17年版)。个人认为考研英语最基础的是词汇，次基础的是语法和长难句理解，在此基础上掌握各种题型的套路就大功告成了。我从三月份开始复习单词和长难句。单词用的朱伟的《恋词》和配套视频，因为我光背单词表会感觉很枯燥，听视频课调节一下，大概三月到五月磨磨蹭蹭地把恋词的三十个视频听完了(最后十个串讲视频太长了，懒得看了)，个人觉得词根词缀对猜词还是很有好处的，不需要刻意去记忆，听课的时候跟着理解一下形成印象就行了，以后碰到眼熟但是不确定的词根词缀或者单词，反复查几次就行了。系统地学完《恋词》之后，可以用单词软件背单词，每天坚持背，不能停下来，坚持到考研。我用的是扇贝，有的阶段一天背500个，有时候300个，有时候200个，根据其他计划酌情调整，只要每天背，坚持到最后一天就行。长难句用的是何凯文的《长难句解密》，每天翻20页左右，三四月份看完的，学怎么断句，怎样整体理解句子。不必刻意去记东西。</p><h4 id="3-2-各个题型经验"><a href="#3-2-各个题型经验" class="headerlink" title="3.2 各个题型经验"></a>3.2 各个题型经验</h4><blockquote><p>阅读:</p></blockquote><p>应该算复习性价比最高的题型?(当然也是重难点题型了)分值高，套路性特别强，英语练习我都是直接用的真题，没有另外买模拟题或者专门的书，12月最后一段时间，直接拿最近五年的真题当模拟题练。<br>大概到七月底才拿起真题练阅读。总共约80篇真题阅读，每天干掉两篇阅读(96-11年)，大概花了40-50天。建议先读文章做题，批改，尝试理解错题，再通读全文，查单词，看全文解析，看题目解析，理解出题和答题套路，做标记，如果实在觉得理解有问题，可以听听阅读专项的视频课(我听的是唐迟的阅读强化课大概04-08年的真题，基本上包括了考研英语阅读的所有套路)。十月到十一月中旬我把阅读刷了第二次(96-11年)，直接通读全文，看标记的单词和标记的文章解析，看题目和题目解析，做标记。十一月中旬到考前，整套刷最近五年真题，三刷96-11年的阅读(直接看标记部分)。第一遍刷阅读边看解析边思考边划记，耗时会久一些，大概一篇阅读45-60分钟，第二轮第三轮就会快很多，因为已经有了适合自己的重点生词和重点解析了。不建议全文翻译，做阅读重在逻辑关系和情感倾向。</p><blockquote><p>新题型:</p></blockquote><p>据说新题型很简单，但是我做新题型很烂，不知道啥原因，于是我听了王晟老师的专项强化课，再不行就只能看命了。新题型放在10-11月刷完阅读后复习(因为觉得阅读是大头，其他题型都是小菜)，先做真题，再批改，再听课学思路。但是18年英语一的新题型当时我做的时候，直觉给出的答案还是和用王晟课程中的思路给出的答案有出入，最后直觉赢了，所以语感还是很重要的。</p><blockquote><p>翻译:</p></blockquote><p>长难句的基础在这里很重要，翻译要求句子结构切分正确，内容完整正确。我看的是唐迟的专项强化班，每次练习完一篇翻译就看一节课，放在十一月中旬到十二月刷阅读之后练习。</p><blockquote><p>作文:</p></blockquote><p>分两块掌握吧，一块是论述结构，一块是表达。论述的结构就那么几种，基本都是三段式，看几篇范文就能领悟，表达就需要自己整理用得顺手的句型和搭配，同时词汇量也要过关。最重要的就是练习，心里有一个论述的结构，向里面填充具体的内容(论述或例子)。作文我从十一月开始准备，从十二月才开始练习(后来还是觉得有点虚，最后主观题只扣了9分，出乎意料)，看的张剑黄皮的作文书和真题的作文解析，积累其中用得顺手的表达。</p><blockquote><p>完型:</p></blockquote><p>我从12月才开始准备，当时想着来不及复习就放弃，完型应该是最考验英语功底的题型了，分值小，范围广，做真题是时候可以注意积累完型的常用搭配，完型还是可以做做模拟题的。</p><h3 id="四、政治"><a href="#四、政治" class="headerlink" title="四、政治"></a>四、政治</h3><p>政治分为客观题和主观题。客观题是拉分的关键。68分，说不上经验，说说个人的复习用书和复习感想。</p><h4 id="4-1-复习用书"><a href="#4-1-复习用书" class="headerlink" title="4.1 复习用书"></a>4.1 复习用书</h4><p>肖秀荣强化三件套(精讲精练，1000题，真题)，《任燕翔主观题背诵宝典》《肖八》《肖四》《肖秀荣命题人时事与政策》《任燕翔四套卷》</p><h4 id="4-2-时间安排"><a href="#4-2-时间安排" class="headerlink" title="4.2 时间安排"></a>4.2 时间安排</h4><p>8-10月中旬，听政治网课，看精讲精练，做1000题。10月中旬-11月中旬看第二遍精讲精练，刷第二遍1000题(只做了一半)，11月中旬-考前，背《任燕翔主观题背诵宝典》(边看视频边背，其实没有完全背下来)，做模拟卷选择题，读肖八主观题，背肖四客观题。政治最后悔的就是10月中旬-11月中旬想二刷1000题，对知识点纠结得过细，浪费了很多时间，但效果一般，导致最后一段时间政治比较被动。客观题我觉得还是快刷，多刷为好，建议最后各个政治老师的模拟卷都买来做做客观题见见世面，模拟卷的客观题错题可以考前强记一波。主观题不要太恐慌，看看任燕翔的主观题直播视频，背好肖四，考试的时候抄抄材料，背背理论就不会崩。</p><h3 id="五、432统计学"><a href="#五、432统计学" class="headerlink" title="五、432统计学"></a>五、432统计学</h3><p>今年突然出了50分计算证明题，大概写出来了20分，拿了115分，对准备的部分还算满意，没准备的数理统计部分也怨不得人了。</p><h4 id="5-1-参考书目"><a href="#5-1-参考书目" class="headerlink" title="5.1 参考书目"></a>5.1 参考书目</h4><ul><li>《统计学》贾俊平(第六版)及配套辅导书</li><li>《统计学》贾俊平(经管版)(有第六版中没有的内容，如实验设计部分内容，时间序列部分模型)</li><li>圣才的《统计学》考研辅导书(蓝白皮的)(用来刷选择题熟悉概念)何晓群《应用回归分析》(第四版)</li><li>王燕《应用时间序列》(第四版)</li><li>何晓群《多元统计分析》(第四版)</li></ul><h4 id="5-2-关于真题"><a href="#5-2-关于真题" class="headerlink" title="5.2 关于真题"></a>5.2 关于真题</h4><p>真题很重要，真题直接反映专业课的考察套路:考哪些内容，考哪些方面，应该怎样作答。研究历年真题，会发现有很多知识点是反复考察的，那就是复习的重点。</p><h4 id="5-3-关于笔记"><a href="#5-3-关于笔记" class="headerlink" title="5.3 关于笔记"></a>5.3 关于笔记</h4><p>不得不说学长学姐的讲义还是挺重要的，可以提供一个基本的整理框架和思路，让我不至于跑偏，但是不能完全依赖学长学姐的笔记，自己整理的东西用起来是最顺手的。我是参考学长的笔记结构和历年真题，按照自己思路整理的总结笔记，补充上我的薄弱项。最后整理了主要的八个模块，回归分析全过程的思维图，时间序列的模型总结，多元统计各个方法的联系图。到最后一个月基本就直接背笔记了，很少翻书。</p><h4 id="5-4-复习过程"><a href="#5-4-复习过程" class="headerlink" title="5.4 复习过程"></a>5.4 复习过程</h4><p>专业课复习从八月开始，我把上面的这几本教材通看了两遍，第一遍是把所有内容自己理解一次(感觉比较难的章节会做笔记加深一下印象)，第二遍注意整理知识结构和在此理解难以理解的部分，这两遍是为了给后续整理自己的笔记和记忆打基础。进入十月下旬，开始一边做真题，一边整理自己的笔记。《统计学》中，概念的辨析和联系是很重要的，如假设检验中第一类第二类错误的概念，p值的含义，假设检验的思想等等。而《回归》《时序》《多元》中，各种方法的适用范围和优缺点，还有分析思路是很重要的。比如回归分析的整个过程，就要从收集数据，数据清洗开始，到设定模型形式，到参数估计拟合模型，到模型评价，到模型改进和模型选择，再到预测控制，各个环节有各自对应的不同评估指标和处理方法，整个一套过程下来理清楚，就不容易出现记忆错乱的情况;时间序列中理清楚不同类型时间序列的不同处理方法以及具体模型是主线…</p><h4 id="5-5-关于2018年专业课"><a href="#5-5-关于2018年专业课" class="headerlink" title="5.5 关于2018年专业课"></a>5.5 关于2018年专业课</h4><p>今年专业课一反常态，出了三个概统的题，50分，难倒一片。第一个是辛普森悖论，第二个是证估计量的性质，第三个是证概率不等式，用到示性函数和柯西不等式的小技巧。可能专硕对数统的要求会有所提高，建议以后大家复习书目加上茆诗松的《概率论与数理统计》…</p><p>最后，决定好了的事情就用心去做，祝愿大家得偿所愿。</p><h2 id="第二篇：2018人大应统初试第六经验贴-by-肖健一"><a href="#第二篇：2018人大应统初试第六经验贴-by-肖健一" class="headerlink" title="第二篇：2018人大应统初试第六经验贴 by 肖健一"></a>第二篇：2018人大应统初试第六经验贴 by 肖健一</h2><p>一战人大应统，政治67，英语67，数学139，专业课119，初试成绩排名第六，专业课和数学总分排名第一，重点写一下数学三和432统计学专业课的学习经验，英语和政治则稍微简要一点。(以下我说的每一句话都是重中之重，知道同学们疲于观看冗长的经验贴，我已经尽量精简了)</p><h3 id="一、432统计学专业课"><a href="#一、432统计学专业课" class="headerlink" title="一、432统计学专业课"></a>一、432统计学专业课</h3><p>我们将准备考研的过程分为三个阶段，暑假前(3-6月)暑假(7-8月)暑假后(9-12月)我的专业课复习过程贯穿于全程，但是方法不同。9月份之前，我仅仅只是将贾俊平老师的统计学看了两遍，9月份之后开始陆续把回归，时序，多元三本书看完，此时脑中有一个初步的知识架构:专业课总共有八个专题，统计学独占前五个专题(数据图表展示以及度量，统计量与抽样分布，假设检验与参数估计，方差分析，列联分析)回归，时序，多元分别是第六七八专题。但是我对八个专题的细节还不清楚，这时候我开始自己拿一个新本子，整理自己的专业课笔记，六七八专题作为重点，一至五专题则作为次要，写完了一个本子。在这里我要特别感谢人大学长学姐为我辅导专业课，由于专业课考试范围过于宏大，你很需要过来人指出考试重点以及考场感受!到了11月中旬，我已经将八个专题的笔记整理完全，之后就开始了整个复习过程中最重要的一环:默写。可以说之前你所做的全是铺垫工作，构架了知识体系，了解了各专题中常见的问题，但是我们还是需要在考场上写出大概12面A4纸的内容，八个题目，每个题目题干一两句话，答案全需要你牢牢记在脑子里并且能完整默写出来!所以我的最后一个月全在不停的默写，对照笔记本，拿出白纸，直接默写出每个专题的常见问题答案，再对照自己的笔记本，做往年真题，默写出答案，默写默写再默写，再对照自己的笔记本，总之就是默写以及围绕自己笔记本!就这样笔记本已经翻烂，笔芯不知写过多少，八个专题已经牢牢印入脑海，各种问题可以说是倒背如流了。上了考场，感觉全是老朋友，只恨不得自己能多长手，全部一顿默写，那种熟悉感觉大大增加了我的信心，学弟学妹们都知道18年专业课有50分证明题，相当于诈和，但是由于信心爆棚，思维打开，我还是做出来了近30分，做完卷子还剩5分钟，大汗淋漓，直呼痛快!</p><h3 id="二、数学三-1"><a href="#二、数学三-1" class="headerlink" title="二、数学三"></a>二、数学三</h3><p>最有感触的一门，详情见知乎回答:如何评价2018年考研数学三?<br><a href="https://www.zhihu.com/question/264535482/answer/283393765" target="_blank" rel="noopener">https://www.zhihu.com/question/264535482/answer/283393765</a></p><p>从七月份开始正式准备考研以来，数学3一直是优势科目，先是把全书做了一遍，然后15年数3真题，之后660题，然后15年数1真题，这时大概到11月份了，一时兴起又补上了数三从87年到04年的真题，之后到了十二月份是每天一套模拟题，张宇12套，超越135，合工大超越卷，我做题的过程有一个特点，就是从九月份开始，每天都是以模拟考的形式做数学，每天上午8.30到11.30雷打不动，全真模拟，就是那种不准拉的模拟=(虽然好像每次都没憋住…</p><p>就这样一直做到12.22，我记得大概是从11月开始，我的模拟成绩就稳定在真题145加，模拟题130左右的水平</p><p>上了考场，看到第一个题导数不存在就看出来这套卷子不简单，第二题卡住，看到二阶可导确实想到了泰勒，但是当时也没有再深入思考，再bd中徘徊，然后随手画了个图选了d，那个时候已经有点慌了，但是由于平时模拟考场次数很多，特别是最后的各种模拟题给了我很大历练，就是那种在考场上碰到不会做的题至少不慌的能力，所以强忍着看第三题，万幸看出来了那个中间量是1，所以也就成功做出来，从第三题开始，进入了我平时模拟的状态，一路绿灯到差分方程，其实这里我要多说一句，因为我考的是应用统计，所以我是知道二阶差分的，因为时间序列分析中有多阶差分消除趋势成分的内容，但也只限于我认识那个二阶符号，我当时第一个想到的就是这题超纲了，陈独秀啊…于是没敢耽误一分一秒赶紧跳，最后花了一小时做完选择填空，平时我模拟大概也是这样的时间，于是继续往下</p><p>往下是大题，当时我应该是已经进入了状态了，后面几道高数都比较顺利，提一下级数展开an那个题，当时不知道要怎么处理x的2n次方这一项，但是想想了应该是不能再化简了，于是就暴力合并，分奇偶数情况写上了答案，答案复杂到我都不敢写，但是做过的模拟题告诉我真的有正确答案是很复杂的，所以就这么过了那道题。</p><p>之后就到了数列递推这道题，这个时候我陈独秀同志真的有话说了，因为其实在考前，我在做往年数3真题的时候，已经发现了一个特别恐怖的规律，特别是到了1617年，我发现最近的数3真的有一种怎么偏怎么考的感觉，比如我在做17年真题的时候，当时有三个点很怪：</p><ol><li>差分方程</li><li>级数那道大题，第一问就不说了，玄学证明收敛半径大于1。。。第二问在合并的时候，考到了级数下角标以及n要变的情况，也就是n=0还是n=1要变化的情况，而以前从没有出过，数1中有考到过，但数3没有</li><li>概率最后一道大题一反常规，不是直接考估计，而是先让你推出来概率密度，也是数3以前没有考到过的</li></ol><p>因为我当时发现了17年已经有点不对了，于是就特别注意一个冷门的考点：数列递推，单调有界准则。这一类题目，数3从来没有考过，数1倒是有考过，所以我在做模拟题的时候碰到这种题就很注意了一下，知道一般证有界需要用数学归纳法，于是在考场上那道题也就顺利做出来。</p><p>之后到了线代，线代是真的不考常规，说好的正交变换是重点，反而考了配方法，我相信我们考生最熟悉的关于二次型的题就是让你常规求正交变换，但是万幸的是，我之前有一段时间专攻了二次型，这还要归功于模拟题，因为真题大部分都是让你直接正交变换的，而不会深入考你二次型，所以第一时间我就想到了要分a的情况讨论，来看是不是可逆线性变换，于是这题也过了。</p><p>之后三道题就是真的比较常规了，但是我在做的时候也有一些小插曲。。。在做线代第二道的时候，第一问我把a算错了，到第二问的时候发现A矩阵是可逆的，我心想AP=B求P直接左乘A逆不就行了吗！！太弱智了，但是在算A逆的时候突然发现A好像不可逆！！于是又返回去算A行列式，发现第一问的a算错了，于是开始大面积划掉答案，改的时候手都在抖，心想差点，差点就凉了，10分啊！！还好悬崖勒马！然后两道概率就中规中矩了。</p><p>这个时候还剩5分钟，之前我有说过我选择题第二题是蒙的，差分方程没有做，于是这时返回去看这两个题，这时猪操作来了，因为我考前总结了大概14-17的选择题答案，发现ABCD是2231的分布，也就是说会有三个是选一样，然后是两个一样的，两个一样的，最后剩一个，但是到底是ABCD哪一个选三个是不确定的，于是我当时自以为很聪明的开始看我的其他七个确定的题，发现已经有3个A，2个D，1个B，1个C，如果第二题我再选D，就会有3个D，3个A，正好第二题我又在BD中徘徊，于是我当机立断马上改为B，没跑了！还很美滋滋。。觉得自己很帅。。。再回来看差分方程那个题，已经犯迷糊了，因为看那个yx很不爽，潜意识里告诉自己这题超纲！再加上当时就两分钟了，所以就没有做。</p><p>加一条线，显示我终于把整个考试过程说清楚了，昨天上午对完了答案，发现选择错一个（那个自以为很秀的第二题）填空错一个（差分）之后的大题好像没有错。</p><p>做一个总结吧，2018的数3，总体来说是难的，而且是历史最难，没有之一，从1987年到2017年但是我想强调点是，如果你的考研数学复习，一直是限于做真题，全书，而且做很多遍的情况下，来做2018的题，是绝对不够的，因为它和往年的真题真的很不一样，基本上是一种“怎么偏我怎么考，考的常规算我输”的状态，但是如果你有做过大量的模拟题，有经历过在难题堆里挣扎的情形，在考场上至少不会慌张，不会心态爆炸，我觉得我就是这么一种情况，当时从第二题不会做开始，就拼命告诉自己，稳住稳住，什么难题没见过之类话，所以总的来说，我认为2018年题首先是难，然后那道差分方程确实是败笔，但是其他的题，都在考纲范围内，只是比较冷门的知识点，所以说没做出来只能说自己功夫不到家，我到现在都认为我那道选择题是自己没学好才错了的。</p><p>其实在考场上，只要不出现大的失误，类似于题目抄错，考生信息填错等原则性错误，其实都属于自己的正常发挥，没考好也是自己的某方面知识薄弱。</p><h3 id="三、英语一-1"><a href="#三、英语一-1" class="headerlink" title="三、英语一"></a>三、英语一</h3><p>如果你像我一样基础不太好，可以做精翻，也就是把往年阅读做完后再翻译出来，不要做模拟题，反复做真题，做他五六次，然后每天记单词，不要断，一直到考研那天，最重要的是，不要忽视新题型，18年就是英语一新题型诈和，我估摸着我应该是全错了，不然不会这么低。我英语花的时间仅次于数学，感觉还是没考好，不然可以冲一下400分，可惜。</p><h3 id="四、政治-1"><a href="#四、政治-1" class="headerlink" title="四、政治"></a>四、政治</h3><p>考前诈和，周末考试，我周一到周四都在发烧，所以完全没有背分析题，还好上了考场发现答案全在题里，相信这也是政治考试以后的发展趋势吧。不急着复习政治，结合我身边的同学复习情况来看:我女朋友五道口第17名，考前可以说是把所有类型模拟题都做了，政治投入极大，最后也没有上70，一个朋友是今年北大非法学法硕初试第一，他反而确有70多分，我室友连肖4肖8都没有买，也有66??所以我认为考研政治完全是一门玄学，你的复习时间和分数关系不大，分数高低全看天，选择题一定要多做，所有人各种版本的模拟题都可以做一做，反正也就35个题，二十分钟搞定一套，这样虽然不能保证你上70，但65肯定是有的，上不上70看天吧。</p><p>最后总结一下，既然决定了考研就要一心一意，从我身边的同学来看，考研很简单，你认真了，就能上，没有认真，就一定上不了。暑假之前，暑假，暑假之后，这三个阶段中学习强度可以逐渐加强，循序渐进，但这些都是次要的，最重要的是心诚则灵，送两个字给你们:专注。你的心要属于考研，一心向学，必然成功。最后愿所有真正努力过的同学都能取得理想的成绩！</p><h2 id="第三篇：2018-年人大应用统计考研经验贴-by-曾诚"><a href="#第三篇：2018-年人大应用统计考研经验贴-by-曾诚" class="headerlink" title="第三篇：2018 年人大应用统计考研经验贴 by 曾诚"></a>第三篇：2018 年人大应用统计考研经验贴 by 曾诚</h2><p>在 2018 年的考研中，我的分数不算太高，但也算是我自己比较没有遗憾的 一个成绩吧——375 分，也算是给两年的艰辛的考研旅程画上了一个圆满的句号。 各科分数为政治 64，英语 65，数学三 135，统计学 111。之所以写下此经验贴， 一是对自己两年考研历程的一个总结，二也是希望能够给今后考人大的师弟师妹 们提供一些帮助吧。</p><h3 id="一、我的大致情况"><a href="#一、我的大致情况" class="headerlink" title="一、我的大致情况"></a>一、我的大致情况</h3><p>本人就读于天津一个非 985、211 院校，读的是统计专业精算方向。对于专 业的选择，其实没有考虑太多，由于没有读博的打算，所以直接就选择了专硕。 整个大学期间读书还算认真，但碍于非 985、211 院校，保研资格实在是太少太 少，而且就算能够保研，可能所就读的院校也不是特别特别的拔尖(除非从很早 很早就开始准备，刚进校那会就听说有个学姐保送了北大应统，据说从大一就开 始准备，发表过很多论文作品，而且大学期间就拿下了中国准精算师证书，膜拜 膜拜)，所以当时就了解了一下应统比较好的院校，这里说一下我大概了解的情 况，因为本科是在天津，所以更多的还是愿意选择北京的学校，一来北京离天津 很近，二来北京作为三大一线城市之一，就业机会远大于其他城市，其实读本科 的时候就有些后悔，应该选择一线城市的学校去读，且不谈学校如何，城市给你 的感觉截然不同。就拿天津和北京为例，天津的氛围相较于北京，实在是太过于 安逸，只能说天津是个适合安家的城市，但北京的环境所给你带来的无论是眼界、 机遇绝对是天津所给予不了的。所以当时就把目标定在了人大和北大，当然南方 也有许多不错的院校，例如说厦大，听大学一个关系不错的老师说华东师范的精 算很不错，想考精算的童鞋可以了解一下。当然这里我就重点从客观的角度说一 下人大和北大，不用说从院校实力来比较呢，自然是北大要强啦，考的难度自然 也是北大难度大些。从初试分数线来看，北大和人大的初试分数线分别是 380 和 360。从专业课来看，北大偏数理统计，而人大比较偏应用，这也是统计专业 课为数不多的专业课相对来说比较简单的院校了，但可能也是这个原因，从今年 开始人大专业课也来了个 360 度大转弯，把我们打得措手不及，估计以后就不会 那么容易了哦。从招生规模来看，都有小幅度扩招，但人大的招生人数还是远远大于北大，近年人大统招 45 人，而北大只有 17 人，招的人少，这就说明你要和 更多数学大神，专业课大神去拼，不能混入低分飘过的队伍中去了哦。虽然现在 人大的拟录取名单还没出，但从初试名单上的分数来看，低分飘过的小伙伴还是 不占少数，而北大最低的初试分数也达到了 385。从复试来看，北大的复试分差 还是相当恐怖的，最高的有 96 分的大神，在这里膜拜一下，低的才 65 分，初试 分数高的也不一定稳，这点人大还是非常占优势的，人大复试比例只占 30%，相 比其他院校还是低了很多。总之，清华北大这个大神级的学校，要考还是要多三 思。</p><p>再说说我的工作经历吧，在数学难度大增还有专业课改革的大形势下，相信 今年考研的许多小伙伴们都碰了灰。去年的这个时候我也面临着和你们一样的困 境，实习?工作?二战?这似乎是考研失败的小伙伴们避不开的选择。这里直接 给出几条建议吧。要是在纠结工作还是二战的朋友，我真的劝你好好想一想你是 否真的值得再花一年宝贵的时间来学习?今年成绩不理想的原因在哪?再给你 一年时间你在哪科能有巨大的提升?不妨再问一下自己，这个研究生是否值得读， 是否比两年或者三年的工作经历来的更重要?重新审视之后再做出决定，可以先 去认认真真地实习两个月，体会一下工作是一个什么样的状态，准备二战的也可 以实习，毕竟二战暑假再开始准备也是完全来得及的。再就是纠结全职二战还是 专心二战，本人是全职二战，不得不说当时的考虑就是想着自己毕业了，也不能 老靠着家里，就找了一个相对轻松的工作，一个月能赚足自己的生活费。但我必 须要提醒大家的是，要全职二战可是会非常的辛苦了，即使是一份轻松的工作， 你一天的学习时间也绝对不会超过 8 个小时，这可是比第一年的学习时间直接砍 掉了将近一半，而且有时候下班累了，就真的已经不想在学习了。所以我对二战 的小伙伴们的建议就是，要么就找个好点的实习，实习几个月然后专心考研;要 么就找个相对轻松的工作，但是后者会非常辛苦，建议慎重考虑。</p><h3 id="二、各科复习进度与复习方法"><a href="#二、各科复习进度与复习方法" class="headerlink" title="二、各科复习进度与复习方法"></a>二、各科复习进度与复习方法</h3><p>我主要还是讲一下我的备考经历，按时间顺序，里面会加上我的复习心得。</p><h4 id="2-1-数学三"><a href="#2-1-数学三" class="headerlink" title="2.1 数学三"></a>2.1 数学三</h4><blockquote><p>复习用书</p></blockquote><p>复习全书、概率论与数理统计计提方法与技巧、微积分解题与技巧、线性代数辅导讲义、数学基础过关 660 题、历年真题、模拟题(李永乐)、 合工大三套卷</p><blockquote><p>复习进度</p></blockquote><p>由于第二年考研时间比较短，复习的时间规划不太详细，以第一年时间规划为例。</p><ul><li>第一阶段:7 月-9 月(基础阶段)</li></ul><p>每天 3-4 小时 建议使用李永乐复习全书、概率论与数理统计计提方法与技巧、微积分解题与技巧、线性代数辅导讲义。第一本比较系统，但是有些许定理会直接摆在上面， 并没有给予证明，可能第一遍会看不太懂，不过这也正常，可以去翻看本科的数 学课本，第一遍看的时候尽量把知识点都弄得详尽一些，最近几年对于细节的考 点越来越多，以前看似不会考的考点，比如说数列收敛性的证明，差分方程，都 成为近两年数三试卷上的宠儿(差分方程的题目连错两年，不是难，平时这类题 目练得少，公式总记不住)。后三本是分别针对数三的微积分、线代和概率论三 部分的书。其中，微积分解题技巧这本书比较难，当时也是看了 14 年考上北大 的学长经验贴买的，内容要比全书上多很多，要看不懂可以酌情跳过，但是最近 数三的微积分部分越考越难，我觉得有必要推荐一下，上面有很多题目的解题方 法。线性代数的讲义写的很有条理，思路很清晰。概率论的这本书真的是相当推 荐，有很多方法相当实用，看完这本书，基本上概率论这部分就没什么问题了。</p><p>这个阶段大家尽量将每个知识点都理解透彻，不要放过每一个细节，最好自 己列一个知识点框架，把一些重要的公式记下来，下次再记不住，就用记号笔重 点画出。刷题的时候，不会的题和猜对但不知道原理的题都要用记号标出，不要 糊弄，最后都会直接体现在你的考研分数中，这部分时间长，一定要把知识点学 扎实。</p><ul><li>第二阶段:10 月上旬(提升阶段) 每天 3 小时</li></ul><p>建议基础过关 660 题，这本书 20 天左右绝对刷的完。我第一年选择的是张宇 1000 题，第二年选的 660，这两本书我觉得 660 更贴近真题一些，张宇 1000 题偏难，对答案的时候非常扎心。660 只有选择和填空两种题型，1000 题所有题 型都有，但讲真，有些大题还真是有点难，大家根据自身情况进行选择。</p><ul><li>第三阶段:</li></ul><p>10 月下旬-12 月底(冲刺阶段) 每天 3 小时 建议历年真题、模拟题(李永乐)、合工大三套卷，很多一战的人都喜欢先</p><p>刷历年真题，再刷模拟题，没错我一战也是这样，我这个人喜欢总结套路，由于 真题简单，我就开始总结哪些题会考哪些题不会考，结果 2017 考研的时候我就 傻眼了，以为不会考的差分和数列出现在试卷上。所以大家一定要吸取我的教训， 千万不要以为某个知识点是一定不会考的，近几年的数学题是一年比一年刁钻。 我刷完真题之后发现我好像只会那么真题的那么几类题型了，做模拟题的时候好 多题型完全想不起来怎么做。所以第二年我先从模拟题刷起，把你的水平先拔高， 再去对待简单的真题。强烈推荐合工大三套卷，感觉它的出题风格非常像今年的 数学真题了，有点难，但还挺锻炼你的临场发挥能力的。每套卷子一定要掐着时 间做。我当时还专门买了考研专用的答题卡来模拟训练，因为我这个人还有个毛 病，一看见答题卡就紧张，当然我觉得这也是有必要的，因为毕竟将答案誊写到 答题卡上还要一定的时间。</p><p>12 月份我就没有再练习新的题了，这个时候在数学上的时间可以缩减到 2 个甚至 1 个小时，因为这段时间对你数学的提分作用不大，应该多放时间在其他 三门记忆性的学科上。这段时间可以看看你的错题，总结总结自己在哪方面还比 较薄弱、公式重点记忆、查缺补漏，千万不要在做题了，只会越做越紧张!</p><h4 id="2-2-英语一"><a href="#2-2-英语一" class="headerlink" title="2.2 英语一"></a>2.2 英语一</h4><p>复习用书:扇贝 app，历年真题，王江涛高分写作</p><p>这门学科我就不说太多了，17 年考了 76 分，18 年才考了 65 分，分析一下 分数降低的原因吧，也给不了太多的建议。</p><p>今年分数下来看见自己的英语成绩，是不能接受的。真的未免太低了，不过 后来想想也就该得这个分。近年可以说真的是一个单词都没背，这能充分说明背 单词的重要性了。学了很多阅读的技巧什么的，但终归抵不过单词不认识，句子 看不懂。所以说不要妄想走捷径，根基不稳，终究是不行滴!</p><p>英语的重心还是放在阅读上吧，阅读占的分值实在太大。历年真题即可，无 需其他的辅导书。05 年之前的真题和现在出题风格不太一样，时间不多的话就 可以不用刷了。10 年后英语开始变难。一篇一篇阅读认真刷，最好弄懂每篇文 章的每个单词和句子，对后面的翻译也是有好处的。</p><p>再就是写作，这部分真的最好要提前准备，千万不要等到 12 月份才开始准备。小作文非常有套路，我第二年因为时间不够，就把 10 年到 17 年所有小作文 考的题型列出来，发现常考的就那么 5、6 类，而且邀请信出现次数最少，结果 还真就考了，哈哈哈。大作文也是有套句的。</p><p>作文一定要背句子，不要整篇整篇的背，因为有些句子是可以通用的，文章 背完了可能只适合那一类题材，而且容易被判卷老师看出来是背的模板。平时也 要有意识的训练自己写句子的能力，毕竟不能所有的句子都写套句。</p><p>其他三部分真的是听天由命了，考的非常惨淡，就不给出建议了。</p><h4 id="2-3-政治"><a href="#2-3-政治" class="headerlink" title="2.3  政治"></a>2.3  政治</h4><p>复习用书:肖秀荣命题人知识点精讲，肖秀荣 1000 题，肖 8，肖 4</p><p>这种学科要考好真的是完全靠天赋了，两年都是 60 几分，总之，告诫各位 前面时间真的别用太长，9 月开始准备足矣。最后一个月肖 8 肖 4，尤其是肖 4 努力背，使劲背，背着全是你的，哈哈，2017 年政治大题全压中了，可怕。其 他的不多说了~</p><h4 id="2-4-432-统计学"><a href="#2-4-432-统计学" class="headerlink" title="2.4 432 统计学"></a>2.4 432 统计学</h4><p>复习用书:统计学第六版、统计学第四版、应用时间序列分析第四版、多元 统计分析第四版、应用回归分析第四版，今年考的证明据说是茆诗松的概率论与 数理统计的书上的，具体也不是很清楚，最好好好了解一番，不过这本书是很 多学校统计考研都会考的书，偏理论证明。</p><p>今年考研专业课画风突变，今年之前从来没有考过定理的证明，但今年考了 三道大题，一道简单，另外两道比较难，感觉有一道跟切比雪夫不等式比较像， 但怎么也证不出来，另外一道连题目都看不懂。而且今年不知道为什么初试包括 复试都只考了统计学，不知道明年还是不是这样。不管考不考，其他三本书该复 习还是得复习，再加上一本偏理论的数理统计教程。</p><p>建议大家先把历年真题都过一遍，知道大概每道题都考什么知识点，因为真 的不是所有书上的内容都会考到的，这样做非常省时间，不然毫无目的看完一遍 之后什么也记不下来。人大的专业课考研是分模块的，考试一般考 8-9 个题，全 是大题，一般分八个模块，都是按统计方法分的，每个模块一到两道题，你可以 把每个模块的题都放一起看，看看都考什么知识点。比如说第一个模块是统计图 表，知识点就是数据的分类、每类数据适用的图表以及特点。通过这些问题去找答案，看书效率事半功倍。我第二年书都没看，直接看的笔记，仅仅只花了 2 个月的时间复习专业课，最后考了 111 分，还算可以吧。不过证明题这块个人真 的不知道怎么复习，以前也没考过，这里就不给出建议了。</p><p>另外强调一下，大家在做历年真题的时候一定要自己亲自动手做，我第一年没动手做，结果到考场上专业术语全都想不起来，写的语言特别大白话，最后分 也不是很理想。不要嫌麻烦，真的，想的和写出来的不太一样的，写一遍，再对 照书本或是学长学姐的资料或笔记重新改一遍，重点记忆的部分用记号笔做标记。 另外，一个小细节，关于字母的书写的，凡是涉及字母的题目都要在开始标注清 楚每个字母都代表什么，保证做题的严谨。其他的有关于每本书的复习思路相信 在前几届学长学姐的经验贴中已经说的非常详细了，此处不再赘述。</p><h3 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h3><p>考研除了复习方法之外，保持身体强健与心态平和也尤为重要。要知道复习 时间紧迫，只要一病就有可能耽误好几天，所以一定要保持自己身体的健康，每 天给自己半个小时或一个小时的休息锻炼时间，劳逸结合。心态平和更是重要， 第一年由于自己的心态问题导致数学相当惨烈，不仅紧张，还没休息好，考数学 前差点睡着，考试大脑一片空白，想想都可怕。考试前一定就不要熬夜了，也不 要花太多时间在复习上了，保证良好的休息时间才能有清醒的头脑对待考试。<br>数学和专业课真的相当重要了，特别特别拉分，建议多花点时间。<br>以上就是全部关于两年的考研历程的总结，希望大家能够多多吸取我的教训 吧，都是血和泪的教训啊，希望能对考人大的学弟学妹们有所帮助。也祝愿大家 能在 2019 年的考研中取得一个自己满意的成绩!</p><h2 id="第四篇：2018人大应统考研经验帖-by-王雪楠"><a href="#第四篇：2018人大应统考研经验帖-by-王雪楠" class="headerlink" title="第四篇：2018人大应统考研经验帖 by 王雪楠"></a>第四篇：2018人大应统考研经验帖 by 王雪楠</h2><p>大家好，我是 18 考研中国人民大学应用统计专业的小王，初试分数为政治 73、英语一 78、 数学三 124、专业课 103、总分 378 分，初试排名 15/54，复试成绩未出，成绩不算很高， 备考经验仅供参考。(注:18 考研指的是 2018 年研究生入学那一拨人的考研，实际是在 2017 年末考的)</p><h3 id="一、-背景介绍"><a href="#一、-背景介绍" class="headerlink" title="一、 背景介绍"></a>一、 背景介绍</h3><ol><li>学业背景<br>本人为应届生，本科读统计学专业;<br>六级裸考520+(听力和写作较弱)，高中英语语法尚可(后面会提到)。</li><li>目标院校考研情况 人大应用统计专业最近几年的分数水涨船高，报的人多，收的人多，分数线也很高; 去年校线 390，今年校线 360，30 分主要差在专业课上，18 考研人大应统专业课难度突然 提升，导致分数线下降，个人认为分数线的下降与数学今年较难无关; 专业课按照以往的经验全部是论述题，但 18 考研突然出了 50 分的证明题，确实有些措手不 及，其中有 30 分(我猜)大部分人都不太会，所以分数线明显下降，至于明年会不会再考 证明不好说。</li></ol><h3 id="二、-备考经验"><a href="#二、-备考经验" class="headerlink" title="二、 备考经验"></a>二、 备考经验</h3><h4 id="2-1-第一阶段"><a href="#2-1-第一阶段" class="headerlink" title="2.1 第一阶段"></a>2.1 第一阶段</h4><p>大三下学期即 2017.03-2017.07 大三下我还有课要上，而且课还不少，所以没有具体规划每天的时间，有大块时间就会去图 书馆，计划也是定的至少一个月以内的计划，并没有单日或单周计划。</p><blockquote><p>数学三 </p></blockquote><ul><li>复习资料:</li></ul><p>李永乐复习全书(红皮)及配套分阶习题、李永乐线性代数辅导讲义、张宇高数 基础班视频 复习进度:因为我有课，所以目标是期末(2017.07)之前刷过一遍全书和分阶习题即可， 实际进度也是如此。</p><ul><li>复习安排:</li></ul><p>按照高数、线性代数、概率论的顺序复习。</p><p>高数部分: 按照章节看张宇高数基础班视频并做笔记。张宇老师的课讲的非常精彩，前期复习比较迷 茫的话可以一听，个人认为听了该视频做过全书的话那么可以不必再看十八讲。 每看完一章视频，去做一章全书加一章配套的分阶习题。 在全书上，会且做对的题目标1，会但做错/不太会瞎蒙对的标2，不会的题目标3，其他 部分也同样如此，方便后续复习。</p><p>线代部分: 直接做了线性代数辅导讲义。个人认为做了线代辅导讲义那么全书的线代部分和分阶习题的 线代部分可不做。</p><p>概率论:刷全书+分阶习题。</p><blockquote><p>英语一 </p></blockquote><p>简单看了一下考研英语的语法视频，发现讲课内容主要集中在从句部分。而从句我的高中英 语老师讲得很好，我掌握得还可以，所以没有单独学习考研英语语法部分。如果同学觉得自 己从句部分掌握得不是很好，那么可以专攻一下英语的各种从句，不必听全套英语语法视 频浪费时间。</p><ul><li>复习资料</li></ul><p>扇贝 app 复习目标:没有具体目标，只希望自己能坚持每天打卡背单词，没有开始做英语真题。 复习安排:每天在扇贝上背 200-400 个单词，一个学期过去应该是背过了考研单词一轮。 </p><p>其他:我没有使用单词书(如新东方大绿皮)和看恋练有词视频的原因: 我一开始用大绿皮背单词，每天两个新的 list，还要复习。用单词书时会看的非常细致，每 一个意思都希望自己能够记住，先背再检验是否背了下来有时可能会用一整个上午的时间， 我觉得有点浪费时间，所以最后不看单词书选择用 APP 背单词; 恋练有词里面朱伟废话连篇，虽然可以快进但是体验不太好;另一个比较主要的原因是我看 过视频后不会立刻去背单词和他讲的词根词缀等东西，过了好几天再翻发现已经忘了，最后 索性就不看视频了。如果有同学能够坚持看下来的话应该效果也不错。</p><blockquote><p>432 统计学</p></blockquote><ul><li>复习资料</li></ul><p>人大出版的 统计学第四版、统计学第六版及配套学习指导书、应用回归分析、 时间序列分析、多元统计分析</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvqao9q7dj30ht0gqgmf.jpg" alt=""></p><ul><li>复习目标</li></ul><p>期末前看完上面所有书第一遍，不做笔记只是读书。 复习安排:有时间就看看，没有单日计划，能在暑假开始前看完即可。</p><blockquote><p>政治</p></blockquote><p>没看。</p><h4 id="2-2-第二阶段"><a href="#2-2-第二阶段" class="headerlink" title="2.2 第二阶段"></a>2.2 第二阶段</h4><p>暑假即 2017.07-2017.08在家，并没有每天学习，进度不快。</p><blockquote><p>数学三</p></blockquote><ul><li>复习资料</li></ul><p>李永乐复习全书(红皮)、李永乐 660 题、李永乐线性代数辅导讲义、第一轮自己做的笔记</p><ul><li>复习进度</li></ul><p>暑假内二刷完全书，做完了 660 题</p><ul><li>复习安排</li></ul><p>按照章节看全书和自己的笔记。看全书时，第一遍标1的题目不再看，只看标2和3的题 目，从前不会做的如今会做且做对那么将标号改为1，以此类推。 每看过一章全书和笔记做一章 660 题，我当时的目标是每天 50 道。</p><blockquote><p>英语一</p></blockquote><ul><li>复习资料</li></ul><p>张剑黄皮书三本，扇贝 APP</p><ul><li>复习目标</li></ul><p>继续每天背单词，阅读随缘</p><ul><li>复习安排:</li></ul><p>每天早上在扇贝上背 700 个单词再起床，大约用时 1h; 从张剑黄皮书最早的年份开始，只做阅读题。当时是(尽量)一天精读一篇，全篇落实笔头 翻译，进度非常慢。开学前没有做完第一本阅读。</p><ul><li>其他:</li></ul><p>为什么不直接做第二本第三本(题型更贴合的年份)? 学习方法需要慢慢摸索，用第一本书来大胆试错，省得把第二本和第三本浪费了。当时我全 篇翻译很费时间，所以进度很慢，后来只翻译阅读中的长难句，再后来只在心里默默翻译并 在卷子上标明句子结构，慢慢才找到适合我自己的方法。全篇翻译有必要吗?个人认为没有必要。</p><blockquote><p>432 统计学 </p></blockquote><p>资料同上，依然是每天默默看书，希望大家能够在暑假时把专业课笔记自己整理完。</p><blockquote><p> 政治</p></blockquote><p>没看。</p><h4 id="2-3-第三阶段"><a href="#2-3-第三阶段" class="headerlink" title="2.3 第三阶段"></a>2.3 第三阶段</h4><p>2017.09-2017.12</p><blockquote><p>数学三</p></blockquote><p>2017.09-2017.10</p><ul><li>复习资料</li></ul><p>李永乐复习全书(红皮)、李永乐 660 题、李永乐线性代数辅导讲义、第一轮自己做的笔记、李永乐数学三历年真题 复习进度:三刷全书(包括笔记和线代讲义)，看完了 660 的错题，做完了 97-17 的真题。 复习安排: 大约花了一个月的时间三刷全书和从前的错题，个人认为这段时间有点浪费，错题不必太纠 结; 三刷全书以后大约以每天一套数学三真题的速度往下刷，每做五套休息一到两天，整理真题 错题，易错的知识点及时复习。个人认为真题没有必要刷两三遍，因为比较简单。 2017.11-2017.12</p><ul><li>复习资料:</li></ul><p>李永乐 6+2 模拟题，张宇八套卷，张宇四套卷，合工大模拟题，</p><ul><li>复习安排</li></ul><p>每一套模拟题都定好闹钟在三小时内完成，做一套或两套休息一天来整理，及时回顾易错知 识点直到考前。模拟题没有二刷。 (即使是现在我也可以说数学是我复习的最好用时最长的一门，没想到考试的时候考砸分数 不高，对我来说特别遗憾。但我觉得复习的过程还是可以借鉴的，因为当时真的数学复习得 最用心 T^T)</p><blockquote><p>英语一</p></blockquote><p>阅读、完型、新题型、翻译部分:</p><ul><li>复习资料:</li></ul><p>张剑黄皮书，扇贝 APP</p><ul><li>复习安排:</li></ul><p>单词数自己决定，不要低于 200 也不要超过 600; 第一轮:每天精读两篇阅读，不包括完型新题型，全做过一遍后进入第二轮; 第二轮:每天精读两篇阅读，不包括张剑第一本，不包括完型新题型，全做过一遍后进入第 三轮; 第三轮:每天精读四篇阅读(即一年的)，不包括张剑第一本，每天一篇完型/新题型/翻译。 如果还有时间那么继续读真题阅读和完型新题型，没有时间三轮足矣。</p><ul><li>作文部分:</li></ul><p>12 月份开始每天背王江涛大小作文各一篇;12 月中旬看何凯文的作文模板视频并背诵。 (英语一我完型错了一个，阅读没错，新题型五个空错了四个，最后 78 分。个人认为阅读 的复习经验可以借鉴，新题型我也很无奈，作文和翻译(扣了 13.5 分)在北京的极旱区给 分我个人觉得还算可以，但是作文准备的并不是很充分，我考前一篇作文都没写过，不要学 我。)</p><blockquote><p>432 统计学 </p></blockquote><p>整理完笔记就是背诵，考前能够背过五轮就可以了。至于证明题由于我当时没有复习所以我 没办法给出比较好的实践过的建议。 除去背诵记得看真题。真题重要，真题参考答案也很重要。我联系了人很好的章华师兄，买了真题的参考答案，给自己做题方面指引了一些方向。 总之专业课就是一直背诵直到考前。</p><blockquote><p>政治 </p></blockquote><ul><li>复习资料</li></ul><p>肖秀荣精讲精练、肖秀荣一千题、肖秀荣时事政治小册子、肖秀荣八套卷、肖秀 荣四套卷、腿姐复习宝典</p><ul><li>复习安排</li></ul><p>2017.09-2017.11<br>看精讲精练做一千题，反正看完了做完了啥也没记住。<br>2017.11-2017.12<br>花了两天时间集中看了肖秀荣时事政治小册子，把时事政治部分搞定; 问答题背诵肖秀荣八套卷四套卷的问答题即可，18 考研肖秀荣全部命中; 选择题，看腿姐的复习宝典，有时间搭配视频来看，选择题效果拔群。</p><ul><li>其他:</li></ul><p>我为什么不看风中劲草: 风中劲草知识点太全了，把所有知识点都拿出来=什么都没说，背不下来浪费时间，不如多 看几遍腿姐的复习宝典(12 月份会出)(徐涛老师的也可以，总之选择题我认为不要靠风中 劲草或者一千题或者八套卷四套卷来提高，看各位老师总结的重点知识点比较有用)。<br>我</p><p>个人的复习经验大致如此，不一定适合每个人。成绩不高写这个经验帖感觉比较羞耻，希 望大家能够多看经验帖找到适合自己的学习方法而不是照搬他人。本人自制力较差，即使是 考前一周也会因为心情不好而在宿舍躺尸一天，相信大家严格要求自己肯定可以取得不错的 成绩。</p><h2 id="第五篇：18-年人大应用统计经验贴-by-冯亚宁"><a href="#第五篇：18-年人大应用统计经验贴-by-冯亚宁" class="headerlink" title="第五篇：18 年人大应用统计经验贴 by 冯亚宁"></a>第五篇：18 年人大应用统计经验贴 by 冯亚宁</h2><p>我本科就读于武汉某高校经济统计学专业，说实话，当初经历了专业调剂， 转专业的风波，最后也是阴差阳错选择了统计学。起初真的没抱太多的期望， 随着接触了越来越多的统计学知识，我渐渐的迷上了统计，这大概就是所谓的 “日久生情”吧。但是，随着毕业的尾声接近，我越来越觉得自己掌握的知识 有限，因此我决定继续进行统计方面的学习。在选择学校方面，我丝毫没有犹 豫的选择了人大，一是源自我高考的执念，二是人大统计真的非常让人向往。 讲了这么多，介绍一下我的基本情况，我是二战，两年都是应用统计学专业， 去年总分 388，今年 362，刚刚过线。答应了师兄要写经验贴，想想了一想，经验谈不上，分享一下我的一点心得吧，希望对师弟师妹们有所帮助。</p><h3 id="一、心态问题"><a href="#一、心态问题" class="headerlink" title="一、心态问题"></a>一、心态问题</h3><p>首先，我觉得一定不能偏科，要合理分配自己的时间。即使某一科学习不 太好，也不要让它成为你明显的短板。因为即使你有一科特别出彩，也很容易 被差的一科拉下来。我 17 年，政治 74，英语 62，数学 122，专业课 130，很明 显英语上就相对要低得多。我的经历就给大家作为一个反面教材，提个醒，希 望大家一定要各科均衡发力。其次，数学和专业课是大头。总看这几年的录取 名单，我们可以明显的发现数学和专业课好的同学成绩都比较靠前。希望大家 能够注重数学和专业课的学习。最后，一定要坚持。既然选择了考研，就一定 要记住自己的初心，坚持下去。期间很多同学保研、出国、工作，但是请一定 不要受他们影响。既然选择了远方，<br>那便只顾风雨兼程。</p><h3 id="二、时间安排"><a href="#二、时间安排" class="headerlink" title="二、时间安排"></a>二、时间安排</h3><p>我是 8 月份在人大附近租房准备的，如果有二战的小伙伴，有住宿或者相 关的问题可以问我，具体是作息时间安排，我借鉴一位师兄(花旗先生)的时 间表。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvqavyntcj30lf0ad3zu.jpg" alt=""></p><p>这只是我个人的时间安排，仅提供参考，希望对大家有所帮助。</p><h3 id="三、复习进度安排"><a href="#三、复习进度安排" class="headerlink" title="三、复习进度安排"></a>三、复习进度安排</h3><p>因为是二战，前期复习的比较快，后期主要是整理背记，查漏补缺。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvqb4sr0vj30j20jbdhv.jpg" alt=""><br>这些仅是个人的一点规划，虽然没有严格执行，但是基本上相差不大，学 弟学妹可以借鉴一下，每个人的学习能力都不尽相同，还是要结合自己的实际 情况，合理的安排计划。</p><h3 id="四、参考书目"><a href="#四、参考书目" class="headerlink" title="四、参考书目"></a>四、参考书目</h3><p>我用的书基本上跟学长的经验是一致的，详细的我就不介绍了，仅提供一 个书单，给大家参考一下。</p><ul><li>数学:</li></ul><p>《数学全书》 、《660 题》 《真题》、张宇《8 套卷》 、《1000 题》等;</p><ul><li>英语:</li></ul><p>张剑《英语一》全套，何凯文作文，《红宝书》等;</p><ul><li>专业课: </li></ul><p>《统计学》第六版、经管类《统计学》，《应用回归分析》，《多元统计分析》，《时间序列分析》等。注:今年专业课出现了证明题，大家可能要多看一本《概率与数理统计》， 关注一下证明题。</p><h3 id="五、感悟、感谢"><a href="#五、感悟、感谢" class="headerlink" title="五、感悟、感谢"></a>五、感悟、感谢</h3><p>考研的路上受到了很多人的关心和帮助，有家人的支持和关爱，有一个会 拿着糖葫芦坐十几站公交车来看“探视”我的闺蜜，还有学长的帮助，研友舍 友的陪伴，深深地情谊和感谢不是用言语可以表达的，只希望未来，大家都可 以心想事成，幸福安康!也希望我的经验可以为大家带来一点帮助，祝愿即将 考研的小伙伴们心想事成，金榜题名!</p><h2 id="第六篇：2018人大应用统计考研经验分享——by-wtt"><a href="#第六篇：2018人大应用统计考研经验分享——by-wtt" class="headerlink" title="第六篇：2018人大应用统计考研经验分享——by wtt"></a>第六篇：2018人大应用统计考研经验分享——by wtt</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvqbi8ocbj30gi0na76h.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvqbqlyyrj30gh0nbq5b.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvqbxmv8jj30gf0ncacj.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvqcfb9baj30ge0namza.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvqcusxjdj30gf0n975y.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvqd3cjwpj30gf0n975y.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvqdchkt1j30ge0n9t99.jpg" alt=""></p><h2 id="第七篇：2018-年人大应用统计考研经验贴-by-GGG"><a href="#第七篇：2018-年人大应用统计考研经验贴-by-GGG" class="headerlink" title="第七篇：2018 年人大应用统计考研经验贴 by GGG"></a>第七篇：2018 年人大应用统计考研经验贴 by GGG</h2><p>大家好!我本人是二战的考生，本科就读于中央财经大学应用统计专业，这 次初试成绩是 381 分，政治 67，英语 76，数学 125，统计学 113。关于时间安排 的问题，其实我也看过许多学长学姐的经验贴，写得很详细。不过我认为只要把 握好大体的复习阶段和节奏就好，具体的要看个人习惯，自己尝试几天，发现最 适合的时间段，分配好各科的复习，毕竟计划赶不上变化，要随机应变。这个一 会说每一科的时候再单独说。</p><p>在开始之前，其实我最想说的是复习的心态问题。我本人一战失败的原因有 两点:1.忙于上新东方的考研班，结果忽视了自己做题练习的重要性;2.没有搞 清楚主要矛盾，一些该暂时放下的不太重要的事情没有放下比如一些娱乐项 目….;3.拖延症，把计划想的很好，然后不执行。所以可以说，我一战失败是 必然的，查到初试成绩是 375 分，去年的分数线大家都知道是 390 分，几乎不用 等通知就知道肯定是没戏了。失落消沉是肯定有过的，这些都是很正常的情绪， 大家在今后的一段漫长的复习历程中可能也难免会有。一定不要否定自己当下的 某些负面情绪!不要压抑它，一切都是正常的流露，没有人能够做到一直斗志昂 扬从来不沮丧的。你想要开始好好复习，并不需要先调整好心态。事实上，什么 样的心态并不是最重要的，对复习效果也没什么影响，只要你在做、在学习、在 努力，你就在朝着目标前进，并且不知不觉中，你就会忘记沮丧。我妈和我说: 有担心的时间，还不如多看两页书多做两道题呢!一战失败后，我决定去换个环 境换个心态，就去银河证券实习了 2 个月，一边实习一边复习，也和其他的实习 生聊聊人生。当然一战失败的同学们可以选择别的调整方式，能走出来就好。</p><p>啰啰嗦嗦说了很多，就是希望各位学弟学妹在复习过程中感到有些孤独无助 的时候能知道，其实大家都是这么度过的。每天都要在心里告诉自己，再努力一 下，再坚持一会儿，你就能胜利了。</p><h3 id="一、数学三"><a href="#一、数学三" class="headerlink" title="一、数学三"></a>一、数学三</h3><p>我本人大一时学的是数分和高代，主要侧重定理的证明和推导，和考研数学 的侧重点是有所不同。所以，如果大学期间也是学的数分和高代的同学，不要觉 得高数和线代这本书相对简单就忽视它。数学的复习时间我喜欢安排在上午，英 语在午后。政治在之后的下午，晚上安安静静地看专业课。因为是二战，可能和 大部分同学的情况不一样，我个人的复习进度是:</p><p>3 月中旬到 6 月底，按章节，先看课本做例题(没做课后习题)，然后看《李 永乐考研数学复习全书》的相应章节，做例题，做错的题标注出来，认真研究。 注意，标号章节和题号，可以拿三个本，高数、线代、概率论各一个，方便后期 看错题。这本书编得不错的，我上过新东方的考研数学班，讲得也就是这本书上 的内容。</p><p>7 月到 8 月中旬，刷《数学基础过关 660 题》，我是按科目刷的，先高数、然 后线代、最后概率论。660 题，如果基础知识比较牢固(3 月到 6 月打好基础哦) 的话其实做起来也很快的，因为就是选择和填空，但是建议要留下简单的解题步 骤。我大概是每天刷 30 道题，后面线代和概率论部分可以每天多刷一点。<br>从 8 月中旬或者 9 月初开始，(1)首先，把之前的所有错题(大家不要忘记 标记哦)都再捋一遍，可以新找个本留下点痕迹。其实也不用抄错题，我的做法 是把每道错题都总结成一句或一小段简短的文字或公式，然后时时翻看。这个工 作可以坚持到最后一天，且各科都适用!</p><p>(2)然后，就可以开始每天早 8 点到 11 点的每日一套卷刷题时光啦~回想起这 段时光、真是忙碌又充实又很有成就感!注意自己要掐好时间，一定要习惯在有 紧张感的条件下做题。一开始会觉得时间紧张，但是慢慢就学会怎么安排时间了。 用 3 个小时做完一套卷子之后，大概还要用 1 个多小时的时间来改错和总结，大 家千万不要做完就完了!至于做什么卷子，先做近 15 年的真题，然后差不多《张 宇 8 套卷》就出了!(注意，张宇的卷子会比较难、刚一接触会有受挫感，但是 没关系都这样!大家其实可以去关注一波张宇的微博，还挺正能量的。至于为什 么要推荐张宇的卷子而不是李永乐的，大家也可以买来李永乐的卷子看看，我个 人认为含金量不高。)之后还有会一段时间才会出 4 套卷，这段时间好好要回顾 一下，也可以二刷真题之类的。做完张宇的卷子再做真题就会发现真题 so easy! 真题很重要，一定要好好研究。但同时多做模拟题也是很有好处的，谁做谁知道。 注意:在此之前一直是数学占用的时间比较多，到后期可能别的科目会有很多 要背的东西比如政治。但是!大家一定不要把数学放下!必须要保持做题的手 感的，张宇老师说过，数学这东西一个月不做题就基本废了。所以，真心建议 每天一套卷子，一直到考研的前一天!</p><h3 id="二、政治"><a href="#二、政治" class="headerlink" title="二、政治"></a>二、政治</h3><p>关于用书，感觉没什么好说的，就是肖秀荣的一系列全套。</p><p>4 月中旬到 7 月底，看《命题人知识点精讲精练》，看完一章，做章节后的仿 真模拟题。注意精讲精练上的题只有答案，有错的要自己回到书中去找到出处， 然后画出来。建议看书的顺序是:马原——史纲——毛中特——思修。马原比较 晦涩难懂，没关系也不用太懂，靠做题分清什么事重点!毛中特可以结合着史纲 来看，因为两者讲得基本上是同一历史时期的事件，只不过史纲偏重事件的历史 意义，毛中特偏重政策理论。思修比较简单，考试也只靠重点几章，这些肖秀荣 老师都会考诉你的~形势和当代部分可以先不看。</p><p>8 月到 10 月，刷《命题人 1000 题》。我这年的题我数了一下，选择 1514 道 (没错!命题人大约 1000 题)，分析题 43 道(分析题可以先不做)。选择题做起 来很快的，我自己是每天 80 道(马原、史纲、毛中特、思修，一共 4 部分嘛， 每部分做单选多选各 10 道)，20 天就刷完一遍了。然后，看错题，刷第二遍! 注意只做一遍是肯定不行的，按肖秀荣老师的说法，最好能刷 3 遍呢(虽然我只 刷了 2 遍，但注意我是二战的)。另外，近 10 年的真题的选择题部分(时政不用 管它)也应该做一下。注意选择的错题一定要好好看答案，搞清楚为什么!</p><p>10 月到 11 月，那本《命题人形式与政策以及当代世界经济与政治》的小册 子就出了。上编《形势与政策》包括 116 道选择题，大家看一遍然后把后边单选 题做了，时政部分就基本 OK 了。下编《当代世界经济与政治》的每个专题都有 一些分析题，这些题就可以适当地看看了，理解一下答题的逻辑，因为 10 月份 热点事件差不多都发生了，和后边的 8 套卷里的当代部分的题也都比较像了的。 之前做过的选择题的错题再好好看看!然后，看近 3 年的真题分析题，看看分析 题是怎么出的，答案应该怎么回答。<br>11 月到 12 月，自己做《命题人 8 套卷》的选择题，选择题的答案会编的比较用心，建议都看一遍。熟读分析题答案!(能背一背最好)</p><p>12 月份(从 4 套卷出了开始，记得提前预定!)到考试前，一定要把分析题的答 案背下来!选择部分的建议和 8 套卷一样。很多人觉得难背，其实…就是很难背!<br>我也是靠前头天晚上才差不多可以背下来。</p><p>总之，政治我考得也不算高，但是这么复习下来应该也不会考得太低。</p><h3 id="三、英语一-2"><a href="#三、英语一-2" class="headerlink" title="三、英语一"></a>三、英语一</h3><p>怎么说呢，我没有像很多人一样拿本书或者手机 app 刷单词，我看的单词都 是我在做阅读的时候自己总结的。我自认为这个方法挺好的，毕竟单词还是要在 文章中学习。用的书就是新东方的《考研英语历年真题详解及复习指南》，到后 期 10 月份以后我有刷过阅读的模拟题。</p><p>英语的复习我认为就分成两个阶段吧:</p><p>8 月底之前，做 1999-2010 的历年真题的阅读理解，每天一到两篇，也不用 严格计时，做完之后每道题都认真看答案，如果做错了，一定要搞清楚自己当时 是怎么错的。然后，仔细阅读文章，也不一定要非要翻译，但是一点要做到看懂 每一句话。这个其实好好看新东方那本书就行了，书上已经把单词、短语总结得 很好了。找个小本本，有不认识的单词一定要写下来，记好词性，至于单词对应 的中文，只写你在文中碰到的那个，不要一下写一堆中文意思，不好记的。记单 词的那个本要经常翻看!</p><p>9 月份开始，继续做 2011-2017 年的真题阅读理解，可以计时用 50 分钟做 完 4 篇阅读，对个答案，然后第二天第三天再精度文章，练习考试的感觉;也可 以一天做一到两篇，还和之前一样。总之阅读也是要保持感觉得，单词也要坚持 看，一直到考试前一天。其次，要开始练习写作了。建议先找一本比如说新东方 的写作书，背几篇范文，熟悉下考研英语写作的套路，然后再自己写。注意，自 己动手写作很重要!</p><h3 id="四、432-统计学"><a href="#四、432-统计学" class="headerlink" title="四、432 统计学"></a>四、432 统计学</h3><p>专业课的复习各路大神已经总结得尽善尽美了，我只是把我复习时参考的<br>ZH 学长的经验贴贴出来!就是如下的 2000 多字，总结得可以说非常详细了! 复习用书:</p><ul><li>贾俊平《统计学》第四版(经管类) </li><li>贾俊平《统计学》第六版(21 世纪统计学系列教材) </li><li>何晓群《多元统计分析》</li><li>王燕 《时间序列分析》</li><li>何晓群《应用回归分析》</li></ul><p>复习方案: </p><blockquote><p>贾俊平《统计学》:</p></blockquote><p>一开始看的是第六版，作为门外汉的我觉得这本书还是蛮简单的，因为之前学过数理统计的一些课程，所以理解起来也不难，而且框架 体系也比较清晰，基本上一个章节一天就 OK，看了两遍，然后整理了自己的笔 记。后来了解到原来第四版的内容更饱满一些，就把第六版没有的内容补看了下， 做了笔记。而且今年出事的时候出了一道实验设计的题，最后阶段预测的时候是 万万没有想到会出这个题，所以，建议看第四版，内容全。但我又比较喜欢第六 版的表述，两本结合着看吧，但是第六版上没有的内容一定要补全，像实验设计、哑变量、指数平滑、主成分和因子分析、聚类分析(这俩个属于多元统计分析) 都要添加上去。非参数统计我看了一遍，整理了下笔记，稍微背诵了下，不过复 试的时候有人被问到了，所以也要好好看。复试的时候老师问了我关于哑变量的， 幸好看了第四版。</p><blockquote><p>何晓群《多元统计分析》</p></blockquote><p>吐槽一句，这本书写得像哲学，个人感觉是直接 从英文版翻译过来的，很多表述都没有做到像贾俊平那本书那么通俗易懂。我只 看到了第八章典型相关分析，真的很难说会不会考之后那几章，就目前来看是小 概率事件。这本书最关键的是统计分析方法的基本理论原理、分析步骤和以及去 对应可以解决的问题，不需要去死抠推导过程，这不是 432 需要重视的，但是对 于理解还是有帮助的，有兴趣的可以推推看。16 年没考这部分内容， 但不能预计 17 年会不会考，要复习的全面一些。一些问答题都要结合历年真题 自己根据课本进行总结。</p><blockquote><p>王燕《时间序列分析》:</p></blockquote><p>这本书的编写就相对好得多，条理很清晰，思路引 导很顺畅，一些例题也比较易懂，重点是各种预测描述模型，今年考了一道 08 年学硕考过的题:有趋势有季节变动可建立的模型，写出模型形式并简要说明。 可见学硕的历年真题也是很有借鉴意义的。之前也考过差分运算的，复习的时候 也要注意这种细节，但是这本书里面的例子特别好，几道题对应相应的知识点， 只要你一点点看下来理解了，然后把笔记整理好，后期再背诵下，应该没啥问题。</p><blockquote><p>何晓群《应用回归分析》:</p></blockquote><p>一直以为何晓群老师是个女老师，后来复试的时候 才了解到并非如此。这本书写的也很有条理，多重共线性的后果诊断处理已经多 次考到，自相关性和异方差还没出过，今年考了一个判定系数的解释，当时预测 了几道觉得会考的题，里面就有判定系数和回归模型的综合评价，初试的时候就 考到了，这个虽然比较简单，但可以尝试的方法就是在考试之前，自己预测一些 题，自己给自己出题做，涵盖面广一些，会有意想不到的结果的。</p><blockquote><p>关于真题:</p></blockquote><p>真题强调上百遍都不夸张，他对于你复习的方向有很大的启示作 用。我当时的做法就是把真题整理成八个专题，分别是:《专题一:图表展示与 概括性度量》、《专题二:统计量与抽样分布》、《专题三:参数估计与假设检验》、 《专题四:分类数据分析》、《专题五:方差分析与实验设计》、《专题六:回归分 析》、《专题七:时间序列分析》、《专题八:多元统计分析》，学硕和专硕的历年 真题都要整理分类，基本上人大每年考的都包含在八个专题之间，你需要做的就 是自己认认真真的从课本上找出答案来，然后总结一遍，一些学硕要求的比较偏 数理的可以忽略，需要明确的是，重点一定会反反复复的考，而且乐此不疲，像 今年时序和回归的题都是曾经考过的，几乎一模一样。</p><blockquote><p>关于笔记:</p></blockquote><p>自己整理的笔记的字迹一定要清晰，条理要很清楚，但这是建立 在你把书看了几遍理解透了之后才可以做到的事，当然一开始不理解，到后面反 复的背诵就会逐渐清晰起来了。当时我是和真题一样分了八个专题，参照人大大数据陈思聪学长的笔记整理了手写的笔记，学长的笔记结构完整，内容完善，当 时是如获至宝，每天看着它整理自己的笔记的心情相当愉悦，对我的专业课起到 了至关重要的作用，在这里谢谢学长。在复习过程中，我发现自己常常会对知识 的首次记忆有所偏颇，只知其一不知其二，以为已经完全理解了其确切的意思， 但其实当我在复试复习的时候再回过头来看往往会有更多新奇的发现，此时的知 识域相对来说也会完善一些。</p><blockquote><p>关于背诵</p></blockquote><p>心理学中有一个广为认可的记忆机制，即:我们在记忆的时候将 许多线索(诸如对一个原理的发散性理解、当时联想的事物的多样性)一并编码进入记忆中，能否长时间的保持知识的新鲜感或者说在大脑中的活跃度，取决于 这些线索是否足够丰富，这就为理解记忆提供了有力的证词。贯彻于专业课的背 诵上，其实各个统计方法知识中包含了精确的概念、严谨的逻辑、一般的原则、 生动的背景等无数的记忆线索，而并非是孤立的、任意的文本序列，各个点之间 具有并列、递进、相互排斥的种种关系，推导和演绎出这种联系，从而由点到面， 搭建成一个大的框架体系，就是我个人比较推崇的思维导图，如此进行下去到考 研前几天可以看着那张大的框架图自己逐条背诵，口头表达可以和原文范本有出 入，但是关键词必须要锁定，大致意思要接近。</p><h2 id="第八篇：2018人大应用统计经验贴——by-XXX"><a href="#第八篇：2018人大应用统计经验贴——by-XXX" class="headerlink" title="第八篇：2018人大应用统计经验贴——by XXX"></a>第八篇：2018人大应用统计经验贴——by XXX</h2><p>看到今年还有去年的经验贴，我的复习策略跟他们大致相同。但也希望我的经验，能给学弟学妹们一点不一样的启示。个人基本情况：一战人大应统，总分370+ 本科北京某双非大学 数学专业。跟大多数考上的同学比，也算是个逆袭了。所以双非同学要有信心，只要持之以恒坚持下去，考上人大是可以的。<br>复习过程大致分为三个阶段。</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>大三下学期，每天大约学习考研知识5-6个小时（除了上课）。大三下学期一开始我就已经确定要考人大了。所以一切就全部针对人大应统而复习了。政治一点也没看，专业课看到人大出题相对简单，所以就把复习重点放到选修课 ： 回归分析 跟 多元统计分析，其它除了上课就没在复习专业课的知识了。英语这个学期就是把恋恋有词看了两三遍遍，感觉单词都差不多了解了，然后一个小时做了05年真题阅读错了三个，可以说这一学期英语学习取得很好效果吧。数学呢，一学期做完了36讲跟三分之二的复习全书（其实选择一个就可以了），做了17年真题大约125吧，虽然有的题之前做过，但也满意复习结果</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>暑假期间（业内人士称为考研期间的遵义会议）先回家呆了一个星期看完了人民的名义。回来后就开启了全面复习计划（但从这个角度而言遵义会议好像不太合适了）。</p><p>每天学8-9小时。数学结束复习全书的内容，还完成了660题（这个跟1000题选一个就好了）。英语就是一个星期做一年真题，有听网上老师的讲解。政治一天学也就一个小时或者不到，看哲学跟政经部分。专业课在认真看课本，也买了几家学长的资料，总之，专业课下的资本比较大，舍不得孩子套不着狼，能考上就值了。</p><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>大四上学期，每天6-7；9-10月由于开学有课学校也来了好多人加之略显疲惫，颓废了。数学上了学校里面老师讲的关于考研的课，再复习了一下前面学过的内容。政治看完了近代史，毛概的一部分（因为要开19大好多就留到后面复习了）。英语还是按着暑假的节奏走。专业课，主要复习回归跟多元部分了。10-12.23，这个时间是考研的冲刺时间，每天大概学习9-10个小时吧。数学每天一套历年真题或者模拟题，3小时左右，市面上大部分模拟题做过了。 政治，学完基础知识后，刷了好多好多选择题各种模拟题，每天学2-3小时，最后大题就是往死里背肖八肖四。专业课，3小时左右，基础知识刷好几遍，然后研究历年真题，总结出题规律。英语，时间压缩到一个小时左右，结果证明这是 一个错误之举。最后按照考试时间模拟了几场考试，为考试找感觉。</p><p>考研成绩与努力程度成正比，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年中国人民大学应用统计专业硕士经验贴合集&lt;/p&gt;
    
    </summary>
    
      <category term="人大应统部落" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E9%83%A8%E8%90%BD/"/>
    
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（9）：DCNN</title>
    <link href="http://yoursite.com/2018/03/25/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89%EF%BC%9ADCNN/"/>
    <id>http://yoursite.com/2018/03/25/自然语言处理系列（9）：DCNN/</id>
    <published>2018-03-25T15:14:45.000Z</published>
    <updated>2018-11-03T12:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="http://www.cs.wayne.edu/~mdong/Kalchbrenner_DCNN_ACL14.pdf" target="_blank" rel="noopener">A Convolutional Neural Network for Modelling Sentences</a></p><p>准确地表达句子的能力是语言理解的核心。我们描述了一个被称为动态卷积神经网络(DCNN)的卷积结构，我们采用的是句子的语义模型。该网络使用动态k-Max池，一个通过线性序列的全局池操作。该网络处理不同长度的输入句子，并在句子中归纳出一个特征图，可以明确地捕捉短和长期的关系。该网络不依赖于解析树，并且很容易适用于任何语言。我们在四个实验中对DCNN进行了测试:小尺度二进制和多类情绪预测，六道问题分类和远程监控的推特情绪预测。该网络在前三项任务中取得了出色的性能，并且在最后一项任务中，在最强大的Baseline上减少了25%的错误。</p><a id="more"></a><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>句子模型的目的是为了分析和表征句子的语义内容，以达到分类或生成的目的。句子建模问题是许多涉及到一定程度的自然语言理解的任务的核心。这些任务包括情绪分析、意译、识别、总结、语篇分析、机器翻译、基础语言学习和图像检索。由于个别句子很少被观察到或根本没有被观察到，所以一个句子必须根据经常被观察到的句子中的单词和短的n-grams来表示一个句子。句子模型的核心是一个特征函数，它定义了从单词或n-grams的特征中提取句子特征的过程。</p><p>各种各样的模型方法已经被提出来了。基于组合的方法已经应用于从共现统计中得到的单词意义的向量表示，从而获得更长的短语的向量。在某些情况下，组合是由代数运算来定义的，而不是词义向量来生成句子的意思 (Erk and Pado ́, 2008; Mitchell and Lapata, 2008; Mitchell and Lapata, 2010; Tur- ney, 2012; Erk, 2012; Clarke, 2012).。在其他情况下，一个复合函数被学习，或者与特定的句法关系有关(Guevara, 2010; Zanzotto et al., 2010) 或特定的词类型相关联(Baroni and Zamparelli, 2010; Coecke et al., 2010; Grefenstette and Sadrzadeh, 2011; Kart- saklis and Sadrzadeh, 2013; Grefenstette, 2013)。另一种方法是用自动提取的逻辑形式来表示句子的意义 (Zettlemoyer and Collins, 2005)。</p><p>核心模型是基于神经网络的模型。这些范围从基本的神经词袋或n-grams模型到更结构化的递归神经网络，以及基于卷积运算的时滞神经网络(Collobert and Weston, 2008; Socher et al., 2011; Kalchbrenner and Blunsom, 2013b)。神经网络句模型有很多优点。他们可以通过预测，例如，利用单词和短语的上下文，来获得单词和短语的一般向量。通过监督训练，神经网络句模型可以将这些向量调整为特定于某项任务的信息。除了将强大的分类器作为其体系结构的一部分之外，还可以使用神经句模型来建立一个神经语言模型来逐字生成句子 (Schwenk, 2012; Mikolov and Zweig, 2012; Kalchbrenner and Blunsom, 2013a)。</p><p>我们定义了一个卷积神经网络结构，并将其应用于句子的语义建模。该网络处理不同长度的输入序列。在网络中，层间层交织着一维的卷积层和动态k-max池化层。动态k-max池是最大池操作的一般化。最大池操作符是一个非线性的子采样函数，它返回一组值的最大值 (LeCun et al., 1998)。该算子在两个方面是广义的。首先，k-max在一个线性序列上集合，返回序列中k最大值的子序列，而不是单个最大值。其次，可以通过将k作为网络的另一种功能或输入来动态选择池参数k。</p><p>卷积层在句子矩阵的每一列特征上都应用了一个可编辑的过滤器。在句子中的每一个位置上，将相同的过滤器与n-gram进行卷积，使得这些特征可以独立于句子中的位置提取出来。一个卷积层接着是一个动态池层和一个非线性形式的feature map。就像在对象识别的卷积网络中，我们通过对输入语句应用不同的过滤器来计算多个特征映射来丰富第一层的表示。后续层还具有多个特征映射，这些特征映射通过与下面一层的所有映射进行卷积来计算。这些层的权值构成一个四维张量。由此产生的结构被称为动态卷积神经网络。</p><p>卷积和动态池操作的多层结构会在输入语句中引入结构化特征图。图1展示了这样一个图。在较高层次的小筛选器可以捕获在输入句中相隔很远的非连续短语之间的句法或语义关系。特征图引入了一种类似于语法分析树的层次结构。这种结构与纯句法关系无关，是神经网络的内部结构。</p><p>我们在四种环境中进行网络实验。前两个实验包括预测电影评论的情绪(Socher et al., 2013b)。该网络在二进制和多类实验中都优于其他方法。第三个实验涉及在TREC的数据集下的六个问题类型的分类 (Li and Roth, 2002)。该网络与其他基于大量工程特性和手工编码的知识资源的先进方法的准确性相一致。第四项实验是通过远程监控来预测Twitter帖子的人气(Go et al., 2009)。该网络接受了160万条推文，根据出现在他们身上的表情符号自动标记。在手工标记的测试集上，在Go et al.(2009)中所报告的最强的unigram和bigram基线的预测误差中，该网络减少了超过25%。</p><p>论文的提纲如下。第2节描述了DCNN的背景，包括中心概念和相关的神经句模型。第3节定义了相关的操作符和网络的层。第4节介绍了网络的诱导特征图和其他属性。第5节讨论了实验，并考察了学习的特征检测器。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><p>DCNN的层是由一个卷积操作和一个池化操作形成的。我们首先回顾一下相关的神经网络句模型。然后描述了一维卷积和经典时滞神经网络的运算(TDNN) (Hinton, 1989; Waibel et al., 1990)。通过在网络中加入一个最大池化层，TDNN可以被作为一个句子模型来使用(conbert and Weston, 2008)。</p><h3 id="2-1-Related-Neural-Sentence-Models"><a href="#2-1-Related-Neural-Sentence-Models" class="headerlink" title="2.1 Related Neural Sentence Models"></a>2.1 Related Neural Sentence Models</h3><p>各种各样的神经网络语言模型已经被提出。基本句型模型的一般类型是神经网络词汇(NBoW)模型。这些通常包括一个投影层，将单词、子字单元或n-grams映射到高维的嵌入。然后将组件与操作(如求和)组合在一起。所产生的组合向量通过一个或多个全连接层进行分类。</p><p>采用外部解析树提供的更一般结构的模型是递归神经网络 (RecNN) (Pollack, 1990; Ku ̈chler and Goller, 1996; Socher et al., 2011; Hermann and Blunsom, 2013)。在树的每个节点上，节点的左右子节点都由一个经典层组合起来。该层的权值在树的所有节点上共享。在顶部节点计算的层给出了这个句子的表示。递归神经网络(RNN)是递归网络的一种特殊情况，它所遵循的结构是一个简单的线性链(Gers and Schmidhuber, 2001; Mikolov et al., 2011)。RNN主要作为一种语言模型，但也可以被看作是一个线性结构的句子模型。在最后一个单词中计算的层代表这个句子。最后，基于卷积运算和TDNN架构，进一步构建了一类神经语句模型 (Collobert and Weston, 2008; Kalchbrenner and Blunsom, 2013b)。这些模型中使用的某些概念是DCNN的核心，接下来我们将描述它们。</p><h3 id="2-2-Convolution"><a href="#2-2-Convolution" class="headerlink" title="2.2 Convolution"></a>2.2 Convolution</h3><p>一维卷积是一个权重向量$m\in R^m$和一个被视为序列的输入向量$s\in R^s$之间的运算。向量m是卷积的滤波器。具体地说，我们认为s是输入语句，$s_i$是与句子中第i个单词相关的单一特征值。一维卷积背后的思想是在句子中求每个m-gram与向量m的点积，从而获得另一个序列$c$：</p><script type="math/tex; mode=display">c_j = m^T s_{j−m+1:j}\qquad (1)</script><p>根据j的取值范围，公式1给出了两种类型的卷积。窄卷积要求$s≥m$，序列$c\in R^{s-m+1}$的j的范围是$m$到$s$。宽卷积对s或m没有大小要求，序列$c\in R^{s-m+1}$的索引j的范围是1到$s+m-1$。超出范围($i<1或者i>s$)的输入值$s_i$会被设为零，狭义卷积的结果是广义卷积结果的子序列。两种一维卷积在图2中得到了说明。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4jx1yf3j309q03lt8n.jpg" alt=""></1或者i></p><p>过滤器m中训练的权重相当于一个语言特征检测器，它学习对一个特定的n-gram进行编码，这些n-grams为大小n≤m,m是滤波器的宽度。在一个宽的卷积中应用权重m比在一个窄的卷积中应用它们有一些优势。一个宽卷积可以确保过滤器中的所有权重达到整个句子，包括边缘的单词。当m被设置为相对较大的值(比如8或10)时，这是非常重要的。此外，宽卷积保证了滤波器m对输入语句的应用总是产生一个有效的非空结果c，独立于宽度m和句子长度s。我们接下来描述一个TDNN的经典卷积层。</p><h3 id="2-3-Time-Delay-Neural-Networks"><a href="#2-3-Time-Delay-Neural-Networks" class="headerlink" title="2.3 Time-Delay Neural Networks"></a>2.3 Time-Delay Neural Networks</h3><p>TDNN将一系列的输入序列与一组权重m进行卷积。在语音识别的TDNN (Waibel et al.， 1990)中，序列s被视为具有时间维度，而卷积应用于时间维度。每一个$s_j$往往不只是一个单一的值，而是一个d个数字组成的向量，因此$s\in R^{d×s}$。同样,m是一个大小为d×m权重矩阵。每一行m与相应的s行卷积，卷积通常是窄类型的。将生成的序列c作为输入到下一层，可以叠加多个卷积层。</p><p>Max-TDNN句子模型是基于TDNN的体系结构 (Collobert and Weston, 2008)。在模型中，窄卷积被应用到句子矩阵s上，其中每一列对应句子中的一个词的特征向量$w_i\in R^d$</p><script type="math/tex; mode=display">s=[w_1 ... w_s] \qquad (2)</script><p>为了解决不同的句子长度问题，Max-TDNN在生成的矩阵c中取每一行的最大值，从而产生一个d个数组成的向量。</p><script type="math/tex; mode=display">{ C }_{ max }=\begin{bmatrix} max({ c }_{ 1,: }) \\ ··· \\ max({ c }_{ d,: }) \end{bmatrix}\qquad (3)</script><p>目标是捕捉最相关的特性，即对于生成的矩阵c的d行中的每一个具有最高值的特性。然后将固定大小的向量cmax作为输入，用全连接层进行分类。</p><p>Max-TDNN模型有许多可取的特性。它对句子中单词的顺序很敏感，它不依赖于外部语言特定的特性，如依赖关系或选区解析树。它对句子中每个单词的信号都有很大程度的统一的重要性，除了边缘上的单词，在计算窄卷积时次数更少。但该模型也有一些局限性。特征检测器的范围仅限于权重的跨度m。增加m或叠加多卷积层的窄类型使特征检测器的范围更大。与此同时，它也加剧了对句子边缘的忽视，增加了卷积所需要的输入语句的最小规格s。由于这个原因，高阶和远程特性检测器不能很容易地并入模型中。最大池操作也有一些缺点。它无法区分一个行中的相关特性是否只发生一次或多次，它会忘记特征发生的顺序。更普遍的是,池因子的减少信号矩阵的对应于s−m + 1。即使是对于中等的s，池因子也可能是过量的。下一节的目的是在保留优势的同时解决这些限制。</p><h2 id="3-Convolutional-Neural-Networks-with-Dynamic-k-Max-Pooling"><a href="#3-Convolutional-Neural-Networks-with-Dynamic-k-Max-Pooling" class="headerlink" title="3 Convolutional Neural Networks with Dynamic k-Max Pooling"></a>3 Convolutional Neural Networks with Dynamic k-Max Pooling</h2><p>我们使用一个卷积结构来建模句子，它通过动态的k-max池来交替使用宽卷积层和动态池层。在网络中，中间层特征图的宽度取决于输入句子的长度。所得到的体系结构是动态卷积神经网络。图3表示一个DCNN。我们开始详细描述这个网络。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4jnu9nnj30bq0hzjsf.jpg" alt=""></p><h3 id="3-1-Wide-Convolution"><a href="#3-1-Wide-Convolution" class="headerlink" title="3.1 Wide Convolution"></a>3.1 Wide Convolution</h3><p>给定一个输入句子，获得DCNN的第一层，其中，我们得到每个句子的每个词的词嵌入表示$w_i\in R^d$，然后构造一个句子矩阵$s\in R^{d×s}$，如（2）式所示。嵌入的值$w_i$是在训练期间优化的参数。网络中的卷积层是通过对权值矩阵$m$和下一层的激活矩阵进行卷积操作得到的。例如，第二层是通过将卷积应用到句子矩阵s本身来获得的。维度d和滤波器宽度m是网络的超参数。我们让这些操作是一维宽卷积，如第2.2节所述。由此产生的矩阵c的维度为$d×(s + m−1)$</p><h3 id="3-2-k-Max-Pooling"><a href="#3-2-k-Max-Pooling" class="headerlink" title="3.2 k-Max Pooling"></a>3.2 k-Max Pooling</h3><p>接下来我们描述的是一个池化操作，它是在Max-TDNN语言模型中的关于时间维度的最大池化操作的一般化，不同于用于目标检测的卷积网络中使用的局部最大池化操作 (LeCun et al., 1998)。给定一个值k，和一个长度为$p$的序列$p\in R^p$ (p&gt;k)，$k-max pooling$选择了一个由向量p中最大的数值组成的子序列$p_{max}^k$。$p^k_{max}$中值的顺序对应于它们在p中的原始顺序。</p><p>k-max池操作使得选出在p中的k个最活跃特征成为可能，它们位于一些不同的位置。它保留了特征的顺序，但对它们的特定位置不敏感。它还可以更精细地分辨出在p中，特征被高度激活的次数，以及在p上的特征变化的被高度激活的状况。将k-max池运算符应用于最顶层卷积层后的网络中。这保证了全连接层的输入独立于输入句子的长度。但是，正如我们接下来看到的，在中间卷积层中，池参数k不是固定的，而是动态选择的，以便能够平滑地提取更高阶和更长的特性。</p><h3 id="3-3-Dynamic-k-Max-Pooling"><a href="#3-3-Dynamic-k-Max-Pooling" class="headerlink" title="3.3 Dynamic k-Max Pooling"></a>3.3 Dynamic k-Max Pooling</h3><p>一个动态k-max池操作是一个k-max池操作，我们让k成为句子长度和网络深度的函数。虽然可能有很多函数，但我们只是简单地将池参数建模如下：</p><script type="math/tex; mode=display">K_{l}=\max \left( k_{top}, \left \lceil \frac {L-l}{L} s \right \rceil \right)\qquad (4)</script><p>其中l表示当前卷积的层数（即第几个卷积层），L是网络中总共卷积层的层数；$k_{top}$为最顶层的卷积层pooling对应的k值，是一个固定的值。举个例子，例如网络中有三个卷积层，$k_{top}=3$，输入的句子长度$s=18$；那么，对于第一层卷积层下面的pooling参数$k_1=12$，而第二层卷积层的pooling参数$k_2=6$，第三层有固定的池化参数$k_3=k_{top}=3$。方程4是描述第l部分的序列的相关部分在长度为s的句子上的相关部分所需要的数值数量的模型。对于情绪预测中的一个例子，根据方程，在长度s的句子中，一阶特征，例如一个正数，大多数出现$k_1$次，而另一个二阶特征，如否定句或子句，最多出现$k_2$次。</p><h3 id="3-4-Non-linear-Feature-Function"><a href="#3-4-Non-linear-Feature-Function" class="headerlink" title="3.4 Non-linear Feature Function"></a>3.4 Non-linear Feature Function</h3><p>在动态池化应用于卷积的结果之后，一个偏置项$b\in R^d$和一个非线性函数$g$被应用于被池化的矩阵的每一个元素。每个集合矩阵的每一行都有一个单偏差值。如果我们暂时忽略池化层，我们可以说明在卷积层和非线性层后如何计算矩阵$a$中的d维的列a。定义M为对角矩阵。</p><script type="math/tex; mode=display">M=[diag(m:,1),···,diag(m:,m)] \qquad (5)</script><p>其中m为宽卷积的d维滤波器的权值。然后，在第一对卷积和一个非线性层之后，矩阵a中的每一列a得到如下所示，对于一些索引j：</p><script type="math/tex; mode=display">a=g\left( M\begin{bmatrix} { w }_{ j } \\ ··· \\ { w }_{ j+m-1 } \end{bmatrix}+b \right) \qquad (6)</script><p>这里a是一列的一级特征。二阶特征也类似于将公式（6）应用于一个序列的一阶特性$a_j,…a_{j + m′−1}$与另一个权重矩阵$m′$。除了池，公式（6）是特征提取函数的核心，它有一个一般形式。特征函数与池化才操作引入了位置不变性，使高阶特征变量的范围变大。</p><h3 id="3-5-Multiple-Feature-Maps"><a href="#3-5-Multiple-Feature-Maps" class="headerlink" title="3.5 Multiple Feature Maps"></a>3.5 Multiple Feature Maps</h3><p>到目前为止，我们已经描述了如何应用一个宽卷积，一个(动态的)k-max池化层和一个非线性函数到输入句子的矩阵来获得一阶特征图。这三种操作可以重复，以生成递增顺序的特征图和增加深度的网络。我们用$F_i$来表示第i阶的特征图。在对目标识别的卷积网络中，为了增加特定顺序的学习特征检测器的数量，可以在同一层并行计算多个特征映射。每一个特征映射$F_j^i$是通过不同的滤波器来对矩阵$m_{j,k}^i$和第$i-1$阶的特征映射$F_k^{i-1}$进行卷积操作，并把结果加和：</p><script type="math/tex; mode=display">F_j^i=\sum^n_{k=1}m^i_{j,k}*F_k^{i-1}\qquad (7)</script><p>其中∗表示宽卷积。权重$m^i_{j,k}$构成一个4阶张量。在宽卷积之后，首先进行动态k-max池化，然后将非线性函数分别应用于每个映射。</p><h3 id="3-6-Folding"><a href="#3-6-Folding" class="headerlink" title="3.6 Folding"></a>3.6 Folding</h3><p>到目前为止，在网络的形成过程中，应用于句子矩阵的单个行的特征检测器可以有多种顺序，并在多个特征映射的同一行中创建复杂的依赖关系。然而，不同行的特征检测器相互独立，直到顶部的全连接层。可以通过在Eq. 5中使M变成满矩阵来实现完全依赖于不同的行，而不是一个稀疏矩阵的对角线。在这里，我们探索一种更简单的方法，称为折叠，它不引入任何其他参数。在一个卷积层之后，动态k-Max池化之前，将一个feature map组件中的每两行相加。对于d行的映射，折叠返回d/2行的映射，从而使表示的大小减半。使用折叠层之后，第i层的特征探测器现在依赖于更低的第$i-1$层的两行特征值。这样我们结束了对DCNN的描述。</p><h2 id="4-Properties-of-the-Sentence-Model"><a href="#4-Properties-of-the-Sentence-Model" class="headerlink" title="4 Properties of the Sentence Model"></a>4 Properties of the Sentence Model</h2><p>我们描述了基于DCNN的句子模型的一些属性。我们描述了由卷积和池化层的继承而导致的特征图的概念。我们简单地将这些性质与其他神经句模型的性质联系起来。</p><h3 id="4-1-Word-and-n-Gram-Order"><a href="#4-1-Word-and-n-Gram-Order" class="headerlink" title="4.1 Word and n-Gram Order"></a>4.1 Word and n-Gram Order</h3><p>其中一个基本属性是对输入句子中单词顺序的敏感性。对于大多数应用，为了学习细粒度的特性检测器，对于模型来说，能够区分输入中是否存在特定的n-gram是有益的。同样，对于模型来说，能够分辨出最相关的n-grams的相对位置是有益的。该网络旨在捕捉这两个方面。第一层的宽卷积的滤波器m可以学习识别具有小于或等于滤波器宽度m的特定n-grams。正如我们在实验中看到的，在第一层中，m通常被设置为一个相对较大的值，比如10。由广义池操作提取的n-grams子序列，将不变性引入到绝对位置，但维持了它们的顺序和相对位置。至于其他的神经句模型，NBoW模型的类根据定义对词序不敏感的。一个基于递归神经网络的句子模型对词序很敏感，但它倾向于将其作为输入的最新单词 (Mikolov et al., 2011)。这使得RNN在语言建模方面表现出色，但在输入句中，它是在记忆n-grams时是最不理想的。类似地，递归神经网络对词序很敏感，但对树中最顶层的节点有偏倚。浅树可以在一定程度上缓解这种影响 (Socher et al., 2013a)。在第2.3节中，max - tdnn对词序是敏感的，但是max池只在句子矩阵的每一行中选出一个单一的n-grams特征。</p><h3 id="4-2-Induced-Feature-Graph"><a href="#4-2-Induced-Feature-Graph" class="headerlink" title="4.2  Induced Feature Graph"></a>4.2  Induced Feature Graph</h3><p>模型不需要任何的先验知识，例如句法依存树等，并且模型考虑了句子中相隔较远的词语之间的语义信息；</p><h2 id="5-Experiments"><a href="#5-Experiments" class="headerlink" title="5 Experiments"></a>5 Experiments</h2><blockquote><p>模型训练及参数</p></blockquote><ul><li>输出层是一个类别概率分布（即softmax），与倒数第二层全连接；</li><li>代价函数为交叉熵，训练目标是最小化代价函数；</li><li>L2正则化；</li><li>优化方法：mini-batch + gradient-based (使用Adagrad update rule, Duchi et al., 2011)</li></ul><blockquote><p>实验结果</p></blockquote><p>在三个数据集上进行了实验，分别是(1)电影评论数据集上的情感识别，(2)TREC问题分类，以及(3)Twitter数据集上的情感识别。结果如下图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4igf83mj30ao0dbwfb.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4izyrl4j30ah0enjsa.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv4j6x9orj30ah08fglt.jpg" alt=""></p><p>可以看出，DCNN的性能非常好，几乎不逊色于传统的模型；而且，DCNN的好处在于不需要任何的先验信息输入，也不需要构造非常复杂的人工特征。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6 Conclusion"></a>6 Conclusion</h2><p>我们描述了一个动态的卷积神经网络，它使用动态k-max池化运算符作为非线性的子采样函数。网络所引起的特征图能够捕获不同大小的单词关系。该网络在问题和情绪分类上获得了很高的性能，而不需要由解析器或其他资源提供外部特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;http://www.cs.wayne.edu/~mdong/Kalchbrenner_DCNN_ACL14.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Convolutional Neural Network for Modelling Sentences&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;准确地表达句子的能力是语言理解的核心。我们描述了一个被称为动态卷积神经网络(DCNN)的卷积结构，我们采用的是句子的语义模型。该网络使用动态k-Max池，一个通过线性序列的全局池操作。该网络处理不同长度的输入句子，并在句子中归纳出一个特征图，可以明确地捕捉短和长期的关系。该网络不依赖于解析树，并且很容易适用于任何语言。我们在四个实验中对DCNN进行了测试:小尺度二进制和多类情绪预测，六道问题分类和远程监控的推特情绪预测。该网络在前三项任务中取得了出色的性能，并且在最后一项任务中，在最强大的Baseline上减少了25%的错误。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="DCNN" scheme="http://yoursite.com/tags/DCNN/"/>
    
  </entry>
  
  <entry>
    <title>计算机视觉系列（1）：从LeNet到DenseNet</title>
    <link href="http://yoursite.com/2018/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BB%8ELeNet%E5%88%B0DenseNet/"/>
    <id>http://yoursite.com/2018/03/21/计算机视觉系列（1）：从LeNet到DenseNet/</id>
    <published>2018-03-21T13:14:45.000Z</published>
    <updated>2018-11-03T11:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>ImageNet Large Scale Visual Recognition Challenge，简称ILSVRC，它是图像分类领域的比赛，每年举办一次，下图为每年的得奖模型及其top-5错误率，这篇文章主要梳理一下这些模型的结构：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0vmozl1j30k10azwfo.jpg" alt=""></p><a id="more"></a><h2 id="一、LeNet-5"><a href="#一、LeNet-5" class="headerlink" title="一、LeNet-5"></a>一、LeNet-5</h2><p>LeNet-5是LeCun等人于1998年在论文 <a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf" target="_blank" rel="noopener">Gradient-based learning applied to document recognition</a> 提出的一个用于手写字体识别的卷积神经网络模型，是卷积神经网络的开山之作。它的模型结构相对于现在流行的网络来说略显简单，但其组成部分卷积层、池化层、全连接层都是后来的CNN网络的一部分。但在当时由于计算能力的局限且与支持向量机分类能力旗鼓相当，没有引起大范围的深入研究和关注。先看一下它的结构示意图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-05-28 下午6.21.32.png" alt="屏幕快照 2018-05-28 下午6.21.32"></p><ul><li>INPUT：输入为32×32的的单通道图片像素数值矩阵；</li><li>C1：卷积层，共6个卷积核，卷积核大小均为5×5，卷积操作步长为1，得到6×28×28的feature maps；</li><li>S2：池化层，池化窗口大小为2×2，最大池化，得到6×14×14的maps；</li><li>C3：卷积层，卷积核大小均为5×5，卷积操作步长为1，关键的地方是S2是6层，而C3有16层，中间是怎么变换过去的呢？这里有一个Locally Connect的方法；</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-05-28 下午6.18.00.png" alt="屏幕快照 2018-05-28 下午6.18.00"><br>举几个例子，C3层的第0个map是有S2层的第0、1、2个map经过3个滤波器后相加得到，以此类推。</p><ul><li>S4：池化层，池化窗口大小为2×2，最大池化，得到16×5×5的maps；</li><li>C5：卷积层，卷积核大小均为5×5，卷积操作步长为1，得到120个1*1的maps；</li><li>F6：全连接层，84个神经元。</li><li>OUTPUT：输出层神经元核函数(作用函数)是高斯函数，对输入信息进行空间映射的变换，最后输出属于各个类别（一共是10个）的分布。</li></ul><p><a href="https://www.zhihu.com/question/44328472" target="_blank" rel="noopener">RBF神经网络和BP神经网络有什么区别？</a></p><h2 id="二、AlexNet"><a href="#二、AlexNet" class="headerlink" title="二、AlexNet"></a>二、AlexNet</h2><p>AlexNet是深度学习从沉寂走向繁盛的一个关节点，在2012年的ImageNet图像分类竞赛上，相比上一年的冠军，AlexNet的top-5错误率下降了十个百分点，远远超过当年的第二名。它的网络结构示意图如下所示：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3zx85ylj30q608g0te.jpg" alt=""><br>网络结构的简化版如下所示：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4047pgaj30rz0lqwg2.jpg" alt=""><br>AlexNet 之所以能够成功，深度学习之所以能够重回历史舞台，原因在于：</p><ol><li><a href="https://plushunter.github.io/2017/05/12/深度学习系列（8）：激活函数/" target="_blank" rel="noopener">ReLU</a></li><li><a href="https://plushunter.github.io/2017/05/20/深度学习系列（11）：神经网络防止过拟合的方法/" target="_blank" rel="noopener">Dropout</a></li><li><a href="https://plushunter.github.io/2017/05/20/深度学习系列（11）：神经网络防止过拟合的方法/" target="_blank" rel="noopener">Data augmentation</a></li><li>局部响应归一化层（Local Response Normalization Layer）:存在于第一层卷积层和第二层卷积层的激活函数后面，引入这一层的主要目的，主要是为了防止过拟合，增加模型的泛化能力。对当前层的输出结果做平滑处理。这个策略贡献了1.2%的Top-5错误率。前后几层（对应位置的点）对中间这一层做一下平滑约束，计算方法是：<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0vqvuxpj30e502u74g.jpg" alt=""></li><li>重叠池化（Overlapping Pooling）：Overlapping的意思是有重叠，即Pooling的步长比Pooling Kernel的对应边要小。这个策略贡献了0.3%的Top-5错误率。</li><li>大数据训练：百万级ImageNet图像数据</li><li>多GPU训练：每个GPU上并行地、分别地运行AlexNet的一部分（例如将4096个神经元的全连接层拆分为两个并行的2048个神经元的全连接层，第一个卷积层有96个feature map而在一块GPU上只有48个feature map等），两块GPU只在特定的层上有交互。</li><li>学习率衰减：</li></ol><h2 id="三、VGGNet"><a href="#三、VGGNet" class="headerlink" title="三、VGGNet"></a>三、VGGNet</h2><p>网络结构如下所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15279114581250.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv40fpu2bj30k00n3di6.jpg" alt=""><br>VGGNet与AlexNet不同的地方主要在于卷积核大小、卷积步数以及网络深度。</p><p>VGGNet将小卷积核带入人们的视线，AlexNet中第一个卷积层使用的kernel大小为 $11\times11$  ，stride为4，C3和C5层中使用的都是 $5\times5$ 的卷积核；而出现在VGGNet中大多数的卷积核都是大小为$3\times3 $，stride为1的。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15279117977701.jpg" alt=""></p><p>直观上我们会觉得大的卷积核更好，因为它可以提取到更大区域内的信息，但是实际上，大卷积核可以用多个小卷积核进行代替。例如，一个 $5\times5$ 的卷积核就可以用两个串联的 $3\times3$ 卷积核来代替，一个 $7\times7$ 的卷积核就可以用三个串联的 $3\times3$ 卷积核来代替。这样的替代方式有两点好处：</p><ol><li>减少了参数个数：两个串联的小卷积核需要$3\times3\times2=18$ 个参数，一个 $5\times5 $的卷积核则有25个参数；三个串联的小卷积核需要$3\times3\times3=27$个参数，一个 $7\times7$的卷积核则有49个参数。大大减少了参数的数量。</li><li>引入了更多的非线性：多少个串联的小卷积核就对应着多少次激活(activation)的过程，而一个大的卷积核就只有一次激活的过程。引入了更多的非线性变换，也就意味着模型的表达能力会更强，可以去拟合更高维的分布。</li></ol><p>值得一提的是，VGGNet结构的C里面还用到了 $1\times1 $的卷积核。但是这里对这种卷积核的使用并不是像Inception里面拿来对通道进行整合，模拟升维和降维，这里并没有改变通道数，所以可以理解为是进一步的引入非线性。</p><p>VGGNet的出现让我们知道CNN的潜力无穷，并且越深的网络在分类问题上表现出来的性能越好，并不是越大的卷积核就越好，也不是越小的就越好，就VGGNet来看， $3\times3$ 卷积核是最合理的。</p><h2 id="四、GoogLeNet"><a href="#四、GoogLeNet" class="headerlink" title="四、GoogLeNet"></a>四、GoogLeNet</h2><p>GoogLeNet的核心思想是：将全连接，甚至卷积中的局部连接，全部替换为稀疏连接。这样既能保持网络结构的稀疏性，又能利用密集矩阵计算的高效性的方法。大量研究表明，可以将稀疏矩阵聚类为较为密集的子矩阵来提高计算性能，Inception应运而生。Inception结构如下所示：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv41gqsjqj30k00c90t6.jpg" alt=""><br>这里的稀疏性是指卷积运算过程中，kernel的尺寸远远小于图片的尺寸，一个feature map仅与少数的输入单元相连接；而密集矩阵计算是指在Inception模块中的四个分支可以看作是较为稀疏的部分，但是拼接之后又成为一个大的密集矩阵。这种基本模块使用了3种不同的卷积核，那么提取到的应该是3种不同尺度的特征，既有较为宏观的特征又有较为微观的特征，增加了特征的多样性。池化层则保留较为原始的输入信息。在模块的输出端将提取到的各种特征在channel维度上进行拼接，得到多尺度的特征。</p><p>GoogleNet将上述模块进行堆积，整个GoogleNet的网络结构如下所示：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0vrxsqij30j01x2dnw.jpg" alt=""></p><p>此外，还有升级版本的Inception，如下所示：</p><ul><li>Inception v2 &amp; v3</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv0vss06qj30k0090abq.jpg" alt=""></p><ul><li>Inception-v4 &amp;Inception-ResNet-v2</li></ul><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv42rtczqj30el0ltq3q.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://omu7tit09.bkt.clouddn.com/15309403639180.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://omu7tit09.bkt.clouddn.com/15309403720288.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv43gp7q6j30fm0j6jru.jpg"></div></div></div></div><h2 id="五、ResNet"><a href="#五、ResNet" class="headerlink" title="五、ResNet"></a>五、ResNet</h2><p>ResNet，深度残差网络，在top-5上的错误率为3.6%，是2015年ILSVRC的冠军，其网络结构如下所示：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv0vtpncej30dj0emgo1.jpg" alt=""></p><p>残差网络的设计理念归纳起来就是：</p><ul><li>保持简洁</li><li>VGG-style</li><li>没有最深，只有更深，目前已突破1k层<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0vv2qm9j30k00aygn1.jpg" alt=""></li></ul><p>接下来讲讲网络中最关键的残差结构：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15309317415559.jpg" alt=""><br>如上图所示，这个网络的提出本质上还是要解决层次比较深的时候无法训练的问题。它借鉴了Highway Network的思想，在旁边专门开个通道使得输入可以直达输出，而优化的目标由原来的拟合输出H(x)变成输出和输入的差H(x)-x，其中H(X)是某一层原始的的期望映射输出，x是输入，箭头称作shortcut connection。</p><p>作者的解读是这样的：</p><ul><li>if identity were optimal,easy to set weights as 0;</li><li>if optimal mapping is closer to identity,easier to find small fluctuations</li></ul><p>如果identity是最优的，它就是我们想要的理想映射，那么我们可以直接将F(x)的参数全部置零；如果identity和H(x)很相近，那么我们就可以通过学习残差来修正这种差别。</p><p>但为什么深度残差网络没有因为网络的加深而带来梯度消失或者梯度爆炸的问题呢？下面这篇文章分析了其为何性能优越，而且提出了一种新的残差单元，并且比较了各种残差单元的性能优劣，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15309313107650.jpg" alt=""></p><p><a href="https://arxiv.org/abs/1603.05027" target="_blank" rel="noopener">Identity Mappings in Deep Residual Networks</a></p><p>归纳地说就是因为残差结构的特殊性，在由loss对输入求导的时候，导数项会被分解为两个，而有一个直接对输入的导数项并不会消失，所以梯度一直存在。</p><h2 id="六、DenseNet"><a href="#六、DenseNet" class="headerlink" title="六、DenseNet"></a>六、DenseNet</h2><p>众所周知，最近几年卷积神经网络提高效果的方向，要么深（比如ResNet，解决了网络深时候的梯度消失问题）要么宽（比如GoogleNet的Inception），而作者则是从feature入手，通过对feature的极致利用达到更好的效果和更少的参数。归纳起来，DenseNet有以下几个优点：</p><ol><li>减轻了vanishing-gradient（梯度消失） </li><li>加强了feature的传递 </li><li>更有效地利用了feature </li><li>一定程度上较少了参数数量</li></ol><p>DenseNet保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层连接起来。在传统的卷积神经网络中，如果你有L层，那么就会有L个连接，但是在DenseNet中，会有L(L+1)/2个连接。简单讲，就是每一层的输入来自前面所有层的输出。如下图：$x_0$是input，$H_1$的输入是$x_0$（input），$H_2$的输入是$x_0$和$x_1$（$x_1$是$H_1$的输出）<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-07-07 下午12.15.05.png" alt="屏幕快照 2018-07-07 下午12.15.05"></p><p>梯度消失问题在网络深度越深的时候越容易出现，原因就是输入信息和梯度信息在很多层之间传递导致的，而现在这种dense connection相当于每一层都直接连接input和loss，因此就可以减轻梯度消失现象，这样更深网络不是问题。另外作者还观察到这种dense connection有正则化的效果，因此对于过拟合有一定的抑制作用。</p><p>文章与ResNet进行了对比，如下：</p><ul><li>ResNet：$X_l= H(x_{l-1})+x_{l-1}$</li></ul><p>这里的l表示层，$x_l$表示l层的输出，$H_l$表示一个非线性变换。所以对于ResNet而言，l层的输出是$l-1$层的输出加上对$l-1$层输出的非线性变换。</p><ul><li>DenseNet：$x_l = H_l([x_0,x_1,···,x_{l-1}])$</li></ul><p>$[x_0,x_1,…,x_{l-1}]$表示将0到l-1层的输出feature map做concatenation。concatenation是做通道的合并，就像Inception那样。而前面ResNet是值的相加，通道数是不变的。</p><p>下图是整个网络结构，这个结构图中包含了3个Dense Block，其中加入了bottleneck layer和transition layer操作，每个dense block的3×3卷积前面都包含了一个1×1的卷积操作，就是所谓的bottleneck layer，目的是减少输入的feature map数量，既能降维减少计算量，又能融合各个通道的特征；另外作者为了进一步压缩参数，在每两个dense block之间又增加了1×1的卷积操作，表示增加了这个Translation layer，该层的1×1卷积的输出channel默认是输入channel到一半。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-07-07 下午12.17.12.png" alt="屏幕快照 2018-07-07 下午12.17.12"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>绝佳的介绍文章：<a href="https://zhuanlan.zhihu.com/p/31006686" target="_blank" rel="noopener">从LeNet-5到DenseNet</a></li><li>LeNet-5：<a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf" target="_blank" rel="noopener">Gradient-based learning applied to document recognition</a> </li><li>AlexNet：<a href="https://link.zhihu.com/?target=https%3A//papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a></li><li>VGGNet：<a href="https://arxiv.org/abs/1409.1556v6" target="_blank" rel="noopener">Very Deep Convolutional Networks for Large-Scale Image Recognition</a></li><li>VGGNet：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1512.00567v3.pdf" target="_blank" rel="noopener">Rethinking the Inception Architecture for Computer Vision</a></li><li>GoogleNet：<a href="https://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li><li>ResNet：<a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">Deep Residual Learning for Image Recognition</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ImageNet Large Scale Visual Recognition Challenge，简称ILSVRC，它是图像分类领域的比赛，每年举办一次，下图为每年的得奖模型及其top-5错误率，这篇文章主要梳理一下这些模型的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fwv0vmozl1j30k10azwfo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="LeNet" scheme="http://yoursite.com/tags/LeNet/"/>
    
      <category term="AlexNet" scheme="http://yoursite.com/tags/AlexNet/"/>
    
      <category term="VGGNet" scheme="http://yoursite.com/tags/VGGNet/"/>
    
      <category term="GoogLeNet" scheme="http://yoursite.com/tags/GoogLeNet/"/>
    
      <category term="ResNet" scheme="http://yoursite.com/tags/ResNet/"/>
    
      <category term="DenseNet" scheme="http://yoursite.com/tags/DenseNet/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（8）：RCNN</title>
    <link href="http://yoursite.com/2018/03/08/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89%EF%BC%9ARCNN/"/>
    <id>http://yoursite.com/2018/03/08/自然语言处理系列（8）：RCNN/</id>
    <published>2018-03-08T15:14:45.000Z</published>
    <updated>2018-11-03T12:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="http://www.nlpr.ia.ac.cn/cip/~liukang/liukangPageFile/Recurrent%20Convolutional%20Neural%20Networks%20for%20Text%20Classification.pdf" target="_blank" rel="noopener">Recurrent Convolutional Neural Networks for Text Classification</a></p><p>文本分类是许多NLP应用的基础任务。传统的文本分类器通常依赖于许多人设计的特性，如字典、知识库和特殊的树内核。与传统的方法相比，我们引入了一个递归的卷积神经网络来进行文本分类，而没有人为设计的特征。在我们的模型中，我们应用了一个经常的结构，在学习单词表示法时尽可能地捕捉上下文信息，这可能大大减少了与传统的基于窗口的神经网络相比的噪音。我们还使用了一个自动判断哪些单词在文本分类中扮演关键角色，以在文本中捕获关键组件的方法。我们对四个常用的数据集进行实验。实验结果表明，该方法在多组数据集上优于最先进的方法。</p><a id="more"></a><h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p>文本分类是许多应用的重要组成部分，如web搜索、信息过滤和情绪分析(Aggarwal和Zhai 2012)。因此，它引起了许多研究者的关注。</p><p>文本分类中的一个关键问题是特征表示，这通常是基于单词bagof -words (BoW)模型，其中的unigrams、bigrams、n-grams或一些精心设计的模式通常被提取为特征。此外，还应用了频率、MI (Cover and Thomas 2012)、pLSA (Cai and Hofmann 2003)、LDA (Hingmire et al. 2013)等几种特征选择方法，以选择更具鉴别性的特征。</p><p>然而，传统的特征表示方法往往忽略文本中的上下文信息或词序，对于捕捉词的语义仍然不满意。例如，在句中，“沿着南岸的夕阳漫步提供了一系列令人惊叹的优势。”当我们分析“Bank”(unigram)这个词时，我们可能不知道它是指金融机构还是河旁。此外，“South Bank”(bigram)，尤其是考虑到两个大写字母，可能会误导那些对伦敦不太了解的人，把它当作金融机构。当我们获得更大的上下文“沿着南岸漫步”(5-gram)，我们就能很容易地辨别出它的意思。虽然高阶n-grams和更复杂的特性(如树内核(Post和Bergsma 2013))被设计用于捕获更多的上下文信息和单词序列，但它们仍然存在数据稀疏问题，这严重影响了分类的准确性。近年来，经过预先训练的word embedding和深层神经网络的快速发展，给各种NLP任务带来了新的启发。word embedding是单词的一种分布式表示，极大地缓解了数据稀疏问题(Bengio et al. 2003)。Mikolov、Yih和Zweig(2013)表明，预先训练的词嵌入可以捕捉有意义的句法和语义规律性。在word embedding的帮助下，人们提出了一些基于合成的方法来获取文本的语义表示。</p><p>Socher et al .(2011 a;2011 b;2013年提出递归神经网络(RecursiveNN)，在构建句子表示方面已被证明是有效的。然而，递归通过树结构捕获了一个句子的语义。它的性能很大程度上取决于文本树结构的性能。此外，构造这样一种文本树的时间复杂度至少为$O(n^2)$，其中n为文本的长度。当模型遇到长句或文档时，这将是非常耗时的。此外，两个句子之间的关系很难用树结构来表示。因此，递归不适合对长句或文档建模。</p><p>另一种模型，循环神经网络（RNN），模型时间复杂度为$O(n)$。该模型通过逐字分析一个文本单词，并将所有先前文本的语义存储在一个固定大小的隐藏层中(Elman 1990)。RNN的优点是能够更好地捕捉上下文信息。这可能有利于捕获长文本的语义。然而，RNN是一个有偏倚的模型，在这个模型中，后面的单词比先前的单词更具优势。因此，当它被用于捕获整个文档的语义时，它可能会降低效率，因为关键组件可能出现在文档中的任何地方，而不是最后。为了解决偏置问题，我们引入了卷积神经网络(CNN)，将一个不带偏见的模型引入到NLP任务中，它可以很好地确定文本中带有最大池化层的识别性短语。因此，与递归或循环神经网络相比，CNN可以更好地捕捉文本的语义。CNN的时间复杂度也是$O(n)$。然而，以前对CNNs的研究倾向于使用简单的卷积核，如固定窗(bert et al. 2011;Kalchbrenner和Blunsom 2013)。使用这样的内核时，很难确定窗口大小:小窗口大小可能导致一些关键信息的丢失，而大的窗口会导致巨大的参数空间(这可能很难训练)。因此，它提出了一个问题:我们能否比传统的基于窗口的神经网络学习更多的上下文信息，更准确地表示文本的语义。</p><p>为了解决上述模型的局限性，我们提出了一个循环卷积神经网络(RCNN)，并将其应用于文本分类的任务。首先，我们应用一个双向的循环结构，与传统的基于窗口的神经网络相比，它可以大大减少噪声，从而最大程度地捕捉上下文信息。此外，该模型在学习文本表示时可以保留更大范围的词序。其次，我们使用了一个可以自动判断哪些特性在文本分类中扮演关键角色的池化层，以捕获文本中的关键组件。我们的模型结合了RNN的结构和最大池化层，利用了循环神经模型和卷积神经模型的优点。此外，我们的模型显示了$O(n)$的时间复杂度，它与文本长度的长度是线性相关的。</p><p>我们用英语和汉语四种不同的任务来比较我们的模型和以前的最先进的方法。类别分类包含主题分类,情感分类和写作风格分类。实验表明，我们的模型在四种常用数据集的三种情况下比以往的先进方法更出色。</p><h2 id="二、Related-Work"><a href="#二、Related-Work" class="headerlink" title="二、Related Work"></a>二、Related Work</h2><h3 id="2-1-Text-Classification"><a href="#2-1-Text-Classification" class="headerlink" title="2.1 Text Classification"></a>2.1 Text Classification</h3><p>传统的文本分类工作主要集中在三个主题:特征工程、特征选择和不同类型的机器学习算法。对于特征工程来说，最广泛使用的功能是bag-of-words。此外，还设计了一些更复杂的功能，比如词性标签、名词短语(Lewis 1992)和tree kernels (Post and Bergsma 2013)。特征选择旨在删除噪声特征，提高分类性能。最常见的特征选择方法是去停词(例如，“The”)。先进的方法使用信息增益、相互信息(Cover和Thomas 2012)或L1正则化(Ng 2004)以选择有用的特性。机器学习算法常用分类器，如逻辑回归(LR)、朴素贝叶斯(NB)和支持向量机(SVM)。然而，这些方法都存在数据稀疏问题。</p><h3 id="2-2-Deep-neural-networks"><a href="#2-2-Deep-neural-networks" class="headerlink" title="2.2 Deep neural networks"></a>2.2 Deep neural networks</h3><p>最近，深度神经网络(Hinton and Salakhutdinov 2006)和表示学习(Bengio, Courville，和Vincent 2013)提出了解决数据问题的新思路，并提出了许多学习单词表示的神经模型(Bengio et al. 2003;Mnih and Hinton 2007;Mikolov 2012;Collobert et al . 2011;huanget al . 2012;Mikolov et al . 2013)。一个单词的神经表示被称为单词嵌入，它是一个实值向量。“嵌入”一词使我们能够简单地利用两个嵌入向量之间的距离来测量单词的相关性。通过预先训练的词嵌入，神经网络在许多NLP任务中表现出色。Socher等人(2011b)使用半监督递归自动编码器来预测句子的情绪。Socher等(2011a)提出了一种用循环神经网络进行语义检测的方法。Socher等人(2013)引入递归神经张量网络分析短语和句子的情绪。Mikolov(2012)利用循环神经网络构建语言模型。Kalchbrenner和Blunsom(2013)提出了一个新的对话行为分类网络。conbert等人(2011)引入了卷积神经网络的语义角色标记。</p><h2 id="三、Model"><a href="#三、Model" class="headerlink" title="三、Model"></a>三、Model</h2><p>我们提出了一个深度神经模型来捕获文本的语义。图1显示了我们模型的网络结构。网络的输入是一个文档$D$，它是一个序列的单词$w_1, w_2…w_n$。网络的输出为类别。我们使用$p(k|D，θ)$来表示文档类别$k$的概率,$θ$是网络参数。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4kkm6wzj30v10dtwgb.jpg" alt=""></p><h3 id="3-1-Word-Representation-Learning"><a href="#3-1-Word-Representation-Learning" class="headerlink" title="3.1 Word Representation Learning"></a>3.1 Word Representation Learning</h3><p>我们结合一个词和它的上下文来呈现一个词。语境帮助我们获得更准确的词义。在我们的模型中，我们使用一个循环结构，它是一个双向的循环神经网络，用来捕获上下文。我们将$c_l(w_i)$定义为词$w_i$左边的文本，将$c_r(w_i)$定义为词$w_i$右边的文本。$c_l(w_i)$和$c_r(w_i)$都是具有|c|个实值元素的稠密向量。使用式（1）来计算词$w_i$左边的文本，$e(w_{i-1})$是词$w_{i-1}$的词嵌入，它是一个长度为$|e|$的实值向量。$c_l(w_{i-1})$是上一个词$w_{i-1}$的左半部分文本。任何文档的第一个词的左半边文本使用相同的参数$c_l(w_1)$。$W^{(l)}$是一个将隐藏层(context)转换为下一个隐藏层的矩阵。$W^{(sl)}$是一个矩阵，用来将当前单词的语义与下一个单词的左上下文结合起来。$f$是非线性激活函数。右半边文本$c_r{(w_i)}$用相同的方式计算，如公式（2）所示。一个文档的最后一个词的右半边文本共享参数$c_r(w_n)$</p><script type="math/tex; mode=display">c_l(w_i)=f(W^{(l)}c_l(w_{i-1})+W^{(sl)}e(w_{i-1})) \qquad (1)\\c_r(w_i)=f(W^{(r)}c_r(w_{i+1})+W^{(sr)}e(w_{i+1})) \qquad (2)</script><p>如式(1)和(2)所示，上下文向量捕获了所有左和右上下文的语义。例如，在图1中，$c_l (w_7)$编码了左侧上下文的语义“沿着南方漫步”以及前面的所有文本，$c_r (w_7)$编码了右侧上下文的语义“提供了一个……””。然后，我们定义单词$w_i$的表示形式为式(3)，即左侧上下文向量$c_l(w_i)$，词嵌入表示$e(w_i)$和右侧上下文向量$c_r(w_i)$的连接。用这种方式，我们的模型可以更好地消除“$w_i$”这个词的含糊含义，而不是只使用固定窗口的传统神经模型，（例如他们只使用关于文本的部分信息）</p><script type="math/tex; mode=display">x_i=[c_l(w_i);e(w_i);c_r(w_i)]\qquad (3)</script><p>循环结构可以在文本的向前扫描时获取所有的$c_l$，在反向扫描时获取所有的$c_r$。时间复杂度为$O(n)$。当我们获得了单词$w_i$的表示$x_i$后，我们将一个线性变换与tanh激活函数一起应用到$x_i$，并将结果传递到下一层。</p><script type="math/tex; mode=display">y_i^{(2)}=tanh(W^{(2)}x_i+b^{(2)})\qquad (4)</script><p>$y$是一个潜在的语义向量，每一个语义因素都将被分析，以确定代表文本的最有用的因素。</p><h3 id="3-2-Text-Representation-Learning"><a href="#3-2-Text-Representation-Learning" class="headerlink" title="3.2 Text Representation Learning"></a>3.2 Text Representation Learning</h3><p>我们模型中的卷积神经网络是用来表示文本的。从卷积神经网络的角度来看，我们以前所提到的重复结构是卷积层。当计算所有单词的表示时，我们应用一个max-pooling层。</p><script type="math/tex; mode=display">y^{(3)}=max_{i=1}^ny_i^{(2)}\qquad (5)</script><p>max函数是一个按元素的函数。$y^{(3)}$的第k个元素是$y_i^{(2)}$的所有向量的第k个元素的最大值。池化层将不同长度的文本转换为固定长度的向量。通过使用池化层，我们可以在整个文本中捕获信息。还有其他类型的池层，比如平均池层(Collobert et al. 2011)。我们这里不使用平均池，因为这里只有几个单词和它们的组合对于捕获文档的含义非常有用。在文档中，最大池化层试图找到最重要的潜在语义因素。池化层接受循环结构的输出作为输入。池化层的时间复杂度为$O(n)$。整体模型是一个循环结构和一个最大池化层的级联，因此，我们的模型的时间复杂度仍然是$O(n)$。我们模型的最后一部分是一个输出层。与传统的神经网络相似，它被定义为</p><script type="math/tex; mode=display">y^{(4)}=W^{(4)}y^{(3)}+b^{(4)}\qquad (6)</script><p>最后，将$softmax$函数应用于$y^{(4)}$。它可以把输出数字转换成概率。</p><script type="math/tex; mode=display">p_i=\frac{exp(y_i^{(4)})}{\sum_{k=1}^nexp(y_k^{(4)})}\qquad (7)</script><h2 id="四、Training"><a href="#四、Training" class="headerlink" title="四、Training"></a>四、Training</h2><h3 id="4-1-Training-Network-parameters"><a href="#4-1-Training-Network-parameters" class="headerlink" title="4.1 Training Network parameters"></a>4.1 Training Network parameters</h3><p>我们定义的所有训练参数为$θ$。</p><script type="math/tex; mode=display">\theta =\{E,b^{(4)},c_l(w_1),c_r(w_n),W^{(2)},W^{(4)},W^{(l)},W^{(r)},W^{(sl)},W^{(sr)}\}</script><p>具体来说，参数$E\in R^{|e|×|V|}$是词嵌入，偏差向量$b^{(2)}\in R^{|H|}$,$b^{(4)}\in R^O$，初始文本$c_l(w_1),c_r(w_n)\in R^{(H×(|e|+2c))}$，转换矩阵$W^{(2)}\in R^{H×(|e|+2|c|)}$,$W^{(4)}\in R^{O×H}$,$W^{(4)}\in R^{(O×H)}$,$W^{(l)},W^{(r)}\in R^{|c|×|c|}$,$W^{(sl)},W^{(sr)}\in R^{|e|×|c|}$，其中$|V|$是词库中词的数量，$H$是隐藏层的规格，$O$是文档类别数。</p><p>网络的训练目标是使得$\theta$满足对数似然最大化：</p><script type="math/tex; mode=display">\theta  →\sum_{D\in D}log p(class_D|D,\theta) \qquad(9)</script><p>其中$D$是训练文档集，$class_D$是文档$D$的真实类别。</p><p>我们使用随机梯度下降法(Bottou 1991)来优化训练目标。在每一步中，我们随机选择一个样本(D, classD)进行一次梯度下降：</p><script type="math/tex; mode=display">\theta ← \theta+\alpha\frac{\partial log p(class_D|D,\theta)}{\partial \theta}\qquad(10)</script><p>其中$\alpha$是学习率。<br>在训练神经网络的训练过程中，我们采用了一种常用的方法来训练神经网络。我们将神经网络中的所有参数服从均匀分布初始化。最大或最小值的大小等于“fan-in”的平方根(Plaut和Hinton 1987)。数值是我们模型中前面一层的网络节点。该层的学习速率除以“fan-in”。</p><h3 id="4-2-Pre-training-Word-Embedding"><a href="#4-2-Pre-training-Word-Embedding" class="headerlink" title="4.2 Pre-training Word Embedding"></a>4.2 Pre-training Word Embedding</h3><h2 id="五、Experiments"><a href="#五、Experiments" class="headerlink" title="五、Experiments"></a>五、Experiments</h2><h3 id="5-1-Datasets"><a href="#5-1-Datasets" class="headerlink" title="5.1 Datasets"></a>5.1 Datasets</h3><h3 id="5-2-Experiment-Settings"><a href="#5-2-Experiment-Settings" class="headerlink" title="5.2 Experiment Settings"></a>5.2 Experiment Settings</h3><h3 id="5-3-Comparison-of-Methods"><a href="#5-3-Comparison-of-Methods" class="headerlink" title="5.3 Comparison of Methods"></a>5.3 Comparison of Methods</h3><h3 id="5-4-Results-and-Discussion"><a href="#5-4-Results-and-Discussion" class="headerlink" title="5.4 Results and Discussion"></a>5.4 Results and Discussion</h3><h3 id="5-5-Contextual-Information"><a href="#5-5-Contextual-Information" class="headerlink" title="5.5 Contextual Information"></a>5.5 Contextual Information</h3><h2 id="六、Conclusion"><a href="#六、Conclusion" class="headerlink" title="六、Conclusion"></a>六、Conclusion</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;http://www.nlpr.ia.ac.cn/cip/~liukang/liukangPageFile/Recurrent%20Convolutional%20Neural%20Networks%20for%20Text%20Classification.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Recurrent Convolutional Neural Networks for Text Classification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文本分类是许多NLP应用的基础任务。传统的文本分类器通常依赖于许多人设计的特性，如字典、知识库和特殊的树内核。与传统的方法相比，我们引入了一个递归的卷积神经网络来进行文本分类，而没有人为设计的特征。在我们的模型中，我们应用了一个经常的结构，在学习单词表示法时尽可能地捕捉上下文信息，这可能大大减少了与传统的基于窗口的神经网络相比的噪音。我们还使用了一个自动判断哪些单词在文本分类中扮演关键角色，以在文本中捕获关键组件的方法。我们对四个常用的数据集进行实验。实验结果表明，该方法在多组数据集上优于最先进的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="CNN" scheme="http://yoursite.com/tags/CNN/"/>
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="RCNN" scheme="http://yoursite.com/tags/RCNN/"/>
    
      <category term="LSTM" scheme="http://yoursite.com/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>日知录（5）：认知偏误列表</title>
    <link href="http://yoursite.com/2018/03/02/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%885%EF%BC%89%EF%BC%9A%E8%AE%A4%E7%9F%A5%E5%81%8F%E8%AF%AF%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/02/日知录（5）：认知偏误列表/</id>
    <published>2018-03-02T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、认知偏误简介"><a href="#一、认知偏误简介" class="headerlink" title="一、认知偏误简介"></a>一、认知偏误简介</h2><p>认知偏误（Cognitive biases）是一种倾向，它认为在某些方面，认知会与理性标准（Standard of rationality）或者良好的判断相偏离，它经常应用于心理学（Psychology）和行为经济学（Behavioral economics）的研究中。</p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/15145188999131.jpg" alt=""></p><p>认知偏误的存在虽然被可重复的研究（Replicable research）证实，但是目前仍然有许多关于如何对这些偏误进行分类或如何解释它们的争论。部分偏误受到大脑用于处理判断与决策的启发式（Heuristics）信息处理规则（如心理捷径Mental shortcuts）的影响，这些影响统称为认知偏误。偏误拥有各种形式的认知（“冷性质”），比如心理噪音（Mental noise），或者动机（“热性质”）的解释（Motivational explanations），比如当理念被一厢情愿（Wishful thinking）歪曲的时候，以上两种性质的影响都可能在同时出现。</p><p>也有一些争论探讨这里面的部分偏误是否是无用的、不合理的（Irrational）或者可能会引致有效益的态度或行为。例如，当试图去了解别人的时候，人们倾向于提出确认自己关于对方的假设性引导性的问题（Leading questions）。有人认为这种确认偏误（Confirmation bias）是一种社会技能（Social skill），为了用于与其他人建立联系。</p><p>对这些偏误的研究绝大多数是关于人的，然而，一些调查显示部分偏误也存在于非人类的动物身上。例如，双曲贴现（Hyperbolic discounting）的情况存在于老鼠、鸽子和猴子身上。</p><h2 id="二、决策、信念与行为的偏误"><a href="#二、决策、信念与行为的偏误" class="headerlink" title="二、决策、信念与行为的偏误"></a>二、决策、信念与行为的偏误</h2><div class="table-container"><table><thead><tr><th>中文名称</th><th>英文名称</th><th>描述</th></tr></thead><tbody><tr><td>模糊效应</td><td>Ambiguity effect</td><td>也称为不明确效应，倾向于选择信息量更大的选项，避免选择缺少信息或者未知的选择项</td></tr><tr><td>锚定效应</td><td>Anchoring or focalism</td><td>人们在对某人某事做出判断时，易受到第一印象或第一信息的支配，思想就像沉入海底的锚 一样被固定在某个点</td></tr><tr><td>注意力偏误</td><td>Attentional bias</td><td>人们的知觉受到再现的想法的影响，如做决定时受制于环境或情绪，忽略一些相关信息而更关注某些特定信息</td></tr><tr><td>自动化偏误</td><td>Automation bias</td><td>过度依赖自动化系统，这可能导致错误的自动化信息取代正确的决定</td></tr><tr><td>叠加效应</td><td>Availability ca</td><td>也称效用层叠，某一观点不断重复确认后会加强，如集体观念通过其在公共话语中不断地重复获得越来越多的合理性，自我认知也将随之产生强化。换言之重复足够多那么它将变成“真的”，有点像三人成虎，以及“重要的事情说三遍”</td></tr><tr><td>可得性启发</td><td>Availability heuristic</td><td>在记忆中高估事件可能性的倾向，它受到记忆的远近程度、事件的罕见程度以及情绪化的影响，因而在作评价时更多依赖记忆中记住的信息而不是全部信息。在使用启发法进行判断时，人们往往会依赖最先想到的经验和信息，并认定这些容易知觉到或回想起的事件更常出现，以此作为判断的依据</td></tr><tr><td>逆火效应</td><td>Backfire effect</td><td>也称逆反效应，人们通过强化他们的信仰来为驳斥现象做出反应。如当一个错误的信息被更正后，如果更正的信息与其原本的看法相违背，它反而会加深人们对原本错误信息的信任</td></tr><tr><td>从众效应</td><td>Bandwagon effect</td><td>同羊群效应，人们从事或者相信某件事时依赖于其他相同情况的人做出的选择，相关的是群体思想（Groupthink）和从众行为（Herd behavior）</td></tr><tr><td>基率谬误/忽视</td><td>Base rate fallacy / neglect</td><td>忽视基本的比率信息（通用的、一般的），而倾向于在某些特定情况下才适用的特定的信息，可参考统计学中的贝叶斯统计（Bayesian Statistics）理论</td></tr><tr><td>信念偏误</td><td>Belief bias</td><td>或称信仰偏误，人们评价论据是否合乎逻辑的可信程度受到其结论可信度的影响，因为相信结论所以相信其推理过程</td></tr><tr><td>偏见盲点</td><td>Bias blind spot</td><td>认为自己的偏见比别人更少，或者说认为别人的偏见比自己多的倾向</td></tr><tr><td>拉拉队效应</td><td>Cheerleader effect</td><td>人们在团体里面比在孤立状态下表现得更有吸引力的倾向，就像在拉拉队中更倾向于表现自己</td></tr><tr><td>选择支持性偏误</td><td>Choice-supportive bias</td><td>认为自己做出的选择是更好的而事实上可能并非如此（忽略不利的地方），稍有自我安慰之意</td></tr><tr><td>聚集性错觉</td><td>Clustering illusion</td><td>也称丛集错觉或聚类错觉，人们倾向于将大量随机小样本中不可避免的“条纹”或“聚簇”状的随机分布考虑为某种具有统计学意义的“规律”（幻象模式Phantom patterns），此处可参考知乎问题“打麻将的时候，为什么会有连续一段时间运气特别好的现象？”下面的回答</td></tr><tr><td>舒适区效应</td><td>Comfort zone effect</td><td>对于过去常用的方案，高估其效益或成功机会；对于过去少用的方案，低估其效益或成功机会</td></tr><tr><td>确认偏误</td><td>Confirmation bias</td><td>也称证实偏误，人们偏向于关注、寻找、解释和记忆能够证实自身预想的信息，而忽视事实去支持自己的成见</td></tr><tr><td>一致性偏误</td><td>Congruence bias</td><td>也称相合性偏误，对假设的验证完全依赖于直接的测试，而不对其替代性假设的可能性做测试；或者说只相信直接证明假说的实验，而忽视间接的证明或是证明其他假说的可能</td></tr><tr><td>合取谬误</td><td>Conjunction fallacy</td><td>也称联合谬误，认为特殊情况比一般情况更可能发生；认为单个条件发生的概率要小于多个条件联合发生的概率。如对某人的描述很像女性主义者时，认为某人是替妇女辩护的律师的可能性比认为某人是律师的可能性更高</td></tr><tr><td>保守主义</td><td>Conservatism</td><td>在新的证据出现时仍然难以改变某人观念（Revise one’s belief）的现象，相对于贝叶斯信念修正（Bayesian Belief-revision）来说，人们看重先验分布（Prior distribution）而轻视新的样本证据（Sample evidence）</td></tr><tr><td>对比效应</td><td>Contrast effect</td><td>同一刺激因背景不同而产生的感觉差异的现象，或者说当与最近观察到的有所差异的对象相比较时，加深或降低感知刺激的现象</td></tr><tr><td>知识的诅咒</td><td>Curse of knowledge</td><td>见多识广的人很难从并不那么博识的人的角度看问题，或者说知情者很难从不知情者的角度看问题</td></tr><tr><td>数据迁就偏误</td><td>Data-snooping bias</td><td>也称数据探查偏误、数据拟合偏误，指在基于先前得到的实证经验后对历史数据进行分析后所引起的偏误，由于模型“迁就”历史数据（即与历史数据拟合得太好），反而导致“预测”结果十分糟糕（与未来有偏差）</td></tr><tr><td>诱饵效应</td><td>Decoy effect</td><td>人们对两个不相上下的选项进行选择时，因为第三个新选项（诱饵）的加入，会使某个旧选项显得更有吸引力。有时“诱饵”并不需要真的存在，即“幽灵诱饵”</td></tr><tr><td>辩护人谬误</td><td>Defendant’s fallacy</td><td>泛指多种根据不相关资讯认定被告“犯罪的概率”很小的情况。另参见检察官谬误（Prosecutor’s fallacy）</td></tr><tr><td>似曾相识效应</td><td>Déjà vu effect</td><td>对某些事物有强烈的熟悉感，似乎曾经接触过，且能预先想到接下来会发生什么事</td></tr><tr><td>面额效应</td><td>Denomination effect</td><td>相对于大面额的钞票来说，小面额的钞票会花费得更快</td></tr><tr><td>处置效应</td><td>Disposition Effect</td><td>倾向于出售价值增长的资产，而抵制出售价值下降的资产</td></tr><tr><td>区分偏误</td><td>Distinction bias</td><td>两个事物作为备选项一起考虑时比单独考虑时区别更大。另见越少越好效应（Less-is-better effect）</td></tr><tr><td>丹宁克鲁格效应</td><td>Dunning-Kruger effect</td><td>也称达克效应，指无知要比知识更容易产生自信。如能力欠缺的人在自己认识不足的基础上得出错误结论，但是无法正确认识到自身的不足，察觉到自己的错误行为</td></tr><tr><td>时长忽视</td><td>Duration neglect</td><td>也称过程时间忽视，在确定某事件的价值时忽视该事件的持续时间。心理观察发现，人们判断某件痛苦经历的不愉快程度很少依赖于时长因素，但是经历中痛苦的最高点（Peak）和痛苦的消减速度却是两个最主要因素，一般来说消减得越快，会觉得这段经历更加痛苦</td></tr><tr><td>同理心断层</td><td>Empathy gap</td><td>也称移情差异、移情隔阂，人们低估情感的影响或者力量的倾向，“子非鱼，焉知鱼之乐？”</td></tr><tr><td>禀赋效应</td><td>Endowment effect</td><td>也称敝帚自珍效应，当个人一旦拥有某项物品，那么他对该物品价值的评价要比未拥有之前大大增加，总认为自己的东西是最好的；放弃某件物品比希望拥有它更有难度</td></tr><tr><td>本质主义</td><td>Exaggerated expectation</td><td>期望超出估计和现实，世界不是那么戏剧化，理想很热血，现实很平淡。相反的是保守主义偏误（Conservatism bias）</td></tr><tr><td>排除偏误</td><td>Exclusion bias</td><td>也称剔除偏误，研究进行时由于排除某些看似不符预期的样本产生的偏误</td></tr><tr><td>试验偏误或预期偏误</td><td>Experimenter’s or expectation bias</td><td>实验者相信、证实并发布那些支持他们预期结果的数据，相反地，对相矛盾的结果持怀疑、抛弃的态度或者对它们进行降权。推荐书籍《推理的迷宫》</td></tr><tr><td>聚焦效应</td><td>Focusing effect</td><td>对事物的某一方面过分注重的倾向，这可能导致错误的预期</td></tr><tr><td>福勒效应/巴纳姆效应</td><td>Forer effect / Barnum effect</td><td>人们常常认为一种笼统的、一般性的人格描述十分准确地揭示了自己的特点，而这些描述往往十分模糊及普遍，以至于能够适用到很多人身上（放之四海而皆准）。这种效应可以提供关于普遍接受的一些观念和做法的解释，如占星（Astrology）、算命（Fortune telling）、笔迹学（Graphology）和某些类型的性格测试</td></tr><tr><td>正向偏置</td><td>Forward Bias</td><td>模型是基于历史数据建立的，因此仅对过去的数据进行了验证，很难预测未知</td></tr><tr><td>框架效应</td><td>Framing effect</td><td>一个问题两种在逻辑意义上相似的说法却导致了不同的决策判断。人际交往中指关键不在于说什么，而在于怎么说；经济学中指当消费者感觉某一价格带来的是“损失”而不是“收益”时，他们对价格就越敏感</td></tr><tr><td>频率错觉</td><td>Functional fixedness</td><td>也称功能固着，认知限制某人只能在传统的方式上使用某种物品或对象的倾向；当需要解决问题时，思维阻断了使用新方法的可能性</td></tr><tr><td>经费偏误</td><td>Funding bias</td><td>也称赞助偏误，选择研究方法或诠释研究结果时，倾向于迎合经费提供者或赞助商的立场</td></tr><tr><td>赌徒谬误</td><td>Gambler’s fallacy</td><td>也称蒙地卡罗谬误，一种负近因效应（Negative recency），认为某事物在未来的几率会因过去的事件发生改变，事实上并非如此，统计规律不适用于个体，有些已经发生的事不会影响将要发生的事。概率上认为随机序列中一个事件发生的机率与之前发生的事件有关，即其发生的机率会随着之前没有发生该事件的次数而上升。典型的概念为大数定律（Law of large numbers）。如在某事件的一面连续发生后，人们会认为另一面在下一次“风水轮流转”或“翻盘”的几率更大。另参见逆赌徒谬误（Inverse gambler’s fallacy）</td></tr><tr><td>难度效应</td><td>Hindsight bias</td><td>也称后见之明偏误、后视偏误，常说的“事后诸葛亮”，事情已经发生了却说自己早已预料到</td></tr><tr><td>敌对媒体效应</td><td>Hostile media effect</td><td>也称敌意媒介效应，可以理解为意识形态偏误，由于强烈的阵容观念的存在，总是认为立场与自己不同的媒体有偏见、不客观</td></tr><tr><td>热手谬误</td><td>Hot-hand fallacy</td><td>也称热手效应、热手现象（Hot hand phenomenon），一种正近因效应（Postive recency），认为某事多次发生则未来发生的概率会较大；认为经历过成功的人物在额外的尝试之下有更大的机会获得进一步成功的可能。如人们会以为随机的连赢来自杰出的表现</td></tr><tr><td>双曲贴现</td><td>Hyperbolic discounting</td><td>更关注眼前利益而不是长远利益，相对于未来的回报，更倾向于现在的回报，这将导致人们的选择基于相同的原因却会随着时间的推移而发生改变。也作现时偏误（Current moment bias / Present-bias），可以参考动态不一致（Dynamic inconsistency）理论</td></tr><tr><td>可识别受害者效应</td><td>Identifiable victim effect</td><td>相对于处于危难中的一大群人来说，人们更倾向于为单个的可辨识的人做出响应，这里还涉及到同理心（Empathy）的问题</td></tr><tr><td>宜家效应</td><td>IKEA effect</td><td>当人们亲自组装、构建自己的东西（如宜家IKEA家具）时，无论最终结果如何，都会对它评价甚高，而且投入越多的劳动或情感就越容易产生依恋感和自豪感而高估物品的价值</td></tr><tr><td>控制错觉</td><td>Illusion of control</td><td>高估对外部事件的影响程度，人们以为自己对事物的控制能力或控制权超过实际上所拥有的控制能力，个体对自己成功的可能性的估计远高于其客观可能性的一种不合理的期望</td></tr><tr><td>有效性错觉</td><td>Illusion of validity</td><td>认为通过进一步地获取信息，将产生更多相关的辅助预测的数据，虽然可能并非如此，因为不一定有用</td></tr><tr><td>错觉关联</td><td>Illusory correlation</td><td>或称相关性错觉，错误地认为两个毫不相关的事物之间存在联系</td></tr><tr><td>影响偏误</td><td>Impact bias</td><td>也称影响力偏误，高估事件对未来情绪状态的影响力，如认为中大奖后会永远开心却并非如此</td></tr><tr><td>信息偏误</td><td>Information bias</td><td>也称资讯偏误，指人们为了获取信息会搜寻那些并不一定起作用的信息的倾向。如人们为了更好地决策，会搜集尽可能多的信息，但是并不用得上</td></tr><tr><td>样本大小不敏感性</td><td>Insensitivity to sample size</td><td>小样本中的变化容易被忽视的现象，人们判断样本统计（Sample statistic）中的概率时不考虑样本大小；评估统计数据时，未考虑小样本比大样本更容易观察到极端结果</td></tr><tr><td>逆赌徒谬误</td><td>Inverse gambler’s fallacy</td><td>认为概率很小的事发生了，一定是做了很多次。另参见赌徒谬误（Gambler’s fallacy）</td></tr><tr><td>不理性增值</td><td>Irrational escalation</td><td>也称沉没成本谬误（Sunk cost fallacy），人们基于累积的前期投资来证明某增加投资的决策是正确的，尽管新证据表明该决策可能是错误的；增加投资时关注已有业绩而不关注当前更有价值的信息</td></tr><tr><td>妄下结论</td><td>Jumping to conclusions</td><td>根据少许的信息即做出判断与决策。如诛心、预言、贴标签等等</td></tr><tr><td>公平世界假定</td><td>Just-world hypothesis</td><td>或称公平世界原则，人们倾向于相信自己生活在一个公平的世界里，每个人都得到他应得</td></tr><tr><td>领先时间偏误</td><td>Lead-time bias</td><td>也称超前时间偏误，经常出现在疾病检测中，当比较新近的或实验的测试与之前的测试时，其结果没有变化的现象，因为新近的或实验的测试只是比之前更早确定疾病，因此给人以病症时间延长的错觉</td></tr><tr><td>时长偏误</td><td>Length-time bias</td><td>也称时距偏误，选择偏误的一种，由于统计结果失真造成数据结论错误。当随机选择的时间点或空间点间隔参与到时长间隔的分析中时将会造成此偏误，这一分析过程倾向于选择较长的间隔，从而影响数据的准确性</td></tr><tr><td>越少越好效应</td><td>Less-is-better effect</td><td>当判断的时候，不联合在一起，倾向于分离出较小的集合而不是较大的集合加以考虑</td></tr><tr><td>损失厌恶</td><td>Loss aversion</td><td>也称损失规避，倾向于避免损失而获得收益，因为放弃某事物的负效用大于拥有它的正效用，差距可能超出1倍。可参考沉没成本效应（Sunk cost effects）和禀赋效应（Endowment effect）</td></tr><tr><td>戏局谬误</td><td>Ludic fallacy</td><td>一种不相干的谬误，指错误地将游戏的机率模式套用到现实世界，以及过度使用统计与概率预测未来</td></tr><tr><td>麦纳马拉谬误</td><td>McNamara fallacy</td><td>一种非形式谬误，指描述过度使用数据评估事情的现象，过度相信数据、依赖数据评估事情，忽略难以量化的事</td></tr><tr><td>单纯曝光效应</td><td>Mere exposure effect</td><td>也称曝光/熟悉/多看/重复/暴露/接触效应等，因为仅仅熟悉或亲近某一人事物而表现出对TA过分喜爱的倾向。某人事物在TA首次出现时如果没有带来厌恶感，那么随着TA出现的次数越多，对其产生的好感度也越高</td></tr><tr><td>货币错觉</td><td>Money illusion</td><td>也称金钱错觉，注重于货币上的名义面额价值，而不是其购买力的实际价值</td></tr><tr><td>道德凭证效应</td><td>Moral credential effect</td><td>道德会导致无意识的偏误，良好而平等的历史记录或看法增加了后续出现不平等偏误的可能性，受影响的人可能意识不到先前思维中已经建立的道德凭证或者说对某个事物的看法。如某人由于得到了某些高道德的评价或认证，而认为自己做得够好，反而在其他面向做了相反的事</td></tr><tr><td>多重比较谬误</td><td>Multiple Comparisons Fallacy</td><td>广泛比较二个群体的各种特征，从中找出有明显差异的几个，宣称它就是造成二个群体不同的原因</td></tr><tr><td>消极偏误</td><td>Negativity bias</td><td>也称负面/消极偏误或负性认知偏误，是一种心理现象，相比于积极的记忆，人们更容易回想起那些不愉快的记忆；相比积极的事物，人们更加注重消极的</td></tr><tr><td>负性效应</td><td>Negativity effect</td><td>也称负向效果，当人们评估一个他们不喜欢者的行为的原因时，倾向于将积极行为归因于周边环境，而将消极行为归因于个人的本性。人们在印象形成过程中，消极信息的作用往往大于积极信息的作用，人们根据他人的消极品质形成的印象或评价很难改变，而且更愿意相信</td></tr><tr><td>可能性忽视</td><td>Neglect of probability</td><td>或称概率忽视，做决定时人们会忽略掉一些可能性，如决策时完全不理会不确定条件下的可能性或几率</td></tr><tr><td>反安慰剂效应</td><td>Nocebo effect</td><td>也称反伪药效应，给予有效的药物或治疗，病人却相信或觉得病情有所恶化。另参见安慰剂效应（Placebo effect）</td></tr><tr><td>正常化偏误</td><td>Normalcy bias</td><td>高估事物正常化发展的趋势，因而在发生变故时拒绝为之前从来没有发生过的灾祸、失败（disaster）做出计划、反应或者推卸责任；对突如其来的灾难人们更难接受，更想恢复原状</td></tr><tr><td>非本地发明</td><td>Not invented here</td><td>也称非我发明，一种心理现象，拒绝接触、使用外部开发的产品、研究、标准和知识。另参见宜家效应</td></tr><tr><td>选择性观察偏误</td><td>Observation selection bias</td><td>观察时不可避免受到前置条件的限制而筛选了样本，因而得出不适当的结论。例如问卷调查到的人是个热心、愿意填问卷的人，因而其结果未必能反映不热心、不愿意填问卷的人的想法</td></tr><tr><td>选择性观察偏误</td><td>Observation selection bias</td><td>观察时不可避免受到前置条件的限制而筛选了样本，因而得出不适当的结论。例如问卷调查到的人是个热心、愿意填问卷的人，因而其结果未必能反映不热心、不愿意填问卷的人的想法</td></tr><tr><td>观察者期望效应</td><td>Observer-expectancy effect</td><td>研究员在期待给定的结果时，会因此不自觉地操纵实验或者曲解数据，以便找到它。另参见受试者期望效应（Subject-expectancy effect）</td></tr><tr><td>忽略偏误</td><td>Omission bias</td><td>也称忽视偏误、不作为偏误，认为错误的行为比不作为更糟糕。相比将同样有害的行为忽略或者不作为来说，将有害的行为付诸行动被看成是使情况更加糟糕的或者不道德的，因为行动比不作为更加明显</td></tr><tr><td>遗漏变量偏误</td><td>Omitted-variable bias</td><td>遗漏了有关变量而产生的估计量的偏误</td></tr><tr><td>乐观偏误</td><td>Optimism bias</td><td>也称乐观主义倾向，态度过于乐观，高估了有利和令人愉快的结果，过分相信事情会向好的一方面发展。另参见一厢情愿（Wishful thinking），情价效应（Valence effect），正面结果偏误（Positive outcome bias）</td></tr><tr><td>鸵鸟效应</td><td>Ostrich effect</td><td>不理会明显的消极的情形或条件，是一种逃避现实的心理，也是一种不敢面对问题的懦弱行为，就像鸵鸟被逼得走投无路时，就把头钻进沙子里。相关成语掩耳盗铃</td></tr><tr><td>结果偏误</td><td>Outcome bias</td><td>也称结果效应/偏好，它是发生在决策评估中的一种偏误式判断，即当决策结果与决策质量不存在实质性联系时，评估者仍根据结果信息评估决策质量，是一种不考量决策当时的状况，而以结果论成败的倾向</td></tr><tr><td>自负效应</td><td>Overconfidence effect</td><td>在判断、解答、决策问题时，自己往往过度自信。如人们对某些问题，回答者“99%肯定”很有可能40%是错误的</td></tr><tr><td>过度诊断偏误</td><td>Overdiagnosis bias</td><td>也称过度诊断偏倚，指诊断出受试者（或患者）并不会造成症状或死亡的“疾病”，经常出现于早期疾病筛查中</td></tr><tr><td>空想性视错觉</td><td>Pareidolia</td><td>也称空想性错视、幻想性视错觉，将模糊随机的外界刺激（声音、图像等）看成是显著的并赋予实际意义，如像动物的云朵、月球上的人脸、听到倒播影音（Records played in reverse）中不存在的隐藏信息等</td></tr><tr><td>悲观主义偏误</td><td>Pessimism bias</td><td>人，尤其是经历过不幸或消极的人，认为不好的事情发生在自己身上的可能性更大</td></tr><tr><td>安慰剂效应</td><td>Placebo effect</td><td>也称伪药效应，给予无效的药物或治疗，病人却相信或觉得病情有所改善。另参见反安慰剂效应（Nocebo effect）</td></tr><tr><td>计划谬误</td><td>Planning fallacy</td><td>或称规划谬误，计划时低估任务完成时间的倾向。如人们在计划未来时，往往为未来安排过多的事物，设定过于理想化的目标，而实际实施时却很难完成计划，计划赶不上变化</td></tr><tr><td>正面结果偏误或情价效应</td><td>Positive outcome bias or Valence effect</td><td>认为积极正面的结果比负面的更容易发生</td></tr><tr><td>购后合理化</td><td>Post-purchase rationalization</td><td>或称买入后理性化论、“买家的斯德哥尔摩症候群”，人们在买入某东西之后为劝说自己而加入对购买行为合理化的解释，即使买下的产品太过昂贵或发现瑕疵，以此来化解认知失调</td></tr><tr><td>预筛选偏误</td><td>Pre-screening bias</td><td>也称预审偏误，筛选样本时预先排除了某些不应排除的样本</td></tr><tr><td>首因效应</td><td>Primacy effect</td><td>也称首位效应、起始效应、第一印象作用、先入为主效应，是一种开头刺激或信息的记忆过于引人注目的认知偏误。通过“第一印象”最先输入的信息对客体以后的认知会产生显著的影响，它是由第一印象所引起的一种心理倾向，许多人习惯称之为“第一感”。如人们更容易回想起序列中起始的项目而不是后面的项目</td></tr><tr><td>创新偏误</td><td>Pro-innovation bias</td><td>对于发明或者创新在社会上的作用持过分乐观倾向，同时往往忽视其局限性和弱点。如只看重新意而忽视其具体应用状况</td></tr><tr><td>检察官谬误</td><td>Prosecutor’s fallacy</td><td>泛指多种根据不相关资讯认定被告“无辜的概率”很小的情况。另参见辩护人谬误（Defendant’s fallacy）</td></tr><tr><td>假确定性效应</td><td>Pseudocertainty effect</td><td>当预期的结果是正的（收益）时候作风险规避（Risk-averse）的选择，当结果是负的（损失）时候作风险寻求（Risk-seeking）的选择，在选择项内容一致的情况下，其选择受描述结果的方式影响的趋向。另参见损失厌恶（Loss aversion）</td></tr><tr><td>对抗心理</td><td>Reactance</td><td>也称感应抵抗、抗拒心理，当他人想要限制你自由选择或做不想做之事的时候，产生站在对立面或者持反对意见的一种冲动。另参见逆反心理（Reverse psychology）</td></tr><tr><td>反冲性贬低</td><td>Reactive devaluation</td><td>也称反冲性贬抑，只是因为源自对手而认为其价值不大</td></tr><tr><td>近因偏误</td><td>Recency bias</td><td>也称近因效应、新颖效应，与首因效应相反，它更重视近期的数据或经验，忽视早期的数据或经验（参见“峰终定律”Peak-end rule）；在多种刺激一次出现的时候，印象的形成主要取决于后来出现的刺激</td></tr><tr><td>新近错觉</td><td>Recency illusion</td><td>或称新词错觉，认为某词语或语法是新近才出现的，事实上它们已经存在很久了。另参见眼球效应（Frequency illusion）</td></tr><tr><td>复原谬误</td><td>Regression fallacy</td><td>也称还原谬误，非常态的甲事发生以后，用乙措施处理后甲事扭转，便断定乙措施可扭转甲事。然而非常态的事发生后，本来就比较容易发生较接近常态的事</td></tr><tr><td>可能性贝叶斯回归</td><td>Regressive Bayesian likelihood</td><td>对条件概率的估计偏于保守而不是偏激的</td></tr><tr><td>回归偏误</td><td>Regressive bias</td><td>或称退缩偏误、逆行偏误，思维中将高价值高可能性的情况低估，反之高估的倾向</td></tr><tr><td>报告偏误</td><td>Reporting bias</td><td>也称报告选择偏误，指在反映情况时，选择性披露或隐藏信息的现象</td></tr><tr><td>自制偏误</td><td>Restraint bias</td><td>也称压制偏误，人们高估自己面对诱惑的抵抗力</td></tr><tr><td>押韵效应</td><td>Rhyme as reason effect</td><td>或称押韵有理效应，押韵的语句被认为是更加真实的。典型的案例出现在辛普森审判（O.J Simpson trial）一案中，辩词说道“If the gloves don’t fit, then you must acquit”（如果手套是不合手的，那么你就是无罪的）</td></tr><tr><td>风险补偿/佩兹曼效应</td><td>Risk compensation / Peltzman effect</td><td>在安全性增加的情况下，人们往往倾向于做出更加危险的举动。诸如很多安全产品的发明反而增加了相关活动的风险系数</td></tr><tr><td>选择偏误</td><td>Selection bias</td><td>一种系统误差，来源于研究对象的选择过程以及影响研究对象参与的因素，由于选入的研究对象与未选入的研究对象在某些特征上存在差异而引起的误差，常发生于研究的设计阶段</td></tr><tr><td>选择性感知</td><td>Selective perception</td><td>也称预期感知，事先的期望影响了事物的感知。如打针时事先觉得很疼就真觉得很疼</td></tr><tr><td>自我选择偏误</td><td>Self-selection bias</td><td>也称志愿者偏误（Volunteer bias），是指由于普查组与对照组人员自身条件差异造成偏误的情况，由于志愿者的自我选择而造成统计结果产生异常或偏误</td></tr><tr><td>塞默尔维斯反射</td><td>Semmelweis reflex</td><td>拒绝接受与已建立的规范、信仰或价值观相矛盾的新证据，仅凭证据并不能改变心理现状</td></tr><tr><td>社会比较偏误</td><td>Social comparison bias</td><td>在雇佣人才的时候，倾向于选择那些在某些方面不如自己的候选者</td></tr><tr><td>社会期望偏误</td><td>Social desirability bias</td><td>或称社会赞许性偏误，倾向于向外人展示自己社会期许的或者社会友好型的能力和行为，而隐藏社会不太看重的或者不利的方面</td></tr><tr><td>现状偏误</td><td>Status quo bias</td><td>期待事物保持不变，安于现状的倾向。另参见损失厌恶（Loss aversion），禀赋效应（Endowment effect），系统正当化（System justification）</td></tr><tr><td>刻板印象</td><td>Stereotyping</td><td>也称定型化效应，人们对某事物具体特点形成的一种固定的看法，并把这种观看法推而广之，认为这个事物或者整体都具有该特征，而忽视个体差异，有如将心中刻好的模板套到每个个体身上</td></tr><tr><td>次可加性效应</td><td>Subadditivity effect</td><td>或称分开加总效应，认为整体的可能性比部分的可能性（之和）更低</td></tr><tr><td>受试者期望效应</td><td>Subject-expectancy effect</td><td>由于受试者期待某种结果，因而下意识地扭曲了回报内容。另参见观察者期望效应（Observer-expectancy effect），案例安慰剂效应（Placebo effect）</td></tr><tr><td>主观验证</td><td>Subjective validation</td><td>也称主观确认，相信某事是对的，就感觉它是对的。也会把巧合的事当作有关联</td></tr><tr><td>幸存者偏误</td><td>Survivorship bias</td><td>也称存活者偏误、“死人不会说话”等。当取得资讯之渠道仅来自于幸存者时（因为无法从死者获得来源），此资讯可能会存在与实际情况不同的偏误。联系成语“兼听则明，偏信则暗”</td></tr><tr><td>德州神枪手谬误</td><td>Texas sharpshooter fallacy</td><td>即“先射箭再画靶”，原用以形容流行病学上的群集错觉，后衍生泛指统计研究做出结果后，把其中的群集独立出来当作有统计意义，然而实际上此集群更可能是随机产生</td></tr><tr><td>省时偏误</td><td>Time-saving bias</td><td>低估从低速加速（减速）行进时节省（损失）的时间；而高估从高速加速（减速）行进时节省（损失）的时间</td></tr><tr><td>单位偏误</td><td>Unit bias</td><td>认为计量单位反映合理程度，人们倾向于认为给定的一个单位、一瓶、一罐、一盘或更多其他精细度量的单位食物，就是适当的食用份量。这个偏误强烈影响到分装食物的消费，如果分装的食物看上去应该就是一顿或一人份，那么他们就会一直吃到见底</td></tr><tr><td>熟悉路线效应</td><td>Well travelled road effect</td><td>低估走熟悉路线的持续时间；高估走陌生路线的时间</td></tr><tr><td>只看整体效应</td><td>Whole only effect</td><td>选项为整套方案时，只关注整体，而忽略个别部分有协商的可能</td></tr><tr><td>零风险偏误</td><td>Zero-risk bias</td><td>偏向于将小的风险降为零，虽然说高风险降低的程度可能更大。如偏向将2%降到0%，而不是20%降到5%</td></tr><tr><td>零和直观推断</td><td>Zero-sum heuristic</td><td>也称零和捷思，直观地判断某情形是零和的（收益和损失之和为零）或者说总体平衡的，但事实未必如此。零和（Zero-sum）概念来自博弈论（Game theory）。这种偏误的产生可能与社会主导倾向（Social dominance orientation）的个人因素有关</td></tr></tbody></table></div><h2 id="三、社会偏误"><a href="#三、社会偏误" class="headerlink" title="三、社会偏误"></a>三、社会偏误</h2><p>这里的大部分偏误被称为归因偏误（Attributional biases）。</p><div class="table-container"><table><thead><tr><th>中文名称</th><th>英文名称</th><th>描述</th></tr></thead><tbody><tr><td>观察者偏误</td><td>Actor-observer bias</td><td>也称行为者-观察者偏误，解释其他个体的行为时过分强调内在个性的影响，而轻视当时的外在情况（参见基本归因错误Fundamental attribution error），而在解释自己行为时则与此相反</td></tr><tr><td>防御性归因假定</td><td>Defensive attribution hypothesis</td><td>也称防御性归因，当后果变得越严重或者自己与受害者的情况越相似时，对加害者的责怪或谴责也就越多</td></tr><tr><td>自我中心偏误</td><td>Egocentric bias</td><td>相比于外部归结的责任来说，人们更倾向于将合作行动中的责任归结于自己；人们作为参与者要比作为观察者更能承担责任</td></tr><tr><td>外在激励偏误</td><td>Extrinsic incentives bias</td><td>一种基本归因错误，认为他人要靠外在动机如情境才能做好；而自己可以靠内在动机如个人特质做好</td></tr><tr><td>错误共识效应</td><td>False consensus effect</td><td>也称错误共识理论，指人们高估其他人对自己认同程度的倾向，认为别人跟自己的想法是一致的</td></tr><tr><td>基本归因错误</td><td>Fundamental attribution error</td><td>也叫基本归因谬误，人们在评判他人的行为时倾向于强调人格特质的影响，而低估环境在其中的角色以及给其带来的影响。另参见观察者偏误（Actor-observer bias），群体归因错误（Group attribution error），积极效应（Positivity effect），消极效应（Negativity effect）</td></tr><tr><td>群体归因错误</td><td>Group attribution error</td><td>认为群组成员的个体特征反映了群组整体的特征，认为群组的表现反映了群组成员个体的偏好，虽然事实所说明的可能是不同的情况</td></tr><tr><td>光晕效应</td><td>Halo effect</td><td>也称晕轮效应、光圈效应，人们对某件事物的总体映象会影响到人们对其具体特征或属性的看法。另参见外貌魅力偏见（Physical attractiveness stereotype）、刻板印象（Stereotyping）</td></tr><tr><td>非对称认知错觉</td><td>Illusion of asymmetric insight</td><td>或称非对称洞察力错觉，人们认为自己对别人的了解超过别人对自己的了解，认为自己比其他人懂得更多</td></tr><tr><td>外部媒介错觉</td><td>Illusion of external agency</td><td>人们通常低估自己对未来结果产生满意度的能力，当人们体会到这种自我生成的满意度时，他们会错误地认为这些是由外部的影响力（influence）、洞察力（insight）、善意（benevolence）等造成的</td></tr><tr><td>透明度错觉</td><td>Illusion of transparency</td><td>也称洞悉错觉，认为别人很容易看透（理解）自己，自己也很容易看透（理解）别人</td></tr><tr><td>优越感错觉</td><td>Illusory superiority</td><td>也称优越感偏误（Superiority bias）、乌比冈湖效应（Lake Wobegon effect）、优于常人效应（Better-than-average effect）等，相对于其他人来说，自己对个人的优秀品质评价过高，而对不良品质评价过低，即高估自己的优点，低估自己的缺点，认为自己更有水平</td></tr><tr><td>群内偏误</td><td>Ingroup bias</td><td>或称派系偏误，人们对认为是属于自己这一方的成员有优先或者较好待遇的倾向，即偏向某个人自己的群体</td></tr><tr><td>道德运气</td><td>Moral luck</td><td>基于事件结果的道德立场影响人们对事件的评判，而没有考虑到事件的意图、过程及情境</td></tr><tr><td>朴素犬儒主义</td><td>Naïve cynicism</td><td>认为别人的自我中心偏误或者利己行为比自己更多</td></tr><tr><td>朴素现实主义</td><td>Naïve realism</td><td>也称朴素实在论，相信我们的所见所闻就是真实的、客观的、不带偏见的，事实是显而易见的，理性的人一定会赞成我们，不赞成我们的人一定是无知的、懒惰的、无理的、有偏见的</td></tr><tr><td>外群体同质性偏误</td><td>Outgroup homogeneity bias</td><td>或称外群同质性偏误、组外一致性偏误，人们认为自己群体内的成员是比其他群体的成员更加多样化的，外部群体的成员之间彼此极其相似，比内群体成员更加“同质化”，不是自己这一方的都是一样的</td></tr><tr><td>投射偏误</td><td>Projection bias</td><td>也称投射效应，不自觉地以为他人（或未来的自己）和（现在的）自己有相似的情感、思想与价值观。以己度人，认为自己具有某种特性，他人也一定会有与自己相同的特性，是一种把自己的感情、意志、特性投射到他人身上并强加于人的认知障碍</td></tr><tr><td>自利偏误</td><td>Self-serving bias</td><td>或称自利性偏误、利己偏误，相比失败，更多地将成功归因于自己，在评价模棱两可的信息时，也倾向于描述得对自己有利。另参见利群偏误（Group-serving bias）</td></tr><tr><td>共有信息偏误</td><td>Shared information bias</td><td>群体成员倾向于花费更多地时间和精力讨论大家都熟悉的信息（Shared information），而对只有部分人了解的信息（Unshared information）则讨论得更少</td></tr><tr><td>系统正当化</td><td>System justification</td><td>也称体制合理化，倾向于保卫和巩固现状，现有的社会、经济、政治状况往往是首选，而其他方案往往遭到贬抑，即使牺牲个人或者集体利益。另参见现状偏误（Status quo bias）</td></tr><tr><td>性格归属偏误</td><td>Trait ascription bias</td><td>也称个性归属偏误，认为自己的个性、行为、情绪是多变的，而他人是一成不变且容易预测的</td></tr><tr><td>终极归因错误</td><td>Ultimate attribution error</td><td>也称最终归因错误，类似于基本归因错误（Fundamental attribution error），只是这里人们倾向于将问题归因于整个群体，而不是群内的个体</td></tr><tr><td>差于常人效应</td><td>Worse-than-average effect</td><td>在任务困难的时候认为自己比别人更差，与优于常人效应（Better-than-average effect）相反</td></tr></tbody></table></div><h2 id="四、记忆的错误与偏误"><a href="#四、记忆的错误与偏误" class="headerlink" title="四、记忆的错误与偏误"></a>四、记忆的错误与偏误</h2><p>心理学与认知科学（Cognitive science）中，记忆偏误（Memory bias）是一种认知偏误（Cognitive bias），它将强化或者削弱记忆，其中包括记忆回想（recall）起来的可能性以及记忆回想起来的所需时间，或者是改变记忆的内容。</p><p>以下是各种记忆偏误：</p><div class="table-container"><table><thead><tr><th>中文名称</th><th>英文名称</th><th>描述</th></tr></thead><tbody><tr><td>怪异效应</td><td>Bizarreness effect</td><td>怪异的事物或情况比正常的更容易记住</td></tr><tr><td>改变偏误</td><td>Change bias</td><td>在参与到事物的变化中后，很难回忆起其之前的状况</td></tr><tr><td>童年期遗忘</td><td>Childhood amnesia</td><td>也称童年失忆症，人们很难回忆起四岁之前的情况</td></tr><tr><td>选择支持性偏误</td><td>Choice-supportive bias</td><td>也称支持选择偏误，在回顾自己做过的选择时，认为是明智的</td></tr><tr><td>保守主义或回归偏误</td><td>Conservatism or Regressive bias</td><td>记忆中将高价值高可能性的情况记成比实际低，而低价值低可能性的记成比实际高。基于证据的记忆情况是非极端化的，参见回归偏误（Regressive bias）</td></tr><tr><td>一致性偏误</td><td>Consistency bias</td><td>记忆中错误地将某人过去的态度和行为看成像是现在的态度和行为</td></tr><tr><td>情境效应</td><td>Context effect</td><td>也称语境效应，认知与记忆依赖于所处情境，回忆脱离情境的事件比处于情境内中的更难，某些情境的记忆在其他情境中也不容易回想，如在家里回忆工作内容，它所需的时间更长而准确性也更低</td></tr><tr><td>跨种族效应</td><td>Cross-race effect</td><td>相比辨认种族内的人来说，辨认其他种族成员的难度更高</td></tr><tr><td>潜隐记忆</td><td>Cryptomnesia</td><td>也称隐藏记忆，错误归因（Misattribution）的一种，当一个被遗忘的记忆无意识地出现时，会以为是自己新的原创的，是灵感的涌现。人们可能因此错误地回想或产生某个想法、观念，这在某方面可能会造成剽窃的争议</td></tr><tr><td>自我中心偏误</td><td>Egocentric bias</td><td>回忆中存在自利或自我美化的倾向，例如记得考试成绩比实际的好或者记得抓住的鱼比实际的大</td></tr><tr><td>衰退效应偏误</td><td>Fading affect bias</td><td>也称情感衰退偏误，负面情绪、不愉快的记忆比正面的积极的衰退得更快</td></tr><tr><td>虚假记忆/虚构症</td><td>False memory or Confabulation</td><td>也称错误记忆、伪记忆、虚谈症，记忆障碍和错误归因（Misattribution）的一种，记忆中产生空想、虚构，并非有意欺骗地捏造、歪曲、曲解关于某件事物的记忆，区别于撒谎，因为自己都不知道那些信息是虚假的</td></tr><tr><td>谷歌效应</td><td>Google effect</td><td>人们对于很容易用搜索引擎（如谷歌）就能从网络上搜集到的信息很容易淡忘</td></tr><tr><td>幽默效应</td><td>Humor effect</td><td>幽默的事物更加容易记住，可能的原因解释是幽默的事物会增加认知处理的时间以及激发情感</td></tr><tr><td>真相错觉效应</td><td>Illusion of truth effect</td><td>即使没有意识到听说过，人们也倾向认为听过的是真的，而不管该陈述实际上是否正确。换言之，人容易相信熟悉的话胜过陌生的</td></tr><tr><td>错觉关联</td><td>Illusory correlation</td><td>或称相关性错觉，错误地认为两个毫不相关的事物之间存在联系</td></tr><tr><td>延迟效应</td><td>Lag effec</td><td>也称滞后效应、间隔效应（Spacing effect），相对于短时间内多次接触的信息来说，人们容易学习记住那些长时间跨度但是接触少的信息。这一效应表明突击式的考前复习并不能带来很好的学习效果（质量），但是短时间内能够带来良好的记忆表现（Memory performance）</td></tr><tr><td>钝化与锐化</td><td>Leveling and Sharpening</td><td>可理解成强化与弱化，记忆随着时间的推移发生扭曲丢失细节的现象，特别重要的事情会得到锐化或者被选择性地想起，而其中的细节和某些方面的信息将被钝化或者遗忘。随着时间的推移以及回忆次数的增加，这两种趋势将进一步加强</td></tr><tr><td>处理深度效应</td><td>Levels-of-processing effect</td><td>深层次的分析产生更精细、持久、强大的记忆痕迹，且记忆中用不同方式“编码”的信息拥有不同的效力等级</td></tr><tr><td>列表长度效应</td><td>List-length effect</td><td>列表的长度越长，所能记住的项目的比例越少，但是随着列表长度的增加，所能记住的绝对数量也将增加</td></tr><tr><td>误导信息效应</td><td>Misinformation effect</td><td>也称错误信息效应，由于事后信息（Post-event information）的干扰，记忆变得愈加模糊或不准确</td></tr><tr><td>通道效应</td><td>Modality effect</td><td>也称模态效应，通过口语传达出来的信息，最后听到的东西会记忆得比较深刻，而书写的则相对更低</td></tr><tr><td>心境一致性记忆偏误</td><td>Mood-congruent memory bias</td><td>与当前心境相合的记忆更加容易回想</td></tr><tr><td>轮流发言效应</td><td>Next-in-line effect</td><td>当人们一个接着一个发言时，后面发言的人不太容易记住前一个人说过的话</td></tr><tr><td>部分项目提示效应</td><td>Part-list cueing effect</td><td>当记忆的内容是一整组的时候，提示其中的一项会使回忆起其他项目的难度加大</td></tr><tr><td>峰终定律</td><td>Peak-end rule</td><td>体验一项事物之后，所能记住的大约只有在高峰期与最终时的体验，而在过程中好与不好的比重和时间长短、总体的感觉，对记忆影响不大</td></tr><tr><td>创伤的持续性</td><td>Persistence of traumatic event</td><td>记忆中往往对创伤事件（Traumatic event）进行反复不断地回忆。另参见“创伤后压力症候群”</td></tr><tr><td>图画优异性效应</td><td>Picture superiority effect</td><td>也称图优效应，通过图片来传达的信息记忆效果要比通过文字传达的更好</td></tr><tr><td>积极效应</td><td>Positivity effect</td><td>或称正面效应，老年人的记忆偏向积极美好的倾向</td></tr><tr><td>首因效应、近因效应和序位效应</td><td>Primacy effect, Recency effect &amp; Serial position effect</td><td>在序列末尾的项目最容易想起，接着是起始的，而处于中间的项目最不容易想起</td></tr><tr><td>处理难度效应</td><td>Processing difficulty effect</td><td>处理难度更高的信息时，由于花费更多时间阅读与思考而更容易想起</td></tr><tr><td>怀旧凸显</td><td>Reminiscence bump</td><td>回忆人生事件时，青春期和成年早期的事比其他时期的事更容易想到</td></tr><tr><td>玫瑰色回忆</td><td>Rosy retrospection</td><td>也称美好的回忆，将过去事件的回忆美化得比实际更好</td></tr><tr><td>自我生成效应</td><td>Self-generation effect</td><td>人们记忆自己生成的信息更加清楚，而别人给出的信息则容易淡忘</td></tr><tr><td>自我关联效应</td><td>Self-relevance effect</td><td>与自己有关的记忆比与他人有关的记忆更加容易回想</td></tr><tr><td>来源混淆</td><td>Source confusion</td><td>记忆中把偶然发生的事件与其他信息相混淆，造成记忆歪曲</td></tr><tr><td>间隔效应</td><td>Spacing effect</td><td>长时间跨度重复暴露的信息比短时间跨度重复暴露的信息要更容易想起；比起无间隔的重复接触，有间隔的重复接触有较好的记忆与学习效果。另参见延迟效应（Lag effect）</td></tr><tr><td>焦点效应</td><td>Spotlight effect</td><td>也称聚光灯效应，高估别人关注自己表现和行为的错觉，认为自己是瞩目的焦点</td></tr><tr><td>陈规偏误</td><td>Stereotypical bias</td><td>记忆向着陈规或刻板映象扭曲，如种族和性别偏见，又如错误地认为某些名字是罪犯的</td></tr><tr><td>后缀效应</td><td>Suffix effect</td><td>也称附加效应，在不太需要回想起来的主题或条目后面加入合理的项目，会减少近因效应的影响，这是近因效应的一种应用</td></tr><tr><td>可暗示性</td><td>Suggestibility</td><td>错误归因（Misattribution）的一种，想法容易受到暗示者的提醒而发生扭曲</td></tr><tr><td>伸缩效应</td><td>Telescoping effect</td><td>记忆中将近期的事情往更早移，遥远的事情往更近移的倾向。因此近期的事情变得更加遥远，而遥远的事情变得更加临近</td></tr><tr><td>测试效应</td><td>Testing effect</td><td>或称测验效应，人们更容易记住自己反复书写过的信息，而不是反复阅读的信息</td></tr><tr><td>舌尖现象</td><td>Tip of the tongue phenomenon</td><td>能够想起一件事情的一部分或者相关的信息，但是难以回忆起全部。当多个相似的记忆同时出现时，会产生干扰或者阻塞，这将造成人们说话时欲言又止或者说到一半卡住</td></tr><tr><td>逐字效应</td><td>Verbatim effect</td><td>人们说过的话语中的大意比逐字的词语或完整的句子更容易记住，因为记忆记住的是表述而不是直接复制</td></tr><tr><td>雷斯多夫效应</td><td>Von Restorff effect</td><td>也称莱斯托夫效应、梵•雷斯托夫效应，突出的、醒目的、特别强调的事物更容易记住</td></tr><tr><td>蔡格尼克效应</td><td>Zeigarnik effect</td><td>也称蔡格尼克记忆效应、蔡格尼效应，未完成或者中断了的事物比完成了的事物更容易被记住</td></tr></tbody></table></div><h2 id="五、认知偏误的成因理论"><a href="#五、认知偏误的成因理论" class="headerlink" title="五、认知偏误的成因理论"></a>五、认知偏误的成因理论</h2><blockquote><p>有限理性（Bounded rationality）——理性与优化的限制1.</p></blockquote><ol><li>前景理论（Prospect theory）</li><li>心理账户（Mental accounting）</li><li>适应偏误（Adaptive bias）：基于有限的信息作出决策，并因错误的代价而有所偏误</li></ol><blockquote><p>属性替代（Attribute substitution）——无意识地用简单的判断替代了复杂的、困难的判断<br>归因理论（Attribution theory）</p></blockquote><ol><li>显著性（Salience）</li><li>朴素现实主义（Naïve realism）</li></ol><blockquote><p>认知失调（Cognitive dissonance），相关的是：</p></blockquote><ol><li>印象管理（Impression management）</li><li>自我感知理论（Self-perception theory），也称自我知觉理论</li></ol><blockquote><p>启发式判断与决策（Heuristics in judgment and decision making），包括：</p></blockquote><ol><li>可得性启发（Availability heuristic）：记忆中容易想起的东西偏向于生动、不寻常和充满感情</li><li>代表性启发（Representativeness heuristic）：基于相似性来判断可能性</li><li>情绪性启发（Affect heuristic）：通过情绪反应来作出决策，而不是风险效益的考量</li></ol><blockquote><p>关于情绪（Emotion）的其他理论：</p></blockquote><ol><li>情绪二因素理论（Two-factor theory of emotion），也称情绪二因论</li><li>躯体标记假说（Somatic markers hypothesis）</li></ol><blockquote><p>内省错觉（Introspection illusion）<br>统计（Statistics）的误解（Misinterpretations）与误用（Misuse），数字盲（Innumeracy）</p></blockquote><p>2012年一份《心理学公报》（Psychological Bulletin）指出，至少有8种看似无关的偏误是由同一种信息理论（Information-theoretic）生成机制产生，它认为在人类记忆中存储与提取（Retrieval）信息时存在的杂乱信息处理过程造成了偏误。</p><p>转载自silensea的<a href="http://silensea.org/2015/09/13/List-of-cognitive-biases-Wikipedia/" target="_blank" rel="noopener">个人博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、认知偏误简介&quot;&gt;&lt;a href=&quot;#一、认知偏误简介&quot; class=&quot;headerlink&quot; title=&quot;一、认知偏误简介&quot;&gt;&lt;/a&gt;一、认知偏误简介&lt;/h2&gt;&lt;p&gt;认知偏误（Cognitive biases）是一种倾向，它认为在某些方面，认知会与理性标准（Standard of rationality）或者良好的判断相偏离，它经常应用于心理学（Psychology）和行为经济学（Behavioral economics）的研究中。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="行为经济学" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
      <category term="认知偏误" scheme="http://yoursite.com/tags/%E8%AE%A4%E7%9F%A5%E5%81%8F%E8%AF%AF/"/>
    
      <category term="Cognitive biases" scheme="http://yoursite.com/tags/Cognitive-biases/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（7）：TextCNN调参技巧</title>
    <link href="http://yoursite.com/2018/02/26/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89%EF%BC%9ATextCNN%E8%B0%83%E5%8F%82%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/02/26/自然语言处理系列（7）：TextCNN调参技巧/</id>
    <published>2018-02-26T15:14:45.000Z</published>
    <updated>2018-11-03T16:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="https://arxiv.org/pdf/1510.03820.pdf" target="_blank" rel="noopener">A Sensitivity Analysis of (and Practitioners’ Guide to) Convolutional Neural Networks for Sentence Classification</a></p><p>近年来，卷积神经网络在句子分类任务上取得了显著的成绩(Kim, 2014;Kalchbrenner et al .,2014)，然而，这些模型要求从业者指定精确的模型结构与模型参数，例如，选择滤波器大小、正则化参数等等。目前尚不清楚对于句子分类的任务，不同的参数设定会对模型性能造成什么样的影响。因此，在这里我们对单层卷积神经网络进行情感分析，探索不同的参数对模型性能的影响；我们的目标是找出对语句分类来说的重要因素和不重要因素。由于一层的CNN结构简单，实验的表现也很好(Kim, 2014)，我们就着重使用这个模型来验证(而不同更复杂的模型)，从我们广泛的实证结果中得到一些了实用的建议，这些结果对于那些有兴趣用CNN对句子分类的人来说很有用。我们的实验结果所证实的一个重要结论是，研究人员应该记录性能差异，因为这可能是由于随机初始化或推理产生的。</p><a id="more"></a><h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p>在这个工作中，我们关注的是情感分类的重要任务。最近，研究表明，神经网络(CNNs)对这项任务的表现很好(Kim, 2014; Kalchbrenner et al., 2014; Wang et al., 2015; Goldberg, 2015; Iyyer et al., 2015)。这类模型利用词的分布式表示，首先将包含每个句子转换成一个向量，从而形成一个矩阵作为输入给CNN(图1)。实证结果令人印象深刻。这些模型不需要太复杂就能实现强大的结果：例如，Kim(2014)提出了一种直接的单层CNN架构，它可以在多个任务中实现一致的(或类似的)结果。因此，现在有了令人信服的支持，更倾向于使用CNN而不是稀疏线性模型来进行句子分类任务。然而，CNN的一个缺点是，它们要求从业者指定要使用的精确模型架构，并设置超参数。同样的，做出这样的决定似乎是一种黑箱操作，特别是因为在模型中有许多“自由参数”可以探索。这与广泛用于文本分类的线性模型形成了鲜明的对比，例如正则化的逻辑回归和线性支持向量机(SVMs) (Joachims, 1998)。这样的模型特征通常是通过对文本的稀疏表示而产生的，并且需要相对较少的调优:通常只需要设置正则化项的系数(即:模型偏差)。使用训练数据进行线性搜索来确定参数是设置超参数的方法。</p><p>最近关于CNN的句子分类的研究，已经提供了用于实现报告结果的设置。然而这些参数设定是通过并非是特定的调参过程。但实际上，搜索CNN的参数空间是极其昂贵的，至少有两个原因:（1）训练这些模型的速度相对较慢，即使使用gpu。例如，在SST-1数据集(Socher et al.， 2013)中使用与(Kim, 2014)类似的配置，进行10倍交叉验证，需要1个小时。可能的模型架构和超参数空间是巨大的。例如，我们所讨论的简单的CNN架构，至少需要指定以下内容:输入的词向量表示;滤波器大小;特征图的数量;激活功能;池化策略;dropout比例(如果有的话);和l2范数的系数(如果有的话)。</p><p>实际上，对所有这些参数进行调优是不可行的，尤其是考虑到参数估计所需的运行时间。因此，我们的目的是要根据经验来确定那些需要花费精力进行调整的参数，以及那些在性能上无关紧要的，或者在特定的数据集上有“最佳”效果的参数。我们从前人对神经模型的经验分析中得到启发，该模型由Coates et al.(2011)和Breuel (Breuel, 2015)进行，研究了非监督特征学习效果的影响因素，以及随机梯度下降(SGD)超参数对训练的影响。在这里，我们考虑了模型结构的配置和单层CNNs的超参数值对句子分类任务的影响。我们报告了大量实验的结果，探索了不同的模型结构，运行了7个句子分类数据集。</p><h2 id="二、背景和预备"><a href="#二、背景和预备" class="headerlink" title="二、背景和预备"></a>二、背景和预备</h2><p>深度学习方法已在机器学习中得到很好的应用(LeCun et al.， 2015;Bengio,2009)。对于图像和语音处理任务来说，它们尤其成功(也很受欢迎)。然而，最近这些方法已经开始超越传统的自然语言处理(NLP)任务的线性模型(Goldberg, 2015)，这个领域的大部分兴趣都集中在如何得到分布式的词语表达(Bengio et al.， 2003;Mikolov et al.， 2013)并共同将这种“内部”表征嵌入到分类模型中(Col lobert and Weston, 2008;Collobert et al .,2011)或句子建模(Kalchbrenner et al.， 2014;Socher et al .,2013)。</p><p>在(Kalchbrenner et al.， 2014)中，作者构建了一个包含多个卷积层的CNN架构。他们的模型使用了动态k-max池。他们的模型假定潜在的、密集的、低维度的词向量(在推理之前初始化为随机值)。</p><p>Kim(2014)定义了一个更简单的架构，在相同的数据集上实现了类似的结果(Kalchbrenner et al.， 2014)。这个模型也将每个单词都表示为一个稠密的、低维的向量(Mikolov et al.， 2013)，他们使用预先训练的词向量，并考虑两种方法:静态和非静态。在前一种方法中，词向量被视为静态输入，而在后一种方法中，则动态调整为特定任务的词向量。</p><p>在其他地方，Johnson和Zhang(2014)引入了相似的模型，但改用了高维的one-hot向量表示。他们考虑了这一方法的两种变体，seq-CNN和bow-CNN。前者完全保留了顺序结构(以在非常高维的空间输入空间中操作的代价)，而后者保留了一些序列，但在小区域内丢失了顺序。他们的重点是更长的文本的分类，而不是句子(当然，这个模型也可以用于句子的分类)。Kim的体系结构相对简单——这与Johnson和Zhang(2014)所提出的基本相同，模块化的词向量——再加上在多个数据集上观察到的强大的经验性能，使得这是一个很有吸引力的句子分类方法。然而，在实践中，我们需要做一些模型架构决策和设置各种超参数。目前，很少有经验数据可以指导此类决定;解决这一差距是我们的目标。</p><h3 id="2-1-CNN"><a href="#2-1-CNN" class="headerlink" title="2.1 CNN"></a>2.1 CNN</h3><p>我们首先描述我们在本文中使用的相对简单的CNN架构。我们从一个标记化的句子开始，然后我们将它转换成一个句子矩阵，其中的行根据每个词得到的单词向量。例如，这些可能是谷歌word2vec (Mikolov et al.， 2013)或GloVe(Pennington et al.， 2014)模型的输出。我们用d表示向量的维数。如果给定句子的长度(即词汇数)是s,然后句子的维数矩阵s×d.接下来，我们可以有效地将句子矩阵作为一个“图像”，通过线性滤波器对它进行卷积操作。在NLP应用中，数据具有固有的顺序结构。直观上，因为行表示离散的符号(即单词)，所以使用宽度等于向量的维数的滤波器是合理的。（比如d)。然后我们可以考虑只改变滤波器的“高度”，它指的是共同考虑的相邻行数(词向量)。从这一点开始，我们将把滤波器的高度称为滤波器的区域大小。</p><p>假设有一个滤波器的参数化权向量$w∈R^{h×d}$和区域大小$h$;$w$包含要估计的$h·d$个参数。我们用$A\in R^{s×d}$表示句子矩阵,并使用$A[i,j]$代表从第$i$行到第$j$行的子矩阵。卷积算子的输出序列是通过对A的子矩阵进行重复的卷积操作而得到的:</p><script type="math/tex; mode=display">o_i = w·A[i:i+h-1 ] \ (1)</script><p>其中，$i=1….s-h+1$，$.$表示子矩阵和滤波器的点积（先对对应元素做乘法，然后求和）,输出序列的长度为$s-h+1$。再加上一个偏置项$b$以及激活函数$f$得到对应的特征图$c\in R^{s-h+1}$：</p><script type="math/tex; mode=display">c_i=f(o_i+b)</script><p>注意，我们可以使用多个滤波器来实现相同的区域大小，目标是每个滤波器从相同的区域学习互补的特性。也可以指定多个不同区域大小的过滤器(例如:“高度”)。</p><p>每个滤波器生成的特征图的维数，正好是句子长度和滤波区域大小的函数。然后，将一个池化函数应用到每个feature map中，以减少需要估计的参数的尺寸和数量。通常，池化操作为1-max池函数(Boureau et al.，2010b)，它从每个feature map生成一个一维特性。或者，可以将池化操作修改为在特征映射中在相同大小的区域内对每个区域对应的显著特征进行编码。每个滤波器映射生成的输出可以被连接到一个“顶部”特征向量，在1-max池的情况下它的大小将独立于单个的句子长度。然后通过一个softmax函数来生成这个表示，以生成最终的分类。在这个softmax层，可以选择应用“dropout策略”(Hinton et al.， 2012)作为正则化方法。这需要在向量中随机设置一些值为0。我们也可以选择施加l2范数约束，当它超过这个值时，将向量的l2范数线性扩展到一个指定的阈值。在训练过程中，最小化的目标是分类的交叉熵损失，估计的参数包括滤波器的权向量(s)、激活函数中的偏置项，以及softmax函数的权向量。请注意，我们可以选择固定词向量(我们将其称为“static”)或作为模型的附加参数，并在模型训练过程中调整(我们将把这种方法称为“non-static”)。我们探索了这两种变体。图1提供了一个简单的示意图，以说明刚刚描述的模型架构。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvc9jocbfj30lc0mn75z.jpg" alt=""></p><h2 id="三、数据集"><a href="#三、数据集" class="headerlink" title="三、数据集"></a>三、数据集</h2><p>我们使用同样的7个数据集(Kim, 2014)，简要总结如下:</p><ul><li>MR:句子极性数据集(Pang and Lee, 2005)。</li><li>SST-1: Stanford Sentiment Treebank (Socher et al.， 2013)。请注意，为了使输入表示在任务中一致，我们只对句子进行训练和测试。与之形成对比的是(Kim, 2014)，在这篇文章中，作者对短语和句子进行了训练。</li><li>SST-2:从SST-1派生而来，但只对两个类进行解析。我们只对句子进行训练和测试，不包括短语。</li><li>Subj:主观性数据集(Pang and Lee, 2005)。</li><li>TREC:问题分类数据集(Li and Roth, 2002)。</li><li>CR:客户审核数据集(Hu and Liu, 2004)。</li><li>MPQA:观点极性数据集(Wiebe et al.， 2005)</li></ul><p>在表1中，我们报告了所有七个数据集的平均长度和标记化语句的最大长度。有关这些数据集的更多细节，请参考(Kim, 2014)。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvc9riyo9j30d608sweq.jpg" alt=""></p><h2 id="四、baseline模型的性能"><a href="#四、baseline模型的性能" class="headerlink" title="四、baseline模型的性能"></a>四、baseline模型的性能</h2><p>为了给CNN的结果提供一个参考点，我们首先报告了使用稀疏正则化SVM进行句子分类的性能。我们使用unigram和bigram特性，只对所有数据集保持最频繁的3万个特征。我们还想通过将信息直接嵌入到这些模型中，来探索实现的相对收益。为此，我们用平均的单词向量(从谷歌word2vec3或GloVe4)来计算这个表达式，并计算出包含句子的单词，类似于(Lai et al.， 2015)中的方法。然后，我们使用RBF-kernel SVM作为在这个稠密特性空间中操作的分类器。我们还尝试将unigram, bi-gram和word2vec作为句子的特征，使用线性支持向量机作为分类器。我们通过嵌套的交叉折叠验证来优化正则化超参数，从而提高了精度。对所有的数据集都进行了十折交叉验证，结果如表2所示。为了保持一致性，我们对之前工作中描述的数据使用相同的预处理步骤(Kim, 2014)。从这些结果中可以立即发现的一件事是，将word2vec输出引入到特征向量中可以实现性能提升。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvca3xkhwj30iz088wfa.jpg" alt=""></p><h2 id="五、CNN情感分析"><a href="#五、CNN情感分析" class="headerlink" title="五、CNN情感分析"></a>五、CNN情感分析</h2><p>我们现在报告的结果来自于我们的主要分析工作，目的是使用CNNs对句子情感分析，作为一个具体的架构和超参数设置的功能。为此，我们以baseline配置(如下所述)作为起点，该配置在之前的工作(Kim, 2014)中表现得很好。然后，我们依次探讨了修改该baseline配置组件的效果，并保持其他设置不变。</p><p>我们用“静态”和“非静态”两种词向量来进行实验。在前一种情况下，在训练过程中，单词向量不会被更新，而在后一种情况下，向量会不断调整。非静态配置优于静态配置。因此，本文只报告非静态结果，尽管我们提供了附录中静态配置的结果。</p><h3 id="5-1-Baseline-参数设置"><a href="#5-1-Baseline-参数设置" class="headerlink" title="5.1 Baseline 参数设置"></a>5.1 Baseline 参数设置</h3><p>我们现在考虑CNN的baseline模型配置的性能。具体来说，我们从之前工作中使用的模型架构和超参数开始(Kim, 2014)。为了将由于各种体系结构决策和超参数设置导致的性能差异置于环境中，必须严格评估参数估计过程中的差异。不幸的是，尽管有一个高度随机的推理过程，但大多数之前的工作并没有说明这样的差异。该方差可归因于随机梯度下降(SGD)、随机dropout和随机权值参数初始化的估计。我们表明，通过10倍交叉验证计算的平均性能在重复运行时表现出较高的方差。</p><p>我们首先使用表3中描述的原始参数设置，并为每个数据集复制实验100次，其中每一个复制都是一个10倍的CV，并且复制的折叠是固定的。表3中的“ReLU”指的是整流线性单元(Maas et al.， 2013)，这是CNN常用的激活函数。我们记录每个重复试验的10折交叉验证的平均精度，并报告超过100次重复试验的平均值、最小值和最大值。我们对静态和非静态方法都这样做。这提供了一种我们可以观察到的不改变模型的方差的感觉。结果如表4所示。图2提供了在所有数据集上对这两种方法的100次重复的平均精度的密度图。为了清晰显示，我们排除了SST-1，因为在这个数据集上，精度明显降低(但是，结果可以在表中找到)，由于我们对某些数据集进行了不同的分割和处理，正如前面所描述的那样，结果也与原来的不同。因为在这个工作中，我们只关心CNN的每个部分对性能的敏感性和影响，我们不太关心绝对的准确性，也不会比较我们在之前的作品中得到的结果。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcaeoom3j30bk063wep.jpg" alt=""></p><p>在确定了CNNs的基准性能之后，我们现在考虑不同架构决策和超参数设置的影响。为此，我们保留所有其他的设置常量(如表3所示)，并且只改变感兴趣的组件。对于我们所考虑的每一个配置，我们重复实验10次，每一次实验都是10折交叉验证。就像原始参数设置的100次重复试验一样，我们也报告了10次10折交叉验证试验的平均均值、最小均值和最大值。对于所有的实验，我们对数据使用与(Kim, 2014)相同的预处理步骤。类似地，我们使用ADADELTA更新规则 (Zeiler, 2012)，并将minibatch大小设置为50。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcar7hxij30ld077wf4.jpg" alt=""></p><h3 id="5-2-word2vec"><a href="#5-2-word2vec" class="headerlink" title="5.2 word2vec"></a>5.2 word2vec</h3><p>句子分类模型的一个很好的特性是，它以分布式的词语作为输入的形式开始，这是一种灵活的结构，它可以在不同的预先训练的词向量中交换。因此，我们首先探讨了CNNs对所使用的输入表示的句子分类的敏感性。特别地，我们用Glove表示替换谷歌word2vec。谷歌word2vec使用了一个局部上下文窗口模型，从谷歌新闻(Mikolov et al.， 2013)中训练了1000亿单词，而GloVe则提出了一个模型，它利用了一个非常大的语料库(Pennington et al.， 2014)，利用全局单词的联合作用来统计数据。在本文中，我们使用了一个Glove版本，它是从一个包含8400亿个web数据标记的语料库中训练出来的，并且还有300个维度。我们保留所有其他设置与原始配置相同。我们的报告结果见表5。(请注意，我们还报告了SVM的结果，这些结果在表2中增加了平均Glove向量。)</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvcb1gox0j30c8063wew.jpg" alt=""></p><p>作为获取对所有数据集最佳性能的潜在简单方法，我们还考虑了一种方法，该方法利用了这两种预先训练出来的表示方法。具体地说，我们将word2vec和Glove向量连接到每个单词，生成了600维的单词向量，我们将它们作为CNN的输入。预训练的向量可能并不总是适用于特定的单词(在word2vec或Glove中，或者两者都有);在这种情况下，我们随机初始化相应的子向量，如上所述。结果见表6。这里我们报告的结果只针对非静态变量，考虑到它的一般优势。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcbhg8rkj30fz08ydgb.jpg" alt=""></p><p>从这些结果中可以看出，使用Glove和word2vec时的相对性能取决于数据集，不幸的是，仅仅将这些表示连接起来并不一定有帮助。实际上，当面对一个新的数据集时，很可能需要使用训练数据来尝试不同的预先训练的单词向量。我们也尝试用长、稀疏的one-hot向量作为输入词表示(Johnson and Zhang, 2014)。在这个策略中，每个单词被编码成一个热矢量，它是一个稀疏的高维向量。在这种情况下，句子矩阵的宽度等于词汇量。在训练过程中，一个one-hot向量是固定的，因为这个方法就像它在一个预构建的字典中搜索每个单词一样。性能如表7所示。</p><p>将结果与word2vec和Glove的结果进行比较，我们可以看到在相同的CNN基本配置下，one-hot的性能比word2vec或Glove差。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcbpaye7j30eq07zgm0.jpg" alt=""></p><p>我们不排除有特定配置的可能性，one-hot的CNN可能会比其他的输入表示的句子分类地更好。但我们这里的证据是，one-hot表示的CNN可能不适合句子分类。这可能是由于稀疏性;这些句子可能过于简短，不足以提供足够的信息来进行这种高维编码(而对于长文档来说，这可能不是一个问题)。</p><h3 id="5-3-滤波器区域大小"><a href="#5-3-滤波器区域大小" class="headerlink" title="5.3 滤波器区域大小"></a>5.3 滤波器区域大小</h3><p>我们首先将区域大小设为1来看看滤波器区域大小的效果，我们将这个区域的feature map的数量设置为100(与原来的配置一样)。我们考虑区域大小为1、3、5、7、10、15、20、25和30，并记录每个区域大小的10倍交叉验证的平均值、最小值和最大精度，并将结果显示在表8中。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcbw23ajj30gh0emq3c.jpg" alt=""><br>图3显示了每个区域大小和区域大小为3时的10次重复实验的平均精度之间的差异。因为我们只对精确的趋势感兴趣，因为我们改变了CNN的区域大小或其他组件(而不是每个任务的绝对性能)，我们只显示了从任意baseline的精度变化(这里，一个区域大小为3)。我们遵循本公约的所有数据，以方便解释。</p><p>从图中可以看出，每个数据集都有自己的最佳滤波区域大小范围。实际上，这表明在指定范围内执行粗网格搜索;这里的数据表明，句子分类的合理范围可能是2到25。然而，对于包含较长句子的数据集，例如CR(最大语句长度为105)，最优区域的大小可能更大。这也可能是由于在CR中，在更大的窗口下，更容易预测正面/负面的客户评论。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvcc38e0kj30w9081404.jpg" alt=""></p><p>我们还探讨了合并多个不同的过滤器区域大小的效果，同时保持每个区域大小的feature map的数量为100。在这里，我们发现将几个过滤器与区域大小接近最佳的单一区域大小可以提高性能，但是在最优范围之外添加区域大小可能会损害性能。例如，从图3可以看出，MR数据集的最佳单个区域大小是7。因此，我们将几个不同的过滤器区域大小结合到这个最优范围内，并将其与在此范围之外使用区域大小的方法进行比较。从表9可以看出，使用(5,6,7)和(7,8,9)和(6,7,8,9)——靠近最佳单一区域大小的集合——产生最好的结果。当与(3,4,5)baseline设置比较时，差异尤其明显。注意，即使只使用单个良好的过滤器区域大小(这里为7)，结果也比组合不同的大小(3、4、5)更好。最佳的组合是简单地使用许多特征映射(这里为400)，以及所有区域大小等于7，即最好的区域大小。</p><p>但是，我们注意到在某些情况下(例如，对于TREC数据集)，使用多个不同的，但接近最优的区域大小表现最好。我们在表6的TREC数据集上使用几个区域大小提供了另一个示例性经验结果。从单个区域大小的性能来看，我们发现TREC的最佳单过滤区域大小是3和5，因此我们研究这些值附近的区域大小，并将其与使用多个区域大小的值进行比较。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvccf5n01j30fy0nv764.jpg" alt=""></p><p>这里我们看到(3,3,3)和(3,3,3)比(2,3,4)和(3,4,5)更差。然而，结果仍然表明，在最优的最佳区域尺寸附近的区域大小的组合比在最优的单一区域大小下使用多个区域的大小要好得多。此外，我们再次看到一个良好的区域大小(3)超过了几个次优区域大小(7、8、9)和(14、15、16)。</p><p>根据这些观察,我们认为这建议先进行粗线通过一个过滤器搜索区域大小找到最好的考虑数据集的大小,然后探索附近的几个区域大小的组合这最好的尺寸,包括结合不同的区域大小和副本的最优尺寸。</p><h3 id="5-4-特征图数量"><a href="#5-4-特征图数量" class="headerlink" title="5.4 特征图数量"></a>5.4 特征图数量</h3><p>我们再次保持其他配置不变，因此有3个过滤器区域大小:3、4和5。我们只更改每个相对于100的baseline的特征映射的数量。我们考虑大小10,50,100,200,400,600,1000,2000。报告结果如图4所示。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvccmthpxj30zk06i0u5.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvccr9f3sj30g80fa3yw.jpg" alt=""></p><p>每个过滤器区域大小的“最佳”feature map数量取决于数据集。然而，增加超过600个feature map，充其量只能带来边际收益，而且往往会损害业绩(可能是由于过拟合)。另一个重要的事实是，当feature map的数量增加时，需要更长的时间来训练模型。实际上，这里的证据表明，搜索范围可能在100到600之间。注意，当一个人面临一个新的类似的句子分类问题时，这个范围只是提供一个可能的标准。当然，有可能在某些情况下，超过600个特征图是有益的，但这里的证据表明，花费精力去探索这一点可能是不值得的。</p><h3 id="5-5-激活函数"><a href="#5-5-激活函数" class="headerlink" title="5.5 激活函数"></a>5.5 激活函数</h3><p>我们考虑了卷积层的七个不同的激活函数，包括:ReLU(根据baseline配置)，双曲正切(tanh)， Sigmoid函数(Maas et al.， 2013)， SoftPlus函数(Dugas et al.， 2001)， Cube function (Chen and Manning, 2014)和tanh Cube function (Pei et al.， 2015)。我们使用“Iden”来表示原本函数，这意味着不使用任何激活函数。表15展示了使用不同的激活函数在非静态CNN中实现的结果。在9个数据集中，最好的激活函数是Iden、ReLU和tanh。在只有一个数据集(MPQA)中，SoftPlus函数的性能超过了其他函数。Sigmoid、Cube和tanh数据集始终比其他激活函数执行得更糟糕。因此，我们在这里不报告结果。tanh函数的性能可能是由于它的零中心特性(与Sigmoid相比)。ReLU与Sigmoid相比具有非饱和形式的优点，并且已经观察到可以加速SGD的收敛(Krizhevsky等，2012)。一个有趣的结果是，不应用任何激活函数(Iden)有时会有所帮助。这表明在一些数据集上，一个线性变换足以捕获单词嵌入和输出标签之间的相关性。然而，如果存在多个隐藏层，则Iden可能比非线性激活函数更不合适。实际上，对于单层CNNs中激活函数的选择，我们的研究结果表明对ReLU和tanh进行了实验，也可能是Iden。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvcd1w2vrj30fx0ee74m.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcd6fnk8j30w00663zr.jpg" alt=""></p><h3 id="5-6-池化"><a href="#5-6-池化" class="headerlink" title="5.6 池化"></a>5.6 池化</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcdd8qivj30fj0gnq37.jpg" alt=""><br>接下来我们研究了池化策略和池化区域大小的影响。我们将过滤器区域大小和特征映射的数量固定在baseline配置中，从而只改变池策略或池区域大小。在baseline参数设定中，我们对所有的feature map都使用了最大池化。得到长度为1的特征向量。但是，也可以在较小的相同大小的局部区域上执行池化操作，而不是在整个feature map (Boureau et al.， 2011)上执行。feature map上的每个小区域都经过池化操作生成单个数字，并且这些数字可以连接成一个feature map对应的特征向量。下面的步骤与1-max池相同:我们将所有的特征向量连接在一起，形成分类层的单个特征向量。我们试验了大小为3、10、20和30的局部区域，并发现1-max池比所有局部最大池配置的性能好。所有的数据集都呈现了这个结果。我们还考虑了类似于k-max池化的策略(Kalchbrenner et al.， 2014)，其中从整个feature map中提取了最大的k个值，并保留了这些值的相对顺序。我们对k进行了探索，发现1-max池的性能最好，始终优于k-max池。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvcdjuec3j30we0fo426.jpg" alt=""></p><p>接下来，我们考虑取区域的平均值，而不是区域的最大值(Boureau等人，2010a)。我们保留了其余的参数。我们尝试了区域大小为  的局部平均池化。我们发现，至少在CR和TREC数据集上，平均池化比最大池化的性能差(很多)。由于在平均池下观察到的性能和运行时间非常慢，所以我们没有对所有数据集进行完整的实验。我们对池化策略的分析表明，1-max池化对句子分类任务的效果总是优于其他策略。这可能是因为预测上下文的位置无关紧要，而句子中的某些n-grams可以比共同考虑的整个句子更具预测性。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvcdpbjqsj30go097mxu.jpg" alt=""></p><h3 id="5-7-正则化"><a href="#5-7-正则化" class="headerlink" title="5.7 正则化"></a>5.7 正则化</h3><p>CNNs的两种常见正则化策略是dropout和l2范数。我们在这里探讨这些效应。从输入到倒数第一层应用Dropout。我们试验了从0.0到0.9的dropout比率，并根据baseline配置将l2范数约束固定到3。非静态CNN的结果如图5所示，0.5指定为baseline。我们也展示了当我们去掉了dropout和l2范数约束时(即不执行正则化时)的准确性，表示为None。另外，我们还考虑了l2正则对权重向量的影响，这些权重向量参数化了softmax函数。回想一下，当一个权重向量的l2范数超过这个阈值时，它是线性伸缩的，因此较小的c意味着更强的正则化。像dropout，这个策略只适用于倒数第一层。我们在图8中显示了不同c对非静态CNN的相对影响，我们将dropout率固定在0.5；3是这里的baseline模型的正则化参数，（再一次地，任意地)。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvcdu8yg9j30wt0el77p.jpg" alt=""></p><p>从图7和图8可以看出，根据数据集，非零的dropout比率可以帮助(尽管非常少)从0.1到0.5。但是，施加l2正则约束通常不会很大地提高性能(除了Opi)，甚至对至少一个数据集(CR)的性能产生负面影响。我们还研究了在增加feature map的数量时dropout比率效应。我们将每个过滤器大小的feature map的数量从100增加到500，并将max l2正则约束设置为3。dropout比率的影响如图7所示。我们看到，drouout比率的影响几乎和特征图的数量是100的时候一样，而且没有多大帮助。但是我们观察到，对于数据集SST-1来说，当它是0.7时，dropout比率实际上是有帮助的。从图4可以看出，当feature map的数量大于100时，可能由于过拟合而影响了性能，所以在这个情况下dropout将会减轻这种影响。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcdzhiuzj30gs0erwep.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvce6j82gj30fx0f00t3.jpg" alt=""></p><p>我们也尝试了只在卷积层上应用“dropout”，但仍然将分类层的最大标准约束设置为3，使所有其他设置完全相同。这意味着我们在训练时随机将句子矩阵的元素设置为0，然后在测试时将p与句子矩阵相乘。从图8中可以看出，dropout比率对卷积层的影响如图8所示。我们再次看到，在卷积层上运用dropout帮助很小，而且很大的dropout率极大地伤害了性能。</p><p>总之，与现有的一些文献(Srivastava et al.， 2014)相反，我们发现dropout对CNN的表现没有什么好处。我们将这一现象归因于一层CNN的参数数量比多层深度学习模型要小。另一种可能的解释是，使用词嵌入有助于防止过拟合(与基于单词的编码相比)。然而，我们并不是主张完全放弃正则化。实际上，我们建议将dropout率设置为一个小的值(0 -0.5)，并使用一个相对较大的max正则约束，同时增加feature maps的数量，以查看更多的特性是否会有所帮助。当进一步增加feature map的数量似乎会降低性能时，增加dropout比率可能是值得的。</p><h2 id="六、结论"><a href="#六、结论" class="headerlink" title="六、结论"></a>六、结论</h2><p>我们对CNNs的句子分类进行了广泛的实验分析。我们总结了我们的主要发现，并从这些实际的指导中总结出了研究人员和实践者在现实场景中使用和部署cnn的方法。</p><h3 id="6-1-主要实证结果的总结"><a href="#6-1-主要实证结果的总结" class="headerlink" title="6.1 主要实证结果的总结"></a>6.1 主要实证结果的总结</h3><ul><li><p>以前的工作往往只报告模型实现的数据集的平均性能。但是，这种忽略方差完全是由于随机推理过程所使用的。这可以是相当大的:保持所有的常数(包括折叠)，因此方差是完全由随机推理过程决定的，我们发现，平均精度(通过10倍交叉验证计算)的范围可以达到1.5个点。在irony数据集上，AUC的范围甚至更大，达到3.4分(见表3)。在将来的工作中应该进行更多的复制，并且应该报告范围/方差，以防止可能的关于相对模型性能的错误结论。我们发现，即使将它们调到手边的任务，输入词向量表示(例如，在word2vec和Glove之间)的选择对性能有影响，但是不同的表示对不同的任务有更好的表现。至少对于句子分类来说，两者似乎都比直接使用one-hot向量要好。</p></li><li><p>然而,我们注意到:(1)如果有一个足够大量的训练数据，结果可能就不是这样,以及(2)与这里的简单版本相比，最近由约翰逊和张提出的semi-supervised CNN模型(Johnson and Zhang, 2015)可能提高性能(Johnson and Zhang, 2014)。</p></li><li><p>过滤区域的大小对性能有很大的影响，应该进行调整。</p></li><li><p>feature map的数量也可以在性能上扮演重要的角色，增加feature map的数量会增加模型的训练时间。</p></li><li><p>1-max池一致优于其他池化策略。</p></li><li><p>正则化对模型的性能影响较小。</p></li></ul><h3 id="6-2对从业人员的具体建议"><a href="#6-2对从业人员的具体建议" class="headerlink" title="6.2对从业人员的具体建议"></a>6.2对从业人员的具体建议</h3><p>根据我们的经验结果，我们提供了关于CNN架构和超参数的指南，为那些希望在句子分类任务中部署cnnn的从业者提供参考。</p><ul><li><p>考虑从表2中描述的基本配置开始，使用非静态word2vec或Golve，而不是one-hot矢量。但是，如果训练数据集的大小是非常大的，那么使用one-hot向量来探索可能是值得的。或者，如果一个人能够访问大量未标记的域内数据(Johnson和Zhang, 2015)，也可能是一个选项。</p></li><li><p>通过对单个过滤器区域大小的线性搜索来找到“最佳”的单一区域大小。一个合理的范围可能1至10。然而，对于像CR这样的长句的数据集，可能值得探索更大的过滤器区域大小。一旦确定了这一“最佳”区域大小，就可能值得探索将多个过滤器组合在一起，使用区域大小接近这个最佳大小的区域，因为根据经验，多个“好”区域大小总是优于仅使用单一最佳区域大小。</p></li><li><p>将每个过滤器区域的特征映射的数量从100个更改为600个，并且在这个过程中，使用一个小的dropout比率(0 -0.5)和一个大的max正则约束。注意，增加feature map的数量会增加运行时间，因此需要权衡考虑。还要注意发现的最佳值是否在距离边界附近(Bengio, 2012)。如果最好的值接近600，那么尝试更大的值可能是值得的。</p></li><li><p>如果可能，考虑不同的激活函数:ReLU和tanh是最好的整体候选。对于我们的一层CNN来说，完全没有激活函数是值得的。</p></li><li><p>使用1-max池;似乎没有必要花费资源来评估替代战略。</p></li><li><p>关于正则化:当增加feature map的数量开始减少性能时，试着施加更强的正则化，例如，dropout比率大于0.5。</p></li><li><p>在评估模型的性能(或其特定配置)时，必须考虑方差。因此，应该重复交叉折叠验证过程，并考虑方差和范围。</p></li></ul><p>当然，以上建议仅适用于包含有相似属性的句子的数据集。也许有一些与我们的发现背道而驰的例子。尽管如此，我们相信这些建议可能会为研究人员或实践者提供一个合理的起点，他们希望将简单的一层CNN应用到现实世界的句子分类任务中。我们强调，我们选择了这个简单的单层CNN，根据观察到的强大的经验性能，它将它定位为一个新的baseline模型，类似于词袋SVM和逻辑回归。因此，在实施更复杂的模型之前，应该考虑这种方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;https://arxiv.org/pdf/1510.03820.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Sensitivity Analysis of (and Practitioners’ Guide to) Convolutional Neural Networks for Sentence Classification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近年来，卷积神经网络在句子分类任务上取得了显著的成绩(Kim, 2014;Kalchbrenner et al .,2014)，然而，这些模型要求从业者指定精确的模型结构与模型参数，例如，选择滤波器大小、正则化参数等等。目前尚不清楚对于句子分类的任务，不同的参数设定会对模型性能造成什么样的影响。因此，在这里我们对单层卷积神经网络进行情感分析，探索不同的参数对模型性能的影响；我们的目标是找出对语句分类来说的重要因素和不重要因素。由于一层的CNN结构简单，实验的表现也很好(Kim, 2014)，我们就着重使用这个模型来验证(而不同更复杂的模型)，从我们广泛的实证结果中得到一些了实用的建议，这些结果对于那些有兴趣用CNN对句子分类的人来说很有用。我们的实验结果所证实的一个重要结论是，研究人员应该记录性能差异，因为这可能是由于随机初始化或推理产生的。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="TextCNN" scheme="http://yoursite.com/tags/TextCNN/"/>
    
      <category term="Dropout" scheme="http://yoursite.com/tags/Dropout/"/>
    
      <category term="non-static" scheme="http://yoursite.com/tags/non-static/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（11）：深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2018/02/25/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/02/25/python编程系列（11）：深拷贝与浅拷贝/</id>
    <published>2018-02-25T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="深拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="http://yoursite.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（6）：TextCNN</title>
    <link href="http://yoursite.com/2018/02/24/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9ATextCNN/"/>
    <id>http://yoursite.com/2018/02/24/自然语言处理系列（6）：TextCNN/</id>
    <published>2018-02-24T15:14:45.000Z</published>
    <updated>2018-11-03T12:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自卷积神经网络用于文本分类的开山之作<a href="https://arxiv.org/abs/1408.5882" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a>，并相应的对其实现代码进行讲解。</p><p>我们进行了一系列关于卷积神经网络(CNN)的实验，这些实验是基于预先训练的词向量训练的，用于句子级别的分类任务。我们得到了一个简单的参数微调的以及静态矢量的CNN在多个基准上取得了优异的结果。通过微调学习任务特定的向量可以进一步提高性能。我们还建议对体系结构进行简单的修改，以允许使用特定于任务的和静态的向量。CNN在这里讨论了7项任务中4项的改进，包括情绪分析和问题分类。</p><a id="more"></a><h2 id="一、导语"><a href="#一、导语" class="headerlink" title="一、导语"></a>一、导语</h2><p>近年来，深度学习模式在计算机视觉(Krizhevsky et al.， 2012)和语音识别(Graves et al.， 2013)中取得了显著的成绩。在自然语言处理中，许多深度学习方法都涉及通过神经语言模型学习词向量表示(Bengio et al.， 2003;Yih et al .,2011;Mikolov et al.， 2013)，并通过学习的词向量进行分类(bert et al.， 2011)。词向量，在单词中从一个稀疏的1- V编码(这里V是词汇量)到一个较低维度的向量空间，通过一个隐藏层，本质上是特征提取器，在它们的维度中编码词汇的语义特征。在这样稠密的表示法中，语义上相近的词在欧几里得或余弦距离上也同样接近（低维向量空间）。</p><p>卷积神经网络(CNN)利用具有卷积滤波器的层来应用于局部特征(LeCun等人，1998)。开端于计算机视觉的CNN模型后来被证明在自然语言处理中也很有效，在语义解析(Yih et al .,2014)、搜索查询检索(沈et al .,2014)、句子建模(Kalch -布伦纳et al .,2014)和其他传统NLP任务(Collobert et al .,2011)都取得了非常好的效果。</p><p>在目前的工作中，我们训练了一个简单的CNN，它只有一层卷积层，前面连接由无监督的神经语言模型训练的的词向量。这些向量是由Mikolov等人(2013)在谷歌新闻的1000亿字上进行训练得到，并已经公开了。我们首先保持向量静态，只学习模型的其他参数。即使对超参数进行了微调，这个简单的模型在多个基准上也都取得了出色的结果，这表明预先训练的词向量是“通用”的特征构造器，它们可以用于各种分类任务。通过微调，学习特定任务的向量可以得到进一步的改进。我们最后描述了对体系结构的一个简单的修改，允许使用多个通道来使用预先训练的和任务特定的向量。</p><p>我们的工作与Razavian et al.(2014)类似，它表明，对于图像分类，从预先训练的深度学习模型获得的特征提取器在各种任务中都表现良好，包括与最初的任务不同的任务，这些任务的特征提取器是经过训练的。</p><h2 id="二、模型"><a href="#二、模型" class="headerlink" title="二、模型"></a>二、模型</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4l4e186j30qd0cjmxx.jpg" alt=""></p><p>图1所示的模型架构是CNN架构的一个小变体。$x_i\in R^k$表示一个句子中第$i$个词的$k$维词向量。一个长度为$n$的句子（可以padding）表示为</p><script type="math/tex; mode=display">x_{1:n}=x_1⊕x_2⊕...⊕x_n \ (1)</script><p>其中⊕是连接操作符。一般来讲，$x_{i:i+j}$表示词$x_i,x_{i+1}···，x_{i+j}$的连接。卷积运算涉及到一个滤波器，它被应用到一些单词的窗口，以产生一个新特征。比如，特征$c_i$产生于一个词汇窗口$x_{i:i+h-1}$，计算公式为：</p><script type="math/tex; mode=display">c_i=f(w·x_{i:i+h-1}+b) \ (2)</script><p>$b∈R$是偏置项，$f$是一个非线性函数,例如双曲正切函数。该滤波器应用在句子中${x_{1∶ h}, x_{2∶h+1},…,x_{n+h-1∶n}}$每一个可能的单词窗口从而产生一个特征映射： </p><script type="math/tex; mode=display">c=[c_1,c_2,…,c_{n+h-1}]</script><p>这里$c∈R^{n-h+1}$。然后我们对特征映射采用最大池化策略（Collobert et al.， 2011）即取最大的值$\hat c=max{c}$作为对应此滤波器的特征。此思路是去捕获最重要的特征——每个特征映射中最大的值。最大池化可以处理不同的句子长度。 </p><p>我们已经说明了通过一个滤波器抽取一个特征的过程。当然使用多个滤波器（不同的窗口大小）可以获取多个特征。这些特征组成了倒数第二层并且传给全连接的softmax层，输出标签的概率分布。 </p><p>在其中一个模型变种中，我们做了将词向量分两个“通道”的实验，一个通道中的词向量在模型训练的过程中保持不变，另一个通过BP算法（3.2节）进行细粒度的调节。在多通道架构中，如图1所示，每个滤波器应用在两个通道，再把结果加起来，然后用等式（2）计算$c_i$。除此之外模型等价于单通道的架构。 </p><h3 id="2-1-正则化"><a href="#2-1-正则化" class="headerlink" title="2.1 正则化"></a>2.1 正则化</h3><p>为了解决过拟合的问题，我们采用正则化的方法，在倒数第二层我们使用dropout机制，并且使用L-2范数来约束权重向量。Ｄropout机制可以防止隐藏层的过拟合，通过随机的dropout：例如在反向传播的过程中将p部分的隐藏单元设置为０。即，已知，倒数第二层的特征向量z=[C1,……，Cm]　(表示这里我们有m个滤波器)。经典的情况神经元的输出应该是：</p><script type="math/tex; mode=display">y=w·z+b  (4)</script><p>在前向传播中对输出单元y，dropout使用的是：</p><script type="math/tex; mode=display">y = w · (z ◦ r) + b \ (5)</script><p>这里∘表示按元素逐个相乘操作，$r∈R^m$是一个“掩盖”向量，向量中的元素都是一个伯努利随机变量，有p的概率变为1。梯度仅仅可以通过非掩盖的单元反向传播。在测试阶段，权重向量通过因子p缩减例如$\hat w=pw$,并且$\hat w$被用来（没有使用dropout）给掩盖的句子打分。我们另外限制权重向量的二范式，在每一步梯度下降之后，如果$‖w‖_2&gt;s$，重新将w的二范式设置为$‖w‖_2=s$。</p><h2 id="三、数据集和实验步骤"><a href="#三、数据集和实验步骤" class="headerlink" title="三、数据集和实验步骤"></a>三、数据集和实验步骤</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv4lc1g1pj30f507wgm7.jpg" alt=""></p><p>表1：分词之后的数据集的简要统计。C：目标类的个数。l：平均句子长度。N：数据集大小。|V|：单词总数。|V_pre |：出现在预训练词向量中词的个数。Test：测试集的大小（CV意味没有标准的训练/测试集并且采用十折交叉验证的方法）</p><p>我们在不同的基准上测试我们的模型。数据集的简要统计如表1所示。</p><ul><li>MR: 一句话的电影评论。分类标签分为积极/消极的评论（Pang and Lee, 2005）。</li><li>SST-1：斯坦福情感树库——MR数据的扩展，但是包含train/dev/test数据集的划分及细粒度的标签（非常积极、积极、中立、消极、非常消极），被Socher et al.（2013）重新标记。</li><li>SST-2: 和SST-1一样，但是没有中立的评论，只有积极和消极两种标签。</li><li>Subj：主观数据集，任务是去划分一个句子是主观性的还是客观性的（Pang and Lee. 2004）。</li><li>TREC：TREC问题数据集——任务涉及到将一个问题划分为六种问题类型（人，位置，数值信息等）（Li and Roth, 2002）。</li><li>CR：不同产品（照相机、MP3s等等）的客户评论。任务是预测积极/消极的评论（Hu and Liu, 2004）。</li><li>MPQA：MPQA数据集（Wiebe et al., 2005）的观点极性检测子任务。</li></ul><h3 id="3-1-超参数和训练过程"><a href="#3-1-超参数和训练过程" class="headerlink" title="3.1 超参数和训练过程"></a>3.1 超参数和训练过程</h3><p>我们在所有的数据集中都采用下列参数：</p><ul><li>对于所有的数据集我们使用修正线性单元(Rectified linear units)；</li><li>滤波器窗口大小h为3、4、5， 每种滤波器个数为100。；</li><li>dropout的比例为0.5；</li><li>l2正则化限制权值的大小为３；</li><li>mini-batch大小为50；</li><li>这些值都是在SST-2 验证数据集上通过网格搜索选择得到的。 </li></ul><p>我们除了在验证集上进行early stpping外没有另外进行任何特定数据集的调节，对于没有标准验证集的数据集，我们从训练数据集中随机选择10%的数据作为验证集。通过采用Adadelta更新参数（Zeiler, 2012）及随机mini-batches策略的随机梯度下降算法进行训练。 </p><h3 id="3-2-预训练的词向量"><a href="#3-2-预训练的词向量" class="headerlink" title="3.2 预训练的词向量"></a>3.2 预训练的词向量</h3><p>在没有大量监督训练集（Colobert et al., 2011; Socher et al., 2011; Iyyer et al., 2014）的情况下，使用从非监督神经语言模型训练得到的词向量进行初始化是用来提升结果的流行方法。我们使用公用的、由10亿Google 新闻数据中训练出来的Word2vec词向量。此向量的维度是300并且是采用连续的词袋架构（Mikolov et al., 2013）训练出来的。而将没有出现在预训练词向量中的单词随机初始化。 </p><h3 id="3-3-模型变种"><a href="#3-3-模型变种" class="headerlink" title="3.3 模型变种"></a>3.3 模型变种</h3><p>我们使用以下模型变种进行实验。</p><ul><li>CNN-rand：我们的基准模型，所有的词被随机初始化，并在训练的工程中进行调节。</li><li>CNN-static：使用预训练的词向量——Word2vec。所有的词——包括随机初始化的未出现在预训练词向量中的词——保持不变而仅仅调节模型其它的参数。</li><li>CNN-non-static：和CNN-static相似，但是预训练的词向量在每个任务中会有细粒度的调节。</li><li>CNN-multichannel：有两个词向量集合的模型。将每个向量集合看作一个“通道”并且每个滤波器应用在所有的通道，但是梯度只能通过其中一个通道进行反向传播。因此，模型能够细粒度的调节其中一个向量集合，而保持另外一个不变。 </li></ul><p>为了探究上述变种对其它随机因子的影响，我们消除了其它随机化的影响——交叉验证次数赋值，未知词向量的初始化，CNN模型参数的初始化——在每个数据集上保持一致。</p><h2 id="四、结果和讨论"><a href="#四、结果和讨论" class="headerlink" title="四、结果和讨论"></a>四、结果和讨论</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv4lhq5igj30tq0hcdii.jpg" alt=""></p><ul><li>RAE：由维基百科(Socher et al.， 2011)中得到预先训练的词向量的递归自编码器。</li><li>MV-RNN：句法分析树的矩阵-向量递归神经网络(Socher et al.， 2012)。</li><li>RNTN：递归神经张量网络，具有基于时态的特征函数和句法分析树(Socher et al.， 2013)</li><li>DCNN: k-max汇聚的动态卷积神经网络(Kalchbrenner et al.， 2014)</li><li>Paragraph-Vec：在段落向量之上的逻辑回归(Le and Mikolov, 2014)</li><li>CCAE: 组合类自动编码器与组合类语法运算符(Hermann and Blunsom, 2013)</li><li>Sent-Parser::情绪分析特定解析器(Dong et al.， 2014)</li><li>NBSVM, MNB: 朴素贝叶斯SVM和多项朴素贝叶斯。</li><li>G-Dropout, F-Dropout: 高斯Dropout和快速Dropout</li><li>Tree-CRF: 条件随机场依赖树(中川等，2010)</li><li>CRF-PR：后正则化条件随机场(Yang and Cardie, 2014)</li><li>SVMS: SVM使用uni-bi-trigrams、wh word、head word、POS、parser、hypernyms和60个手工编码的规则作为特性。</li></ul><p>表2为我们模型和其它模型的结果对比。我们随机化所有词向量的基准模型（CNN-rand）就其本身而言表现的不是很好。然而我们期望通过预训练的词向量来提升效果的模型，我们对效果提升的幅度感到很吃惊。即使使用静态向量的简单模型（CNN-static）表现的相当好，产生了与利用复杂池化模式的复杂深度学习模型（Kalchbrenner et al., 2014）和需要提前计算解析树的模型（Socher et al., 2013）可抗衡的结果。这些结果说明预训练的词向量是好的，它可以作为“通用”的特征抽取器，并且可以跨数据集使用。对每个任务细粒度的调节词向量可以进一步提升结果（CNN-non-static）。 </p><h3 id="4-1-多通道与单通道模型比较"><a href="#4-1-多通道与单通道模型比较" class="headerlink" title="4.1 多通道与单通道模型比较"></a>4.1 多通道与单通道模型比较</h3><p>我们一开始期望多通道的架构可以避免过拟合（通过确保学到词向量不会偏离初始值太远），并且比单通道的模型效果好，尤其在更小的数据集上。然而，结果是含混的，进一步的微调工作是有必要的。例如，与其使用非静态部分的额外通道，还可以维护单个通道，但使用额外的维度，在训练期间允许修改。</p><h3 id="4-2-静态与非静态表示比较"><a href="#4-2-静态与非静态表示比较" class="headerlink" title="4.2 静态与非静态表示比较"></a>4.2 静态与非静态表示比较</h3><p>与单通道非静态模型一样，多通道模型能够对非静态通道进行微调，以使其更特定于任务。例如，good在word2vec中最类似于bad，大概是因为它们(几乎)在语法上是等价的。但是对于在SST-2数据集上的非静态信道中的向量来说，情况并不是如此(表3)。同样地，可以说在表达情感上，nice和great相比，与good更相近，这在训练的词向量中被真实的反映出来。 </p><p>对于（随机初始化）不在预训练向量集合中的词，细粒度的调节允许它们学到更有意义的表示：网络训练得到感叹号经常与热情洋溢的表达联系在一起，并且逗号经常和连接副词联系在一起。 </p><h3 id="4-3-进一步观察"><a href="#4-3-进一步观察" class="headerlink" title="4.3 进一步观察"></a>4.3 进一步观察</h3><p>我们做了进一步的实验和观察。 </p><ul><li>Kalchbrenner et al.（2014）使用和我们单通道架构相同的CNN架构，但是却得到了不好的结果。例如，他们采用随机初始化词向量的Max-TDNN（时间延迟神经网络）模型在SST-1数据集上获得的结果是37.4%，和我们模型获得的45%相比。我们将此差异归因于我们的CNN有更大的容量（多个滤波器和特征映射）。 </li><li>Dropout是如此好的正则化方法以致于用在一个比必要网络更大的网络上并且仅仅使用dropout去正则化效果是好的。</li><li>Dropout一般可以将结果提升2%-4%。 </li><li>当随机初始化不在Word2vec集合中的单词时，向量的每一维从U[-a,a]采样，结果获得了微小的提升，这里的a的选择要使随机初始化的词向量的方差和预训练的词向量有相同的方差。在初始化的过程中，尝试应用更复杂的方法反映预训练词向量的分布，看能否使结果得到提升是很有意思的事情。 </li><li>我们在Collobert et al.（2011）通过维基百科训练的、另一个公用的词向量上进行试验，并且发现使用Word2vec的结果要远远优于它。目前不清楚是因为Mikovlov et al.（2013）的架构还是因为10亿的Google新闻数据集。</li><li>Adadelta（Zeiler，2012）和Adagrad（Duchi et al., 2011）的结果相似，但是需要更少的训练次数。</li></ul><h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>在这篇论文中，我们使用卷积神经网络和Word2vec进行了一系列的实验。尽管微小的超参数调节，具有一个卷积层的简单CNN就表现的非常好。我们的实验再次证明：将深度学习应用在NLP领域，非监督预训练的词向量是一个非常重要的因素。 </p><h2 id="六、代码解释"><a href="#六、代码解释" class="headerlink" title="六、代码解释"></a>六、代码解释</h2><p>待完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自卷积神经网络用于文本分类的开山之作&lt;a href=&quot;https://arxiv.org/abs/1408.5882&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Convolutional Neural Networks for Sentence Classification&lt;/a&gt;，并相应的对其实现代码进行讲解。&lt;/p&gt;
&lt;p&gt;我们进行了一系列关于卷积神经网络(CNN)的实验，这些实验是基于预先训练的词向量训练的，用于句子级别的分类任务。我们得到了一个简单的参数微调的以及静态矢量的CNN在多个基准上取得了优异的结果。通过微调学习任务特定的向量可以进一步提高性能。我们还建议对体系结构进行简单的修改，以允许使用特定于任务的和静态的向量。CNN在这里讨论了7项任务中4项的改进，包括情绪分析和问题分类。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="TextCNN" scheme="http://yoursite.com/tags/TextCNN/"/>
    
      <category term="Dropout" scheme="http://yoursite.com/tags/Dropout/"/>
    
      <category term="non-static" scheme="http://yoursite.com/tags/non-static/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（5）：FastText</title>
    <link href="http://yoursite.com/2018/02/20/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9AFastText/"/>
    <id>http://yoursite.com/2018/02/20/自然语言处理系列（5）：FastText/</id>
    <published>2018-02-20T15:14:45.000Z</published>
    <updated>2018-11-03T16:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="https://arxiv.org/pdf/1607.01759.pdf" target="_blank" rel="noopener">Bag of Tricks for Efficient Text Classification</a></p><p>本文探讨了一个简单而有效的文本分类baseline。我们的实验表明，快速文本分类器在精度上通常与深度学习分类器相当，并且在训练和评估方面的速度要快得多。我们可以在不到10分钟的时间内使用标准的多核CPU对超过10亿单词的快速文本进行训练，在不到一分钟的时间内对312000类的50万个句子进行分类。</p><a id="more"></a><h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p>文本分类是自然语言处理中的一项重要任务，它有很多应用，比如web搜索、信息检索、排序和文档分类等。最近，基于神经网络的模型变得越来越流行(Kim, 2014; Zhang and LeCun, 2015; Conneau et al., 2016)。虽然这些模型在实践中取得了很好的性能，但是它们在训练和测试时都比较慢，这限制了它们在非常大的数据集上的使用。</p><p>与此同时，线性分类器通常被认为是文本分类问题的强大baseline(Joachims, 1998; McCallum and Nigam, 1998; Fan et al., 2008)。尽管它们很简单，但如果使用正确的特性，它们通常会获得最先进的性能(Wang and Manning, 2012)。它们也有可能扩展到非常大的语料库。</p><p>在这篇文章中，我们探讨了在文本分类的背景下，将这些baseline扩展到一个很大的输出空间的大型语料库。受最近的高效词汇表示法的启发(Mikolov et al.， 2013;Levy et al.， 2015)，我们展示了具有秩约束和快速损失逼近的线性模型，它在10分钟内可以训练10亿个单词，同时达到与最先进的水平相同的性能。我们在两个不同的任务上评价我们的方法FastText的质量，即标记预测和情绪分析。</p><h2 id="二、Model-architecture"><a href="#二、Model-architecture" class="headerlink" title="二、Model architecture"></a>二、Model architecture</h2><p>一个简单而有效的文本分类baseline是将文本描述成bag of word (BoW)，训练一个线性分类器，例如，逻辑回归或SVM(Joachims, 1998; Fan et al., 2008)。然而，线性分类器并不在特征和类别之间共享参数。这可能限制了它们在大的输出空间环境中的泛化，在这个大的输出空间中，一些类别的样本可能非常少。解决这个问题的常用方法是将线性分类器分解成低秩矩阵(Schutze, 1992;Mikolov et al., 2013)或者使用多层神经网络 （Collobert and Weston, 2008 ; Zhang et al., 2015)。</p><p>图1显示了一个具有秩约束的简单线性模型。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcerb8eyj30iw0cgmxj.jpg" alt=""><br>第一个权重矩阵A是对单词的查找表。然后对文本的中所有词向量求平均得到一个文本的表示，依次进入线性分类器。这些文本表示是一个潜在的可重用的隐藏变量。这个架构类似于Mikolov et al.(2013)的cbow模型，只是它中间的单词被一个标签代替。我们使用将$softmax$函数$f$计算预定义类的概率分布。对一组N个文档，最小化负对数似然函数</p><script type="math/tex; mode=display">-\frac{1}{N}\sum_{n=1}^Ny_nlog(f(BAx_n))</script><p>其中$x_n$是第$n$个文档的标准化特征，$y_n$是类别标签，$A$和$B$是权重矩阵。该模型通过随机梯度下降和线性衰减学习率在多个cpu上进行异步训练。</p><h3 id="2-1-Hierarchical-softmax"><a href="#2-1-Hierarchical-softmax" class="headerlink" title="2.1 Hierarchical softmax"></a>2.1 Hierarchical softmax</h3><p>当类的数量很大时，计算线性分类器的计算代价很高。更准确地说，计算复杂度是$O(kh)$，$k$是类的数量，$h$是文本表示的维度。为了提高我们的运行时间，我们在Huffman编码树(Mikolov et al.， 2013)的基础上使用了一个分层的softmax (Goodman, 2001)。在训练过程中，计算复杂度下降到$O(h log_2(k))$。在搜索最有可能的类时，分层的softmax在测试时也是有利的。每个节点都与从根到该节点的路径的概率相关。如果深度$l+1$的节点，它的父节点为$n_1$、$n_2$、$n_l$，则它的概率为</p><script type="math/tex; mode=display">P(n_{l+1})=\prod _{i=1}^lP(n_i)</script><p>这意味着子节点的概率总是低于其父节点的概率。探索树的深度优先搜索和跟踪最大概率的叶子允许我们丢弃任何与一个小概率相关的分支。在实践中，我们观察到在测试时将复杂度降低到$O(hlog_2(k))$。使用二进制堆，这种方法进一步扩展到以$O(log(T))$的代价计算T-top目标。</p><h3 id="2-2-N-gram-features"><a href="#2-2-N-gram-features" class="headerlink" title="2.2 N-gram features"></a>2.2 N-gram features</h3><p>词袋中的词顺序是固定的，但明确地把这个顺序考虑进去通常是非常昂贵的。相反，我们使用一个n-grams作为额外的特征，以获取关于局部词序的部分信息。这在实践中非常有效，同时实现了与明确使用顺序的方法(Wang and Manning, 2012)差不多的结果。</p><p>我们通过一个哈希（hashing）技巧维持了快速且有效的 n-gram 映射（Weinberger et al., 2009），这个哈希技巧带有与 Mikolov et al.（2011）论文中相同的哈希函数和 10M bins（如果我们仅使用 bigram 的话），否则就需要 100M bin.</p><h2 id="三、Experiments"><a href="#三、Experiments" class="headerlink" title="三、Experiments"></a>三、Experiments</h2><p>我们在两个不同的任务上评估fastText。首先，我们将其与现有的文本分类器对情绪分析问题进行比较。然后，我们评估其在标记预测数据集上扩展到大的输出空间的能力。请注意,我们的模型可以用Vowpal Wabbit库来实现,但是在实践中我们看到,我们的实现至少有2到5倍的提升。</p><h3 id="3-1-Sentiment-analysis"><a href="#3-1-Sentiment-analysis" class="headerlink" title="3.1 Sentiment analysis"></a>3.1 Sentiment analysis</h3><blockquote><p>Datasets and baselines</p></blockquote><p>我们采用了同样的8个数据集，并采用了Zhangetal(2015)的评价协议。我们比较了了Zhang et al.(2015)的n-gram和TF-IDF 的baseline，以及Zhang and LeCun(2015)的字符级卷积模型(char-cnn)，基于字符的卷积循环网络(char-CRNN) (Xiao and Cho, 2016)和Conneau等人(2016)的深度卷积网络(VDCNN)。我们还比较了Tang等人(2015)的评估方案。我们比较了他们的主要baseline，以及基于循环网络的两种方法(Conv-GRNN和LSTM-GRNN)。</p><blockquote><p>Results</p></blockquote><p>我们在图1中展示了结果。我们使用10个隐藏单元，并在5个epochs中运行fastText，其学习率从{0.05,0.1,0.25,0.5}中选择。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvcicqehej316w0gy0xw.jpg" alt=""></p><p>在这个任务中，添加bigram信息可以提高1-4%的性能。总体而言，我们的准确性略好于char-CNN和char-CRNN，差于VDCNN。请注意，我们可以通过使用更多的n-gram来略微提高精确度，例如使用trigrams，在搜狗数据集上的性能达到了97.1%。最后，图3显示了我们的方法与Tang et al.(2015)中的方法相竞争。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcipj2w9j30hp0a5mxu.jpg" alt=""></p><p>我们对验证集上的超参数进行调优，并观察到使用n-grams达到5时性能最佳。与Tang et al.(2015)不同，fastText不使用预先训练的词嵌入，这可以解释1%的准确性差异。</p><blockquote><p>Training time</p></blockquote><p>CNN和VDCNN都用NVIDIA Tesla K40 GPU训练，而我们的模型在CPU上使用了20个线程。表2显示使用卷积的方法比fastText慢几个数量级。虽然利用10倍的速度提升的CUDA来加速char-CNN的训练，FastText花了不到一分钟的训练。Tang et al.(2015)的GRNNs方法在CPU上以单个线程的时间为12小时左右。随着数据量增加，与神经网络方法相比，我们的模型加速至少达到了15000倍</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcj21tv5j31760gctbn.jpg" alt=""></p><h3 id="3-2-Tag-prediction"><a href="#3-2-Tag-prediction" class="headerlink" title="3.2 Tag prediction"></a>3.2 Tag prediction</h3><blockquote><p>Dataset and baselines.</p></blockquote><p>为了测试我们的方法的可扩展性，在YFCC100M数据集(Thomee et al.， 2016)上进行了进一步的评估，该数据集包含了近1亿张带有说明、标题和标签的图像。我们专注于根据标题和标题预测标签(我们不使用图像)。我们删除了出现少于100次的单词和标记，并将数据分成训练集、验证集和测试集。该训练集包含91,188,648个样本(1.5B tokens)。验证集有930497个样本，测试集有543,424个样本。词汇量为297,141，有312,116个独特的标签。我们将发布一个脚本，重新创建这个数据集，以便可以复制我们的数据。我们报告的精度为1。</p><p>我们考虑一个基于频率的baseline，它预测最频繁的标记。我们也比较了Tagspace (Weston et al.， 2014)，这是一个类似于我们的标签预测模型，但是基于Weston et al.(2011)的Wsabie模型。虽然Tagspace模型是使用卷积来描述的，但是我们考虑的是线性版本，它实现了类似的性能，但是速度要快得多。</p><blockquote><p>Results and training time</p></blockquote><p>表5给出了fastText和baseline的比较。我们运行5个epochs的fastText，并将其与隐藏层的两个不同尺寸的Tagspace进行比较，即50和200。这两种模型都实现了一种类似的性能，它有一个隐藏的小层，但是添加了bigrams，这就大大提高了精度。在测试时，Tagspace需要计算所有类的分数，这使得它相对较慢，而我们的快速推理在类的数量很大(这里超过300K)时，会有显著的加速增长。总的来说，我们的模型速度超过了一个数量级，且获得了更高质量的效果。测试的加速阶段更显著(600倍加速)。表4显示了一些定性的例子。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvcj75g91j30n309rab4.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvcjm3m2wj30sy0meq6x.jpg" alt=""></p><h2 id="四、Discussion-and-conclusion"><a href="#四、Discussion-and-conclusion" class="headerlink" title="四、Discussion and conclusion"></a>四、Discussion and conclusion</h2><p>在本文中，我们提出了一种简单的文本分类baseline方法。不像从word2vec中训练出来的不受监督的单词向量，我们的单词特征可以被平均起来组成一个好的句子表示。在一些任务中，fastText获得的性能与最近提出的以深度学习为灵感的方法相比，速度更快。虽然深层神经网络在理论上比浅层模型具有更高的表征能力，但尚不清楚简单的文本分类问题，如情绪分析是否是正确的评价方法。我们将发布我们的代码，以便研究社区能够轻松地构建我们的工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;https://arxiv.org/pdf/1607.01759.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bag of Tricks for Efficient Text Classification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文探讨了一个简单而有效的文本分类baseline。我们的实验表明，快速文本分类器在精度上通常与深度学习分类器相当，并且在训练和评估方面的速度要快得多。我们可以在不到10分钟的时间内使用标准的多核CPU对超过10亿单词的快速文本进行训练，在不到一分钟的时间内对312000类的50万个句子进行分类。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="FastText" scheme="http://yoursite.com/tags/FastText/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（10）：sys</title>
    <link href="http://yoursite.com/2018/02/20/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9Asys/"/>
    <id>http://yoursite.com/2018/02/20/python编程系列（10）：sys/</id>
    <published>2018-02-20T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="sys" scheme="http://yoursite.com/tags/sys/"/>
    
  </entry>
  
  <entry>
    <title>读书记（21）：维特根斯坦论语言的限度（7）—— 哲学的意义</title>
    <link href="http://yoursite.com/2018/02/17/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8821%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%20%E5%93%B2%E5%AD%A6%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2018/02/17/读书记（21）：维特根斯坦论语言的限度（7）—— 哲学的意义/</id>
    <published>2018-02-17T14:20:45.000Z</published>
    <updated>2018-11-05T16:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>只有把哲学当作天下公器的时候，我们的哲学才有生命力，所以我理解的哲学是可以处理一切问题的，它不仅仅可以处理我们所面对的问题，也可以处理我们所没有面对到的问题。所以一定要把哲学看作是一个可以被适用在不同的对象上的一种工作方法，它是我们思考问题的一种方式，会带动我们去分析问题，甚至带动我们去想办法解决问题</p><a id="more"></a><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxnh3ykkuj30qt0dhdk9.jpg" alt=""><br>其实我研究维特根斯坦的目的并不是要去让大家都像维特根斯坦一样，我们研究一个哲学家的目的，第一个是要了解他，第二个要通过他去了解他所给我们提供的这样一种哲学的思想方法，我们能够从中学到什么。我们当然也可以批评质疑他的一些观点，但是一定要有根据，因为维特根斯坦所有的思想都有自己的理路，如果不懂他的理路去批评他，最后可能就是一个堂吉诃德式的风车之战，你根本不是真的在跟维特根斯坦作战，所以一定要了解他，这是最基本的。但是很少有人真的去了解维特根斯坦，或者说我是按照维特根斯坦的方式去做，很少有人这样，所以这是我为什么要通过各种途径来讲解维特根斯坦，让维特根斯坦让成为大家所知道的人物，并且让大家去阅读维特根斯坦，让维特根斯坦的思想方式成为我们所熟知的方式。我们不一定按照维特根斯坦的方式去思考问题，但是我们一定要了解维特根斯坦的思维方式，这是我们了解当代哲学一个重要的组成部分，这也是我的目的之一。</p><p>别人问我江老师你是做分析哲学吗？我说我不知道。也有人问我，如果你是做分析哲学，为什么不像分析哲学家那样对一些具体的问题做出一些解读，对一些概念做逻辑上的推理？我其实做了很多的概念分析，包括真理、意义这些概念我都发过文章。他们之所以问这个问题，是因为从我的文章当中，他们看出我的思想倾向，认为我可能不像搞分析哲学的，更像搞大陆哲学的。一个搞分析的人怎么会讲拓扑学，做大陆哲学才会讲到拓扑概念。现在英国有一些哲学家他们专门做欧洲大陆的哲学家，他们做海德格尔拓扑学，有的做伽德默尔拓扑学，他们做的风格跟我做的风格不一样，我是做Philosophical Topology，我做的是哲学拓扑学，哲学拓扑学跟我们通常讲的数学的、几何学的、集合论的，或者说代数拓扑有直接关系，我更多是科学意义上来谈拓扑。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxnh9xpthj30qt0dhwi7.jpg" alt=""></p><p>我对于整个哲学史的把握要比现在纯粹做分析的人要有优势，因为这么多年从古希腊到当代，我一直在给学生讲课，所以我对历史非常熟悉，我自己也正在写西方哲学史。我对当代哲学，欧洲大陆哲学也是非常熟的，从胡塞尔一直到德里达、福柯，读他们作品，通过阅读更多地了解他们的工作性质，我可以不同意他们的观点，但是绝不能够不读他们的书。但是现在很多搞分析的不读这些书，这就是最大的麻烦，也是有失公允的一种做法，所以我们首先需要了解。我觉得这是我们做学问的一种方法，通过广泛的了解再深入地进入讨论问题的方式。这些所有的哲学家的观点其实都是我们的一种资源，它虽然并不能够成为我们思想的一个出发点，但是通过这种思想资源我们可以了解我们究竟应当如何去做哲学。</p><p>我是一个无立场的哲学家，我既不是一个维特根斯坦的哲学家，也不是一个分析哲学家，也不是欧洲大陆哲学家，更不是中国哲学家，我是一个没有国籍没有立场的哲学家，因为哲学我把它当作天下公器，并且只有把哲学当作天下公器的时候，我们的哲学才有生命力，所以我理解的哲学是可以处理一切问题的，它不仅仅可以处理我们所面对的问题，也可以处理我们所没有面对到的问题，因为哲学只有在这个高度上，我们才能够真正理解哲学的价值。如果把哲学只限于解决某些具体的问题上，哲学的生命力或者价值就非常有限的，所以一定要把哲学看作是一个可以被适用在不同的对象上这样一种工作的方法，所以哲学是一种工作方法，或者说它是我们思考问题的一种方式，而这种思考问题的方式，会带动我们去分析问题，甚至带动我们去想办法解决问题。所以哲学不仅仅是对问题的讨论，甚至不仅仅是提出问题，我个人理解哲学应当能够解决一些问题。并不是像维特根斯坦在这本书里面说他一劳永逸地解决了哲学问题，但是它应当能够解决一些我们所讨论的某一些问题，解决的意思并不是说我能够彻底把这个问题完全让它成为在现实中，实践当中可以加以考量的问题，而是说能够消除我们思想上的困难，有一点像是每一次我的课程结束的时候，学生都会找我提问题，每一次我给学生解读完了我的理解之后，学生满意的离开了，这个时候我就想，问题解决了。哲学就是干这个事情，你能够让他的思想上解决问题，这个时候哲学的价值就出来了。当然会不断有新的问题产生，解决完这个问题，又有新的问题出来，可以进一步来解决，所以哲学是一个不断解决问题的活动。所以维特根斯坦说的很好，哲学是一种活动。这一点我接受，哲学一定是一种活动，它不是一种理论体系，不是一种观念体系，它应当是一种我们共同来践行的思想活动，我想这是最重要，只有这样我们的哲学才能有发展的可能性，这也是我力图想推广的一种哲学的观念。</p><p>并且，哲学不是一个可以用理论的方式构造出来的体系，哲学它一定是用来考察我们使用语言，使用概念，甚至是我们使用某一些思想来解决问题的活动和能力，只有在这个活动当中才能够验证哲学的价值。如果没有这样的活动，哲学就变成理论家能说会道的一种本事，而不能够成为大家普遍接受的某一些真实观念，我觉得这样的哲学就变的没有意义了。我从来认为社会对哲学的拒绝，是哲学家的耻辱，而不是社会的耻辱。换句话说，哲学在社会中的消沉是哲学家的失职，而不是社会的冷漠。你不能够把这个罪责归咎于社会，你给别人提供了什么？你不提供一个创新性的思想，一个解决问题的方案，一个能够让我们深入思考某一些重要现实问题的解决方式，甚至连一个问题都没有提出来，凭什么让人家接受？所以这个时候哲学家们需要主动的要为社会做点贡献，这是问题所在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只有把哲学当作天下公器的时候，我们的哲学才有生命力，所以我理解的哲学是可以处理一切问题的，它不仅仅可以处理我们所面对的问题，也可以处理我们所没有面对到的问题。所以一定要把哲学看作是一个可以被适用在不同的对象上的一种工作方法，它是我们思考问题的一种方式，会带动我们去分析问题，甚至带动我们去想办法解决问题&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（4）：深度学习解决大规模文本分类问题</title>
    <link href="http://yoursite.com/2018/02/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%A7%A3%E5%86%B3%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/16/自然语言处理系列（4）：深度学习解决大规模文本分类问题/</id>
    <published>2018-02-16T15:14:45.000Z</published>
    <updated>2018-11-03T16:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章总结了文本分类领域特别是应用深度学习解决文本分类的相关思路、做法和部分实践的经验。转载自知乎清凇撰写的文章<a href="https://zhuanlan.zhihu.com/p/25928551" target="_blank" rel="noopener">用深度学习（CNN RNN Attention）解决大规模文本分类问题 - 综述和实践</a></p><blockquote><p>业务问题描述：</p></blockquote><p>淘宝商品的一个经典的例子见下图，图中商品的标题是“夏装雪纺条纹短袖t恤女春半袖衣服夏天中长款大码胖mm显瘦上衣夏”。淘宝网后台是通过树形的多层的类目体系管理商品的，覆盖叶子类目数量达上万个，商品量也是10亿量级，我们的任务是根据商品标题预测其所在叶子类目，示例中商品归属的类目为“女装/女士精品&gt;&gt;蕾丝衫/雪纺衫”。很显然，这是一个非常典型的短文本多酚类问题。接下来分别会介绍下文本分类传统的和深度学习的做法，最后简单梳理下实践的经验。</p><a id="more"></a><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv393tqn5j30k00aj75c.jpg" alt=""></p><h2 id="一、传统文本分类方法"><a href="#一、传统文本分类方法" class="headerlink" title="一、传统文本分类方法"></a>一、传统文本分类方法</h2><p>文本分类问题算是自然语言处理领域里一个非常经典的问题了，相关研究最早可以追溯到上世纪50年代，当时是通过专家规则（Pattern）进行分类，甚至在80年代初一度发展到利用知识工程监理专家系统，这样做的好处是短平快的解决top问题，但显然天花板非常低，不仅费时费力，覆盖的范围和准确性都非常有限。</p><p>后来伴随着统计学习方法的发展，特别是90年代后互联网在线文本数量增长和机器学习学科的兴起，逐渐形成了一套解决大规模文本分类问题的经典玩法，这个阶段的主要套路是人工特征+浅层分类模型。训练文本分类器过程见下图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvc4xdqcmj30k004q0ss.jpg" alt=""></p><p>整个文本分类问题就拆分成了特征工程和分类器两部分，玩机器学习的同学对此自然再熟悉不过了。</p><h3 id="1-1-特征工程"><a href="#1-1-特征工程" class="headerlink" title="1.1 特征工程"></a>1.1 特征工程</h3><p>特征工程在机器学习中往往是最耗时耗力的，但却及其的重要。抽象来讲，机器学习问题是把数据转换成信息再提炼到知识的过程，特征是“数据—&gt;信息”的过程，决定了结果的上限，二分类器是“信息—&gt;知识”的过程，则是去逼近这个上限。然而特征工程不同于分类器模型，不具备很强的通用性，往往需要结合对特征任务的理解。</p><p>文本分类问题所在的自然语言处理领域也有其特有的特征处理逻辑，传统文本分类任务大部分工作也在此处。文本特征工程分为文本预处理、特征提取、文本表示三个部分，最终目的是把文本转换成计算机可理解的格式，并封装足够用于分类的信息，即很强的特征表达能力。</p><h4 id="1-1-1-文本预处理"><a href="#1-1-1-文本预处理" class="headerlink" title="1.1.1 文本预处理"></a>1.1.1 文本预处理</h4><p>文本预处理过程是在文本中提取关键词表示文本的过程，中文文本处理中主要包括文本分词和去停用词两个阶段。之所以进行分词，是因为很多研究表明特征粒度为词粒度远好于字粒度，其实很好理解，因为大部分分类算法不考虑词序信息，基于字粒度显然随时了过多“n-gram”信息。</p><p>具体到中文分词，不同于英文有天然的空格间隔，需要设计复杂的分词算法。传统算法主要有基于字符串匹配的正向/逆向/双向最大匹配；基于理解的句法和语义分析消歧；基于统计的互信息/CRF方法。近年来随着深度学习的应用，WordEmbedding+Bi-LSTM+CRF方法逐渐成为主流，本文重点在文本分类，就不展开了。而停用词是本文中一些高频的带刺连词介词等对文本分类无意义的词，通常维护一个停用词表，特征提取过程中删除停用词表中出现的词，本质上属于特征选择的一部分。</p><p>经过文本分词和去停用词之后淘宝商品示例标题变成了下图“/”分割的一个个关键词的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">夏装 / 雪纺 / 条纹 / 短袖 / t恤 / 女 / 春 / 半袖 / 衣服 / 夏天 / 中长款 / 大码 / 胖mm / 显瘦 / 上衣 / 夏</div></pre></td></tr></table></figure><h4 id="1-1-2-文本表示和特征提取"><a href="#1-1-2-文本表示和特征提取" class="headerlink" title="1.1.2 文本表示和特征提取"></a>1.1.2 文本表示和特征提取</h4><blockquote><p>文本表示</p></blockquote><p>文本表示的目的是把预处理后的文本转化成计算机可以理解的方式，是决定文本分类质量最重要的部分。传统做法常用词袋模型（BOW，Bag Of Words）或向量空间模型（Vector Space Model），最大的不足是忽略上下文关系，没歌词之间彼此独立，并且无法表征语义信息。词袋模型的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( 0, 0, 0, 0, .... , 1, ... 0, 0, 0, 0)</div></pre></td></tr></table></figure><p>一般来说词库至少都是百万级别，因此词袋模型有两个最大的问题：高维度、高稀疏性、词袋模型是向量空间模型的基础，因此向量空间模型通过特征项选择降低纬度，通过特征权重计算增加稠密性。</p><blockquote><p>特征提取</p></blockquote><p>向量空间模型的文本表示方法的特征提取对应特征项的选择和特征权重计算两部分。特征选择的基本思路是根据某个评价指标独立的对原始特征项（词项）进行评分排序，从中选择得分最高的一些特征项，过滤掉其余的特征项。常用的评价有文档频率、互信息、信息增益、$\chi ^2$统计量等。</p><p>特征权重主要是经典的TF-IDF方法及其扩展方法，主要思路是一个词的重要度与在类别内的词频成正比，与所有类别出现的次数成反比。</p><blockquote><p>基于语义的文本表示</p></blockquote><p>传统做法在文本表示方面除了向量空间模型，还有基于语义的文本表示方法，比如LDA主题模型、LSI/PLS概率潜在语义索引等方法，一般认为这些方法得到的文本表示可以认为文档的深层表示，而Word Embedding文本分布式表示方法则是深度学习方法的重要基础，下文会展现。</p><h3 id="1-2-分类器"><a href="#1-2-分类器" class="headerlink" title="1.2 分类器"></a>1.2 分类器</h3><p>分类器都是统计分类方法了，基本上大部分机器学习方法都在本文分类领域有所应用，比如朴素贝叶斯分类算法、KNN、SVM、最大熵和神经网络等等，传统分类模型不是本文重点，在这里就不展开了。</p><h2 id="二、深度学习文本分类方法"><a href="#二、深度学习文本分类方法" class="headerlink" title="二、深度学习文本分类方法"></a>二、深度学习文本分类方法</h2><p>上文介绍了传统的文本分类做法，传统做法主要问题的文本表示是高维度高稀疏性的，特征表达能力很弱，而且神经网络很不擅长对此类数据的处理；此外需要人工进行特征工程，成本很高。而深度学习最初之所以在图像和语音取到巨大的成功，一个很重要的原因是图像和语音原始数据是连续和稠密的，有局部相关性。应用深度学习解决大规模文本分类问题最重要的是解决文本表示，再利用CNN/RNN等网络结构自动获取特征表达能力，去掉繁杂的人工特征工程，端到端的解决问题。接下来会分别介绍：</p><h3 id="2-1-文本的分布式表示：词向量（Word-Embedding）"><a href="#2-1-文本的分布式表示：词向量（Word-Embedding）" class="headerlink" title="2.1 文本的分布式表示：词向量（Word Embedding）"></a>2.1 文本的分布式表示：词向量（Word Embedding）</h3><p>分布式表示（Distributed Representation）其实Hinton最早在1986年就提出了，基本思想是将没歌词表达成N维稠密、连续的实数向量，与之相对的one-hot encoding向量空间只有一个维度是1，其余都是0。分布式表示最大的优点是具备非常powerful的特征表达能力，比如n维向量每一维k个值，就可以表征$k^n$个概念了。事实上，不管是神经网络的隐层，还是多个潜在变量的概率主题模型，都是应用分布式表示。下图是03年Bengio在<a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">A Neural Probabilistic Language Model</a><br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3958u9bj30wc0iiace.jpg" alt=""></p><p>这篇文章提出的神经网络语言模型（NNLM，Neural Probabilistic Language Model），采用的是文本分布式表示，即每个词表示为稠密的实数向量。NNLM模型的目标是构建语言模型：</p><script type="math/tex; mode=display">f(w_t，···，w_{t-n+1})=P(w_t|w_1^{t-1})</script><p>词的分布式表示即词向量（Word Embedding）是训练语言模型的一个附加产物，即图中的Matrix C。</p><p>尽管Hinton 86年就提出了NNLM，词向量真正火起来是google的Mikolov在13年发表的两篇Word2Vec的文章<a href="https://arxiv.org/abs/1301.3781" target="_blank" rel="noopener">Efficient Estimation of Word Representations in Vector Space</a> 和 <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality</a> ，更重要的是发布了简单好用的<a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="noopener">Word2Vec工具包</a>，在语义维度上得到了很好地验证，极大的推动了文本分析的进程。下图是文中提出的CBOW和Skip-Gram两个模型的结构，基本类似于NNLM，不同的是模型去掉了非线性隐层，预测目标不同，CBOW是上下文预测当前词，Skip-Gram则相反。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3965t51j30k008lq34.jpg" alt=""><br>除此之外，提出了Hierarchical Softmax和Negative Sample两个方法，很好地解决了计算有效性，事实上这两个方法都没有严格的理论证明，有一些trick之处，非常的实用主义。详细的过程不再阐述了，有兴趣深入理解Word2Vec的，推荐读读这篇不错的paper：<a href="https://arxiv.org/abs/1411.2738" target="_blank" rel="noopener">word2vec Parameter Learning Explained</a>。额外多提一点，实际上WordVec学习的向量和真正语义还有差距，更多学到的是具备相似上下文的词，比如“good”“bad”相似度也很高，反而是文本分类任务输入有监督的语义能够学到更好的语义表示，有机会后续系统分享下。</p><p>至此，文本的表示通过词向量的表示方法，把文本数据从高维度高稀疏性的神经网络难处理的方式，变成了类似图像、语言的连续稠密数据。深度学习算法本身有很强的数据迁移性，很多之前在图像领域很适用的深度学习算法比如CNN等也可以很好的迁移到文本领域了，下面一小节具体阐述下文本分类邻域深度学习的方法。</p><h3 id="2-2-深度学习文本分类模型"><a href="#2-2-深度学习文本分类模型" class="headerlink" title="2.2 深度学习文本分类模型"></a>2.2 深度学习文本分类模型</h3><h4 id="2-2-1-fastText"><a href="#2-2-1-fastText" class="headerlink" title="2.2.1 fastText"></a>2.2.1 fastText</h4><p>fastText是上文提到的Word2Vec作者Mikolov转战Facebook后16年7月刚发表的一篇论文<a href="https://arxiv.org/pdf/1607.01759v2.pdf" target="_blank" rel="noopener">Bag of Tricks for Efficient Text Classification</a>把fastText放在此处并非因为他是文本分类的主流做法，而是他及其简单，模型图见下：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3972m51j30k00a5t8q.jpg" alt=""></p><p>原理是把句子中所有的词向量进行平均（某种意义上可以理解为只有一个Avg Pooling的特征CNN），然后直接接SoftMax层。其实文章也加入了一些n-gram特征的tric来捕获局部序列信息。文章到没有太多的信息量，算是“水文”吧，带来的思考是文本分类问题是有一些“线性”问题的部分，也就是说不必做过多的非线性转换、特征组合即可捕获很多分类信息，因此有些任务即便简单的模型便可以搞定了。</p><h4 id="2-2-2-TextCNN"><a href="#2-2-2-TextCNN" class="headerlink" title="2.2.2 TextCNN"></a>2.2.2 TextCNN</h4><p>本篇文章的题图选用的就是14年这篇文章提出的TextCNN的结果（见下图）。fastText中的网络结构是完全没有考虑词序信息的，而他用的n-gram特征Trick恰恰说明了局部序列信息的重要意义。<a href="http://colah.github.io/posts/2014-07-Understanding-Convolutions/" target="_blank" rel="noopener">卷积神经网络（CNN Convolutional Neural Network）</a>最初在图像领域取得了巨大成功，CNN原理就不讲了，核心点在于可以捕捉局部相关性，具体到文本分类任务重可以利用CNN来提取句子中类似n-gram的关键信息。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvc5dxt8jj30ta0c6jub.jpg" alt=""></p><p>TextCNN的详细过程原理图见下：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3982n8sj30k00jl40d.jpg" alt=""></p><p>TextCNN详细过程：第一层是图中最左边的7乘5的句子矩阵，每行是词向量，维度=5，这个可以类比为图像中的原始像素点了。然后经过有 filter_size=(2,3,4) 的一维卷积层，每个filter_size 有两个输出 channel。第三层是一个1-max pooling层，这样不同长度句子经过pooling层之后都能变成定长的表示了，最后接一层全连接的 softmax 层，输出每个类别的概率。</p><p><strong>特征</strong>：这里的特征就是词向量，有静态（static）和非静态（non-static）方式。static方式采用比如word2vec预训练的词向量，训练过程不更新词向量，实质上属于迁移学习了，特别是数据量比较小的情况下，采用静态的词向量往往效果不错。non-static则是在训练过程中更新词向量。推荐的方式是 non-static 中的 fine-tunning方式，它是以预训练（pre-train）的word2vec向量初始化词向量，训练过程中调整词向量，能加速收敛，当然如果有充足的训练数据和资源，直接随机初始化词向量效果也是可以的。</p><p><strong>通道（Channels）</strong>：图像中可以利用 (R, G, B) 作为不同channel，而文本的输入的channel通常是不同方式的embedding方式（比如 word2vec或Glove），实践中也有利用静态词向量和fine-tunning词向量作为不同channel的做法。</p><p><strong>一维卷积（conv-1d）</strong>：图像是二维数据，经过词向量表达的文本为一维数据，因此在TextCNN卷积用的是一维卷积。一维卷积带来的问题是需要设计通过不同 filter_size 的 filter 获取不同宽度的视野。</p><p><strong>Pooling层</strong>：利用CNN解决文本分类问题的文章还是很多的，比如这篇 <a href="https://arxiv.org/pdf/1404.2188.pdf" target="_blank" rel="noopener">A Convolutional Neural Network for Modelling Sentences</a> 最有意思的输入是在 pooling 改成 (dynamic) k-max pooling ，pooling阶段保留 k 个最大的信息，保留了全局的序列信息。比如在情感分析场景，举个例子：</p><blockquote><p>“ 我觉得这个地方景色还不错，但是人也实在太多了 ”</p></blockquote><p>虽然前半部分体现情感是正向的，全局文本表达的是偏负面的情感，利用 k-max pooling能够很好捕捉这类信息。</p><h4 id="2-2-3-TextRNN"><a href="#2-2-3-TextRNN" class="headerlink" title="2.2.3 TextRNN"></a>2.2.3 TextRNN</h4><p>尽管TextCNN能够在很多任务里面能有不错的表现，但CNN有个最大问题是固定 filter_size 的视野，一方面无法建模更长的序列信息，另一方面 filter_size 的超参调节也很繁琐。CNN本质是做文本的特征表达工作，而自然语言处理中更常用的是递归神经网络（RNN, Recurrent Neural Network），能够更好的表达上下文信息。具体在文本分类任务中，Bi-directional RNN（实际使用的是双向LSTM）从某种意义上可以理解为可以捕获变长且双向的的 “n-gram” 信息。</p><p>RNN算是在自然语言处理领域非常一个标配网络了，在序列标注/命名体识别/seq2seq模型等很多场景都有应用，<a href="https://www.ijcai.org/Proceedings/16/Papers/408.pdf" target="_blank" rel="noopener">Recurrent Neural Network for Text Classification with Multi-Task Learning</a>文中介绍了RNN用于分类问题的设计，下图LSTM用于网络结构原理示意图，示例中的是利用最后一个词的结果直接接全连接层softmax输出了。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv398h84aj30k0069dg4.jpg" alt=""></p><h4 id="2-2-4-TextRNN-Attention"><a href="#2-2-4-TextRNN-Attention" class="headerlink" title="2.2.4 TextRNN + Attention"></a>2.2.4 TextRNN + Attention</h4><p>CNN和RNN用在文本分类任务中尽管效果显著，但都有一个不足的地方就是不够直观，可解释性不好，特别是在分析badcase时候感受尤其深刻。而注意力（Attention）机制是自然语言处理领域一个常用的建模长时间记忆机制，能够很直观的给出每个词对结果的贡献，基本成了Seq2Seq模型的标配了。实际上文本分类从某种意义上也可以理解为一种特殊的Seq2Seq，所以考虑把Attention机制引入近来，研究了下学术界果然有类似做法。</p><p>Attention机制介绍：详细介绍Attention恐怕需要一小篇文章的篇幅，感兴趣的可参考14年这篇paper <a href="https://arxiv.org/pdf/1409.0473v7.pdf" target="_blank" rel="noopener">NEURAL MACHINE TRANSLATION BY JOINTLY LEARNING TO ALIGN AND TRANSLATE</a>。</p><p>以机器翻译为例简单介绍下，下图中 $x_{t}$ 是源语言的一个词，$y_{t}$ 是目标语言的一个词，机器翻译的任务就是给定源序列得到目标序列。翻译 $y_{t}$ 的过程产生取决于上一个词 $y_{t-1}$ 和源语言的词的表示 $h_{j}$（$x_{j}$ 的 bi-RNN 模型的表示），而每个词所占的权重是不一样的。比如源语言是中文 “我 / 是 / 中国人” 目标语言 “i / am / Chinese”，翻译出“Chinese”时候显然取决于“中国人”，而与“我 / 是”基本无关。下图公式, $\alpha _{ij} $则是翻译英文第 i 个词时，中文第 j 个词的贡献，也就是注意力。显然在翻译“Chinese”时，“中国人”的注意力值非常大。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv399gvptj30k008sjrm.jpg" alt=""></p><p>Attention的核心point是在翻译每个目标词（或 预测商品标题文本所属类别）所用的上下文是不同的，这样的考虑显然是更合理的。</p><h4 id="2-2-5-TextRNN-Attention"><a href="#2-2-5-TextRNN-Attention" class="headerlink" title="2.2.5 TextRNN + Attention"></a>2.2.5 TextRNN + Attention</h4><p>我们参考了这篇文章 <a href="https://www.cs.cmu.edu/~diyiy/docs/naacl16.pdf" target="_blank" rel="noopener">Hierarchical Attention Networks for Document Classification</a>，下图是模型的网络结构图，它一方面用层次化的结构保留了文档的结构，另一方面在word-level和sentence-level。淘宝标题场景只需要 word-level 这一层的 Attention 即可。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvbpacj93j30k00daaac.jpg" alt=""></p><p>加入Attention之后最大的好处自然是能够直观的解释各个句子和词对分类类别的重要性。</p><h4 id="2-2-6-TextRCNN（TextRNN-CNN）"><a href="#2-2-6-TextRCNN（TextRNN-CNN）" class="headerlink" title="2.2.6 TextRCNN（TextRNN + CNN）"></a>2.2.6 TextRCNN（TextRNN + CNN）</h4><p>我们参考的是中科院15年发表在AAAI上的这篇文章 Recurrent Convolutional Neural Networks for Text Classification 的结构：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvbpi25guj30k0020mx2.jpg" alt=""><br>利用前向和后向RNN得到每个词的前向和后向上下文的表示：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvbppgpufj30k0020mx2.jpg" alt=""></p><p>这样词的表示就变成词向量和前向后向上下文向量concat起来的形式了，即：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvc4h4shwj30pc01m0sv.jpg" alt=""></p><p>最后再接跟TextCNN相同卷积层，pooling层即可，唯一不同的是卷积层 filter_size = 1就可以了，不再需要更大 filter_size 获得更大视野，这里词的表示也可以只用双向RNN输出。</p><h2 id="三、一点经验"><a href="#三、一点经验" class="headerlink" title="三、一点经验"></a>三、一点经验</h2><p>理论和实践之间的Gap往往差异巨大，学术paper更关注的是模型架构设计的新颖性等，更重要的是新的思路；而实践最重要的是在落地场景的效果，关注的点和方法都不一样。这部分简单梳理实际做项目过程中的一点经验教训。</p><p>模型显然并不是最重要的：不能否认，好的模型设计对拿到好结果的至关重要，也更是学术关注热点。但实际使用中，模型的工作量占的时间其实相对比较少。虽然再第二部分介绍了5种CNN/RNN及其变体的模型，实际中文本分类任务单纯用CNN已经足以取得很不错的结果了，我们的实验测试RCNN对准确率提升大约1%，并不是十分的显著。最佳实践是先用TextCNN模型把整体任务效果调试到最好，再尝试改进模型。</p><p>理解你的数据：虽然应用深度学习有一个很大的优势是不再需要繁琐低效的人工特征工程，然而如果你只是把他当做一个黑盒，难免会经常怀疑人生。一定要理解你的数据，记住无论传统方法还是深度学习方法，数据 sense 始终非常重要。要重视 badcase 分析，明白你的数据是否适合，为什么对为什么错。</p><p>关注迭代质量 - 记录和分析你的每次实验：迭代速度是决定算法项目成败的关键，学过概率的同学都很容易认同。而算法项目重要的不只是迭代速度，一定要关注迭代质量。如果你没有搭建一个快速实验分析的套路，迭代速度再快也只会替你公司心疼宝贵的计算资源。建议记录每次实验，实验分析至少回答这三个问题：为什么要实验？结论是什么？下一步怎么实验？</p><p>超参调节：超参调节是各位调参工程师的日常了，推荐一篇文本分类实践的论文 <a href="https://arxiv.org/pdf/1510.03820.pdf" target="_blank" rel="noopener">A Sensitivity Analysis of (and Practitioners’ Guide to) Convolutional Neural Networks for Sentence Classification</a>，里面贴了一些超参的对比实验，如果你刚开始启动文本分析任务，不妨按文章的结果设置超参，怎么最快的得到超参调节其实是一个非常重要的问题，可以读读 萧瑟的这篇文章 <a href="https://zhuanlan.zhihu.com/p/24720954?utm_source=zhihu&amp;utm_medium=social" target="_blank" rel="noopener">深度学习网络调参技巧 - 知乎专栏</a>。</p><p>一定要用 dropout：有两种情况可以不用：数据量特别小，或者你用了更好的正则方法，比如bn。实际中我们尝试了不同参数的dropout，最好的还是0.5，所以如果你的计算资源很有限，默认0.5是一个很好的选择。</p><p>fine-tuning 是必选的：上文聊到了，如果只是使用word2vec训练的词向量作为特征表示，我赌你一定会损失很大的效果。</p><p>未必一定要 softmax loss： 这取决与你的数据，如果你的任务是多个类别间非互斥，可以试试着训练多个二分类器，也就是把问题定义为multi lable 而非 multi class，我们调整后准确率还是增加了&gt;1%。</p><p>类目不均衡问题：基本是一个在很多场景都验证过的结论：如果你的loss被一部分类别dominate，对总体而言大多是负向的。建议可以尝试类似 booststrap 方法调整 loss 中样本权重方式解决。</p><p>避免训练震荡：默认一定要增加随机采样因素尽可能使得数据分布iid，默认shuffle机制能使得训练结果更稳定。如果训练模型仍然很震荡，可以考虑调整学习率或 mini_batch_size。</p><p>没有收敛前不要过早的下结论：玩到最后的才是玩的最好的，特别是一些新的角度的测试，不要轻易否定，至少要等到收敛吧。</p><h2 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h2><p>几年前校招面阿里时，一面二面聊的都是一个文本分类的项目（一个新浪微博主题分类的学校课题项目），用的还是文中介绍的传统的做法。面试时对特征项处理和各个分类器可谓如数家珍，被要求在白板上写了好几个特征选择公式，短短几年传统做法已经被远远超越，不得不感慨深度学习的发展。</p><p>值得感慨的一方面是今天技术的发展非常快，故步自封自然是万万万万不可取，深知还有很多理论尚且不懂还要继续深读paper；另一方面，理解理论原理和做好项目间实际非常有巨大的gap，特别是身处工业界的同仁们，学术圈值得钻但要把握分寸，如果仅仅追逐技术深度，不免容易陷入空中阁楼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章总结了文本分类领域特别是应用深度学习解决文本分类的相关思路、做法和部分实践的经验。转载自知乎清凇撰写的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25928551&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用深度学习（CNN RNN Attention）解决大规模文本分类问题 - 综述和实践&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;业务问题描述：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;淘宝商品的一个经典的例子见下图，图中商品的标题是“夏装雪纺条纹短袖t恤女春半袖衣服夏天中长款大码胖mm显瘦上衣夏”。淘宝网后台是通过树形的多层的类目体系管理商品的，覆盖叶子类目数量达上万个，商品量也是10亿量级，我们的任务是根据商品标题预测其所在叶子类目，示例中商品归属的类目为“女装/女士精品&amp;gt;&amp;gt;蕾丝衫/雪纺衫”。很显然，这是一个非常典型的短文本多酚类问题。接下来分别会介绍下文本分类传统的和深度学习的做法，最后简单梳理下实践的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="fastText" scheme="http://yoursite.com/tags/fastText/"/>
    
      <category term="TextCNN" scheme="http://yoursite.com/tags/TextCNN/"/>
    
      <category term="TextRNN" scheme="http://yoursite.com/tags/TextRNN/"/>
    
      <category term="Attention" scheme="http://yoursite.com/tags/Attention/"/>
    
      <category term="TextRCNN" scheme="http://yoursite.com/tags/TextRCNN/"/>
    
  </entry>
  
  <entry>
    <title>读书记（20）：维特根斯坦论语言的限度（6）—— 维特根斯坦与罗素</title>
    <link href="http://yoursite.com/2018/02/16/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8820%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%20%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E4%B8%8E%E7%BD%97%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/02/16/读书记（20）：维特根斯坦论语言的限度（6）—— 维特根斯坦与罗素/</id>
    <published>2018-02-16T14:20:45.000Z</published>
    <updated>2018-11-05T16:26:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>维特根斯坦的思想不是逻辑的，是形而上学的。他通过对语言的了解是要说明,其实我们人类有很多东西是隐藏在语言背后没法说出来的，而这恰恰是一种推动我们用语言去表达的动力。但是对于罗素来说是很难理解的，因为罗素是一个经验主义者，他所有的观念都是建立在我们对经验的了解和认识之上，而维特根斯坦不是一个经验主义者，他是一个真正的理性主义者，他的观念具有很强的形而上学的根据，这是罗素很难理解的。</p><a id="more"></a><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxnf35x1tj30qt0dhadg.jpg" alt=""></p><p>他跟罗素的师生关系其实保持的时间并不长久，1912年他正式跟随罗素学习，到1918年以后基本就开始逐渐疏远了。他去农村教书基本上就跟学术界失去了联系，前后加起来有将近有十年的时间，那时候跟罗素也没有直接的往来。跟哥德尔的具体历史过程我不是太熟悉，不知道他到底跟哥德尔交往得有多深，不仅仅是哥德尔，在当时的时代里面有很多后来成为大家的学者们，包括经济学家凯恩斯，米塞斯他们都有很多的交往，还有图灵,本来就跟他有亲戚关系，所以他当时对这些人是有影响的，乃至于后来他们讨论说图灵从维特根斯坦那里得到什么东西.图灵肯定不会说他受了维特根斯坦的影响，但是从他们的时代来看他们两个是有交集的，我们就能够知道维特根斯坦在那个年代，他的思想的活跃程度是受益于当时他跟这些人有这样一些接触，也保证了他的思想总是站在前面，具有更广泛的影响力。</p><p>罗素对他的前期哲学是推崇有佳，这本书的导言是罗素写的，罗素写完以后维特根斯坦并不满意，我在我的《〈逻辑哲学论〉导读》里详细的分析了为什么维特根斯坦不满意罗素的导言，罗素是借用这个机会表达自己的观点，所以很多地方理解的根本不到位。到现在为止我们基本上可以判断，罗素真的没有读懂维特根斯坦。因为维特根斯坦的思想不是逻辑的，甚至不是语言的，是形而上学的。他通过对语言的了解，是要说明其实我们人类有很多东西是隐藏在语言背后的，这个隐藏在语言背后的东西是没法说出来，而这种没法说出来恰恰是一种推动力，推动我们用语言去表达，就像我们说话，其实有的时候不是我们想说话，而是我们不得不说话，当我们说我想说话的时候，其实不是你主观愿望想说话，而是有一个东西在推动你让你去说。所以海德格尔说，不是我说语言，是语言让我说。维特根斯坦实际上已经意识到这个问题了，但是对于罗素来说是很难理解的，因为罗素是一个真正的经验主义者，他所有观念的建立都是基于我们对经验的了解，所有这些都是根据我们对当下经验活动的认识，而维特根斯坦不是一个经验主义者，他是一个真正的理性主义者，或者叫逻辑主义者，所以他的这种观念具有很强的形而上学的根据，这是罗素很难理解的。罗素对他的后期哲学的评价很低，虽然前期他还能够推崇他，但是到后期哲学他就完全不理解维特根斯坦在干什么，所以罗素在他的晚年1949年所写的《我的哲学的发展》里评价维特根斯坦后期哲学的时候说，维特根斯坦后期哲学只能作为我们茶余饭后的谈资，而不能够当作深刻的思想。显然他就根本没有读懂，虽然那个时候维特根斯坦的书还没有出来，但是其实他很多的讲稿已经在外面传播开来了，所以很多人对维特根斯坦的了解不是《哲学研究》出版以后才了解的，而是之前很多人就已经知道了，只是到了他去世以后，《哲学研究》那本书才被正式的编辑出版。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxnfl9mbej30qt0dhq63.jpg" alt=""><br>不仅仅是罗素，G. E. Moore这样的哲学家也完全不能理解维特根斯坦，G. E. Moore和他差了好几个档次。他从来没有觉得罗素厉害，他去找罗素也是不得已而为之，是因为弗雷格推荐，他觉得弗雷格比罗素厉害得多，弗雷格的思想实际上在很大程度上给他提供了方向，维特根斯坦所做的工作其实是沿着弗雷格的工作往前推进的，跟罗素一点关系都没有，罗素只是帮助他完成了推进，所以罗素在他的心目当中并没有那么重要，为什么一直不把罗素放在眼里就是这个原因，他仅仅把他当作一个我思考哲学问题的助手，可想而知他有多么傲气，以及他的心智水平有多么高，这不是一般人能够达到的。罗素让他读哲学史，先看历史上的那些哲学家他们是怎么来讨论问题的，维特根斯坦拒绝，罗素震惊了，说那你回去写一篇东西，维特根斯坦就利用圣诞节期间写了几篇文章，罗素看了就说，这是天才。虽然罗素自己不一定能够达到这么高的心智水平，但他还是能够判断出来维特根斯坦的确是一个心智很高的人，这一点超出了常人。所以他跟维特根斯坦的姐姐写信说，你的弟弟将会成为我们中间最棒的一个人，他将会成为伟大的哲学家。这就是罗素当年给他下的一个判断。</p><p>罗素在1918年的时候他在发表他的代表作的时候，在伦敦做了一个系列的演讲，叫“逻辑原子主义哲学”演讲，开场白就说，我以下要讲的思想不是我的，是来自于我的学生和我的朋友维特根斯坦，但是我现在不知道他的死活。因为1918年第一次世界大战结束了，维特根斯坦是被作为俘虏被收编到意大利的俘虏营。后来维特根斯坦从俘虏营里寄了个明信片告诉罗素，他写了一本书叫《逻辑哲学论》，希望他们有时间能够见面聊一聊。1918年12月份他们俩商定在海牙见面，两个人在海牙整整谈了一个星期，讨论他这本《逻辑哲学论》，最后罗素答应给这本书写一个序言，这就是整个的维特根斯坦跟他的关系。到了1919年的时候，维特根斯坦就去了奥地利南部当小学教师了，维特根斯坦跟罗素之间他们相处的时间并不是很长，但是维特根斯坦仍旧表现出他自己的那种特殊性质，这种特殊的品质就是他自己的心智之高已经完全不把罗素放在自己的考量之内。他出于尊重在书里会提到罗素，这本书提到两个哲学家，弗雷格和罗素，但是他对罗素的评价远不如对弗雷格评价高，但是罗素毕竟是他的老师。1930年维特根斯坦重返剑桥以后，罗素要给他一个博士学位，但因为剑桥大学对于所有任教的老师是要求有学位的，而维特根斯坦走的时候连硕士都没有毕业，1912年进校1914年就已经去参军了，没有毕业就参军了。</p><p>1929年重返剑桥，到了1930年初的时候，维特根斯坦参加了剑桥大学组织的博士答辩，G. E. Moore向他提议用《逻辑哲学论》当博士论文，当时这本书已经是风靡全球成为经典著作了，维特根斯坦就答应了。但其实他这个时候已经放弃了这本书里的很多观点，不再把这本书当作他主要的思想，但是为了拿到博士学位，所以就以这个作为博士论文申请去答辩，答辩的时候只有两个答辩教授，一个外请一个是自己的，一个是G. E. Moore一个是罗素，两个人简单的对个话，就算是答辩了。很快他就在学校里面任教了，后来为了拿到更高的教席，必须要有东西，所以他当时就很快就完成了《哲学评论》跟《哲学语法》这两本书，这两本书都是作为正式的出版物已经做好编辑了，但是没有付印，只是作为提交申报教职的材料，因为虽然有学位但是没有东西不行。所以他就写了这两本书，大概1930年到1932年完成的，在这个过程当中，他的思想就开始发生剧烈的变化。从1929年到1936年，大概就这五六年时间里面，他的思想就已经开始成型了，从1936年开始写《哲学研究》，一直到1945年完成，前后十年的时间完成了《哲学研究》的工作，但到他去世之前仍然是没有被出版的，本来出版社已经接受了他的出版合同，并且跟他签了约，结果他最后要出版之前又撤回来，认为好多想法还不太成熟，还希望能够再补充或者修订，结果一直到他去世这本书也没有正式出版。他去世以后，安斯康作为他的遗嘱执行人最后给他编辑完成了这本书。</p><p>维特根斯坦对自己的要求非常严格，不可能随随便便就可以把一本书交到出版社去出版，他去世之后整理他所有的笔记本，大概有几十本，全部整理出来应该有上千页的内容。但是后来实在量太大就不再整理了，全部做成微缩胶片，现在这个手稿保存在挪威，但微缩胶片在全国各个图书馆都有，有一些部分被编辑、翻译。因为他的原书大部分都是用德文写的，翻译成英文出版。如果我们要更多的了解维特根斯坦的话，需要把维特根斯坦所有的东西看过，才能够知道他在晚年的时候到底还在思考什么问题。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnff01ljj30qt0dhgoy.jpg" alt=""></p><p>在2017年年初我们翻译出版了维特根斯坦跟他另外一个学生的谈话纪要，这个谈话纪要是从1932年一直持续到1946年，在过去没有出版过，后来在2015年的时候被英国的一个著名的杂志《Mind》出版，后来我们就花了一年时间翻译，一年时间校对，今年年初就全部出版出来了，通过这个对话里面就可以看出，他在这一段历史发展过程当中所考虑的问题涉及的面是相当广的，这些问题他的学生给他记录下来，后来这些东西被整理成文字。我们可以看出维特根斯坦直到去世之前都一直在思考哲学，甚至是说他认为自己还有精力（energy）,还有能力去做哲学的工作，只是因为最后身体越来越差。所以，维特根斯坦本人其实是把自己整个生命献给哲学。一个人的经历虽然是很有限的，但是如果一个人他什么事都不管，他只做哲学，你想想这个人会做出多大成就出来。但这个人得有能力去做这件事情，上天给了维特根斯坦这样的能力，只有维特根斯坦这样的人才能够真正做到这一点，这是很奇妙的一件事情，一个人只干一件事情，一辈子只做一件事情，而且把它做的这么好，觉得这个事情唯有他能做，别人真的做不了这个事情，让我们几代人可能都觉得从中受益，我觉得这种哲学家真是了不起。</p><p>我给学生放维特根斯坦照片的时候，大家都说这简直是男神，他的眼睛特别深邃，一看就是思想家，而且不是在看着现在，是望着未来，他的思想也是看着人类未来可能发生什么，这是我们常人很难达到跟做到的，这也是维特根斯坦过人之处。所以维特根斯坦英文的传记――《天才之为责任：维特根斯坦传》写的真好，揭示了他是个天才的哲学家，虽然我们讲哲学家是可以后天慢慢形成，但是像维特根斯坦这样的哲学家，大概真是很少，难得一见，空前绝后。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维特根斯坦的思想不是逻辑的，是形而上学的。他通过对语言的了解是要说明,其实我们人类有很多东西是隐藏在语言背后没法说出来的，而这恰恰是一种推动我们用语言去表达的动力。但是对于罗素来说是很难理解的，因为罗素是一个经验主义者，他所有的观念都是建立在我们对经验的了解和认识之上，而维特根斯坦不是一个经验主义者，他是一个真正的理性主义者，他的观念具有很强的形而上学的根据，这是罗素很难理解的。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书记（19）：维特根斯坦论语言的限度（5）—— 尘世生活</title>
    <link href="http://yoursite.com/2018/02/15/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8819%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E5%B0%98%E4%B8%96%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2018/02/15/读书记（19）：维特根斯坦论语言的限度（5）—— 尘世生活/</id>
    <published>2018-02-15T15:20:45.000Z</published>
    <updated>2018-11-05T16:33:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>维特根斯坦的生活是非常简单的，没有特别高的要求，但他对于思想和哲学上的要求却非常高，他是一个完美的理想主义者。他追求的目标是，所有的东西一定要做到最好，这是一般人做不到的。</p><a id="more"></a><p>维特根斯坦的生活经历是比较复杂的，甚至可以用坎坷这两个字，所谓坎坷说他的生活过程实际上是颠沛流离的状态。他居无定所，自从1945年他辞去了剑桥大学的教授职位以后，他就没有自己固定的住所，经常借住在他的学生家里面，或者到挪威，在山的边上盖了一个小房子，所以他基本上没有一个自己固定的生活住所，在剑桥大学的时候住自己的宿舍，宿舍陈设也非常简单、简陋。他是一个不追求物质也不追求生活情趣的人，虽然他对艺术，文学，以及宗教都有很高的鉴赏跟认识水平，但是尘世的生活并不是一个让他特别眷恋的东西，所以他也没有表现出窘迫，他仅仅表达一种个人的情绪，他在给朋友的信当中描写他当时某一种状况下心情很糟糕写不出东西，或者他觉得自己的思想已经枯竭了已经不能够做哲学了，他经常表示这样的担心。</p><p>他经常会表现出高傲的姿态，对很多人来说他是一个难以接近的人，他经常跟很多人搞不好关系，性格也比较孤僻敏感，虽然跟普通人还是比较容易融洽的，但他对跟他有思想关系的那些人反而表现出自己的独特，因为他老是怀疑他人在剽窃他的思想，尽管这些人其实在宣传他的思想，不断地在解释他的思想，但是他老觉得这些人不怀好意。</p><p>他最好的朋友罗素是他的老师，最后跟他分道扬镳，最好的朋友石里克跟卡尔纳普，当年在维也纳的时候，请大师一样的把他请去讲《逻辑哲学论》，但是最后也分道扬镳了。唯一的能够跟他在一起生活，还能够被接受的就是他的学生安斯康，她后来也是他的几本遗著的编者，因为安斯康从来不跟他计较，也从来不过分宣传他的哲学，所以他觉得安斯康比较靠谱。最后去世的时候也是在安斯康的家里，安斯康跟他的丈夫一块儿照顾他，并且请了自己的家庭医生来照顾维特根斯坦。 </p><p>维特根斯坦最后去世的时候那一句话让人匪夷所思，他说，请告诉他们，我度过了一个美好的人生。当他这句话出来以后大家很奇怪说，他还美好？为什么会美好？虽然他的哲学影响很大，但他个人生活是非常落魄的，但是这个事情对于他来说真的不重要。他在早年的时候把自己继承的遗产分给了自己的家人，并且还资助了比较落魄的诗人――青年诗人里尔克，到了晚年的时候，他基本上靠一点点退休金生活，因为他到1945年算是退出教职了，但是能够从剑桥拿到一些生活费，有时候朋友也接济他。所以他自己的生活是非常的简单，也没有特别高的追求，但他对于思想上的要求，对于哲学上的要求却是非常高的，他是一个完美的理想主义者，普通人真的达不到这一点。他给他的姐姐设计过房子，自己也做过一些小小的雕塑，设计过一些小小的工艺品，这些东西都是做到极致，精巧到极致，这是他追求的目标，所有的东西一定要做到最好，这是一般人做不到的。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxnni4vpqj30qt0dh0vk.jpg" alt=""></p><p>他的这种思想观念，主要还是来自于早年家庭的教育和熏陶，因为他出生于一个很高贵的家庭，家庭成员具有很高的艺术修养和人文关怀，他的父亲很有钱，每天来的基本上都是有很高的思想跟学术的地位的社会名流，在这样的环境中被培养出来，他会要求自己也应当像那样。他在当小学教师的时候跟学生家长经常闹别扭，因为都是农村的家庭，家长基本上都是当地农民，他认为农民一般都比较纯朴简单，所以跟农民打交道没有问题，结果没想到当他去教孩子的时候并不是这样。他对孩子有极高的要求，如果完不成任务会打手板，家长不干了，认为你完全没有必要去惩罚，孩子做不好你好好跟孩子讲，维特根斯坦认为不惩罚他记不住，因为小学生刚开始上一二年级，你跟他讲道理他不会记住的，只有通过身体的惩罚他才能够记住。那些家长就把他告到法院，经过法庭开庭经过审理，最后双方和解。但是从此他也认识到了当地人并不是他想象的那么淳朴，那么可爱，所以他跟当地人一直搞不好关系，包括他周围的人。在很大程度上是他的那种清高和完美主义导致的结果，他一直认为别人做的没有那么好，所以他一直就觉得自己跟他们有距离，这样一种心态导致他在周围很难有一个真心的，可以长久交往的一个朋友，这完全归咎于他的这种完满的理想主义，这就是他的生活。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxnno2o13j30qt0dh41e.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维特根斯坦的生活是非常简单的，没有特别高的要求，但他对于思想和哲学上的要求却非常高，他是一个完美的理想主义者。他追求的目标是，所有的东西一定要做到最好，这是一般人做不到的。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（3）：中文维基语料词向量训练</title>
    <link href="http://yoursite.com/2018/02/15/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E4%B8%AD%E6%96%87%E7%BB%B4%E5%9F%BA%E8%AF%AD%E6%96%99%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/"/>
    <id>http://yoursite.com/2018/02/15/自然语言处理系列（3）：中文维基语料词向量训练/</id>
    <published>2018-02-15T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>要通过计算机进行自然语言处理，首先就需要将这些文本数字化，目前用的最广泛的方法是词向量，根据训练使用算法的不同，目前主要有Word2Vec和GloVe两大方法，本文主要讲述通过这两个方法分别训练中文维基百科语料库的词向量。</p><h5 id="1"><a href="#1" class="headerlink" title="1. "></a>1. <img src="" alt="WechatIMG1zhanghua"></h5><a id="more"></a><h2 id="一、获取并处理中文维基百科语料库"><a href="#一、获取并处理中文维基百科语料库" class="headerlink" title="一、获取并处理中文维基百科语料库"></a>一、获取并处理中文维基百科语料库</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>中文维基百科语料库的下载链接为：<a href="https://dumps.wikimedia.org/zhwiki/" target="_blank" rel="noopener">https://dumps.wikimedia.org/zhwiki/</a>，本试验下载的是最新的<a href="https://dumps.wikimedia.org/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2" target="_blank" rel="noopener">zhwiki-latest-pages-articles.xml.bz2</a>。这个压缩包里面存的是标题、正文部分，该目录下还包括了其他类型的语料库，如仅包含标题，摘要等。</p><h3 id="1-2-抽取内容"><a href="#1-2-抽取内容" class="headerlink" title="1.2 抽取内容"></a>1.2 抽取内容</h3><p>Wikipedia Extractor是一个开源的用于抽取维基百科语料库的工具，由python携程，通过这个工具可以很容易地从语料库中抽取相关内容。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/attardi/wikiextractor.git wikiextractor</div><div class="line">$ wikiextractor/WikiExtractor.py  -b 2000M -o zhwiki_extracted zhwiki-latest-pages-articles.xml.bz2</div></pre></td></tr></table></figure><p>由于这个工具就是一个python脚本，因此无需安装，<code>-b</code>参数指对提取出来的内容进行切片后每个文件的大小，如果要将所有内容保存在同一个文件，那么就需要把这个参数设置地大一点，<code>-o</code>的参数指提取出来的文件放置的目录，抽取出来的文件的路径为<code>zhwiki_extract/AA/wiki_00</code>。更多的参数可参考其github主页的说明。</p><p>抽取后的内容格式为每篇文章被一对<code>&lt;doc&gt;&lt;/doc&gt;</code>包起来，而<code>&lt;doc&gt;</code>中的包含了属性有文章的id、url和title属性，如<code>&lt;doc id=&quot;13&quot; url=&quot;https://zh.wikipedia.org/wiki?curid=13&quot; title=&quot;数学&quot;&gt;</code></p><h3 id="1-3-繁简转换"><a href="#1-3-繁简转换" class="headerlink" title="1.3 繁简转换"></a>1.3 繁简转换</h3><p>由上一步提取出来的中文维基百科中的语料中既有繁体字也有简体字，这里需要将其统一变为简体字，采用的工具也是开源的<a href="https://github.com/BYVoid/OpenCC" target="_blank" rel="noopener">OpenCC</a>转换器。安装使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null</div><div class="line">$ brew install opencc</div><div class="line">$ cd OpenCC</div><div class="line">$ opencc -i /Users/HuaZhang/Desktop/zhwiki_extracted/AA/zhwiki_extract/AA/wiki_00 -o zhwiki_extract/zhs_wiki -c /Users/HuaZhang/OpenCC/data/config/t2s.json</div></pre></td></tr></table></figure><p>其中<code>-i</code>表示输入文件路径，<code>-o</code>表示输出的文件，<code>-c</code>表示转换的配置文件，这里使用的繁体转简体的配置文件，OpenCC自带了一系列的转换配置文件，可以参考其github主页的说明。</p><h3 id="1-4-去除标点"><a href="#1-4-去除标点" class="headerlink" title="1.4 去除标点"></a>1.4 去除标点</h3><p>去除标点符号有两个问题需要解决，一个是像下面这种为了解决各地术语，名称不同的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">他的主要成就包括Emacs及後來的GNU Emacs，GNU C 編譯器及-&#123;zh-hant:GNU 除錯器;zh-hans:GDB 调试器&#125;-。</div></pre></td></tr></table></figure><p>另外一个就是将所有标点符号替换成空字符，通过正则表达式均可解决这两个问题，下面是具体实现的python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*- </span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> io</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_process</span><span class="params">(input_file, output_file)</span>:</span></div><div class="line">    multi_version = re.compile(<span class="string">ur'-\&#123;.*?(zh-hans|zh-cn):([^;]*?)(;.*?)?\&#125;-'</span>)</div><div class="line">    punctuation = re.compile(<span class="string">u"[-~!@#$%^&amp;*()_+`=\[\]\\\&#123;\&#125;\"|;':,./&lt;&gt;?·！@#￥%……&amp;*（）——+【】、；‘：“”，。、《》？「『」』]"</span>)</div><div class="line">    <span class="keyword">with</span> io.open(output_file, mode = <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> outfile:</div><div class="line">        <span class="keyword">with</span> io.open(input_file, mode = <span class="string">'r'</span>, encoding =<span class="string">'utf-8'</span>) <span class="keyword">as</span> infile:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> infile:</div><div class="line">                line = multi_version.sub(<span class="string">ur'\2'</span>, line)</div><div class="line">                line = punctuation.sub(<span class="string">''</span>, line.decode(<span class="string">'utf8'</span>))</div><div class="line">                outfile.write(line)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Usage: python script.py input_file output_file"</span></div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]</div><div class="line">    pre_process(input_file, output_file)</div></pre></td></tr></table></figure><p>经过该步骤处理之后，得到了简体中文的纯净文本，如下所示：</p><p>&gt;<br>doc id13 urlhttpszhwikipediaorgwikicurid13 title数学<br>数学<br>数学是利用符号语言研究数量结构变化以及空间等概念的一门学科从某种角度看属于形式科学的一种数学透过抽象化和逻辑推理的使用由计数计算量度和对物体形状及运动的观察而产生数学家们拓展这些概念为了公式化新的猜想以及从选定的公理及定义中建立起严谨推导出的定理<br>·······<br>数学奖通常和其他科学的奖项分开数学上最有名的奖为菲尔兹奖创立于1936年每四年颁奖一次它通常被认为是数学的诺贝尔奖另一个国际上主要的奖项为阿贝尔奖创立于2003年两者都颁奖于特定的工作主题包括数学新领域的创新或已成熟领域中未解决问题的解答著名的23个问题称为希尔伯特的23个问题于1900年由德国数学家大卫希尔伯特所提出这一连串的问题在数学家之间有著极高的名望且至少有九个问题已经被解答了出来另一新的七个重要问题称为千禧年大奖难题发表于2000年对其每一个问题的解答都有著一百万美元的奖金而当中只有一个问题黎曼猜想和希尔伯特的问题重复<br>doc</p><h3 id="1-5-jieba分词"><a href="#1-5-jieba分词" class="headerlink" title="1.5 jieba分词"></a>1.5 jieba分词</h3><p>下面需要对其进行分词并且整理成每行一篇文本的格式，从而方便后续的处理。</p><p>分词采用 python 的分词工具 <a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>，通过 <code>pip install jieba</code>安装即可。且将一篇文章分词后的结果存储在一行，由前面可知，每篇文章存储在一对<code>&lt;doc&gt;&lt;/doc&gt;</code>标签中，由于前面去掉了标点，所以现在变成了<code>doc doc</code>,所以只要判断当前行为doc时即可认为文章结束，从而开始在新的一行记录下一篇文章的分词结果。实现的python代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> io</div><div class="line"><span class="keyword">import</span> jieba</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_words</span><span class="params">(input_file, output_file)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="keyword">with</span> io.open(output_file, mode = <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> outfile:</div><div class="line">        <span class="keyword">with</span> io.open(input_file, mode = <span class="string">'r'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> infile:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> infile:</div><div class="line">                line = line.strip()</div><div class="line">                <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:  <span class="comment"># empty line</span></div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">if</span> line.startswith(<span class="string">'doc'</span>): <span class="comment"># start or end of a passage</span></div><div class="line">                    <span class="keyword">if</span> line == <span class="string">'doc'</span>: <span class="comment"># end of a passage</span></div><div class="line">                        outfile.write(<span class="string">u'\n'</span>)</div><div class="line">                        count = count + <span class="number">1</span></div><div class="line">                        <span class="keyword">if</span>(count % <span class="number">1000</span> == <span class="number">0</span>):</div><div class="line">                            print(<span class="string">'%s articles were finished.......'</span> %count)</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> jieba.cut(line):</div><div class="line">                    outfile.write(word + <span class="string">' '</span>)</div><div class="line">    print(<span class="string">'%s articles were finished.......'</span> %count)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Usage: python script.py input_file output_file"</span></div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]</div><div class="line">    cut_words(input_file, output_file)</div></pre></td></tr></table></figure><h2 id="二、通过Word2Vec训练词向量"><a href="#二、通过Word2Vec训练词向量" class="headerlink" title="二、通过Word2Vec训练词向量"></a>二、通过Word2Vec训练词向量</h2><p>Word2vec中包含了两种训练词向量的方法：Continuous Bag of Words(CBOW)和Skip-gram。CBOW的目标是根据上下文来预测当前词语的概率。Skip-gram刚好相反，根据当前词语来预测上下文的概率。这两种方法都利用人工神经网络作为它们的分类算法。起初，每个单词都是一个随机N维向量。训练时，该算法利用CBOW或者Skip-gram的方法获得了每个单词的最优向量。</p><p>最初 Google 开源的 Word2Vec 是用C来写的，后面陆续有了Python ，Java 等语言的版本，这里采用的是 Python 版本的 gensim。通过 gensim 提供的 API 可以比较容易地进行词向量的训练。gensim的建议通过<code>conda install gensim</code>安装</p><p>下面是对上面处理后的语料库进行训练的一个简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">import os, sys</div><div class="line">import multiprocessing</div><div class="line">import gensim  </div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line"></div><div class="line"></div><div class="line">def word2vec_train(input_file, output_file):</div><div class="line">    sentences = gensim.models.word2vec.LineSentence(input_file)</div><div class="line">    model = gensim.models.Word2Vec(sentences, size=300, min_count=10, sg=0, workers=multiprocessing.cpu_count())</div><div class="line">    model.save(output_file)</div><div class="line">    model.wv.save_word2vec_format(output_file + &apos;.vector&apos;, binary=True)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    if len(sys.argv) &lt; 3:</div><div class="line">        print &quot;Usage: python script.py infile outfile&quot;</div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[1], sys.argv[2]</div><div class="line">    word2vec_train(input_file, output_file)</div></pre></td></tr></table></figure><p>上面的训练过程首先将输入的文件转为 <code>gensim</code>内部的 <code>LineSentence</code>对象，要求输入的文件的格式为每行一篇文章，每篇文章的词语以空格隔开。</p><p>然后通过<code>gensim.models.Word2Vec</code>初始化一个<code>Word2Vec</code>模型，<code>size</code>参数表示训练的向量的维数；<code>min_count</code>表示忽略那些出现次数小于这个数值的词语，认为他们是没有意义的词语，一般的取值范围为（0，100）；<code>sg</code>表示采用何种算法进行训练，取0时表示采用<code>CBOW</code>模型，取1表示采用<code>skip-gram</code>模型；<code>workers</code>表示开多少个进程进行训练，采用多进程训练可以加快训练过程，这里开的进程数与CPU的核数相等。</p><p>假设我们训练好了一个语料库的词向量，当一些新的文章加入这个语料库时，如何训练这些新增的文章从而更新我们的语料库？将全部文章再进行一次训练显然是费时费力的，gensim提供了一种类似于“增量训练”的方法。即可在原来的model基础上仅对新增的文章进行训练。如下所示为一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model = gensim.models.Word2Vec.load(exist_model)</div><div class="line">model.train(new_sentences)</div></pre></td></tr></table></figure><p>上面的代码先加载了一个已经训练好的词向量模型，然后再添加新的文章进行训练，同样新增的文章的格式也要满足每行一篇文章，每篇文章的词语通过空格分开的格式。这里需要注意的是加载的模型只能 是通过<code>model.save()</code>存储的模型，从<code>model.save_word2vec_format()</code>恢复过来的模型只能用于查询.</p><h2 id="三、使用词向量模型"><a href="#三、使用词向量模型" class="headerlink" title="三、使用词向量模型"></a>三、使用词向量模型</h2><p>训练好的词向量可以供后续的多项自然语言处理工作使用，下面是通过gensim加载训练好的词向量模型并进行查询的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加载模型</span></div><div class="line"><span class="keyword">import</span> gensim</div><div class="line">model = gensim.models.KeyedVectors.load_word2vec_format(<span class="string">'/Users/HuaZhang/Desktop/zhwiki_extracted/output_word2vec.vector'</span>,binary = <span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># 词向量维度</span></div><div class="line">len(model[<span class="string">u'黑格尔'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 相似度</span></div><div class="line">model.similarity(<span class="string">u'叔本华'</span>,<span class="string">u'康德'</span>)</div><div class="line"><span class="number">0.62428547493158093</span></div><div class="line"></div><div class="line"><span class="comment"># 找出相似度最高的词</span></div><div class="line">words = model.most_similar(<span class="string">u"哈耶克"</span>)</div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">print</span> word[<span class="number">0</span>],word[<span class="number">1</span>]</div><div class="line">    </div><div class="line">米塞斯 <span class="number">0.776977062225</span></div><div class="line">叔本华 <span class="number">0.731572449207</span></div><div class="line">黑格尔 <span class="number">0.723797023296</span></div><div class="line">巴维克 <span class="number">0.723039865494</span></div><div class="line">门格尔 <span class="number">0.719911754131</span></div><div class="line">谢林 <span class="number">0.714867889881</span></div><div class="line">波普尔 <span class="number">0.714080870152</span></div><div class="line">马克思 <span class="number">0.711268663406</span></div><div class="line">尼采 <span class="number">0.710071563721</span></div><div class="line">博姆 <span class="number">0.705146193504</span></div><div class="line"></div><div class="line"><span class="comment"># 找出最不相关的词汇</span></div><div class="line"><span class="keyword">print</span>  model.doesnt_match(<span class="string">u"莎士比亚 卡夫卡 卢梭 爱因斯坦"</span>.split())</div><div class="line">爱因斯坦</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要通过计算机进行自然语言处理，首先就需要将这些文本数字化，目前用的最广泛的方法是词向量，根据训练使用算法的不同，目前主要有Word2Vec和GloVe两大方法，本文主要讲述通过这两个方法分别训练中文维基百科语料库的词向量。&lt;/p&gt;
&lt;h5 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1. &quot;&gt;&lt;/a&gt;1. &lt;img src=&quot;&quot; alt=&quot;WechatIMG1zhanghua&quot;&gt;&lt;/h5&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Skip-gram" scheme="http://yoursite.com/tags/Skip-gram/"/>
    
      <category term="CBOW" scheme="http://yoursite.com/tags/CBOW/"/>
    
      <category term="词向量" scheme="http://yoursite.com/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
      <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
      <category term="jieba" scheme="http://yoursite.com/tags/jieba/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（9）：os</title>
    <link href="http://yoursite.com/2018/02/15/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89%EF%BC%9Aos/"/>
    <id>http://yoursite.com/2018/02/15/python编程系列（9）：os/</id>
    <published>2018-02-15T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="click" scheme="http://yoursite.com/tags/click/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（2）：Word2Vec</title>
    <link href="http://yoursite.com/2018/02/14/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9AWord2Vec/"/>
    <id>http://yoursite.com/2018/02/14/自然语言处理系列（2）：Word2Vec/</id>
    <published>2018-02-14T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="https://arxiv.org/abs/1411.2738" target="_blank" rel="noopener">word2vec Parameter Learning Explained</a></p><p>Mikolov等人的word2vec模型和应用在近两年受到了广泛的关注。由word2vec模型学习的单词的向量表示已经被证明具有语义意义，并且在各种NLP任务中都很有用。随着越来越多的研究人员实验word2vec或类似的技术,我注意到缺乏全面解释字嵌入模型的参数学习过程的细节的材料,从而使得非神经网络专家的研究人员无法理解此类模型的工作机制。</p><p>本文章提供了word2vec模型参数更新方程的详细推导和解释，包括原始的连续bag-of-word (CBOW)和skip-gram (SG)模型，以及优化技术，包括分层的softmax和负采样。对梯度方程的直观解释也提供了数学推导。</p><p>在附录中，提供了关于神经元网络和反向传播的基础知识的综述。我还创建了一个交互式演示，wevi，以促进对模型的直观理解。</p><a id="more"></a><h2 id="一、Continuous-Bag-of-Word-Model"><a href="#一、Continuous-Bag-of-Word-Model" class="headerlink" title="一、Continuous Bag-of-Word Model"></a>一、Continuous Bag-of-Word Model</h2><h3 id="1-1-One-word-context"><a href="#1-1-One-word-context" class="headerlink" title="1.1 One-word context"></a>1.1 One-word context</h3><p>我们从Mikolov et al. (2013a)中引入的最简单的一种连续的单词模型(CBOW)开始。我们假设每个上下文只考虑一个词，这意味着模型将根据上下文单词来预测一个目标单词，这就像一个三元模型。对于不熟悉神经网络的读者来说，建议通过附录A来快速回顾重要的概念和术语，然后再进一步讨论。</p><p>图1显示了简化的上下文定义下的网络模型。我们设定词汇量大小为V，隐藏层的大小为N。相邻层上的单元是全连接的。输入是一个one-hot编码向量，这意味着对于给定的输入上下文，在V个单元${x_1，·，·，x_V}$中只有一个单元为1，所有其他单元都是0。输入层和输出层之间的权值可以表示为一个$V×N$矩阵$W$。$W$的每一行是与输入层的相关词的N维向量表示$v_w$。形式上，$W$的第$i$行是$v_w^T$。给定一个上下文(一个单词)，假设$x_k=1 $、$x_{k’}=0$（$k≠k$）,我们有</p><script type="math/tex; mode=display">h=W_T·x=W^{T}_{(k,:)}:=v_{w_I}^T······（1）</script><p>本质上就是复制$W$的第k行至$h$。$v_{wI}$是输入词$w_I$的向量表示。这意味着隐含层单元的链接(激活)函数是线性的(即:，直接将其和输入加权求和至下一层。</p><p>从隐层到输出层,有一个不同的权重矩阵$W′= { w_{ij}^′}$，这是一个$N×V$的矩阵。使用这些权重，我们可以计算词库中每个单词的得分$u_j$。</p><script type="math/tex; mode=display">u_j=v_{w_j}^{′T}·h······（2）</script><p>$v^′_w$是矩阵$W^′$的第$j$列，然后我们可以使用softmax，一个对数线性$j$分类模型，来获取单词的后验分布，这是一个多项分布。</p><script type="math/tex; mode=display">p(w_j|w_I) = y_j =  \frac{exp(u_j)}{\sum_{j'=1}^Vexp(u_{j'})} ,······（3）</script><p>其中$y_j$是输出层的第$j$个单元的输出。将(1)和(2)代入(3)，得到。</p><script type="math/tex; mode=display">p(w_j|w_I)=\frac{exp(v_{w_j}'^Tv_{w_I})}{exp(v_{w_j'}'^Tv_{w_I})}······（4）</script><p>注意$v_w$和$v’_w$是词$w$的两种表示。$v_w$来自矩阵$W$的行，是输入层至隐藏层的权重矩阵，$v’_w$来自矩阵$W$的列，是隐藏层到输出层的权重矩阵。在随后的分析中，我们把$v_w$称为“输入向量”，把$v’_w$称为词$w$的“输出向量”。</p><blockquote><p>隐藏层到输出层权重的更新公式</p></blockquote><p>现在让我们推导这个模型的权值更新方程。虽然实际的计算是不切实际的(解释如下)，但我们正在做以下的推导，以获得对这个原始模型的见解，并没有使用任何技巧。有关反向传播的基础知识，请参阅附录a。</p><p>训练目标(一个训练样本)是最大化(4)式，在给定输出上下文单词$w_I$的条件下，观察实际输出单词$w_o$的条件概率。</p><script type="math/tex; mode=display">max p({ w }_{ O }|{ w }_{ I })=max { y }_{ { j }^{ * } }\qquad  (5)\\ \qquad \qquad \qquad = max  log  { y }_{ { j }^{ * } }\qquad (6)\\ \qquad \qquad \qquad \qquad = { u }_{ { j }^{ * } }-log\sum _{ { j }^{ ' }=1 }^{ V }{ exp({ u }_{ { j }^{ ' } }):= -E } \qquad (7)</script><p>其中$E=-log p(w_O|w_I)$是我们的损失函数（我们希望最小化$E$），$j^*$是输出层中的实际输出词的索引。注意，这个损失函数可以理解为两个概率分布之间的交叉熵衡量的一个特例。</p><p>现在让我们推导出隐藏和输出层之间权重的更新方程。求$E$关于第$j$个单位网络输入$u_j$的导数，我们得到：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial u_j}=y_j-t_j := e_j   (8)</script><p>比如$t_j=1(j=j^*)$，只有当第$j$个单元是实际输出词时，$t_j$为1，否则$t_j=0$。注意，这个导数只是输出层的预测误差$e_j$。</p><p>接下来我们对$w’_{ij}$求导获得从隐藏层到输出层的梯度。</p><script type="math/tex; mode=display">\frac{\partial E}{\partial w'_{ij}}=\frac{\partial E}{\partial u_j}·\frac{\partial u_j}{\partial w'_{ij}}=e_j·h_i \qquad (9)</script><p>因此,使用随机梯度下降法,得到隐藏的权重更新方程→输出权值:</p><script type="math/tex; mode=display">w^{'(new)}_{ij}=w^{'(old)_{ij}}-\eta · e_j· h_i \qquad (10 )</script><p>或者</p><script type="math/tex; mode=display">v^{'(new)}_{j}=v^{'(old )}_{w_j}-\eta · e_j · h \qquad for j=1,2,···,V.   \qquad (11 )</script><p>其中$eta&gt;0$为学习率，$e_j=y_j-t_j$，$h_i$是隐藏层的第i个单元。$v’_{w_j}$是$w_j$的输出向量。注意，这个更新方程意味着我们必须遍历词汇表中的每个可能单词，检查它的输出概率$y_j$，并将$y_j$与它的期望输出$t_j$(0或1)进行比较。如果$y_j&gt;t_j$(即高估)，我们就从$v’_{w_j}$移除一部分的隐藏层向量$h$(比如$v_{w_I}$)，使得$v’_{w_j}$远离$v_{w_I}$；如果$y_j&lt;t_j$(即低估，当且仅当$t_j=1$时成立，比如$w_j=w_O$)，我们就添加一些$h$至$v’_{w_O}$，使得$v’_{w_O}$靠近$v_{w_I}$。如果$y_j$非常接近$t_j$，根据更公式，权重只会发生非常小的变化。再次注意，$v_w$(输入向量)和$v’_w$(输出向量)是词$w$两种不同的向量表示。</p><blockquote><p>输入层到隐藏层的权重更新公式</p></blockquote><p>已经获取了$W’$的更新公式，现在我们来看看$W$。我们对$E$求隐藏层的输出的导数，得到：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial h_i}=\sum_{j=1}^V\frac{\partial E}{\partial u_j}·\frac{\partial u_j}{\partial h_i} = \sum_{j=1}^V e_j · w'_{ij}:=EH_i \qquad (12)</script><p>其中$h_i$是隐藏层第i个单元的输出；$u_j$是在(2)式中被定义的，即输出层的第j个单元的网络输入；$e_j=y_j-t_j$是输出层中第j个词的预测误差。$EH$是一个N维的向量，是词库中所有单词的输出向量的预测误差加权求和。</p><p>接下来我们对$E$求$W$的导数，首先，回想一下隐藏层对输入层的值进行线性计算。展开（1）中的向量表示，我们得到</p><script type="math/tex; mode=display">h_i=\sum_{k=1}^Vx_k · w_{k_i}</script><p>现在我们可以求E关于W的每个元素的导数，得到:</p><script type="math/tex; mode=display">\frac{\partial E}{\partial w_{k_i}}=\frac{\partial E}{\partial h_i}· \frac{\partial h_i}{\partial w_{k_i}}=EH_i · x_k \qquad (14)</script><p>这是$x$和$EH$的点积等式，</p><script type="math/tex; mode=display">\frac{\partial E}{\partial W}=x ⊗ EH=xEH^{T} \qquad (15)</script><p>这样我们得到了一个$V×N$的矩阵。因为x向量中只有一个元素非零，$\frac{\partial E}{\partial W}$中只有一行非零，且那一行 的值为$EH^T$，一个N维的向量。我们得到了w的更新公式：</p><script type="math/tex; mode=display">v_{w_I}^{(new)}=v_{w_I}^{(old)}-\eta EH^T\qquad (16)</script><p>其中$v_{w_I}$是$W$的一行，及唯一的上下文词的输入向量，也是唯一的导数不为零的$W$的行，所有其他的$W$的行在迭代后保持不变，因为他们的导数为零。</p><p>从直觉上来看，因为向量$EH$是语料库中所有单词的输出并进行预测误差加权后得到的总和，我们可以将（16）理解成为词汇中的每个输出向量的一部分添加到上下文单词的输入向量中。如果在输出层中，一个单词wj作为输出词的概率被高估$(y_j &gt; t_j)$，那么上下文单词$w_I$的输入向量将倾向于远离$w_j$的输出向量。反之，如果$w_j$作为输出词的概率被低估$(y_j &lt; t_j)$，则输入向量$w_I$将趋向于接近$w_j$的输出向量。如果$w_j$的概率相对准确的预测，那么它对$w_I$的输入向量的改变量很小。$w_I$的输入向量的变动是由词汇中所有向量的预测误差决定的。预测误差越大，一个单词对上下文单词输入向量的变动产生的影响就越大。当我们通过从训练语料库中生成的上下文目标词对来迭代更新模型参数时，对向量的影响将会累积。我们可以想象一个单词w的输出向量被w的相邻邻域的输入向量“拖拽”，就好像w的向量和它的邻域的向量之间有物理的弦。同样，输入向量也可以被认为是被许多输出向量拖拽的。这种解释可以提醒我们注意重力，或者是力向图的布局。每个虚弦的平衡长度与相关的两个单词之间的共存强度以及学习速率有关。经过多次迭代，输入和输出向量的相对位置最终会趋于稳定。</p><h3 id="1-2-Multi-word-context"><a href="#1-2-Multi-word-context" class="headerlink" title="1.2 Multi-word context"></a>1.2 Multi-word context</h3><p>图2显示了带有多词上下文的CBOW模型。当计算隐层输出,而不是直接复制的输入向量输入上下文的话,CBOW模型需要的平均向量的输入上下文的话,和使用的产品输入→隐藏权重矩阵和平均向量作为输出。</p><script type="math/tex; mode=display">h=\frac{1}{C}W^T(x_1+x_2+···+x_C)\qquad (17)\\=\frac{1}{C}(v_{w_1}+v_{w_2}+···+v_{w_C})^T\qquad (18)</script><p>其中$C$是上下文中词汇的数量，$w_1,···,w_C$是上下文的词汇，$v_w$是一个词$w$的输入向量。损失函数为：</p><script type="math/tex; mode=display">E=-log p(w_O|w_{I,1},···,w_{I,C})\qquad (19)\\=-u_{j^*}+log\sum_{j'=1}^Vexp(u'_j)\qquad (20)\\=-v_{w_O}^T·h+log \sum^{V}_{j'=1}exp(v_{w_j}'^T·h)\qquad (21)</script><p>可以看到和（7）式one-word-context模型的目标函数相同，除了$h$不同，将（1）式替换为（18）式。</p><p>从隐藏层到输出层权重更新公式和one-word-context模型保持一致，copy如下：</p><script type="math/tex; mode=display">v^{'(new)}_{j}=v^{'(old )}_{w_j}-\eta · e_j · h \qquad for j=1,2,···,V.   \qquad (22 )</script><p>注意,我们需要对隐藏层→输出层的权重矩阵的每个元素为每个训练实例进行更新。</p><p>输入层到隐藏层的权重更新公式与(16)类似,只是现在我们需要应用下列方程至上下文的每一个词:</p><script type="math/tex; mode=display">v_{w_I}^{(new)}=v_{w_I}^{(old)}-\frac{1}{C}\eta EH^T\qquad for \ j=1,2,···，C\qquad (23)</script><p>其中$v_{w_{I,c}}$是在输入上下文中第c个词的输入向量；$\eta$是一个正的学习率；$EH=\frac{\partial E}{\partial h_i}$由（12）式给出。这个更新公式的直观解释和（16）式类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;https://arxiv.org/abs/1411.2738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;word2vec Parameter Learning Explained&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mikolov等人的word2vec模型和应用在近两年受到了广泛的关注。由word2vec模型学习的单词的向量表示已经被证明具有语义意义，并且在各种NLP任务中都很有用。随着越来越多的研究人员实验word2vec或类似的技术,我注意到缺乏全面解释字嵌入模型的参数学习过程的细节的材料,从而使得非神经网络专家的研究人员无法理解此类模型的工作机制。&lt;/p&gt;
&lt;p&gt;本文章提供了word2vec模型参数更新方程的详细推导和解释，包括原始的连续bag-of-word (CBOW)和skip-gram (SG)模型，以及优化技术，包括分层的softmax和负采样。对梯度方程的直观解释也提供了数学推导。&lt;/p&gt;
&lt;p&gt;在附录中，提供了关于神经元网络和反向传播的基础知识的综述。我还创建了一个交互式演示，wevi，以促进对模型的直观理解。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>读书记（18）：维特根斯坦论语言的限度（4）—— 语法与联系</title>
    <link href="http://yoursite.com/2018/02/14/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8818%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/02/14/读书记（18）：维特根斯坦论语言的限度（4）—— 语法与联系/</id>
    <published>2018-02-14T12:20:45.000Z</published>
    <updated>2018-11-05T16:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓“语法”，就是看到联系。联系与结构息息相关，我们在结构当中才能为某一个具体的事物定位。我们看到任何一个游戏的时候，绝对不会想到这只是一个游戏，一定会想到这个游戏它相关的内容，因而，由这个相关的内容来理解游戏，而不是根据这个游戏来把握相关内容，不是由点到点，而是由面到点，这个面就是相互关系的面。</p><a id="more"></a><p>维特根斯坦还有一个重要的概念――语法（grammer），并且他给出了关于语法（grammer）的说明。他在中期阶段曾经留下了一些笔记，去世以后他的学生们给他编撰了一本书，这本书被取名为《哲学语法》（Philosophical grammar），除了《哲学语法》以外，他还有一本书叫《哲学评论》，这两本书通常被看作是他中期思想的两本重要的代表作。</p><p>《哲学语法》这本书里面主要给我们提供的是如何以看见或者观察到我们所有语词，或者是我们的命题之间相互关系的这样一种方式来确定我们所玩的语言游戏，或者我们所使用任何一个概念它所具有的意义和内容。有一个很著名的例子――鸭兔图，如果我们往右面我们就会看到是一个兔子，如果我们往左面看是一只鸭子，两种动物同时体现一副画上。鸭兔图实际上反映了两个不同的视角，语法（grammer)就是当我们看到一个事物的时候，我们其实不仅仅是在了解这个事物的本身，也是在了解这个事物跟其他事物之间的相互联系，因为我们只有通过相互联系，才能够对所谈到的事物本身得以确切的了解，所以我们是在关系当中去认识一个对象的。同样，对于语言游戏也是这样，我们是在各种不同的语言游戏之间的相互联系中来了解某一个语言游戏是如何完成自己的工作的，这就是我们前面讲到的整体论的观念。维特根斯坦有一个词，叫可纵观性（surveyability），是说我们可以通过鸟瞰的方式把握对象，但是我们通常把握的方式不是点到点的方式，而是线到点的方式，通过联系的方式来看到每一个点所处的位置。所以通过联系来看待事物，这是维特根斯坦通过语法的概念来解释他对于语言游戏的理解。当然这个语法不是我们讲的自然语言，他仅仅是在讲这样的一种事物与事物之间相互联系的概念，这是维特根斯坦最重要的一个观点。</p><p>语法的概念就是看到联系，联系其实就是结构的概念，我们在结构当中来为某一个具体的事物定位。你看到任何一个游戏的时候，你绝对不会想到这只是一个游戏，一定会想到这个游戏它相关的内容，因而，由这个相关的内容来理解游戏，而不是根据这个游戏来把握相关内容，不是由点到点，而是由面到点，这个面就是相互关系的面。</p><p>现代拓扑学重要的观点是，当我们谈论一个点的时候，我们往往是通过这个点所触及的面或者触及的联系来认识它。当我们能够确定网络当中任何一个点，我们都不是通过这个点来认识面的，而是相反。这对我们考察人的神经元的构造是非常有帮助的，通过显微镜看我们神经元的变化，你会发现每一个神经元的突起点实际上是不固定的，它是不断的变化的。因为它随着我们思维活动，随着我们的大脑的活动它在发生变化，随着这种变化我们产生了一个节点，这个结点可能就是思维的节点，然后产生了概念。但我们说概念、观念，这是用语言来表达出来的，但大脑当中不是一个概念，它就是一个节点，就是我们讲的那种神经与神经之间交叉的地方，而这个交叉的形成是来自于这些不同的联系，这个思维方式跟原有的思维方式是不一样的，原有的思维方式是按照传统的形而上学提倡的实体观至上的观念，实体就是所有的事物的存在都是根据实体的性质来加以解释的，而实体本身是孤立的，就像莱布尼茨的单子一样，单子与单子之间是没有联系的，然后我们根据每一个单子来理解世界的变化。</p><p>过去认为，事物的存在是世界存在的最基础的内容。但是现在认为事物的存在是以这个事物相关的各种联系所造成的结果，那个点只是造成的一个结果，它本身并不是原因，所以我们要找原因的时候，找的是网络本身给我们的结果所造成的影响，所以考察变动的关系是考察这些网络与网络之间是如何导致这个结果的。现代拓扑学讲的点面关系，点的存在是取决于面，或者取决于关系，而关系本身它是可以变化的，所以这个点是不确定的，但是点一旦被确定，就说明关系被建立起来了，所以我们又是通过这个点来了解这个关系是如何被建立的，维特根斯坦说语言关系就是那个点，所以我们通过这个点，去了解什么东西构成了这个点，然后我们就通过这个点来知道了它相关的所有这些关系，看到的这些相互的关系，如果你看不到这些关系你就没有办法理解这些点。</p><p>在人类社会中其实也是这样，人类学考察的都不是孤立的对象，你看到一个原始人类出现的时候，你绝对不会想到这只是一个个体，你一定想到这个个体它背后有一个群体存在。我们的思维一定是往外扩散的，不是往内收缩的，因为只有通过这种扩张式的方法，我们才能够发现更多的点，然后我们才能够确立这个联系是如何被建立起来，这时候我们发现我们关心的不是这些点，我们关心的是网络本身，这是现代网络最重要的一个思路，如何通过网络的建立来寻找点或者建立点，而不是通过研究点来寻找网络。</p><p>有时候我能够想象，虽然我们不一定能够看见空间真实的状况，但可以想象到空间的状况，就像我们在一些现代的美术作品当中，他们所构想的一个你看不见的世界。我想，这个看不见的世界其实是存在的，不是因为它看不见而存在，而是因为它能够很好的通过另外一种方式向我们展示它的存在。就像地球的两极以及宇宙中的射线，这些东西是看不见的，但是我们能够通过仪器找到它们，能够发现它们，而这个仪器是间接的，但是能够想象的出来这种空间中所大量分布的这样一种结构性的安排，这要回到经典力学当中去讨论作用力跟反作用力的关系。一个物体的存在本身不是单向作用的结果，一定是双向作用，一个事物就像一个人能够在地球存在，不仅仅是我们有重量，重量其实是引力的结果，任何物体都是这样。就像我们知道一个星球它能够按照某种轨道运行，只是我们不知道为什么会这样运行，我们可以看到它运行的轨迹，其实它背后有很多力量在作用，所以导致我们现在新的物理学，天体物理学研究的时候会发现新的天体存在。发现新的天体好像是说过去它不在这里，我们重新又发现它了，不是这样，其实它一直在那里，只是我们过去检测的手段并没有那么先进。门捷列夫发现元素周期表，他觉得这个地方应该有一个元素，只是我们现在不知道这个元素是什么，因为如果没有这个元素你构成不了上下前后的元素关系，所以它中间一定有一个东西，这个方法其实就是拓扑学的方式，通过这样一种不同的联系来确定一个对象所存在的位置，这就是拓扑学的基本观念。然后通过这种方式来寻找这样对象的存在，它的根据是什么，这个根据恰恰是一种不变量所决定的。</p><p>维特根斯坦之所以用《逻辑哲学论》这种方式来表达他的思想，其实里面就包含很严密拓扑学论证。他在柏林读书期间借住在德国柏林的一个专门研究拓扑学的教授家，那是十九世纪末二十世纪初，拓扑学在今天来说还是个新的学科，上个世纪六十年代才正式确立拓扑学学科，在这之前基本上属于前历史阶段，那个教授就是早期从事几何拓扑研究的一个专家，他从中得到了很多启发，所以乃至他后来写文章，写所有的笔记都是按照这种方式来编的，不是论证的方式，因为论证的方式实际上是一个线性的方式，而是一个立体而且多元的方式。所以，他的这本《逻辑哲学论》里面你可以看到整个的篇章布局都是完全按照这样的方式构建出来的，而这个构建方式在他那个时代是少见的，我估计今天也少有这样的写作方法，这对于我们了解拓扑学是如何被贯彻到他的哲学描述当中，以及理解我们所生活的世界的各种结构关系的过程都是非常有意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓“语法”，就是看到联系。联系与结构息息相关，我们在结构当中才能为某一个具体的事物定位。我们看到任何一个游戏的时候，绝对不会想到这只是一个游戏，一定会想到这个游戏它相关的内容，因而，由这个相关的内容来理解游戏，而不是根据这个游戏来把握相关内容，不是由点到点，而是由面到点，这个面就是相互关系的面。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书记（17）：维特根斯坦论语言的限度（3）—— 语言背后的基础</title>
    <link href="http://yoursite.com/2018/02/13/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8817%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20%E8%AF%AD%E8%A8%80%E8%83%8C%E5%90%8E%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/02/13/读书记（17）：维特根斯坦论语言的限度（3）—— 语言背后的基础/</id>
    <published>2018-02-13T15:20:45.000Z</published>
    <updated>2018-11-05T16:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>维特根斯坦哲学的特殊性就在于，它不是以显形的方式让人们去接受的，维特根斯坦是一个隐士，他是隐身在我们的思想背后，然后去触发人们思考很多新的问题，而这些问题实际上在维特根斯坦都已经讨论过了，只是他并没有给我们提供一个现成的结论，而是让我们不断的去思考他提出的这些问题</p><a id="more"></a><p>维特根斯坦讨论语言的界限或者语言的边界的目的是什么？我们这样处理维特根斯坦前后期的关系，并且用语言的界限这样的说法来理解维特根斯坦的时候，我们到底在做什么？我想，当维特根斯坦讨论语言问题的时候，是把这个语言看作一个连贯的整体，虽然这样的语言前期对他来说是逻辑语言，后期是自然语言，虽然看上去各不相同，但它们都是在关心我们思想的表达方式，在这一点上两者是一致的，都是讨论思想的表达方式，只是前期用逻辑的方式给出了思想的定义，后期用显示的方式通过语言游戏来表达思想的内容，所以这两者都是对思想本身的关注，因而维特根斯坦表面上看是讨论语言，他实际上关心的是思想本身，这是我们第一个想要强调的一点。</p><p>第二，我们更想强调一点是，维特根斯坦一直试图要追问：当我们谈论语言的时候，甚至在谈论思想的时候，我们背后的根据是什么？所谓背后的根据就是，我们能不能找到一个构成我们谈论语言和思想的基础的东西？他在前期哲学里讨论逻辑概念的时候是有的。因为所有的逻辑语言，其实都建立在我们对逻辑的一种自觉的先天的意识之上，这种先天的自觉意识是说，我们相信逻辑可以完成这个工作，因而逻辑就是它的基础。</p><p>到了后期哲学的时候，这个基础在哪里？这是维特根斯坦一直追问的问题。甚至不仅仅是维特根斯坦，是整个二十世纪后半叶的西方哲学家们一直追问的问题：当人类失去了一种能够追问的基础的时候，当人类失去我们共同的家园的时候，漂浮在大海上的我们，还能够做什么？</p><p>奥托・纽拉特经常说，人类其实就是在海上一艘永远不能够靠岸的船只，人类永远是生活在这样的船只之上，要修补这个船只我们只能在大海上修补，不能等到靠岸再修补，我们人类的认识活动和知识就像是这样一艘船只，所以当这个船只出了故障的时候，我们只能够通过在大海上的漂泊来修复或者替换它。知识论里面有可替换性原则，就是当我们不能够找到一个根据的时候，我们只能利用另外的东西想办法使得我们要补充修订的这一部分内容可以得到替换，但是要替换它的东西本身也是需要修补的，我们只能够取长补短。所以我们的认识活动是通过这种方式来相互协调而共同发展的，可是我们没有那个基础存在了，我们都找不到那样一个最终的可靠的根据了。</p><p>因为自从现代科学，特别是现代的物理学产生以后，人类知识的大厦就已经受到了严重的挑战。我们几乎很难相信还有一个所谓的最确定的东西，把它当作我们一切知识的根源。在人类的认识活动，包括我们对语言的讨论当中，我们找不到这样的东西。过去我们可以把上帝当作产生语言最终根据，甚至可以把人类的理性当作我们思想的根据，但是这在今天已经被大部分人放弃了，上帝的观念已经被放弃了，而对于理性绝对的盲目崇拜也被放弃了，这导致一个结果――我们失去了家园。现在我们老讲乡愁，我们人类好像似乎总是在往回走，总是要回顾我们过去所经历的那些事情，然后把经历的历史当作我们现在的起点。但事实上经历是回忆性，甚至是幻想性的，因为这些事物其实在我们的心目当中永远只是作为一个记忆中的存在。而如果人类的认识活动建立在这样一种幻想的、回忆的，甚至是虚构的背景之上，那人类的知识就面临很大的挑战。</p><p>其实维特根斯坦整个的思考方式就是要追问有没有这个根据？能不能够找到这个根据，让我们人类的知识哪怕靠不了岸也可以就地抛锚？我们可以把我们的锚栽在河床之上，让这个船只能够稳定，而不是永远在漂浮当中。维特根斯坦试图找到这样一个河床，他把这个河床叫做思想的河床，这是维特根斯坦要做的一个重要工作。维特根斯坦在追问这样一个思想河床的时候，实际上是在为我们人类知识寻找一个根据，他试图想要找到这个东西并且他认为找到了。在《论确定性》当中，他认为这样的东西就叫做生活形式和世界图式。我自己将世界图式看成是类似于世界观的一种思想内容，跟我们通常理解斯宾格勒所说的世界观不太一样，我们通常在德国的语境当中讲世界观的时候，是指预先有一个对世界的理解，但是维特根斯坦理解的世界观是讲我们在已经具备对世界了解之后所形成的对世界的理解方式，而不是在理解世界之前，我们就预先有了某一个世界的概念，这个世界图式不是静态的，是动态的。因为在这个背景当中，有一些东西不断地会被替换掉，然后不断又有新的东西被增加进来，所以它是流动的。按照维特根斯坦的理解，这种变化的世界图景，总有一些东西是不变的，正因为这些不变的内容，使得我们把它看成是一副完整的图像，如果每一个东西都在变化，我们就没法把握这个图像。所以，在维特根斯坦心目当中，整个世界就处于这样的变动当中，而我们要把握就是那个变动当中的，某一些能够让我们把它看成完整图像的不变的内容，这是维特根斯坦要强调的一个重要的观念。</p><p>所以对他来说，他虽然反对以往传统本质主义的观念，认为人类可以有一个工作，可以把它当作一些知识的基础，但是他又试图要为我们能够去寻找这样的基础，这种心理的倾向找到一个说明，证明人类是有这个倾向的，只是找不到而已。就像我们每一个人都希望长寿，但是我们都知道这是不可能的，我们活多长时间不是由我们决定的。这个时候我们会发现，人们的这种主观愿望会直接影响到对事物的判断。在维特根斯坦看来这个倾向是实实在在的，因为实际上它确定了我们当下的这种存在方式，而当下的这种存在的方式恰恰是以这种以变化当中不变的因素来加以保障的，这是维特根斯坦要强调的一个重要的观念。</p><p>我们理解维特根斯坦的时候，会把他看作是一个比较极端的，激进的哲学家，看作是一个完全跟传统背道而驰的哲学家，他自己在《文化与价值》这本书中也多次表达过类似的观点，他反对现代科技，反对现代文化，反对整个现代主流的社会思潮，而我们认为维特根斯坦简直就是像嬉皮士一样是社会的叛逆者。其实仔细读一下他的书发现倒也未必，他思想里面有很多值得我们去进一步去追问的内容。这样就使得维特根斯坦整个的思想就变成大家思考所有当代问题的一个出发点，他不一定给出了答案，但是他的思考方式却引起大家去思索。在当代哲学当中有一个很有意思的现象，几乎每一个人言必称维特根斯坦，但是没有人承认自己是维特根斯坦的信徒，没有人承认自己是受维特根斯坦的影响，包括当代大的一些哲学家，他们在自己的书当中只是引述维特根斯坦的观点，但他们从来不认为维特根斯坦说法就是对的，或者说我认为我就是按照维特根斯坦的方式来做的。</p><p>这是维特根斯坦思想的特殊性，我曾经有文章专门讨论这个问题，维特根斯坦哲学的特殊性就在于，它不是以一个显形的方式让人们去接受的，维特根斯坦是一个隐士，他是隐身在我们的思想背后，然后去触发人们思考很多新的问题，而这些问题实际上在维特根斯坦都已经讨论过了，只是他并没有给我们提供一个现成的结论，而是让我们不断的去思考他提出的这些问题，他一辈子涉及的哲学问题实在太多了，哲学史上关注过的以及当代所面临的问题他都有所涉猎，而且几乎每一个人跟他接触的人都评价说维特根斯坦对所有事情有一个很好的感觉，他那种感觉是超人的，而且他说的话都不外行，但是他一说一表达对这个问题的看法，马上就可以表现出他自己那种天才的那一面，包括人类学、宗教、艺术、文学、诗歌、音乐，所有这些领域他都表达过自己的看法，我想恐怕在他那个时代，也少有这样的学者或者哲学家能够做到这一点，这也是维特根斯坦的过人之处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维特根斯坦哲学的特殊性就在于，它不是以显形的方式让人们去接受的，维特根斯坦是一个隐士，他是隐身在我们的思想背后，然后去触发人们思考很多新的问题，而这些问题实际上在维特根斯坦都已经讨论过了，只是他并没有给我们提供一个现成的结论，而是让我们不断的去思考他提出的这些问题&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书记（16）：维特根斯坦论语言的限度（2）—— 语言的边界</title>
    <link href="http://yoursite.com/2018/02/12/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8816%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%B9%E7%95%8C/"/>
    <id>http://yoursite.com/2018/02/12/读书记（16）：维特根斯坦论语言的限度（2）—— 语言的边界/</id>
    <published>2018-02-12T15:20:45.000Z</published>
    <updated>2018-11-05T16:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>维特根斯坦说，当我们谈到边界的时候，我们不是刻意要追问这个边界在哪里，而是用语言的方式来说明，我们所有的人类活动只有按照语言的这种表达方式来理解，我们的思想才能够被加以定位，思想的活动是通过语言游戏这种方式来加以定位甚至加以理解的，不是纯粹用逻辑的方式去规定思想的目的或方式，而是把语言完全看作是我们人类自身具有的活动能力和活动内容。语言游戏既是我们能够讨论思想边界的一种方式，同时又是我们不断突破思想边界的方式。</p><a id="more"></a><p>维特根斯坦的哲学研究是用语言游戏的方式来显示思想的内容，不是通过语言来表达思想的内容，而是通过语言游戏来显示，由此，就跟逻辑的语言没有关系了，因为逻辑的语言在他看来并不是被代替了，而是说被搁置一边。有一部分是可以用逻辑的方式来表达的，但是还有一些不能够用逻辑的语言来表达得，那关于这个不能够用逻辑语言来表达那一部分，我们只能通过语言游戏的方式来显示它们。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxni7om8aj30qs0dhacb.jpg" alt=""></p><p>但是，维特根斯坦是如何用这样的语言游戏来显示他所说的那些不可能用逻辑的语言来表达的思想内容呢？大部分人都认为维特根斯坦后期对语言的批评和批判和前期不太一样，一种比较经典的观点认为，他的前期哲学是一种静态的对语言结构逻辑的分析，而到了后期是一种动态的对语言活动的一个游戏分析，一个是静态一个是动态，一个是对性质结构的了解，一个是对于活动、运动的了解，对于活动的了解，对于游戏的了解，这两个是完全不太一样，但就是这种不一样导致了维特根斯坦在后期所关心的侧重点不一样，但是并不意味着他完全背离了他前期的哲学，而只是说他关注的重点不同，所以，他只是转换了一个视角，他的研究对象并没有变化，仍旧是对于语言本身的考察。在他后期哲学里面，他对于语言的讨论就不再是界限、限度的问题，而是边界, the bounds of language or the boundary of language。维特根斯坦说，其实我们有时候很难对一个语言游戏划出一个界限，我们能够规定这个语言游戏跟其他的语言游戏是如何被加以区分的，因为我们知道，在《哲学研究》当中，维特根斯坦描述了大量的语言游戏，他并没有给出具体的哪一种语言游戏跟其他语言游戏之间有什么本质性的区别，但是他强调了语言游戏跟另外一个语言游戏之间的相似关系，他用了家族相似这个说法来说明所有的语言游戏都具有某种家族相似的特征，这个家族相似在他那里其实指的是所谓的遵守规则，无论是规则还是家族相似，在他那里都表征着一个特点――所有的语言游戏它们具有一些共同的东西，而这种共同的东西使得语言游戏可以完成它的功能，并且使得我们能够通过语言游戏去了解那些我们试图想表征的内容。</p><p>这里有一个很重要的节点，我们都认为维特根斯坦是在描述语言游戏，而并不认为语言游戏在维特根斯坦那里是被解释的，仅仅是被描述的，但是其实维特根斯坦在这里所描述的语言哲学隐含一种解释性功能，就像显示这个概念一样，显示并不是意味着这个行为本身它给我们显示出了某种特征，如果一个行为，一个活动，或者一个游戏，当它被说成是向我们显示了某一种生活形式的时候，是指这个活动本身它所显示生活形式能够被我们所理解，当我们看到一个我们完全没有见过的陌生游戏，我们没有办法通过这个游戏解读出这个游戏它所显示生活内容或者生活形式，而我们只有在知道有这样的生活形式之后，我们才能够了解这种生活形式是什么，如果完全不了解的话是没有办法解释的，所以表面上看它就只是描述性。他也反复强调说，我们的语言游戏不过就是一项跟平常的游戏一样，所以这个时候我们不需要任何解释。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxnidu8cpj30qt0dhq4x.jpg" alt=""></p><p>按照维特根斯坦的观点，当我们要讨论语言游戏的时候，我们到底在做什么？它是以什么样的方式向我们显示它所谓的生活形式的？生活形式是一个很有意思的概念，我们需要仔细揣摩这个概念所包含的深层含义。因为我们讲的生活形式并不是大家公认的某一种生活方式，或者某一种习俗、传统、文化、历史等等，他讲的生活形式是指我们是按照这样一种方式来生活，它里面包含的内容都已经被隐含在我们的活动方式之中了，我们是通过这种活动方式来显示这样的生活内容。就像我们看到一幅绘画的时候，我们马上就能判断出这幅绘画它所包含一种历史的、文化的乃至民族的特征，这样的特征实际上并不是我们去赋予这个图画的，而是这副图画向我们显示出来的，因而我们在欣赏任何一幅作品的时候，这幅作品向我们显示出来的内涵和意义要远远多于我们赋予它解释的意义，因为解释都是依赖于它所显示的内容。所以在这个前提之下，维特根斯坦强调，我们的语言游戏是以这种显示的方式向我们呈现它的细节的，所有的语言游戏都是以其详细的活动方式和内容向我们显示它背后所隐含的生活方式和生活形式，这就是维特根斯坦一直强调的，当我们了解一个语言游戏的时候，一定要把握语言游戏它所具体的方式，而不是它一般性的内容。比如说下棋，当我们谈下棋的时候，我们一定要进一步追问什么棋、怎么下，什么棋、怎么下这里面背后追问的是：到底是什么样的规则决定了这个游戏的方式？</p><p>因而，你可以看得出维特根斯坦所讲的细节的概念就是讲我们遵守规则的具体活动内容，通过这种细节的描述，我们才能够真正把握维特根斯坦所说游戏的概念是以什么样的形式，向我们显示它背后所给我们提供的内容。我们每一个在日常生活当中生活的人每天都会接触大量的人和事，有一些东西是我们并不熟悉的，有一些东西是我们可能通过书本去了解的，或者通过图片去了解，当我们了解这些内容的时候，我们得有一个前提，我们要知道它向我们展现的这些思想内容背后的东西是什么？</p><p>如何去理解和把握这一点就很玄妙了，只有当我们能够真正理解这种文化所依赖根据的时候，我们才能够真正去理解这个文化向我们显示的内容，如果你不能够了解这个文化，就说明你自己没有办法把这个语言，或者这种活动看作是整个生活形式的一部分，而唯有你自己在整体上把握了这样的文化内容，你才能够真正地了解它所显示出来的文化意蕴。</p><p>后来很多哲学家就把维特根斯坦这个观点发展成了整体论的语言观。所谓整体论的语言观是说，当我们理解一种语言的时候，或者说理解一个语言当中某一些命题的时候，就意味着我们能够完整地理解这个语言和命题所在的整个的语言。就像约翰・赛尔（Jhon Searle）所举的例子，一个英国士兵在二战期间被德军抓了，他大概会说一句德语，他就用这一句德语表示自己是一个德国人。比如他说的德语是鲜花很美，这句德语跟当时的场景完全无关，但他想用这句话来表示我也会德语，我是德国人，是友军。他通过这种方式来表征自己的身份，但事实上这句话本身在这里不表征任何他能够懂这个语言本身，但这是一种特例。在这种特殊的环境下，我们能够理解这句话并不是根据这句话本身它所表达的含义，而是根据它的整个场景，他用这句话来表征他其实是一个德国人。但是我们在理解任何一个语言中一个句子的时候，当我们能够理解一个语言中的一个句子的时候，也就意味着我们能够理解这个语言所承载的这样一种文化背景，其实也就意味着你可以理解这个语言，这就是所谓的整体论的观点。</p><p>这个整体论的观点的确是从维特根斯坦这儿引发出来的。按照维特根斯坦的说法，语言游戏的理解并不是一个单纯的、简单的步骤，也不是一次性完成的工作，它是需要大量的，无数的这样的语言游戏构成一个完整的整体，这个整体就意味着说，当我们理解某一个语言游戏活动的时候，我们能够知道这个活动它所附带的，或者说它所相关的其他的游戏活动。比如当我们玩扑克牌的时候，没有一种游戏叫做玩扑克游戏，因为扑克只是一个工具，可以玩桥牌游戏，打争上游，斗地主，我们可以做各种你可以想象出来的用扑克来玩儿的游戏。这样的游戏实际上它并不依照于纸质或者材料，而是游戏规则。因而，这个时候遵守规则是整个游戏活动当中最为至关重要的一个环节，正因为遵守规则而使得维特根斯坦发现，我们通过遵守规则才能够真正地定位我们所要做的事情，因为这些规则它给我们规定了我们这个游戏的性质，同时也规定了这个游戏它所反映出来的这样一种文化特征。因而通过这个小的游戏来看整个文化的概念，小的语言活动来看整个思想的构成方式，实际上就是维特根斯坦希望通过语言游戏所要达到的目的。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnim8uw5j30qt0dh40p.jpg" alt=""></p><p>在这里，我要进一步解释“边界”的概念。因为我们前面说它不是一个界限，也不是一个范围，而是一个边界。就像孙悟空一样，说要给唐僧划一个界，划的这个边界是唐僧不能够超出的范围，超出了以后他就没有安全保障了。同样，对于语言来说，如果按照逻辑的方式划一个界，只有在逻辑的范围内能够表达清楚的思想，我们都可以用逻辑的方式来表达，这是早期的一个工作。到了后期的时候，他讲的边界是说，这个边界之内的事情都没问题了，但是我们现在要做的是边界之外的事情。这个边界有多大，我们在边界之外所能够完成的工作就有多大。所以维特根斯坦说，这样的边界是没有办法确定的，因为我们的语言活动是“佛法无边”的，语言相当于是我们人类所使用一个佛杖，怎么划它都会成为一个独立的场域。因而，在这个前提下，这个边界实际上是不可能完全被划定。所以维特根斯坦说，当我们谈到边界的时候，我们不是刻意要追问这个边界在哪里，而是用语言的方式来说明，我们所有的人类活动，只有按照语言的这种表达方式来理解的话，我们的思想才能够被加以定位，思想的活动是通过语言游戏这种方式来加以定位甚至加以理解的。这样它就摆脱了早期的纯粹用逻辑的方式去规定思想的目的或方式，而是把语言完全看作是我们人类自身具有的活动能力和活动内容。所以语言游戏对他来说，既是我们能够讨论思想边界的一种方式，同时又成为不断突破思想边界的一种方式。因为，当我们想到一种新的语言游戏的时候，我们实际上就想到一种新的思想的可能性，我们只要创造一种新的游戏规则，我们就又有一种新的思想的产生，我们现代社会的发展变化如此之快，其实也在不断创造新的语言游戏，而对于维特根斯坦来说，其实我们日常生活当中的很多思想观念是伴随着这些语言游戏的生成而形成的。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxniqzz57j30sg0godhf.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维特根斯坦说，当我们谈到边界的时候，我们不是刻意要追问这个边界在哪里，而是用语言的方式来说明，我们所有的人类活动只有按照语言的这种表达方式来理解，我们的思想才能够被加以定位，思想的活动是通过语言游戏这种方式来加以定位甚至加以理解的，不是纯粹用逻辑的方式去规定思想的目的或方式，而是把语言完全看作是我们人类自身具有的活动能力和活动内容。语言游戏既是我们能够讨论思想边界的一种方式，同时又是我们不断突破思想边界的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书记（15）：维特根斯坦论语言的限度（1）—— 语言的限度</title>
    <link href="http://yoursite.com/2018/02/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8815%EF%BC%89%EF%BC%9A%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E8%AE%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%20%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/02/11/读书记（15）：维特根斯坦论语言的限度（1）—— 语言的限度/</id>
    <published>2018-02-11T14:20:45.000Z</published>
    <updated>2018-11-05T16:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>《逻辑哲学论》是维特根斯坦早期的一本代表作，也是他生前出版过的唯一的一本哲学著作。他在这本书里提出了关于哲学是一种对语言的批判的观点，即批判语言实际上是哲学的一个主要工作，甚至是哲学的全部工作。维特根斯坦认为，我们所有思想都是用语言表达的，因而我们即使是要考察思想，也只能通过语言来完成，批判语言就是在批判思想。</p><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxnke5vuwj30qt0dh786.jpg" alt=""></p><p>维特根斯坦是大家都喜欢的一个哲学家，无论是他自己的个人生平还是他的哲学思想，都引起了很多人的关注，尤其是关于他的哲学。通常会认为他有两种哲学，一个是前期的《逻辑哲学论》时期的哲学，另外一个是所谓的《哲学研究》时期的哲学，这两个时期的哲学思想，是有很大的区别的。维特根斯坦在一生当中提出两种具有深远影响的哲学思想，这个对于一般人来讲，的确很难做到，但维特根斯坦做到了，这就足以证明，维特根斯坦是一个非常具有天才性质的哲学家。</p><p>今天我其实要讲的是关于维特根斯坦整个哲学思想的理解，不仅仅是限于他的前期或后期，而是放在一个整体的发展脉络当中来加以把握。把握的方式就是通过他对语言限度的理解，来看待他的前后期之间的相互联系。谈两个哲学之间的差别比较容易，但是要谈他们两个之间的相互关系，确实需要我们去发现和寻找一些相关的线索。我们找的线索是通过对维特根斯坦语言的限度的说明，来看待作为一个整体的维特根斯坦思想的发展过程。限度的英文叫limitation，实际上讲的是在一个界限内我们所能够完成的工作，或者说我们不能够超出这个界限，只能在这个界限之内所做的工作，通常我会把这一部分的思想看作是他前期的哲学，即他在《逻辑哲学论》当中给我们提供的关于语言限度的思想。</p><p>《逻辑哲学论》是维特根斯坦早期的一本代表作，也是他生前出版过的唯一的一本哲学著作。这本书虽然篇幅不长但意义非常重大，他在这本书里首先提出了关于哲学是一种对语言的批判的观点，即批判语言实际上是哲学的一个主要工作，甚至是哲学的全部工作。维特根斯坦认为，我们所有思想都是用语言表达的，因而我们即使是要考察思想，也只能通过语言来完成，在这个意义上，批判语言就是在批判思想。</p><p>根据维特根斯坦自己的论述，我将他整个前期哲学里面关于语言界限的观点分成三个步骤来加以论述。</p><p>第一个步骤，它认为我们所有的思想不过是由有意义的命题构成的，这些有意义的命题形成了我们的思想，而所有这些命题又构成了我们的语言，我们通过了解有意义的命题来了解我们的思想，也就是说我们通过这些构成了有意义命题这样的一些语言来了解我们的思想。由此，语言本身就变成思想的全部，所以语言是思想的全部，我们只有通过考察语言才能了解思想本身。维特根斯坦相信，当我们把语言理解成能够去加以考察和思想的一种内容的时候，我们其实就是在对语言和思想本身做一种批判的工作。这种批判某种意义上意味着，当我们批判思想的时候，实际上是在批判语言，那么反过来说，当我们考察语言的时候其实是在考察思想。在维特根斯坦看来，整个哲学的工作就是要通过对有意义的命题所构成的语言的分析，来理解它所表达的思想内容，这是维特根斯坦一个非常重要的观点。对语言的考察和批判，也构成了维特根斯坦整个前期哲学主要内容。</p><p>维特根斯坦在第二步说，我们在考察语言的时候会发现，语言本身其实是我们人类机体的一个组成部分，由此，语言本身很可能会成为我们了解思想的一个障碍，因为如果我们真的可以通过语言来了解思想，语言就应该是一个透明的，毫无障碍的途径，我们可以直接通过语言去了解思想，但是现实却并非如此。我们的日常语言其实经常会出现模糊、混乱、误用等等这些情况。那么，我们在考察语言的时候如何通过语言的考察接近思想？这本身变成一个困难的事情，因而这里面是否有一个悖论——由于我们考察语言是在考察思想，而语言会妨碍思想，所以我们实际上考察语言是达不到思想的。维特根斯坦要解决这个矛盾，如果来看待我们对思想的考察是通过对语言的考察来完成的？</p><p>维特根斯坦是怎么解决这个问题的呢？他在第一步说，所有考察语言的过程，其实就是考察思想的过程。第二步又说语言本身又会妨碍我们对思想考察，两者之间会产生一些矛盾。第三步维特根斯坦提出，我们并不是完全只是通过考察语言的表达方式去理解思想，我们能够考察的语言是很有限的，因而对这样的语言的考察，满足的是符合逻辑句法要求的语言，只有这样的语言能够给我们清楚的展现它的句子结构并且通过这样的句子结构向我们显示思想的时候，我们才能够说这样的语言考察是对思想的研究。所以，可以看得出来，维特根斯坦这里所说的考察语言本身，考察的并不是自然语言，而是逻辑语言。</p><p>这样就解释了为什么维特根斯坦会提出，对语言的批判其实就是对思想的批判，甚至说整个哲学就是对语言的批判这个观点。这个批判有两个含义，一个是要考察语言所能够发挥的作用，第二就是要考察语言的限度。语言的作用是我们通过语言能了解思想，它的限度是指我们只能通过考察那些符合逻辑要求的语言，我们才能够去达到思想。换句话说，思想是通过符合逻辑要求的语言加以表达的，这是维特根斯坦的一个观点，至少是在他前期哲学当中他是这么认为的。</p><p>这里就有一个麻烦，如果语言是通过逻辑的方式所构造出来才能表达思想的话，那些非逻辑的语言怎么办？维特根斯坦在他的这本书的最后一个命题里说，对于那些不可说的东西，也就是我们不能用清楚的逻辑语言去表达的思想，我们只能保持沉默。最后一个命题维特根斯坦试图给我们表达了一种神秘主义的思想，因为发现我们不能理解和表达的东西，似乎都是不能说的东西，既然他不能够说，按照维特根斯坦的观点它甚至连思想都不能够进行，这是维特根斯坦一个神秘和玄妙之处。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxnknb6vbj30qt0dhtbw.jpg" alt=""></p><p>很多人在讨论维特根斯坦的时候，认为维特根斯坦在这里给我们埋下了一个伏笔，这个伏笔是说一定有一些东西是不能够用逻辑的语言去表达的，而这些不能够用逻辑的语言来表达的东西，我们一定有别的方式可以得到。这个概念在维特根斯坦前期哲学中并没有明确的给出，它只提到一个词——显示，我们可以通过显示的方式给出那些不能够用语言所表达的思想内容。由于前期哲学他主要关心的是逻辑语言，他给出的关于世界的理解，基本上都是一个逻辑世界的概念，而不是一个我们现实的经验世界，因而就使得所有的逻辑语言只能够表达我们所构造出来那个逻辑世界的内容，而不能够去理解经验世界的内容。</p><p>如果退一步我们可以说维特根斯坦实际上隐含这样一个前提，凡是我们可以用逻辑的方式去表达的，我们在经验当中其实都是可以实现的。反过来说，凡是我们在经验中可以去感受和表达的东西，如果它有意义，也应当可以用逻辑的方式加以呈现，这是两个不同的含义。如果仔细体会一下，大概我们能够理解维特根斯坦这里说的一个深刻内涵——所有关于思想的内容，当我们不能够用逻辑的语言去表达的时候，我们到底在说什么？这是一个很重要的问题，维特根思言做到这一步的时候就停止了，他没有往下追问了，因为在他看来，他能够用逻辑语言表达的思想，基本上都在这本书里已经全部说的很清楚了，他认为没有必要说那些不能够用逻辑的语言去表达的思想，所有他说凡是我们不能用逻辑语言表达的思想我们只能够保持沉默。</p><p>维特根斯坦在这本书里面给我们提供了一个如何去理解哲学工作的方式。哲学工作的方式并不是在于我们能够用某一些哲学的概念和观念去提供给人们关于世界的理解，而是相反，所有这些概念跟观念其实都包含着一些能揭示我们对世界理解思想内容的一种陈述方式，这种陈述方式是逻辑的而非经验的，这是维特根斯坦特别强调的一点。所以他从罗素和弗雷格哪里得到了他们所谓的逻辑的观念，一切哲学只有按照这样的观念来做，我们才能真正在做哲学，除此之外都是无法在哲学中加以处理的，除此之外的东西是什么，就是那些不能够说只能被显示的东西。维特根斯坦1929年重返剑桥以后，实际上他的思想发生了一个很重要的变化，他开始重新思考他之前关于逻辑语言所表达的哲学观念这样一种思想是否恰当？大部分人都认为他放弃了之前的观念，而重新给出一种新的对哲学对语言的全新理解。但是，维特根斯坦其实并没有真的完全放弃他之前的那种观念，他只是转换了一个角度，他不再坚持原来的那种以逻辑的方式去观察世界，以逻辑的语言去表达我们思想这一部分的内容，这一部分的内容在他看来并没有错，它其实仍然可以保留在我们对逻辑语言的讨论当中，但是总有一些内容它是没有办法用逻辑的语言表达的，而对于那些不能够用逻辑语言表达的那些思想内容，我们还是不能用逻辑语言表达，但是他换了一种方式，他用语言游戏的方式来显示那些不能用逻辑的语言去加以表达的重要思想。他甚至认为这一部分的思想比用逻辑的语言表达的思想更为关键，在他的哲学体系中他认为这部分更为重要。</p><p>《逻辑哲学论》这本书他所表达的并不是他的全部思想，还有一部分是他这本书还有说出来的，而他认为没有说出来的那一部分还更加重要，这种说法隐含着他后期哲学里面所做工作的意义，为他后面的工作打下很好的基础。《逻辑哲学论》这本书讨论的是在逻辑的语言之内我们所能够从事的哲学工作和所能完成的事情，这一部分包括了他对思想概念和对于世界的理解。所以七个命题里面，前两个命题是关于语言和命题的讨论，最后一个命题关于不可说。</p><p>这七个命题听上去都很简单，但是事实上理解起来却非常困难。因为一开始我们接触第一个命题的时候就不知所云。第一个命题说，世界就是所发生的一切。很多人都在问是什么意思？如果按照逻辑的语言，这句话就是重言式，世界就是他所发生的一切，就相当于A等于A，但事实上不是，那么这句话的重要意义在什么地方？只有把这七个命题颠倒过来理解我们才能真正把握这句话的含义，把它的第一个命题当做他最后一个命题来理解，这个时候我们才能真正体会到维特根斯坦到底在说什么。因为他在最后一个命题里说，一切不可说的东西我们只能保持沉默，他的第二句话应该说，以下所说的东西都是可以说的。关于命题，关于思想乃至于最后关于世界这些说法，在他看来是可以说的，但是这个可说仅仅限制在逻辑语言范围之内，只有在逻辑的概念当中我们才能够去表达我们关于命题、关于思想以及关于世界的观点。后面的这六个命题，我们往回倒着读的话，首先就是关于命题的讨论，所有的命题都是由一些形式展现它的意义的，这是可以说的。</p><p>第二个命题是关于思想。所有的思想都是那些关于事态的命题，因为思想就是关于世界和事实的逻辑图像，也就意味着我们可以通过逻辑的方式来展现这个事实本身，这个展现的图形就是命题，因而，命题就像是一幅图画，它向我们展现了世界的真实情况，这个展现的内容就是意义，或者叫做思想。所以这就是维特根斯坦告诉我们的观点。由这个思想本身再进入世界，因而世界就是我们通过思想展现命题的方式来给我们提供关于在这个命题当中向我们描述的事实的构成形式。</p><p>因为世界是由事实构成的，所有的事实都表现在命题当中，所以我们所了解的世界的概念就是所有这些事实的总和，由此，世界就是它所发生的一切，那发生的一切就是事实的总和。所以我们就可以理解，为什么维特根斯坦一开始就说，世界就是它所发生的一切，而它所发生的一切，就是事实的总和。这几句话实际上是他最后要推出的一个结果，而不是他论述的前提。通过这样的解读，我们就可以理解在维特根斯坦前期哲学当中，他所谈到的界限或者限度这个说法，实际上表征的是他在逻辑语言范围内，所能够表达的一些关于思想跟世界的理解的内容，这是他在前期哲学当中一个重要的观点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《逻辑哲学论》是维特根斯坦早期的一本代表作，也是他生前出版过的唯一的一本哲学著作。他在这本书里提出了关于哲学是一种对语言的批判的观点，即批判语言实际上是哲学的一个主要工作，甚至是哲学的全部工作。维特根斯坦认为，我们所有思想都是用语言表达的，因而我们即使是要考察思想，也只能通过语言来完成，批判语言就是在批判思想。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="维特根斯坦" scheme="http://yoursite.com/tags/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6/"/>
    
      <category term="语言哲学" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E5%93%B2%E5%AD%A6/"/>
    
      <category term="逻辑哲学论" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%93%B2%E5%AD%A6%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书记（14）：康德《纯粹理性批判》句读（1）——  第一版序</title>
    <link href="http://yoursite.com/2018/02/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8814%EF%BC%89%EF%BC%9A%E5%BA%B7%E5%BE%B7%E3%80%8A%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4%E3%80%8B%E5%8F%A5%E8%AF%BB%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%20%20%E7%AC%AC%E4%B8%80%E7%89%88%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/02/10/读书记（14）：康德《纯粹理性批判》句读（1）——  第一版序/</id>
    <published>2018-02-10T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>康德《纯粹理性批判》第一版的序宏观地展示了康德在写作这部著作时所面对的问题，许诺了他将要达到的结果，制定了它在整个体系方面所依据的方法论准绳，以及该著作在他整个哲学构思中的位置。</p><a id="more"></a><blockquote><p>人类理性在其知识的某个门类里有一种特殊的命运，就是它为一些无法摆脱的问题所困扰；因为这些问题是由理性自身的本性向自己提出来的，但它又不能回答它们；因为这些问题超越了人类理性的一切能力。</p></blockquote><p>“某个门类”显然是指形而上学，即纯粹哲学的门类；而“特殊的命运”是指理性的那些最高问题所带来的命运，或者说是一种厄运。理性只有在形而上学中才给自己提出一些他自己不能解答的问题，这是理性的不幸，当然，也是理性的能耐，只有理性才能在他的最高形态中给自己提出超出自己能力的问题。理性的这种自然倾向或者说“本性”自有他的积极意义。不过康德在这里一开始强调的是这种命运的消极面，这也正是他进入问题的入口，即要寻找一条解决理性的困境之道。下面他就来阐明理性的这种困境和引起这种困境的原因。</p><blockquote><p>人类理性陷入这种困境并不是它的罪过。它是从在经验的进程中不可避免地要运用、同时又通过经验而证明其运用的有效性的那些基本原理出发的。</p></blockquote><p>理性的困境之所以是它的“命运”，就在于它并不是有意要陷入进去的，而是从一种正当的要求中不知不觉地陷入的，这种正当要求就是在那些在经验运用中已经证明了其必然性和有效性的理性原理的要求。理性的基本原理在经验中是有效的，这个谁也否认不了，所以这些原理也是不可取消的；但也正是这些原理，当我们立足于它们来追求更高的目标时，就必然把我们带入歧途。</p><blockquote><p>借助这些原理，它们（正如它的本性所将导致的那样）步步高升而达到更遥远的条件。</p></blockquote><p>理性的基本原理具有一种“本性”（或自然），就是要从有条件者去追溯他的条件，也即不但要知其然“而且要“知其所以然”。而这种追溯按照理性的本性来说是无穷尽的，他总是要从近到远，从已知的东西到未知的东西，从经验知识到使这种经验知识得以可能的条件，以及条件的条件。</p><blockquote><p>但由于它发现，以这种方式他的工作必将永远停留在未完成状态，因为这些问题永远无法解决，这样，他就看到自己不得不求助于一些原理，这些原理超越一切可能的经验运用，却仍然显得是那么不容怀疑，以至于就连普通的人类理性也对此表示同意。</p></blockquote><p>理性的这种步步高升的工作永无止境，因而将“永远停留在未完成状态”；但完全停下来又不符合理性的本性，所以理性就“不得不求助于一些原理”，这就是那些超越一切可能经验范围之上的形而上学原理。这里用“一切可能经验”，不只是现在的经验，而且包括一切过去、未来可能有的经验，就是不但从现实的范围上，而且从性质上、本质上是超经验的，也就是超时空的。形而上学原理离开了经验的领域，他们不是要运用于任何经验之上，而是仅仅按照纯粹理性本身的逻辑法则来运行；但由于这些逻辑法则是普通的人类理性中固有的法则，所以虽然没有经验的内容来充实它们，这些抽象的理性原理和法则却仍然能够得到一般人的同意，甚至在他们看来是无可置疑的。</p><blockquote><p>但这样一来，人类理性也就跌入到黑暗和矛盾冲突之中，他虽然由此可以得悉，必定在某个地方隐藏着某些根本性的错误，但它无法把它们揭示出来，因为它的使用的那些原理当超出了一切经验的界限时，就不再承认什么经验的试金石了。这些无休止的争吵的战场，就叫做形而上学。</p></blockquote><p>这就是人类理性的厄运的来由。也就是说，人类理性出于它的本性要求寻找一个超出一切经验之上的最高的无条件者，以便使自己不再停留于未完成状态；但一旦它超出了一切经验，它就失去了用经验来检验自己原理的真理性的试金石，从而变成了公说公有理，婆说婆有理，陷入到“无休止的争吵”和无法解决的“矛盾冲突”之中。这就使形而上学成为了一个这类矛盾冲突的战场。而且，虽然形而上学充斥着这类矛盾，人们却既没有办法解决矛盾，也不知道这类矛盾从何而来，因为他们原先正是为了避免矛盾、特别是为了避免经验的有限性和理性的无限追求之间的矛盾，才跳出一切经验的范围而寻求理性的逻辑一贯性的。但现在矛盾并不是出现在经验和理性之间，而是出现在通常认为不可能有矛盾的理想本身内部。康德在后面关于纯粹理性的“二律背反”的讨论中所揭示的正是这种情况，即两个完全相互矛盾的命题似乎都各自有自己充分的逻辑根据，谁也消灭不了谁。当然康德在这里已经预先暗示，所有这一切矛盾都是由于这些原理超越了一切经验的界限，从而抛弃了经验这个“试金石”。因为关于知识和真理的问题，虽然我们必须借助于理性的先天原理，但这些先天原理是否运用的正当，还是要凭借经验来检验，离开经验的领地来谈知识和真理是不可能的，无论我们把理性的功能发挥到何等地步，如果没有经验的内容，都免不了空谈，甚至免不了陷入自相矛盾的尴尬。由此我们可以看出，康德本身虽然出自大陆理性派传统，但却体现出力图调和经验论和唯理论的主导倾向。不过在康德的时代，还没有人能够清楚地认识到康德所指出的问题，人们已经意识到“必定在某个地方隐藏着某些根本性的错误”，因为那些矛盾冲突已经表面化和白热化了，但他们却“无法把它们揭示出来”，而是仍然固执着自己的片面观点，不是局限于经验论，并由此走向怀疑论，就是执着于唯理论的独断轮。这种分裂局面就使形而上学的名誉遭到了极大的损害。而这就是康德当时所面临的绝望处境。</p><blockquote><p>曾经有一个时候，形而上学称为一切科学的女王，并且，如果把愿望当做实际的话，那么她由于其对象的突出的重要性，倒是值得这一称号。</p></blockquote><p>在历史上，形而上学自亚里士多德倚赖就被称为“第一哲学”，它是“物理学之后”或物理学之上，是一切自然科学和数学的指导科学，所以它是“科学之科学”。把形而上学视为”一切科学的女王“，这是西方两千年来的传统。康德对这个传统是有保留地认同的，就是说，”如果把愿望当做实际的话“，康德认为形而上学的主观愿望和意图确实是指向理性最重要的事业的，只不过她实际上并没有能够做到她想要做的事情罢了。但康德并不因为形而上学未能达到其目的而完全抛弃她，而是致力于用新的途径恢复形而上学的权威地位，重建形而上学。所以他对形而上学今天的这种不景气的状况深表同情。</p><blockquote><p>今天，时代的时髦风气导致她明显地遭到完全的鄙视，这位受到驱赶和遗弃的老妇像赫卡柏一样抱怨：”不久前我还是万人之上，以我众多的女婿和孩子而当上女王————到如今我失去了祖国，孤苦伶仃被流放他乡。“</p></blockquote><p>赫卡柏是特洛伊城最繁荣时期的王后，特洛伊城被希腊人攻陷后，她失去了丈夫和所有的子女，本人变成了俘虏，传说最后被人们用石头砸死，又说她被众神变成了一条狗。她悲惨的遭遇引起了很多诗人的同情，包括欧里彼得斯、但丁和莎士比亚。康德在这里也是以同情的笔调引用她的命运来比喻形而上学的遭遇的。有种常见的说法，说康德摧毁了形而上学，抛弃了形而上学，这是不准确的。应当说他摧毁的是传统的形而上学，但却建立起了新的形而上学，使古老的形而上学焕发了青春。</p><blockquote><p>最初，形而上学的统治在独断论的管辖下是专制的。</p></blockquote><p>哲学上的”独断论“相当于政治上的”专制主义“，它不由分说，也不说明理由，而是以既定的意见和信念作为不言而喻的前提。在形而上学的王国利，长期以来都是独断论站统治地位，但由于这种专制统治必然要引起内部的分裂和外部的抗议，所以在近代它的地位就遭到了不可避免的动摇。</p><blockquote><p>不过，由于这种立法还带有古代野蛮的痕迹，所以它就因为内战而一步步沦为了完全的无政府状态，而怀疑论者类似于游牧民族，他们憎恨一切地面的牢固建筑，便时时来拆散市民的联盟。</p></blockquote><p>“古代野蛮的痕迹”指传统的非批判的粗糙信念；”内战“指独断论的内部分裂，如经验论和唯理论、唯物主义和唯心主义的分裂，其实各方都是独断的，都想实现自己的霸权。这就导致了”完全的无政府状态“，即公说公有理，婆说婆有理，没有一个公正的法庭来对各方的主张进行裁决，从而使各方都在打一场毫无结果的消耗战。但尽管如此，这些独断论毕竟在对真理的信念还是一致的，所以尽管处于无政府状态中，却还是处于共同的利益而建立起某种”市民的联盟“，以便个人经营自己的小地盘，井水不犯河水。但怀疑论者对于这种联盟则是一种更大的威胁，他们”类似于游牧民族“，扫荡一切地面建筑，解构一切固有的联系，如休谟的怀疑论就是无论经验论还是唯理论都不能接受的，它使一切认识论的形而上学探讨都失去了意义。</p><blockquote><p>但幸好他们只是少数人，所以他们不能阻止独断论者一再地试图把这种联盟重新建立起来，哪怕并不根据任何在他们中一致同意的计划。</p></blockquote><p>真正像休谟一样主张彻底的怀疑论的人毕竟只是少数，一般人认为他们只是走极端而已，并不认真对待他们提出的挑战。当时盛行的所谓”健全知性“的观点就是大多数哲学家所依赖的一种权宜之计，他们借此很简单地把休谟式的怀疑主义扫到一边，认为这是一种知性的病态。但是”健全知性“本身是一个模糊概念，究竟怎样才算健全，健全知性应该包含哪些要素，人们并没有明确的规定。所以通常人们只是利用这一概念的模糊性而建立起一种认识论上的”新的联盟“，也就是”可知论“的联盟，来共同对付休谟的不可知论。但其实在他们中并没有”一致同意的计划“，同样是主张健全知性，经验派的健全知性和理性派的健全知性却大不相同，他们的共同之处仅仅在于不走极端，以及为了捍卫科学的尊严和共同抵御怀疑论的进攻。</p><blockquote><p>在近代，虽然一度看来这一些争论似乎应当通过（由著名的洛克所提出的）人类知性的某种自然之学（Physiologie）来做一个了结，并对那些要求的合法性进行完全的裁决；</p></blockquote><p>洛克在《人类理解论》中对人类知性的方方面面进行了详尽的分析，这些分析都是把人类的知性当做一个自然对象来看待，因此康德把它不称之为形而上学或哲学，而称之为“自然之学”，也就是用物理学或自然科学的方式来研究人的认识的结构。在这方面，洛克可以说是做大了最大可能的完备和系统化，人们似乎可以认为他已经对人类认识能力的各种要素的作用的合法性做出了“完全的裁决”。</p><blockquote><p>但结果却是，尽管那位所谓的女王的出身是来自普通经验的贱民，然而，由于这一世系事实上是虚假地为她捏造出来的，而她还一味地坚持她的要求，这就使得一切又重新堕入那旧的、千疮百孔的独断论中去，并由此而陷入到人们想要使科学拜托出来的那种被蔑视的境地。</p></blockquote><p>洛克的哲学实际上还是经验论哲学，康德称之为“出身”于“普通经验的贱民”，并没有任何先天的高贵之处，按照康德的看法经验派必然要称为怀疑论；但是洛克依然主张这种经验知识具有形而上学的认识论意义，即能够认识事物本身，但这种要求实际上是经验派所不能提出来的，所以康德说这种形而上学的世系“是虚假地为他捏造出来的”。但洛克的这位女王仍然一味地提出这种认识事物本身的要求，这就使得洛克的哲学又重新堕入独断论中去了，也就是没有根据地认定自己的知识就是对自在之物本身的认识。而这种无根据也正是人们蔑视形而上学的根本症结，它使形而上学名誉扫地，得到了“伪科学”的恶名。</p><p>不过，康德如此批评洛克是有些不太公平的，因为在洛克的哲学中已经包含有后来由休谟发挥出来的不可知论因素了，他首先把我们从感官直接获得的感觉，如色、声、香、味等等，称之为事物的“第二性的质”，是由我们感官的性质所决定的，因而是主观的，只有像体积、形相、运动、数量等等才属于“第一性的质”，课件他并不完全相信我们的感觉经验，其次他认为即使第一性的质，也只是我们对于客观实在所知道的“名义本质”，而不是它们的“实在本质”，实体的实在本质我们是永远也不可能知道的。这就已经有不可知论的色彩了。这正是休谟后来提出怀疑论和不可知论的最初的思想来源。当然洛克的体系中是包含尖锐的矛盾的，他甚至不太关心使自己的这种矛盾调和起来，所以康德说他是独断论也没有错，只是不全面。</p><blockquote><p>今天，当一切道路都白费力气地尝试过了之后，在科学中占统治地位的是厌倦和彻底的冷淡态度，是混沌和黑夜之母，但毕竟也有这些科学临近改造和澄清的苗头，至少器=是其序幕，他们是用力用得完全不是地方而变得迷糊、混乱和不适用的。</p></blockquote><p>康德的时代哲学界就是这样一片混乱的状态，但也不是毫无希望，而是在这种混乱中包含着“这些科学临近改造和澄清的苗头”，这是康德独具慧眼看出来的。“这些科学指形而上学的各种形态，唯理论和经验论，独断论和怀疑论，康德自认为负有历史使命来改造和澄清它们。但他并不想把它们全盘抛弃，而只是想把它们做一个调和，吸取它们各自的长处，批判它们的缺点。他承认，这些学说都有其合理之处，只是“用力用得完全不是地方”，从而把问题搞乱了。但只要对他们所展示出来的问题进行一番彻底的清理，康德认为将拉开真正科学的形而上学的序幕。</p><p>因此康德对当代哲学中的无所作为的态度是很瞧不起的，他说：</p><blockquote><p>因此，想要对这样一些研究故意装作无所谓的态度是徒劳的，这种研究的对象对于人类的本性来说是不可能是无所谓的。</p></blockquote><p>形而上学在当代出现了问题，但是这些问题是非妥善解决不可的，因为这是涉及人类理性的生死存亡的大问题。但当时哲学界人们都在装聋作哑，用一些模糊概念来回避和打发那些棘手的问题，特别是对于休谟所提出的挑战装作视而不见，从而使科学的基础面临严重的危机。</p><blockquote><p>上述那些冷淡主义者也是这样，不论他们如何想通过改换学院语言而以大众化的口吻来伪装自己，只要他们在任何地方想到某物，他们就不可避免地退回到他们曾装作极为鄙视的那些形而上学主张上去。</p></blockquote><p>“上述那些冷淡主义者”，指上一句话中提到的在科学中“占统治的”冷淡态度，也就是所谓“拒斥形而上学”的态度，持有这种态度的人干脆放弃一切形而上学的努力，而对任何形而上学加以拒斥，甚至在语言上也加以改换，不用形而上学的学院语言，而尽量采取大众化的语言。这种态度在康德的时代还是刚刚萌芽，但在20世纪以来则蔚然成风，一切实用主义和实证主义以及语言分析哲学都在标榜这种态度。但康德指出，这些人拒斥形而上学是虚伪的，实际上他们暗中所遵循的是最坏的形而上学，这与恩格斯的见解如出一辙。形而上学，或者说哲学，是人类逃脱不掉的命运。</p><blockquote><p>然而，这种在一切科学繁盛的中心发生并恰好针对这这些科学——这些科学的知识一当它能够被拥有，人们就无论如何也不会作出丝毫放弃——的无所谓态度，毕竟是一种值得注意和深思的现象。这种态度显然不是思想轻浮的产物，而是这个时代的成熟的判断力的结果。</p></blockquote><p>康德尽管对当时哲学家们“装作无所谓的态度”不满，但仍然从这种态度中看出现代哲学思想的“成熟”因为这种态度只不过是当时人们为了维护科学的尊严而临时借用的一块挡箭牌，他们显然并不为休谟所提出的怪论而受到惊扰，而是对于已经到手的科学知识怀有一种不可动摇的信念。他们之所以装出无所谓的态度，只不过是他们还没有找到可以有力地反驳对方的方法而已，但他们绝不轻易为对方的能言善辩所迷惑、所打动，这一点确实康德十分赞赏的，也是他有信心让自己的批判获得广大科学界人士赞同的理由。他相信，在“一切科学繁盛的中心”所发生的这种“无所谓态度”，其实是一种谨慎的态度，他不是“思想轻浮的产物”，而是人类理性已经成熟到可以面对任何针对科学的挑战的表现，在这样一个基础上，康德批判才能够奏效。</p><p>在这里，康德有一个注释：</p><blockquote><p>人们时常听到抱怨当代思维方式的肤浅和彻底科学研究的沦落。但我看不出那些根基牢固的科学如数学和自然学说等等有丝毫值得如此责备的地方，相反，他们维护了彻底性的这种古老的荣誉，而在物理中甚至超过以往。</p></blockquote><p>显然，康德心目中的数学和自然科学（物理学）的地位是神圣不可侵犯的，他熟悉当时的各门科学，并且自己就是一位杰出的科学家。数学和自然科学是他的批判哲学一切理论的基础，他对科学的信念从未动摇过。所以，他的批判哲学并不是批判这些科学，而是对这些科学的哲学解释。当休谟对科学的普遍必然性提出怀疑的时候，康德的反驳并不在于科学的普遍必然性，在它看来科学的普遍必然性是一个不容否认的事实。他要证明的是这种普遍必然性是从哪里来的，它的根据和条件是什么。所以在某种意义上说，康德其实并没有正面反驳休谟，或者说，一个彻底的休谟主义者、怀疑论者是“驳不倒的”。一个人当他连科学都不相信了，你还能向他证明什么呢？你的一切证明不都是科学吗？所以康德只是在大家公认的科学事实的基础上提出自己的一整套原理，使人们看到这些科学事实是有自己牢固的根基的，这样来维护科学的权威。在它看来，科学精神最可宝贵的就是科学中的彻底性，自从古希腊欧几里得几何学产生依赖，这种科学精神就有了自己的典范。当然，这种彻底性一直贯穿到今天，他的集中体现者是大陆理性派哲学，康德出身于理性派，他对这彻底精神比任何人都更执着。它在牛顿物理学中看到了这种彻底性的当代楷模，这种物理学以极少数的原理贯通天上地下，万事万物，其规模和深刻性显然不是任何古代的科学思想所可以比拟的，康德受这种彻底精神的熏陶，力图将它引进到形而上学中来：</p><blockquote><p>而现在，正是同一个彻底精神也将在另一些知识类型中表明其作用，只要我们首先留意对他们的原则加以校正。在缺乏这种校正的情况下，冷淡、怀疑，最后是严格的批判，反倒是彻底的思维方式的证据。</p></blockquote><p> “另一些知识类型”也就是指哲学、形而上学的知识类型，康德的批判哲学正是要使形而上学本身具有如同牛顿物理学那样的真正的彻底性。但前提是，必须“首先留意对他们的原则加以校正”。以往形而上学的原则本身就是建立在一个错误的基础之上的，如果这个错误基础得不到校正，那么越是彻底，这种体系就越是错的远，正所谓差之毫厘谬以千里。例如休谟的哲学够彻底了，它彻底到几乎没人能够挑出它的逻辑上的毛病，但正因为如此，他的哲学就成了一种无人能够接受的怪论。这种校正显然是康德准备留给自己来做的一件重要的工作。不过，即使这种校正还没有完成，康德已经在上述的冷淡态度和怀疑中，以及在他自己首先提出的“批判”中，看到了“彻底思维方式的证据”。冷淡态度其实也是一种不信任的态度，就是说，当人们还没有被彻底说服的时候，正是出于对彻底性的要求，反而使他们保持一种冷静，对一切奇思怪想姑妄听之。怀疑态度也是这样，就是说，你如果拿不出确凿的证据使我彻头彻尾的信服，那我就宁可停留在怀疑之中。康德的批判则是更进一步，力图对那些貌似有理的理论体系之所以可能的前提进行考察，对凡事不能彻底自圆其说的理论呢都加以清除，以便在真正经得起批判的基地上重建形而上学。其实批判本身已经是校正工作了，它是校正的第一步，但校正的完成则有待于康德自己的形而上学体系的建立。无论如何，所有这些倾向在康德看来都表明一种时代风气，即对彻底的思维方式的严格要求，他自己的批判哲学在这样一种氛围中正是基础体现了这个时代的时代精神的需要。</p><p>这就是康德的下面这句名言的意义：</p><blockquote><p>我们的时代是真正批判的时代，一切都必须经受批判。</p></blockquote><p>康德在他的如此晦涩艰深的哲学研究中竟然体会到了时代精神的内在的脉搏，或者说，真正深刻的哲学都是时代精神的反映，康德是有这种自觉意识的，这也可以说他殚精竭虑、穷其一生来进行哲学批判的内部热情和动力。</p><p>下面他点名了两个在他看来最需要批判的现实邻域：</p><blockquote><p>通常，宗教凭借其神圣性，而立法凭借其权威，想要逃脱批判。但这样一来，他们就激起了对自身的正当的怀疑，并无法要求别人不加伪饰的敬重，理性只会把这种敬重给予那经受得住他的自由而公开的检验的事物。</p></blockquote><p>一般人很难由康德的《纯粹理性批判》联想到宗教和立法这样一些现实生活的内容，虽然他在书中又对上帝存在的证明的各种批判，也经常引用法律方面的例子来说明概念的关系，但是这部著作的主题只是为科学知识和认识论提供先天根据，而并没有明确表示出某种激进的政治倾向。然而，正是这样的理性批判，对于当时统治整个社会的保守势力具有最强烈的摧毁作用。因为通过批判，康德所建立起来的是一个至高无上的理性法庭，凡是不符合理性的要求的事物都将被扫进历史地垃圾箱。从这里我们可以看到康的哲学的启蒙意义，以及对当时德国现实生活的冲击的力度。康德之所以把这样一段重要的话放在不起眼的注释中，大约连他自己都感到了他的批判的锋芒和威力，为了稳妥起见，有必要藏起来一些。</p><p>下面的正文恰好也表达了类似的意思：</p><blockquote><p>这个时代不能够再被虚假的知识拖后腿了，它是对理性的吁求，要求他重新接过他的一切任务中最困难的那件任务，即自我认识的任务，</p></blockquote><p>时代要求理性作出它的“自我认识”，即对理性自身进行再次的考查。自文艺复兴以来，人们已经意识到自己的理性了，莱布尼茨—沃尔夫派的启蒙理性也已经把理性摆到了一个“法庭”的位置上；但康德提出的是一个更高的要求，即理性应该对自己起诉，对自己以往所获取的那些“虚假的知识”起诉，以便对自己重新加以检查。所以康德的纯粹理性批判其实是理性的自我批判，是更高层次的理性，而这也是理性的“一切任务中最困难的那件任务”。所以康德的理性法庭是为理性自己而开的。</p><p>这就是：</p><blockquote><p>委任一个法庭，这个法庭能够受理理性的合法性保障的请示，相反，对于一切无根据的非分要求，不是通过强制命令，而是能够按照理性的永恒不变的法则来处理，而这个法庭不是别的，正是纯粹理性批判。</p></blockquote><p>理性要在这个法庭面前为自己的合法性取得保障，也就是排除一切由于理性的滥用而提出的“非分要求”，如何排除？仍然是“按照理性的永恒不变的法则”来排除。而这个法庭就是他的纯粹理性批判。这就开始把话题引入到正题里面来了。</p><p>以上就是康德对于他在他的时代所面临的问题的一个交代和概括，主要是当时的哲学所遇到的难题以及由此反映出来的时代精神。下面开始介绍这本书的主题内容，也就是他将要在书中所阐明和解决的问题。</p><blockquote><p>但我所理解的纯粹理性批判，不是对这些书或体系的批判，而是对一般理性能力的批判，是对纯粹理性可以独立于任何经验而追求的一切知识来说的，因而是对一般形而上学的可能性或不可能性进行裁决，对他的根源、范围和界限加以规定，但这一切都是出自原则。</p></blockquote><p>康德的纯粹理性批判并不是着眼于对上面所触及到的现有的那些哲学著作或哲学流派的批判，他当然要涉及这些哲学流派，而且甚至处处都在和这些哲学家对话，但它的目的并不是具体针对某个人、某本书，而是更高也更加一般的主题。康德认为他是要对“一般理性能力”进行批判，“是就纯粹理性可以独立于任何经验而追求的一切只是来说的”。通常的批判都是针对具体某本书、某个人、某种思想或某个被宣称的知识；单抗的目标超越于这一切之上，他是要一劳永逸地彻底解决问题，即针对理性能力本身，看它独立于经验而有可能追求到一些什么样的知识。通过这种批判，我们就能够对那个最高的形而上学问题，即“一般形而上学的可能性或不可能性”的问题作出裁决。这就比通常形而上学所探讨的那些内容，如形而上学的基本概念是什么，他们的关系和结构如何，他们与现实的各门科学怎样发生联系等等，要更高一层，因为它涉及任何形而上学是否以及如何可能的问题。如果形而上学根本就不可能，那么所有关于形而上学的理论再好也都是虚假的。而如果形而上学是可能的，那么它又是如何可能的？它的“根源、范围和界限”如何？这同样也是先于一切其他形而上学问题的元问题。总之，康德就是要在进行形而上学的探讨和具体规定之前，先将我们人类理性建立形而上学的能力和可能性搞清楚，或者说，要在认识之前预先清点一下我们用来认识的工具，检查一下这些工具的作用和效能，以免到头来力不从心。但康德强调“这一切都是出自原则”，也就是出自理性本身。康德在后面多次提到，理性归根到底是一种“原则的能力”。通常“原则”比“原理”和“法则”要高，比“规则”更高，是康德认为最高层次的规律。当然这些术语有时也不太严格，康德经常违反自己的规定，但大致上可以这样区分。总而言之，康德在这里想表达的是他的理性法庭是理性对理性本身的审判，最终还是要遵守理性的原则。后来黑格尔批判康德说，他就像一个游泳教练，告诫自己的学生说“未学会游泳之前切勿下水”。康德要在认识之前先对认识的工具进行检验，也就是进行认识，这本身是一个悖论。因为当你检查理性工具时，你已经运用了理性，而你所运用的这个理性必然又是没有经过检查的，这就会导致无穷后退，而一步也迈不开。不过，康德把理性提升到自我意识，这毕竟是他的一大功劳，从此理性就在通常的逻辑理性之上，又增加了一个“批判理性”，即理性的自我批判，这就为后来黑格尔的理性的自我否定运动、即“否定性的辨证论”提供了启示。黑格尔的自我否定就不再是一次性的从一个不可否定的前提出发，而是表现为一连串的否定运动，从中生发出一系列的范畴。在康德这里还未达到这种理解，理性的自我否定有一个上限，这就是理性的最高“原则”，其他的都是从那个原则降下来的。但这在当时至少也是一个很大的推进，是从来没有人做过的工作。</p><p>所以康德接下来说：</p><blockquote><p>现在我走上了这条唯一留下来尚未勘察的道路，我自认为在这条道路上，我找到了迄今使理性在摆脱经验的运用中与自身想分裂的一切谬误得以消除的办法。</p></blockquote><p>经验论和唯理论都不可能摆脱理性的纯粹运用时产生的自身分裂，例如二律背反的分裂，因为在涉及理性脱离经验的运用时，他们都从不同的方向不由自主地陷入了独断论；而怀疑论则只不过是发现了这种分裂，但却毫无批判地认可了这种分裂，从而停留于怀疑。迄今为止，还没有人从批判角度来对待理性的这种自我分裂，即从理性本身去寻找分裂的原因，检查理性运用的范围，它的那些原则的根源，以及他的限度。在康德看来，我们只要找到了理性在理论的运用中的范围和界限，并将它的最高原则作出定位，分清理论的理性和实践的理性的界限，分清可以认识的现象和不可认识的自在之物，理性的这些分裂自然就会烟消云散。</p><blockquote><p>对于理性的这些问题，我不是例如通过借口人类理性的无能而加以回避，而是根据原则将它们完备地详细开列出来，并在把理性对它自己的误解之点揭示出来之后，对这些问题进行使理性完全满意的解决。</p></blockquote><p>在康德看来，休谟式的怀疑本质上是对人类理性的无能的承认，他提出了问题却不能解决问题，而只是回避了问题。康德却试图“根据原则将他们完备地详细开列出来”搞清他们的来龙去脉，然后做出“使理性完全满意的解决”。显然，在他看来休谟之所以不能解决这些问题是由于他的方法不对，不是理性的系统的方法，只是凭借机智而纯粹经验性地发现问题，所以他不能看出问题的症结所在。康德却根据这些问题的性质而在逻辑上对他们进行了条分缕析的清理，只有这样，理性的自相冲突的根源才会显露出来，而抓住这个最终的源头，这些矛盾才有可能迎刃而解。也只有这样，这种解决问题的方式才是理性的，才是使人的理性完全信服的。</p><blockquote><p>虽然对那些问题得出的回答根本不是像独断论的狂人的追求者们所可能期望的那样；因为这些人除了我所不在行的魔法的力量之外，没有什么能够使他们满足。</p></blockquote><p>独断论者在这里被康德等同于魔法，是因为他们试图不根据任何确凿的出自原则的理由就断言事物出身的状况，并对理性所产生的各种幻想信以为真。在他们看来，理性的冲突如果要得到满意的解决，就必须提供出某种非理性的理由，不论是莱布尼茨的“前定和谐”，还是贝克莱德“上帝的知觉”都可以凭空想象出来，而康德则认为自己在这方面不在行，实际上带有讽刺意味。</p><blockquote><p>然而，这倒也并非我们理性的自然使命原来的意图；哲学的职责曾经是：消除由误解而产生的幻觉，哪怕与此同时还要去掉很多倍高度评价和爱好的妄想。</p></blockquote><p>就是说，独断论的那种狂热追求并不符合理性的“自然使命”，因为“哲学的职责”并不是去猜测和强求那种不可能获得的知识，而是要消除“由误解而产生的幻觉”，也就是一种否定性的职责。知识近代哲学在他的发端出一开始就显示出来的理性的作用，例如培根的“四假象”说，就是要把充斥在人们思想中的各种假象清除掉；笛卡尔的“怀疑一切”原则也是如此，凡是不符合理性或与理性的原则有出入的东西都一概被置于怀疑之中。在这样做时，要坚持一种彻底性，“哪怕与此同时还要去掉很多被高度评价和爱好的妄想”，这一点前人已经做出了榜样。在康德看来，理性是一切真理的标准，它的作用首先是批判，是否定那些本该否定的东西，不论他们戴着怎样的权威的面具，或是被众多的追求者所看重。单抗的自认为他在这方面比他的先驱者更上一层楼。</p><blockquote><p>在这件工作中我把很大的关注放在了详尽性方面，我敢说，没有一个形而上学的问题在这里没有得到解决，或至少为其解决提供了钥匙。</p></blockquote><p>也就是说，康德在清除哲学中流行的误解和幻觉的时候，首先在“详尽性”方面超过了前人。这种详尽性，康德理解为系统性，而不是细节上的繁琐性。所谓“没有一个形而上学的问题在这里没有得到解决”，就是说无一遗漏地把所有的形而上学问题都系统考察了一遍并做出了妥善的解决，”或至少为其解决提供了钥匙“。例如传统形而上学的三大问题，灵魂宇宙和上帝的问题，康德在这里都一一作了处理，揭示了它们的谬误和幻相，排除了由此形成的一系列伪科学；但同时又为它们的那些命题的真实含义留下了地盘，即认为它们作为实践理性的一些悬设还是可以接受的。当然在《纯粹理性批判》这部著作里作者讲的形而上学主要还是自然形而上学，或者说理论理性中的形而上学，而不是道德形而上学，道德形而上学是有待于康德自己去建立的，它有关实践理性。所以，，在理论理性中没有得到最终解决的形而上学问题，康德是把它们放到实践理性中去解决的，而在《纯粹理性批判》的结尾部分则对此作了明确的提示。所以康德可以大胆地说，所有的形而上学问题在他这里都得到了解决，因为他不是凭借一些偶然的经验考察或机智的联想，而是按照严格理性的原则来梳理和安排这些问题，使他们处在一个必然的关联之中，所以才能做到无一遗漏。</p><blockquote><p>事实上，就连纯粹理性也是一个如此完善的统一体：只要他的原则哪怕在它凭自己的本性所提出的一切问题中的一个问题上是不充分的，人们就只好将这个原则抛弃，因为这样一来它也就无法胜任以完全的可靠性来处理任何其他问题了。</p></blockquote><p>这表明康德的方法是一种严格系统化的方法，它不是到处去搜集问题，而是凭借纯粹理性的原则去推导问题，他相信由此所推导出来的问题系统不可能是不完备的，而真正的理性原则应该是放之四海而皆准的，只要有一个例证不能为这种原则所证明，这个原则就应当弃置不用。这正是理性派哲学典型的方法，罗素曾在他的《西方哲学史》中称之为”倒金字塔“的体系，这种体系只要抽掉了底下的一块砖，整座建筑就会垮下来。当然罗素所推崇的经验派的”金字塔“形的体系，即如果你从它底下抽掉一块甚至多块砖，对于整个体系并没有多大妨碍。但这种”金字塔“形的体系在康德看来根本算不上什么体系，而只是一些临时应付的偶然观点的堆积，他的解释力是有限的、就事论事的，揭示不了任何普遍的法则，当然也就不存在什么“完全的可靠性”了。康德所追求的则是一种规律性的原则，它能够以一统多，没有例外，只有这样的原则才能获得必然的可靠的知识，使问题得到彻底的解决。可见，他对他的方法的这种自信是建立在一个理性主义者对理性原则的普遍性的信念之上的，他认为它的优势就在于在形而上学这个复杂的领域内他的方法具有完全的彻底性，能够全面颠覆以往一切形而上学，而从一个崭新的基地上重建新的大厦。他对自己体系的这种划时代的重大意义是有充分的自觉和自豪的。这一段后面的这两句话实际上已经从《纯粹理性批判》一书的主题转入到写这本书的方法了。但在对他的方法展开全面阐述之前，他马上想到他对自己的方法的这种自信所可能引来的异议，于是在下面一段中先作了一番澄清。</p><blockquote><p>说到这里，我相信可以在读者脸上看出对于表面上似乎如此大言不惭和却不谦虚的要求报以含有轻蔑的不满神态，然而，这些要求比起那些伪称要在其最普通的纲领中，证明例如灵魂的单纯本质或最初的世界开端的必然性的任何一个作者的要求来，还算温和无比的。</p></blockquote><p>康德似乎担心自己的这种自信是否会给人带来反感，但他马上找到了辩护的理由，即他的这种自信比那些说大话的独断论者其实要谦虚得多。那些人声称他们提出的纲领是“最普通”的，因而看起来“很谦虚”，但却许诺要在关于灵魂和世界整体的方面提供出纯粹理性的知识，实际上狂妄的很。而康德的目标却只不过是指出和严格遵守人类理性的限度，对于不可知的东西就应该保持谦虚的态度。所以他说：</p><p>所以他说：</p><blockquote><p>因为这种作者自告奋勇地想要把人类知识扩展到可能经验的一切界限之外，对此我谦卑地承认：这种事完全超出了我的能力。</p></blockquote><p>康德自认为自己的方法是彻底的、无所不包的，只是由于他对人类的认识能力作出了严格的限制，他只是在认识能力本身的合法范围内，即“可能经验范围内”使理性的运用具有了彻底性，所以看起来好像很骄傲，其实是谦虚的，而独断论者却凭借一般常识就把理性的能力提高到与之不相称的地步。这里的“可能经验”一语是一个很有用的概念，后面还要经常遇到的，说明康德看重经验，反对理性脱离经验，但并不是狭隘的经验论，他指的经验是在先天条件下可以预见到的经验，不仅是眼前所见的经验，而且包括一切以往和将来的经验。不过即使有先天的条件，可能经验毕竟是经验，它对知识的范围做了确切的限定，康德承认，到可能经验的一切界限之外去寻求知识这件事“完全超出了我的能力”。</p><blockquote><p>相反，我只想和理性本身及其纯粹思维打交道，对他的详尽的知识我不可以远离我自己去寻找，因为在我我自身中发现了它们，</p></blockquote><p>康德反对独断论者把知识扩展到超出可能经验之外的理由正在于它们没有检查理性本身的能力，而是借助于某种高于人类理性的力量，相反，康德却“只想和理性本身及其纯粹思维打交道”，首先把我自己的思维结构搞清楚，在我自身内部探求纯粹理性本身的“详尽的知识”。只有这样，我们才能明智地恪守自己的本分，不去强求那些明知超出了自身能力的所谓知识。</p><blockquote><p>在这方面我甚至已经有普通逻辑作为例子，即逻辑的一切简单活动都可以完备而系统地列举出来；</p></blockquote><p>纯粹理性的内部结构首先体现在普通逻辑也就是传统的形式逻辑中，形式逻辑的知识有一个最突出的特点，就是它的那些基本原则自从亚里士多德以来就已经完备的形成了系统，两千年间几乎没有大的变化。在康德心目中，正如一切理性派哲学家一样，形式逻辑是任何严格科学的楷模，因为它最先全面地体现出人类理性思维的“详尽性”，也就是完备性、系统性，这种系统性是不必超出理性能力的界限之外而在自身之内就可以完成的。当然形式逻辑在康德看来也并不代表一切，而只是人类理性思维的形式规律，它的详尽性和系统性也只限于这个层面，康德只是“作为例子”而将它提出来，所以康德接下来补充说：</p><blockquote><p>只是这里有一个问题，即如果我抽掉经验的一切素材和成分，我凭借逻辑可以大致希望有多大的收获。</p></blockquote><p>也就是说，形式逻辑不管经验的内容，而只着眼于思维的形式，这些形式尽管可以详尽而系统地列举出来，但它们毕竟只是形式的知识，还不是我们真正想要达到的现实的知识。以往的逻辑学家们一个最大的误解就在于，他们以为单凭逻辑上的形式推理就可以获得一些现实的客观知识，这就导致了理性派的独断论的狂妄。所以，形式逻辑固然值得推崇，但是如果不考虑经验直观的内容，这些逻辑形式并不能给我们带来更大的收获，更不用说给我们带来真理性的知识了。所谓真理不仅是一种正确的思维方式，而且是思维和对象的符合，这就需要考虑经验的东西，所以在人类理性本身的系统知识中，除了形式逻辑之外应该有一种指导我们如何去获取经验知识的纯粹理性原理，这就是康德在本书中提出的所谓“先验逻辑”。当然先验逻辑也是以形式逻辑为楷模并从形式逻辑中引导出来的，这是后话了。</p><p>上面一段是插入进来的，下面才开始全面归纳他自己在本书中所采用的方法。 </p><blockquote><p>在达到每个目的方面注重完整性的同时，也注重在达到一切目的方面的详尽性，这些并非任意采取的决心，而是知识本身作为我们批判研究的质料的本性向我们提出的任务。</p></blockquote><p>注意，这里提出了两个概念，一个是“完整性”，一个是上面说的“详尽性”。</p><p>完整性是针对“每个目的”本身而言的，详尽性是针对“一切目的”而言的。其实，就研究的对象或“质料”而言，这里的完整性和详尽性都是一个意思，就是要考虑得周全和完备。它们都属于“量”的范畴，一个是内包的量，一个是外延的量。而“内包的量”在康德后面的知性原理体系中有时候又被归于质的原理，即“知觉的预测”之下。所以这两个要求实际上分别属于质的方面和量的方面的要求，它是由康德后面范畴表上的质的范畴和量的范畴所决定的。这就可以理解，为什么康德在这里说这两个要求并不是“任意采取的决心，而是知识本身作为我们批判研究的质料的本性向我们提出的任务”，他们实际上是康德自认为放之四海而皆准的“范畴表”对于任何一个研究对象在质料上提出的要求。康德的范畴表有四大类范畴，即量、质、关系和模态，他把量和质称之为“数学性的原理”，把关系和模态称之为“力学性的原理”，有时又把前者称之为一个对象的“构成性原理”，而把关系和模态称之为“调节性原理”。而在这里，他把量和质的要求归于研究对象的质料，下面则把模态的要求归于对研究对象的形式的要求。总之，康德对于研究方法的选择不是随意的，而是根据研究对象的情况而定的；而研究对象又被纳入到他自己的那一套逻辑框架之中。所以他的方法本身是有方法的、系统化的，这是与以前一切哲学家都不大相同的地方。</p><p>下面是他对于形式方面所提出的要求</p><blockquote><p>再就是确定性和明晰性这两项，这涉及这门研究的形式，它们必须被看做人们对一个敢于做这样一种难以把握的工作的作者可以正当提出的基本要求。</p></blockquote><p>根据康德下面的具体解释，“确定性”属于模态范畴是没有问题的，但是“明晰性”属于什么范畴，这个下面再谈。前面两个要求都是涉及研究对象本身的构成的，即加入你连对研究对象都没有一个周全的概览，或者有些问题和目标在你的视野之外的话，那当然就不可能得出经得起推敲和质疑的正确结论了；但是光有了全景式的视野，还不足以使你的结论达到确定性和清晰性。所以后面这两种方法更具有方法论的形式法则的意义，康德指出他们“涉及到这门研究的形式”，以与上面讲的这门研究的“质料”相区别。应该说，确定性和明晰性是对作者提出了更高的要求，康德说它们“必须别看做人们对一个敢于做这样一种难以把握的工作的作者可以正当提出的基本要求”，虽然是基本要求，但是针对这样一种难以把握的工作所提出来的，而不是对一般研究提出来的；而从这两个要求的性质来看，它们不仅牵涉到研究对象的完备性，而且已经牵涉到研究对象本身的真理性了。所以康德对他们特别重视，花了更大的篇幅来谈他们。先谈确定性。</p><blockquote><p>谈到确定性，那么我们曾经对我自己作过一项决定：在这类的考察中不允许任何方式的意见，一切在其中只是被视为类似于假设的东西都将是禁品，即使以最低的价格也不得出售，而必须一经发现便予以封存。</p></blockquote><p>这里和“确定性”相对立的是“意见”，而在西方传统哲学中，与“意见”相对的正好是“真理”，所以他这里的“确定性”也相当于“真理性”。意见总是动摇的，真理则是确定的，这是柏拉图以来的理性派的观点。康德的这项“决定”显然是由他所出身的大陆理性派哲学所带来的，在他看来意见只是一种“被视为类似于假设的东西”，在这样的一种严格的学术研究中是必须禁止的。当然，康德自己在本书中也作了一些假设，包括纯粹实践理性的“悬设”；但他强调他的这些假设完全是建立在确定性的原理上的。他在后面的“先验方法论”部分甚至专门辟出一节来谈“纯粹理性在假设上的训练”，他在那里说：“如果想象力不应当是狂热，而应当是在理性的严格监视下的构想的话，那么就总是必须预先有某种东西是完全确定的，而不是虚构出来的或是单纯的意见，这种东西就是对象本身的可能性。这样一来就可以允许人们为了对象本身的现实性而最后求助于意见，但这种意见为了不至于是无根据的，就必须与作为解释根据的现实地给予的、因而是确定了的东西连结起来，于是这种意见就叫做假设。”并且他把这种假设的作用限定为“在纯粹理性领域内只容许作为作战武器，不是为了在这上面建立一种权利，而只是为了捍卫这种权利”。纯粹理性的权利已经由确定性建立起来了，才有可能用假设来捍卫它，来对付那些同样只是一些假设的对方观点的攻击。所以作为这项研究本身的任务只能是寻求确定性。而这种确定性在康德看来只能够通过先天性来保证：</p><blockquote><p>因为每一种据认为先天地确定的知识本身都预示着它要被看做是绝对必然的，而一切纯粹先天知识的规定则更进一步，它应该是一切无可争辩（哲学上）确定性的准绳、因而甚至是范本。</p></blockquote><p>先天确定的知识的性质和意见是根本不同的，它应当是“绝对必然的”，而不是偶然的、可以这样也可以那样的。为什么这里说“据认为”先天确定的知识？这里面包含着没有说出来的意思，即你认为是先天确定的，而实际上是不是这样还不一定。康德在后面曾提到一种先天必然性，例如一个人挖一栋房子的基脚，他完全可以预见到这样挖下去房子一定会倒塌，这种知识就被认为是先天确定的，而实际上它是由以往的其他经验所证实了的，所以归根结底还是后天经验的。但无论如何，凡是被认为先天确定的知识都是“预示着它要被看做是绝对必然的”，这一点却是无可怀疑的，至少你心目中是这样预计的。所以接下里康德就讲：“而一切纯粹先天知识的规定则更进一步”，所谓“纯粹先天知识”和“据认为先天地确定的知识”就不同了，后者是可以争辩和讨论的，即这种知识究竟是不是先天的还未定；它也许在这个场合下是先天的，因为房子还未倒，你已经预见到了；但它掺杂任何经验成分的知识，就比那种不纯粹的先天知识更进一步了。在什么方面进一步了呢？“它应当是一切无可争辩的（哲学上）确定的准绳，因而甚至是范本”。就是说，在这里这种确定性在没有什么可争论的了，而且不但是无可争辩的确定性，还是这种确定性的“准绳”和“范本”，也就是最高确定性，衡量一切确定性的确定性。所以这种最高确定性就是“哲学上的”确定性，它是康德在这里所努力追求的。</p><blockquote><p>我在这里自告奋勇做的这件事在这一点上是否做到了，这完全要留给读者来判断，因为对于作者来说应做的只是提供根据，却不是判断这些根据在法官那里得出的结果。</p></blockquote><p>这里康德表示了一点谦虚，当然实际上他是很自信的，他要由读者来判断自己的成绩正表明他的自信，即他认为任何一个有理性的人都能够通过自己的理性判断而对他所达到的确定性的知识深信不疑。</p><blockquote><p>但为了不至于有什么东西不负责任地削弱了这些根据，所以倒是可以容许作者自己对那些容易引起误解的地方，即使它们知识涉及附带的目的，也加以注解，以便及时地防止在主要目的方面读者在其判断的这一点上哪怕只有丝毫的怀疑所可能产生的影响。</p></blockquote><p>这里的“但”说明，虽然康德表示了自己的自信，但是他仍然担心读者会在某些地方产生误解，认为他并没有做到真正的确定性，而是自己引入了某些“意见”或“类似于假设的东西”。为此他需要对那些容易引起误会的地方加以解释，这些地方主要是那些“涉及附带目的”的地方，但在这些地方所引起的误解很可能会影响到那些“主要目的”，这是康德所要极力防止的。所以下面一大段就是专门谈“容易引起误解的地方”的，实际上只谈了一处地方，在康德看来也是最重要的地方，就是关于纯粹知性范畴的“先验演绎”的讨论。这个部分也是康德在第二版中作了大量修改的部分之一，另一个修改得更多的地方是关于理性心理学的批判。这两处修改都是为了解决同一个误解，即当时有人对《纯粹理性批判》第一版妄加解释，认为康德的体系不过是贝克莱主观唯心主义哲学的翻版。其实在第一版中，康德已经预见到了这一误解了，所以他在这个序言中提出要对书中容易引起误解之处进行注释。当然他此时所关注的还只是“先验演绎”，但他认为这是最重要的关键，只有在这里把误解澄清了，后面也就不会发生误解了。</p><p>看下面这一段。</p><blockquote><p>我不知道在对我们所谓知识的能力加以探索并对其运用的规则和界限进行规定的研究中，有什么比我在题为纯粹知性概念的演绎的先验分析论第二章中所从事的研究更重要了；这些研究也是我花费了最多的、但我希望不是没有回报的精力的地方。</p></blockquote><p>这就是说，在他看来他的纯粹理性批判最重要的部分就是“范畴的先验演绎”部分。要对我们的认识能力作批判的考察，要确定他运用的规则和范围，最为关键的就是要对知性范畴如何能够运用于经验性的材料之上做出说明，而这种说明主要就是在“先验演绎”部分进行的。这一部分也是康德整个《纯粹理性批判》中最为艰深难读的部分，是康德“花费了最多的、但我希望不是没有回报的精力的地方”。实际上先验演绎所涉及的是一个康德认识论的根本问题，即他的“哥白尼式的革命”何以可能的问题。康德认识论对传统认识论作了一个颠倒，即把“观念符合于对象”倒转为“对象符合于观念”，把主观符合客观变成了客观符合主观。这样一来，主观观念如何能够必然具有客观效力就是非解决不可的问题，而这正是先验演绎所要解决的问题。先验演绎的任务就是要证明主观的先验范畴所建立起来的知识不是单纯主观中的观念，而且也是有关客观经验对象的知识，因为所谓认识的对象不过是主观范畴能动地建立起来的。但正是在这一论证过程中，康德预计到有可能发生严重的误解，即把它误解成一个贝克莱式的主观唯心主义者。</p><p>他下面就对这种可能的误解加以预防。</p><blockquote><p>但这一颇为深入的考察有两个方面。一方面涉及到纯粹知性的那些对象，应当对知性的先天概念的客观有效性作出阐明和把握；正因为这也是属于我的目的中本质的方面。</p></blockquote><p>他首先强调他的演绎中“本质的方面”就是对知性范畴的“客观有效性作出阐明和把握”，也即是他所谓的“客观演绎”方面。这方面涉及到知性认识的对象，它解决的是“关于经验对象的知识何以可能”的问题，这个问题也等于“经验性的东西作为对象何以可能”的问题。康德对此的解答是，经验性的东西如果没有先验的范畴来规范，它们根本就是一团虚幻的过眼云烟，是完全主观的表象，哪里会有什么客观性呢？这就会堕入到贝克莱和休谟的主观唯心主义和怀疑论中去。但如果经过先验范畴的整理和规范，它们就会凝聚成一个“对象”，且只有这样它们才具有客观性，才能成为有关客观对象的知识。所以从经验的方面看，要么就没有客观对象，要有客观对象就离不开先验范畴的作用，这就是鲜艳范畴必然具有客观效力的证明。所以认识的客观性归根到底是由知性范畴所先天地带来的，只有范畴才能给经验赋予客观性，而靠经验后天地接受只能获得主观性。说明这一点就是康德先验演绎的主要目的。不过，除了这一主要目的之外，他还有一个次要目的，这就是：</p><blockquote><p>另方面则是着眼于纯粹知性本身，探讨它的可能性和它自身立足其上的认识能力，因而是在主观的关系中来考察它，但即使这种讨论对我的主要目的极其重要，但毕竟不是属于主要目的的本质部分；因为主要问题仍然是：知性与理性脱离一切经验能够认识什么、认识多少？而不是：思维的能力自身是如何可能的？</p></blockquote><p>这就是他所谓的“主观演绎”的方面。简单地说，前面的客观演绎主要是探讨知性的对象何以可能，这里的主观演绎则是探讨知性本身何以可能。当然这两方面是有联系的，知性对象何以可能，这里的主观演绎则是探讨知性本身何以可能，当然这两个方面是有联系的，知性对象何以可能，康德是把它归结为知性的能动活动，那么知性到底是如何活动的，这个问题也就是必须加以探讨的了。所以后面这方面的探讨对于前一方面的目的而是“极其重要的”，但它的重要性毕竟不能和前一方面相比较。“因为主要问题仍然是：知性和理性脱离一切经验能够认识什么、认识多少？而不是：思维能力自身是如何可能的？”这里“脱离一切经验”是说，先于一切经验，即先天地能够“认识什么”。当然知性脱离一切经验实际上什么也不能认识，它只能用于经验；但康德在这里所关注的是，在经验知识中有哪些成分是知性先天赋予的，而不是从经验中来的。在这个意义上这些成分是知性“脱离一切经验”而认识到的，这就是诸范畴。至于“认识多少”，这个问题主要是针对理性的狂妄而提出来的，理性总是不满足于知性所获得的那一点点关于现象的知识，而时刻想要把知识的范围扩展到自在之物身上去，所以必须对它的这种狂妄进行批判，加以限制，树立一个界碑。这就是康德在“先验逻辑”的两个主要部分所做的工作：在先验分析论中讨论知性，他主要解决了“认识什么”的问题；在先验辩证论中讨论理性，他主要解决了“认识多少”的问题。当然实际上在每个部分中都涉及到这两个问题，但具体的解决是分两步走的。所有这些都是客观演绎所关心的主题，而这是主观演绎所不关心的，后者关心的是“思维能力自身是如何可能的？”即知性在建立客观知识的过程中，它的内部使如何运作的。这个知性内部的运作过程，康德在第一版的主观演绎中把它分为三个阶段或层次，即“直观中领会的综合”、“想象力中再生的综合”和“概念中认定的综合”，它们最终都依赖于并归结到先验自我意识的统觉的综合统一。当然这种分析就很有一些心理学色彩了，如果孤立起来看，确实也容易与贝克莱的主观唯心主义混为一谈。</p><p>对此康德解释说：</p><blockquote><p>由于后一个问题仿佛是在寻找某个已给予的结果的原因，因而看起来在这里的情况似乎是，由于我允许自己发表这种意见，我也就不得不听凭读者发表另一种意见。</p></blockquote><p>“后一个问题”，亦即上一句中的“思维的能力自身是如何可能的？”这一问题，看起来好像是要寻求一个假设，也就是通过假设一个先验自我意识的统觉来解释我们在认识活动中的这种构造经验对象的过程，而这种假设只不过是我对于这一过程的一种主观的意见，既然只是“意见”，则别人也完全有权采取和发表另外一种不同的意见。但康德说他“在另一个地方将要指出”，其实情况并不是如此。这里说的“另一个地方”，我们可以参看第一版演绎的最后一段，标题是“概述这个纯粹知性概念演绎的正确性和唯一可能性。”所谓“正确性和唯一可能性”，也就相当于这里所说的“确定性”的意思。康德在那段话里说道：“现在，说我们所研究的所有这一切现象、因而所有的对象全都在我们里面，亦即全都是我的同一的自身的诸规定，这种说法本身即把同一个统觉中诸现象的无例外的统一性表达为必然的了。”“通过纯粹想象力而对感性表象的综合，以及一切表象在与本源的统觉的关系的同一，是先行于一切经验性的知识的。所以，纯粹知性概念之所以是先天可能的，甚至在与经验的关系中是必然的，只是由于我们的知识仅仅与现象打交道，这些现象的可能性存在于我们自身中，它们的结合和（在一个对象中的）统一只是在我们里面才被找到，因而是必须先行于一切经验并使一切经验按其形式首次成为可能的。而从这个一切理由中唯一可能的理由中，也才引出了我们的范畴演绎。”这两段话的一个共同的意思就是，先验的演绎虽然是在主观中按照认识能力的层次（感官、想象力和知性）而展开，但实际上并不是一种心理学上的假设，而是对认识对象（现象）的可能性的一种先天必然的客观确定，所以并没有给贝克莱式的主观唯心主义留下任何可钻的空子。康德并不是从经验中“寻找某个已给予的结果的原因”，似乎这个原因在经验本身之外，我们虽然没有经验到它但可以猜测它。如果这样，这个“原因”就会仅仅是一种意见了，如同贝克莱对灵魂的一种假定一样，经不起休谟的怀疑论的攻击。相反，康德正是从经验的结构中分析出了它本身的先天形式（范畴），这个形式就体现在经验中，没有这种形式，经验本身就不可能，甚至不可想象。而一旦有了它，这个经验就借此而成了关于对象的客观知识，而不只是关于我的认识能力的主观知识。所以康德的主观演绎绝不是什么个人意见，而是任何可能的知识的先天结构的展示，当然这个要联系到客观演绎才能完成这层意思，主观演绎本来就是为客观演绎作准备的。所以他最后说：</p><blockquote><p>在这种考察中我必须预先提醒读者：即使我的主观演绎不能对读者产生我所期望的全部说服力，但我在这里给予优先关注的客观演绎却会获得其全部力量，必要时单凭第92-93页所说的东西就足可以应付了。</p></blockquote><p>可将康德是寄希望于它的客观演绎这一”主要目的的本质部分“能够把他的意思说明白，主观演绎只不过是一个引线，一个入口。这种情况有点像胡塞尔现象学的情况，胡塞尔也认为他虽然批判“心理主义”，但他的线性学还得要借助于心理学来进入，即从所谓“描述的心理学”、“纯粹心理学”入手，认为只要不仅仅局限于心理学的理解，就可以从中引出它的先验现象学的诸多原理。康德本人的意思也绝不是要讨论心理学问题，即人的认识能力本身的构造问题，而是要讨论一般可观知识的构造问题；所以他注重的不是思维活动的经验事实的描述，而是这种活动所构成的只是的先天必然性条件。</p><blockquote><p>最后，谈到明晰性，那么读者有权首先要求有凭借概念的那种推论的（逻辑的）明晰性，淡然和也可以要求有凭借直观的直觉的（感性的）明晰性，即凭借实例或其他具体说明的明晰性。</p></blockquote><p>那么，明晰性在康德这里是属于什么范畴的呢？按照康德在《逻辑学讲义》中的划分，它应该归于“质”的范畴。在《逻辑学讲义》中的“知识的特殊的逻辑完备性”这一标题之下，康德分别探讨了：“量”方面的“广泛性和彻底性或重要性和丰富性”，这相当于我们上面讲到的“外延的量和内包的量”（即上面归入“量”和“质”的要求）；“关系”方面的“真理性”，包括形式逻辑的矛盾律和同一律、充足理由律和排中律，相当于我们上面讲的由确定性引出的真理性，只不过是从形式逻辑上讲的，而不是像这个“序言”中是从先验逻辑的角度谈的；“质”方面的“明晰性”，正好相当于我们这里接触到的明晰性要求；最后是模态（中译者许景行翻译为“样式”）方面的“确定性”，它与“意见”相对立，也恰好与这里的前述对研究对象的“确定性”要求相吻合。所以这里的划分与《逻辑学讲义》中的划分大致一致，区别仅仅在于，后者把前者中的“外延的量和内包的量”全部都划归于“量”了，而把“质”的位置留给了“明晰性”；此外，这里没有特别提出“真理性”作为“关系”方面的要求，而是把它合并到“确定性”这一“模态”中，作为从中引出来的一个要求。再就是《逻辑学讲义》中主要是从形式逻辑的层次来谈方法，而这里则既有形式逻辑的要求，也有先验逻辑的要求。现在，在当前这句话中，康德又从“明晰性”中区分出了两种不同的明晰性，即一种是“逻辑的”明晰性，另一种是“感性的”明晰性。这种区分也见于《逻辑学讲义》。康德在那里说：“首先我们必须把一般逻辑的明晰性同感性的明晰区别开来。逻辑的明显以诸多特征的客观的清除为基础，感性的明晰以诸多特征的主观的清除为基础。前者是由概念而来的清楚，后者是由直观而来的清楚。”而这两种明晰是相互冲突的：“客观的明显常常引起主观的模糊，反之亦然。因此，逻辑的明晰往往只能有害于感性的明晰；相反地，借助于例证和比喻（它们并非严格地适宜，而是仅仅按照类推被采用）的感性明晰，则长城那个对于逻辑的明晰是有害的。”由此来理解下面的话就很容易了：</p><blockquote><p>对于前者我已给予了充分的注意。这涉及到我的意图的本质，但它也是种偶然的原因，使得我未能考虑这第二个虽然不是那么严格但毕竟是合理的要求。</p></blockquote><p>对这俩个相互冲突的要求，康德显然偏重于“前者”，即“逻辑的明晰性”，因为它“涉及到我的意图的本质”。但这样一来它也就不得不牺牲感性的明晰性了，后者本来也是一种“合理的要求”，康德对他的放弃不是有意的，而是“偶然的”，即是由于课题本身的性质所决定的，因为这个课题本身只是要搞清只是的逻辑关系。对于这种牺牲，康德自己也感到很遗憾，所以他说：</p><blockquote><p>我在自己的工作进程中对于应如何处理这个问题几乎一直都是犹豫不决的。实例和说明在我看来总是必要的，因而实际上在最初构思时也附带给予了它们以适当的地位。</p></blockquote><p>康德在写作方面并不缺乏感性的明晰生动的才能，这从他多年讲授并在晚年出版的《实用人类学》中可以看出来。一些康德传记也表明，康德在日常生活中经常是谈吐风趣、思想活泼的，并不是一个使周围的人感到沉闷的人。他知识丰富，博闻强识，各种逸闻趣事信手拈来，打比方生动贴切，甚至很懂得讨女人喜欢。应当说这样一个学者在构思自己的主要著作时，不可能不考虑到表达的生动和平易。但他承认，他在写作的一开始就在犹豫不决，究竟是照顾逻辑上的明晰呢，还是兼顾感性直观的明晰？</p><blockquote><p>但我马上看出我将要处理的那些课题之巨大和对象之繁多，并觉得这一切单是以枯燥的、纯粹经院的方式来陈述就已经会使这本书够庞大了，所以我感到用那些仅仅是为了通俗化的目的而必要的实例和说明来使这本书变得更加膨胀是不可取的</p></blockquote><p>就是说，随着构思的深入，他马上看出要兼顾两方面几乎是不可能的。因为他所面对的课题太庞大、太复杂了，单是想要把里面的关系理清楚就已经足够繁琐的了，如果再加上一些说明性的例证和比喻，就会使这件工作超出一般人头脑的负荷。我们经常听到一些人抱怨康德这部著作的艰深难读，完全是概念到概念的抽象思辨，感受不到任何思维的乐趣。但这也正是扛得自己深感苦恼的，他不得不以这种“枯燥的、纯粹经院的方式”来写作，并不是她有意要使人读不懂，而是对象本身的性质所决定的。它以这种纯粹学院化的语言尽量简明地表达思想的内在线索，这本来是一种最节约的表达方式，但就这样也已经使这本书拥有巨大的篇幅了。如果再加上一些通俗化的例子，而为了这些例子不被误会，又必须对之加以说明，这就会使书的篇幅过于膨胀，同时也无助于逻辑的明晰。所以他忍痛牺牲掉感性的明晰性实在是不得已。</p><blockquote><p>尤其是，这本书绝不会适合于大众的使用，而真正的科学内行又并不是那么迫切需要这样一种方便，尽管这种方便总是令人舒服的，但在这里甚至可能引出某种与目的相违的结果来。</p></blockquote><p>也就是说，这本书的目的并不是给一般大众看的，而是一部纯学术著作，而且到了这样一种高深的层次，几乎不可能考虑“雅俗共赏”的问题。相反，为了照顾通俗化而增加一些阅读的“方便”，这往往并不能达到目的，反而会两败俱伤，既没有做到真正的通俗，有打乱了思维的逻辑线索，所以他担心“可能引出某种与目的相违背的结果来”。他把对这本书的理解寄托于“真正的科学内行”，也就是那些纯专业人士，甚至可以说，归根到底，他相信只要他严格按照逻辑的明晰性写作，就会有人理解一种深刻的思想。对学术的真诚和对纯粹真理的追求压倒了媚俗的期待。下面他引用了特拉松院长的一句话：</p><blockquote><p>虽然修道院院长特拉松尝云：如果对一本书的篇幅不是按页数、而是按人们理解他所需要的时间来衡量的话，那么对有些书我们就可以说，如果它不是这么短的话，它将会短得多。</p></blockquote><p>这话的意思是说，如果一本书增加一些生动有趣的例子，就便于人们很快地理解，读者就甚至会缩短阅读的时间，所以虽然书的篇幅增加了，按阅读速度算却相当于读一本篇幅更短的书。康德并不反对这种说法，但他根据自己的情况对之做了引申：</p><blockquote><p>但另一方面，如果我们把目的放在对宽泛但却结合于一条原则中的那个思辨知识整体的可理解之上，那么我们就会有同样的正当理由说：有些书，如果它并不想说地如此明晰的话，它就会更加明晰得多。</p></blockquote><p>这种说法与特拉松的说法实际上是对着干的，就是说，如果不增加那些说明性的生动例子，这本书反而会更加明晰，因为它的逻辑线索没有受到那些感性例证的干扰。当然这是针对着“宽泛但却结合于一条原则中的那个思辨知识整体的可理解性”而言的，即不是一般的可理解性，而是对于按照一条逻辑原则组织起来的思辨体系的可理解性，这就是康德这本书的情况。</p><blockquote><p>这是因为明晰性的辅助手段虽然在部分中有效，但在整体中往往分散了，这样它们就不能足够快地让读者达到对整体的概观，倒是用它们所有那些明亮的色彩贴在体系的结合部或骨架上，使它们面目全非了，而为了能对这个体系的统一性和杰出之处下判断，最关键的却是这种骨架。</p></blockquote><p>这也就是上面所说的，细节的感性的明晰性和整体的逻辑明晰性相互之间有一种冲突关系，感性的明晰性只能作为辅助手段而使部分细节突显出来，但却喧宾夺主，不仅不能达到整体的清晰，反而把整体的概观弄模糊了。康德在本书中所追求的不是这种部分的明晰性，这种表面的通俗和华丽，他不想为了讨好一般读者而使思想的逻辑骨架受到损失。他很清楚自己著作的价值和“杰出之处”在什么地方，一种对真理本身的真诚使他宁可被人抱怨，甚至由于人们无法把握而产生种种误解，而不愿放弃体系的严谨一惯性。所以我们在阅读康德的书时必须要丢掉一切幻想，不要以为他会对我们的思维能力心存怜悯，而要把这本书看作磨砺我们哲学思维最好的磨刀石。</p><p>下面：</p><blockquote><p>我认为，对读者可以构成不小的诱惑的是，将他的努力和作者的努力结合起来，如果作者有希望按照所提出的构想完整地并且持之以恒地完成一部巨大而重要的著作的话。</p></blockquote><p>康德相信，他的《纯粹理性批判》如果有人读懂了的话，就会产生一种“接着讲”的冲动，即以合作者的身份配合康德去共同完成一部完整的形而上学著作，或者是在康德以后继续完成康德未竟的重建形而上学的事业。显然，康德并不认为他的《纯粹理性批判》就是一个完整的体系了，虽然就其本身的任务来说他无疑是完整的，但是它的任务只是“批判”，而不是建设。批判是为建设开道的。不过批判一旦完成，地基一旦清扫干净，对人们就会形成一种诱惑，既要在这一片全新的基地上建设起一座宏伟的大厦来，这座宏伟的大厦就是未来的形而上学。</p><blockquote><p>现在，形而上学，按照我们再次将给出的它的概念，是一切科学在唯一的一门这样的科学，它可以许诺这样一种完成，即在较短的时间内，只花较少的、但却是联合的力气来完成它，以至于不再给后世留下什么工作，只除了以教学法的风格按照自己的意图把一切加以编排，而并不因此就会对内容有丝毫增加。</p></blockquote><p>形而上学按照康德的设想可以一劳永逸地建立起来，这种想法在今天看来十分可笑，但康德的确实认真的。他认为其他的科学都有一些无限的发展过程，比如物理学、化学、电磁学、光学等等，都总是会有新的规律发现出来，没有人敢于说他们中任何一门今天已经完成了，不需要再发展了。因为他们除了先天的认识结构之外，还需要不断涌现的偶然的经验材料，它们的那些规律而是作为偶然被我们发现的经验规律而出现在科学中的，因此总是可以不断增加的。形而上学却不同，他的那些规律和法则只是先天地存在于我们人类的纯粹理性中，因此我们可以不需要顾及到后天经验中又出现了一些什么新的情况，而是单凭反思自己先天固有的各种能力就可以找到它们的那些必然性法则，就像逻辑学自从亚里士多德以来就已经基本奠定了，不需要再作很大的修改。所以他设想，只要人们接受了他的批判哲学的原理，就有可能发挥联合的力量来完成一种最终的形而上学，来给一切科学知识提供出完整的一套形而上学原则。那样的工作不会很困难，因为最艰难的工作已经由他自己完成了，这就是纯粹理性本身进入深入的批判。地基已经打好，材料已经备齐，甚至蓝图也已经设计出来了，一切都经过精密的勘察和敲定，现在只要大家齐心协力，就可以“在较短的时间内，只花较少的、但却是联合的力气”来完成整个形而上学了。他所奠定的这份家业，后人将享用不尽，而不再有什么工作要做了。唯一可以做的只剩下“以教学法的风格按照自己的意图把一切加以编排”而已。所谓“教学法”，又译作“教授法”，德文为Didaktik，指一种通过举例说明的方式通俗地讲解一种学说的原理的方法。例如《实用人类学》的主体部分就是所谓“人类学教授法”，其中按照知情意的次序通俗地描述了人类学的各种实用的原理，这些原理的根基是奠定于他的三大批判之上的，所以有人说读康德的书最好是从《实用人类学》读起。另外在《道德形而上学》最后的“伦理学的方法论”中也有“伦理学教授法”一章，谈到教义问答和榜样的作用。可见所谓“教学法”并不给原理增加任何内容，而只是为了达到通俗易懂的效果而设计的一种策略，是对诸多原理所做的一种合乎目的的安排。所以康德接下来说：</p><blockquote><p>因为这无非是对我们所拥有的一切财产的清单通过纯粹理性而加以系统地整理而已。我们在这里没有忽略任何东西，因为凡是理性完全从自身中带来的东西，都不会隐藏起来，而是只要我们揭示了它的共同原则，本身就会由理性带到光天化日之下。</p></blockquote><p>理性的财产必须带上理性的形式，只有这样才能很容易地被有理性的人所理解和把握；但这种理性的形式本身就包含在理性的共同原则本身中，所以不必从外面拿来，而只需从理性的院里里面发挥出来呢就是。所以这是一种比较轻松的工作，可以由一些智力也许不如康德、但精力比康德要好的人去做。因为纯粹理性的原理经过批判已经得到了最终的确立，它们不会隐藏起来，而是必然由自身而“带到光天化日之下”，昭然于世。教学法的这种作用是一种普及作用，而有了纯粹理性作为它的原则，这种普及不必担心偏离理性的轨道。</p><blockquote><p>对于出自真正纯粹概念的知识，任何经验的东西或哪怕只是应当导致确定几百个样的特殊直观都不能对之产生丝毫影响而使之扩展和增加，这类知识的完全的统一性，将会使这种无条件的完整性称为不仅是可行的，而且是必然的。”看看你自己的住所周围，你将知道你的财产是多么的简单。——波修斯”。</p></blockquote><p>教学法当然要引入经验和直观，其他的各门具体的科学的知识也必须借助于经验直观，但所有这些都不会使一门“出自真正纯粹概念的知识”、即形而上学的知识有丝毫的影响和扩展，所以形而上学有望达成一种“完全的统一性”，并且必然实现体系上的“无条件的完整性”。因为形而上学的原理并不是无限增多的，它们埋藏在人类理性的深处，并不会由于经验材料的加入而增加，而一旦被人类的批判和反思精神所挖掘出来，它们就一劳永逸地摆在那里了。现在康德已经把人类理性的那些原理的“清单”开列出来了，这就是我们所拥有的一切纯粹理性的“财产”，不会再增加，也不会再减少，所以他有充分的信心在不久的将来最终完成形而上学。</p><p>但这里所指的形而上学还只是指“自然地形而上学”。</p><blockquote><p>我希望这样一种纯粹的（思辨的）理性的体系在自然的形而上学这个标题下被提供出来，这个体系比起这里的批判来虽然篇幅还不及一半，但却具有无可比拟地更为丰富的内容。</p></blockquote><p>按照康德的设想，《纯粹理性批判》直接为之奠基的是一门自然科学的形而上学体系，又叫做“自然的形而上学”，属于他在《任何一种能够作为科学出现的未来形而上学导论》（简称《未来形而上学导论》）中所想要建立的那种形而上学。不过这种形而上学康德自己最终并没有建立起来，而只是谢了一本《自然科学的形而上学基础》的小册子。康德《纯粹理性批判》的直接目标就是为这样一种未来的形而上学扫清地盘，但与此同时，一个间接性的、但层次更高的目标则是要建立一门《道德形而上学》。这个任务康德倒是完成了，他不但写了一本《道德形而上学基础》的小册子，而且写出了正式的《道德形而上学》。所以它的未来形而上学体系其实有两部分，一个是自然形而上学，一个是道德形而上学，而这两部分都是依次奠基在《纯粹理性批判》之上的，用康德在第二版序言中的说法，他的《纯粹理性批判》是要通过“悬置知识，以便给信仰留下位置”，具有一箭双雕的作用。不过在这段话里他并没有涉及道德形而上学，而只提到自然形而上学。他为什么没有写出《自然形而上学》来，很可能是由于他认为这种工作比较容易，属于一种事务性的工作，而不是一种创造性、开拓性的工作。最困难的工作已经由他自己做了，剩下来的事情就是按照他所提供出来的基本概念和原则而把那些派生的概念填充到框架里面去就行了。所以康德预计，“这个体系比起这里的批判来虽然篇幅不及一半，但却具有无可比拟地更为丰富的内容”。篇幅短的原因是省去了《纯粹理性批判》中所做的那些大量的繁琐论证，只需要做一些概念的组织和安排；而内容丰富则是由于它是《纯粹理性批判》中已提出的那个基本框架的扩展和充实，每个概念都可以扩展出一系列的派生概念，每个原则也可以推演出一系列的派生原则。例如，康德在后面第十节解释他的“范畴表”的时候说：“范畴作为纯粹知性的真正的主干概念，也有自己的同样纯粹的派生概念，它们在先验哲学的一个完备的体系中是绝不可以忽略的，但我在一个单纯批判性的研究中刻印满足于只要提到它们就行了。”接下来他还做了一个初步的示范：“例如把力、行动、承受的宾位词从属于因果性范畴之下，把当下、阻抗的宾位词”从属于协同性范畴之下，把产生、消失、变化的宾位词从属于模态的云谓关系之下，如此等等。把范畴和纯粹感性的样态相结合，或者也使这些范畴相互结合，就会提供大量先天的派生概念，注意到这些概念，并在可能时把它们记载下来直到完备无遗，这将是一项有用的、不无兴致的劳作，但在这里尚无必要。”显然，有了康德的范畴表，你所能够想到的任何其他的派生的概念都可以各归其位，并由此显示出它们与别的概念之间的逻辑关系。所以《纯粹理性批判》和“未来形而上学”的任务是很不相同的，康德说：</p><blockquote><p>这个批判必须首先阐明形而上学之可能性的来源和条件，并清理和平整全部杂草丛生的基地。在这里我期待读者的是一个法官的耐心和不偏不倚，但在那里则是以为帮手的襄助和支持；</p></blockquote><p>《纯粹理性批判》的任务是平整地基，包括批判和清算旧形而上学的杂草，顶多是在已经平整好的地基上策划未来形而上学的蓝图。这个工作是高度抽象二富有对抗性的，充满着繁琐而细致的推理和论证，必须要有法官的耐心和公正才能理解和掌握。而在“那里”，也就是在未来形而上学中，康德期待的是一位“帮手”，所做的是一种锦上添花的工作。相比较而言，后一种工作是更轻松一些，但也是必不可少的。</p><blockquote><p>因为，即使把该体系的所有原则都完全在批判中陈述出来，属于该体系本身的详尽性的毕竟还有：不要缺乏任何派生出来的概念，这些概念不能先天地凭跳跃产生出来，而必须逐步逐步地去探寻，</p></blockquote><p>未来形而上学的所有基本原则在《纯粹理性批判》中都已经陈述出来了，但这对于该体系的详尽性来说仍然还是不够的，这只是一个初步的蓝图，具体如何建设形而上学的大厦，用什么材料，如何作细部的加工，这些都有待于逐步地完善。一个完整的形而上学体系必须把一切基本概念和由基本概念所派生出来的概念都完全包括在自身之中，这才能达到体系的详尽性。这些派生概念当然也是纯粹的，但在层次上不如基本概念那么高，所以不能够一下子“凭跳跃”产生出来，而必须在基本概念已经提供出来的前提下逐步推演出来，以便在自然形而上学和纯粹自然科学之间形成一种更加对应的结合。例如康德前面举的例子：“力、行动和承受”的概念是从“因果性”范畴中引申出来的，它们与物理学的基本概念就处于更加直接的关系中，如此等等。由此构成的一个完备体系就能够符合形而上学所要求的详尽性，而没有任何遗漏和缺口。</p><blockquote><p>同样，由于在那里概念的全部综合已被穷尽了，所以在这里就额外要求在分析方面也做到这样，这一切将是轻松的，与其说是工作，还不如说是消遣。</p></blockquote><p>《纯粹理性批判》的总问题是“先天综合判断如何可能”，要解决的主要是综合的问题；而在此基础上所建立的未来形而上学则是把已经综合起来的原理加以发挥，从中分析出所有可能的原理和概念，这是一种顺水推舟的工作。综合是难的，特别是先天综合，要求人发挥自己全部的能动性努力超越，才能够找出综合之所以可能的最高条件；分析则是在已有的条件和基础上进行分解，看看从一个前提可以推出什么样的一些概念和原理。所以未来形而上学的完成不再需要像康德在《纯粹理性批判》中所做的那种自下而上的艰苦的努力，而只需要自上而下地收获那些顺理成章的理论成果就行了，所以说它是“轻松的”，甚至是一种“消遣”。这或许正是康德没有自己去建立一门“自然形而上学”的原因，他认定自己是专门对付那些困难问题的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;康德《纯粹理性批判》第一版的序宏观地展示了康德在写作这部著作时所面对的问题，许诺了他将要达到的结果，制定了它在整个体系方面所依据的方法论准绳，以及该著作在他整个哲学构思中的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="康德" scheme="http://yoursite.com/tags/%E5%BA%B7%E5%BE%B7/"/>
    
      <category term="纯粹理性批判" scheme="http://yoursite.com/tags/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（8）：click</title>
    <link href="http://yoursite.com/2018/02/10/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89%EF%BC%9Aclick/"/>
    <id>http://yoursite.com/2018/02/10/python编程系列（8）：click/</id>
    <published>2018-02-10T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="click" scheme="http://yoursite.com/tags/click/"/>
    
  </entry>
  
  <entry>
    <title>读书记（13）：《行为经济学讲义：演化论视角》 第二讲</title>
    <link href="http://yoursite.com/2018/02/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8813%EF%BC%89%EF%BC%9A%E3%80%8A%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%EF%BC%9A%E6%BC%94%E5%8C%96%E8%AE%BA%E8%A7%86%E8%A7%92%E3%80%8B%20%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
    <id>http://yoursite.com/2018/02/05/读书记（13）：《行为经济学讲义：演化论视角》 第二讲/</id>
    <published>2018-02-05T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>囚徒困境：<br>故事：两位印第安人在一条狭长河谷里捉兔子，这时它们面临囚徒困境。兔子可以沿着河谷向两端跑，所以必须各有一个印第安人把守。这样两人向中间推进，可使兔子无路可逃。问题是，如果其中一个人先捉到兔子，那么他可以拒绝与另一个人瓜分这只兔子，这是不合作的策略。他也可以与对方平分这只兔子，这是合作的策略。</p><a id="more"></a><p>囚徒困境发生的前提是：</p><ul><li>1）如果我和你同时采取合作策略，那么我们各自的福利就都会比我们同时采取不合作策略时更好。</li><li>2）如果我合作而你不合作，那么我的福利会比我们同时采取不合作策略时更差并且你的福利会比我们同时采取合作策略时更好。对称地，如果你合作而我不合作，那么你的福利会比我们同时采取不合作策略时更差并且我的福利会比我们同时采取合作策略时更好。</li></ul><p>囚徒困境博弈的最弱版本：滚雪球博弈</p><p>你和你的邻居早晨起来发现都被昨晚的大雪困在家里，如果你和你的邻居合力铲雪，可以比你或你的邻居单独铲雪更早走出困境。当然，你或你的邻居愿意单独出来铲雪，哪怕知道对方是搭便车的人，因为，单独铲雪总比饿死在家里好得多。</p><p>介于滚雪球和囚徒困境之间的，是公共品博弈：拟合你的邻居上了修一条路，自愿出资。双方知道对方可能“免费搭车”，但最优的选择仍是修路，哪怕是独立出资。不过，有时候公共品很贵，必须有足够多的人分摊它的成本，否则公共品就不能存在。这时，公共品博弈就成为多人的囚徒困境博弈。</p><p>囚徒困境意味着社会科学基本问题，即对于一群理性人而言，社会何以可能存在并延续了许多年呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;囚徒困境：&lt;br&gt;故事：两位印第安人在一条狭长河谷里捉兔子，这时它们面临囚徒困境。兔子可以沿着河谷向两端跑，所以必须各有一个印第安人把守。这样两人向中间推进，可使兔子无路可逃。问题是，如果其中一个人先捉到兔子，那么他可以拒绝与另一个人瓜分这只兔子，这是不合作的策略。他也可以与对方平分这只兔子，这是合作的策略。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>python编程系列（7）：logging和pdb</title>
    <link href="http://yoursite.com/2018/02/03/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89%EF%BC%9Alogging%E5%92%8Cpdb/"/>
    <id>http://yoursite.com/2018/02/03/python编程系列（7）：logging和pdb/</id>
    <published>2018-02-03T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="logging" scheme="http://yoursite.com/tags/logging/"/>
    
      <category term="pdb" scheme="http://yoursite.com/tags/pdb/"/>
    
  </entry>
  
  <entry>
    <title>读书记（12）：《行为经济学讲义：演化论视角》 第一讲</title>
    <link href="http://yoursite.com/2018/01/28/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8812%EF%BC%89%EF%BC%9A%E3%80%8A%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%EF%BC%9A%E6%BC%94%E5%8C%96%E8%AE%BA%E8%A7%86%E8%A7%92%E3%80%8B%20%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
    <id>http://yoursite.com/2018/01/28/读书记（12）：《行为经济学讲义：演化论视角》 第一讲/</id>
    <published>2018-01-28T15:14:45.000Z</published>
    <updated>2018-11-05T16:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本书是北大ccer教授汪丁丁2010年在北京大学讲授“行为经济学”课程的课堂讲义，书内汪教授内容旁征博引，涉及心理学、社会学、经济学、博弈论、神经脑科学等，各种各样的知识模块扑面而来，整理至此。</p><a id="more"></a><p>心智地图：可以表达网状的多因多果联系，是PPT线性表达方式的必要补充。Buzan’s iMindMap 4.0/微软Concept Draw/Mindjet Mind-manger 8.0</p><p>手写软件：“黑板” Chalk Board 1.5</p><p>熊十力倡导的读书方法：沉潜往复，从容含玩</p><p>行为经济学参考书：《行为经济学新进展》 凯莫罗（Colin Camerer）/罗文斯坦（George Loewenstein）/拉宾（Mattew Rabin）</p><p>凯莫罗（Colin Camerer）:加州理工教授，研究兴趣为实验经济学和脑科学（认知心理学），专著《行为博弈论》。1980年代芝加哥大学培养的博士，方向为“行为决策理论”。</p><p>罗文斯坦（George Loewenstein）：卡耐基梅隆大学的心理学与经济学讲座教授，CMU可谓是行为经济学的发源地，西蒙（Herbert Simon，1978年因决策过程的行为学研究获得诺贝尔经济学奖，2001年去世）在那里建立的学术传统承前启后，将1940年代的行为经济学研究传统容易CMU深厚的管理学和行为学传统，培养了诸如卢卡斯（Robert Lucas，理性预期学派领袖，获得1995年诺贝尔经济学奖）和威廉姆斯（Oliver Williamson，新制度经济学领袖之一，2009年诺贝尔经济学奖）这样的诺贝尔经济学奖。在行为经济学领域，罗文斯坦比拉宾资深，他在耶鲁的博士论文题目为“预期与跨期选择”，据拉宾介绍，他“无所不知”。</p><p>拉宾（Mattew Rabin）：伯克利经济学助教，在《美国经济评论》发表论文，研究博弈双方公平感对博弈行为的影响。2001年因行为经济学研究获得克拉克奖（两年一次，40岁以下），关注道德问题，本科数学，博士MIT经济系，伯克利任教至今，讲授“心理学与经济学的基础”</p><p>西方文献发表三年周期：</p><p>2009年：“社会仿真”、“诺瓦克”（Martin A. Nowak，哈佛教授，生物学与演化社会仿真学派的领袖人物）</p><p>2006年：“脑科学”、“费尔”（Ernst Fehr，苏黎世学派十堰经济学和神经经济学领袖人物，被认为有等于或高于凯莫罗的诺贝尔奖获奖概率）</p><p>2003年：“桑塔费学派”及其“合作的演化”研究</p><h3 id="一、行为经济学的定义"><a href="#一、行为经济学的定义" class="headerlink" title="一、行为经济学的定义"></a>一、行为经济学的定义</h3><blockquote><p>行为:</p></blockquote><p>是生命的表征。从原核生物到微生物及至人类，只要有生命，就可以有行为。个体、群体     经济学家的问题意识是个体主义的，也叫作“方法论个人主义”，优先研究个体行为，然后才考虑集结一群个体行为去试图解释群体行为。</p><p>价值、判断：行为的研究者有一个共同的假设，就是行为的主体，只要它有生命，它的行为便预设了一套价值和价值判断的评价系统。在这一体系的指引下，有“选择”行为。</p><blockquote><p>选择：</p></blockquote><p>（1）将备选的事物，依照基于过往经验形成的某种既存标准，分别装进由于过往经验而事先存在的一套格子里的这样一种过程。</p><p>（2）可选方案相当于各种可能手段的集合，选出来的结果相当于各种可能目标的集合（希望满足的全部欲望的集合），在这两个集合之间有一种映射（选择算子，在手段的集合里确定一个子集，在这一子集上，目标集的某些目标更容易实现），称为“选择”映射。</p><p>新古典经济学派要求这样的映射必须是“最优的”，并且是“全局最优”而不是“局部最优”。根据价值来评判最优。价值是行为主体长期演化的结果（演化论），若不涉及公共选择，也可称为偏好。贝克尔（Gary Becker，芝加哥学派领袖人物，成功拓展经济学理性选择原理于广泛领域，1992年诺贝尔经济学奖）和他的一名助手在《政治经济杂志》（Journal of Political Economy，芝加哥大学经济系的机关刊物）发表了一篇论文（“Evolutionary Efficiency and Happiness”），旨在解释人类演化过程如何使我们的偏好达到均衡从而稳定地表现出今天可观测到的一些重要性质，即性状。</p><p>哈耶克论证，我们的偏好来源于三重历史：（1）种群演化的历史（2）社会与文化的历史（3）个人史</p><blockquote><p>判断：</p></blockquote><p>两难情境内的选择，因为有至少两种相反且相等强有力的原则将我夹在中间，我必须抉择，否则就毁灭。这就是判断不同于选择的本质之处。判断意味着创造，因为如果没有创造，选择通常不会是“两难的”。当你知道如何选择的时候，你的选择通常不是创新行为，它只是遵循以前发生过的案例而已。当你不知道怎样选择时，你有了创造的机会。</p><p>经济学家在研究任何问题时务求有可观测的数据，从而有统计关系和由统计关系推测建构因果链条的可能性。否则，经济学解释就不再是科学的，而变成一种文学解释了。文学的特征是：因刻画了不可重复的人类经验而无法接受任何科学方法的检验。</p><blockquote><p>约束：</p></blockquote><p>经济学千招万式最终化为一招一式，其中的那“一式”，就是“约束条件”，最优选择是那“一招”，合起来就是“约束下的最优选择”</p><blockquote><p>成本：</p></blockquote><p>Cost is the highest alternative value，在可选方案集合里被你的选择放弃了的那些方案当中可能为你带来最高价值的那些方案的价值。最高价值的定义也就是追求最大幸福，这是经济学假设一切行为的目标函数。贝克尔强调，最大的幸福一定是行为主体想象中的最大幸福（未必是真是的），英文是“perceived maximization”（是基于真实感觉的“想象”，而不应简单译作“统觉”），为什么不是贝克尔当初使用的“imagined maximization”，因为后者有胡思乱想的意思，太不真实。例如你可以在梦境里最大化你的幸福感，但醒后就幻灭了。</p><blockquote><p>道德成本：</p></blockquote><p>就是当你违背了道德自律时你感受到的幸福感下降的程度。这是一种心理成本，为了补偿幸福感的下降，你就限制自己不去做违背道德自律的事情。为了界定道德成本，我们必须界定包含道德行为的可选方案集合，以及包含道德行为的目标函数最大化问题。但你诸如信仰、灵魂和道德这样的事情，通常具有“全有或全无”性质，也就是说，要么你是道德的，要么你是不道德的。59%道德和41%道德这样的状态时很可疑的。关于比道德要求更高的信仰，早如克尔凯郭尔在《或此或彼》中指出的，你要么有信仰，要么无信仰。这两种状态之间是一道难以逾越的深渊。要获得信仰，就必须有纵身一跃的勇气，这里不存在“边际”量，因此渐变是不可能的。</p><h3 id="二、价值、认知与判断"><a href="#二、价值、认知与判断" class="headerlink" title="二、价值、认知与判断"></a>二、价值、认知与判断</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv38rn00uj30ff0am75e.jpg" alt=""></p><blockquote><p>价值：</p></blockquote><p>小密尔（John Stuart Mill，1806—1873）的理解，价值就是“importance felt”（被感受到的重要性）。则新古典经济学的偏好可表达成”所有被感受到的重要性的一个排序”。“什么是重要性？”怀特海三段论——在任何理解之前先有表达，在任何表达之前先有关于重要性的感受。这里，按照怀特海的表达，关于重要性的感受总是面向实事的。金岳霖认为重要性是一种“真实感”——“真”（不假）而且“正”（不邪）。前面说过，判断必须是两难的抉择，我们之所以有判断的冲动，是因为要追求价值。故而有从“价值”到“判断”的关系箭头</p><blockquote><p>重要性：</p></blockquote><p>在漫长的演化过程中，我们或任何动物脑内的神经元网络形成一些专为外界刺激信号分类的“格子”。反复遇到对我们的生存具有重要性的刺激信号，就诱致相应类型的格子的形成。在这一基础上还可形成格子之间的关系，进而有更复杂的关系。一层一层地从较低级的脑区涌现到较高级的脑区，最终映射到“自我意识”脑区，被我们意识到。这就是外部世界的各种重要性在我们脑内的表达过程。《感觉的秩序》（哈耶克毕生唯一重要的学术作品）</p><blockquote><p>认知：</p><p>海纳模型：</p></blockquote><p>越是理性能力完备的行为主体，它的最优选择行为就越是不可预期。</p><p>设想有人对股票市场走势的洞察如上帝那样，全知全能，那么他的最优选择在我们这些智能较低的人的观察中，必是如”白噪声“那样的完全随机行为。</p><p>在智能的另一极端，是所谓的“零智能”假设，我们假设一些动物，智能远比例如蚂蚁更弱，那么这些动物的行为，在对他们而言“变幻莫测”的环境里，只好是循规蹈矩的，于是在我们这些智能较高的观察者来看，这些动物的行为具有很高的可预测性。</p><p>在得到上述结论后，海纳开始广泛运用他的结论。他试图用这一模型解释极其广泛的现象，从科学范式和技术进步路径依赖，到经济行为与文化传统。这就引起广泛的反感</p><blockquote><p>“认知”依赖于“能力”</p></blockquote><p>关于“判断”，真正重要的只有两大要素：价值和认知。认知能力让你能知道多少信息，并且你能处理多少信息？这样一个认知能力的问题，它导致了“海纳模型”及其结论。</p><p>从“能力”到“认知”，虽然只是一个关系箭头，却包含了例如劳动经济学家的主要努力。劳动经济学的努力表明，我们很难测定认知能力，究竟在多大程度上由先天禀赋决定？也就是在多大程度上由后天教养决定？这就是所谓“nature VS nurture”（自然对教养）的争论。</p><h3 id="三、信息、外部环境与认知"><a href="#三、信息、外部环境与认知" class="headerlink" title="三、信息、外部环境与认知"></a>三、信息、外部环境与认知</h3><blockquote><p>信息：</p></blockquote><p>亚当·斯密假设决策者要充当知情且公正无偏的旁观者（fully informed and impartial spectator），这一假设在他的《道德情操论》里占据核心位置，也就是正确的决策，要求决策者掌握足够的信息。哈耶克对信息的定义为生物在长期经验中感受到外界刺激信号并形成一套专用于分类的神经元网络系统。知识或分类系统可以存储在个体脑内，也可以存储在群体里面。而群体常常以社会网络的方式存在。</p><blockquote><p>信息来源依赖于社会网络结构：</p></blockquote><p>信息的来源，有个体也有群体。一个社会的创造性，一方面取决于这个社会里每一个体的认知能力，另一方面取决于这个社会的结构。社会结构可以用拓扑学的语言描述：社会是一个网络，网络有自己的“中心”，有“科层”，还有其他的网络拓扑结构。</p><p>社会网络方法，好处是将个体行为嵌入到群体之内。</p><p>一个群体，不是完全没有结构就可存储信息和知识的。不同的社会结构，费孝通早已论证过（皇权与绅权），一个社会有什么样的结构，决定了它可能积累什么样的知识。中国两千多年来的社会结构决定了它不可能积累下西方社会所积累的那些知识。因为，许多知识，刚开始是以信息的形式存在的，在特定社会结构里，可能不允许被传授。</p><blockquote><p>信息的另一来源：认知的“外部环境”及其不确定性</p></blockquote><p>当外部环境高度不确定时，最好减少动作。</p><p>随着决策环境的不确定性从小到大，根据海纳模型，个体行为表现出来的理性程度就应当是从高到底变动。当不确定性极低时，我们观察到个体理性（reason）。如果环境不确定性继续增加，那么就要有行为灵活性的大幅下降。这是出现了行为规范，尤其是存储在社会里的那些规范（群体规范）。许多社会规范，个体虽然很难理解，但因为违反规范可能遭受社会制裁，也就不得不遵守，久而久之，群体生存得越久远，对个体而言这些规范的“合理性”就变得越显明。哈耶克倾向于将这样的理性称为“演化理性”，与完全基于个体经验的“建构理性”相对峙。</p><p>社会影响通过三种途径施于个人：其一是模仿，尤其是对成功者的模仿。其二是教化，学校的教育，家庭的教育，还有在职培训和自学等方式。其三是遗传，许多行为是遗传决定的，你很难改变这些行为，例如你的人格。晚近发表的对大批受试者的长时期跟踪调查表明，一个人的性格，如果用人格五要素模型来测度，在25岁至83岁这段时间里，他在各维度上的得分，很少发生改变。</p><p>社会结构里存储了大量的决策知识，让个体能够应付极不确定的决策环节。根据海纳模型，在最高不确定的决策环境里，我们只能依靠文化传统。我们的传统延续了数千年，在这样漫长的时间里，必定会遭遇比目前严重数倍的危机。但依旧延续到今天，这就意味着它“管用”，虽然可能令人迷惑。哈耶克说，我们是我们 传统的选择，而不是我们选择了我们的传统。传统越久远，它的合理性就越不能根据一时一事是否合理来评价。我们适应了自己的传统，在这一意义上我们是被传统选择的，并因此而更可能生存下去。</p><blockquote><p>传统：</p></blockquote><p>希尔斯的《论传统》及其序言对传统的定义如下：“传统一词的拉丁文为traditum，意即从过去延传到现在的事物······延传三代以上的、被人类赋予价值和意义的事物都可以看作是传统。······可以看出，这种意义上的传统概念与文化人类学家所使用的“大文化”概念是一致的······不过“传统”一词还有一种更特殊的内涵，即指一条世代相传的事物之变体链，也就是说，围绕一个或几个被接受和延传的主题而形成的不同变体的事物之变体链，也就是说，围绕一个或几个被接受和延传的主题而形成的不同变体的一条时间链。这样，一种宗教信仰、一种哲学思想、一种艺术风格、一种社会制度，在其代代相传的过程中既发生了种种变异，又保持了某种共同的主题······传统是一种社会的文化遗产，是人类过去所创造的种种制度、信仰、价值观念和行为方式等构成的表意象征；它使代与代之间、一个历史阶段与另一个历史阶段之间保持了某种连续性和同一性，构成了一个社会创造与再创造自己的文化密码，并且给人类生存带来了秩序和意义。”</p><p>韦伯的“克里斯玛”学说：马克思·韦伯指出，克里斯玛式人格是历史上尤其富有创造性的革命力量。由于克里斯玛统治下的法规来自于高度个人化的对神思的体验，以及神一般的英雄力量，并且为了体现先知式的对神思的体验，以及神一般的英雄力量，并且为了体现先知式的精神气质而排除了所有外在秩序，所以克里斯玛统治以一种革命的方式转变了所有价值观，破除了所有传统的和理性的规范。这就是说，不仅创建一种传统需要非凡的克里斯玛式的想象力（当然也需要魄力，记忆力和推理能力），而且破除一种传统同样离不开克里斯玛特质，甚至需要有双倍的克里斯玛特质。因为破除一种传统必须同时创建一种更适合时宜和环境的、也更富于想象力的新传统；只有在新传统的克里斯玛力量压倒了旧传统的习惯势力之后，旧传统才会逐渐退出历史舞台。</p><p>学术界公认，希尔斯的重要贡献是论证了“传统”具有某种克里斯玛特性。</p><p>文化传统的演变，可纳入上图的框架。</p><p>物质生活：人类社会从游猎到农耕到工业社会和后工业社会的技术进步，都可置于这一维度上；</p><p>社会情感：随着社会结构的演变，例如，从皇权的社会演变为民主或现代的社会，人们的情感也发生改变。在人类情感当中，几乎没有不是社会的情感。可能有例外，就是“宗教感”。在今天，学术界达成共识：信仰是纯粹的私人事件。除了信仰之外，其他几乎可以列举出来的情感，都是社会情感。</p><p>精神生活：这里可以发生导致社会变迁的重要力量。例如在欧洲社会变迁过程中，如韦伯论证的那样，宗教和信仰的改变，有决定性的意义。</p><p>文化表达过程中社会网络和文化资本对文化表达几乎处处存在重要的影响，这就引导我们到行为经济学和社会学交叉的一个界面——所谓“社会资本”问题。</p><blockquote><p>社会资本：</p></blockquote><p>社会资本就是一个社会网络内存在的全部有利于囚徒困境合作解的那些因素。</p><p>全部社会科学的基本问题，在过去的一个世纪里，是要解释“社会何以可能”。全部行为经济学的基本问题，至今为止，是要解释“合作何以可能”。社会网络的社会资本定义是内生演化的社会资本，注意，这里的社会资本不再是给定的，它是内生的，是演化的。如果合作的人群规模太小，那么它会完全消失。如果合作规模超过了例如三分之一定律所要求的范围，那么它会扩展到全部网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书是北大ccer教授汪丁丁2010年在北京大学讲授“行为经济学”课程的课堂讲义，书内汪教授内容旁征博引，涉及心理学、社会学、经济学、博弈论、神经脑科学等，各种各样的知识模块扑面而来，整理至此。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="行为" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA/"/>
    
      <category term="价值" scheme="http://yoursite.com/tags/%E4%BB%B7%E5%80%BC/"/>
    
      <category term="判断" scheme="http://yoursite.com/tags/%E5%88%A4%E6%96%AD/"/>
    
      <category term="传统" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F/"/>
    
      <category term="海纳模型" scheme="http://yoursite.com/tags/%E6%B5%B7%E7%BA%B3%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（6）：collections</title>
    <link href="http://yoursite.com/2018/01/28/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9Acollections/"/>
    <id>http://yoursite.com/2018/01/28/python编程系列（6）：collections/</id>
    <published>2018-01-28T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="collections" scheme="http://yoursite.com/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（5）：functools</title>
    <link href="http://yoursite.com/2018/01/26/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9Afunctools/"/>
    <id>http://yoursite.com/2018/01/26/python编程系列（5）：functools/</id>
    <published>2018-01-26T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="functools" scheme="http://yoursite.com/tags/functools/"/>
    
  </entry>
  
  <entry>
    <title>读书记（11）：存在主义书单</title>
    <link href="http://yoursite.com/2018/01/25/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E4%B9%A6%E5%8D%95/"/>
    <id>http://yoursite.com/2018/01/25/读书记（11）：存在主义书单/</id>
    <published>2018-01-25T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>存在主义相关书籍整理。</p><a id="more"></a><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1463876/" target="_blank" rel="noopener">存在主义</a></td><td>[美] W. 考夫曼 编著</td><td>商务印书馆</td><td>8.3 (163人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10575149/" target="_blank" rel="noopener">存在主义</a></td><td>[美]科珀</td><td>复旦大学出版社</td><td>8.4 (41人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/27170538/" target="_blank" rel="noopener">存在主义咖啡馆</a></td><td>[英]  莎拉·贝克韦尔</td><td>北京联合出版公司</td><td>9.0 (567人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2222359/" target="_blank" rel="noopener">非理性的人</a></td><td>[美] 威廉·巴雷特</td><td>上海译文出版社</td><td>9.0(463人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3034229/" target="_blank" rel="noopener">存在主义简论</a></td><td>[美]托马斯·R，弗林</td><td>外语教学与研究出版社</td><td>8.2 (284人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2051548/" target="_blank" rel="noopener">人的奴役与自由</a></td><td>[俄]尼古拉·别尔嘉耶夫</td><td>贵州人民出版社</td><td>8.9 (105人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1038306/" target="_blank" rel="noopener">思·史·诗</a></td><td>[中]叶秀山</td><td>人民出版社</td><td>8.6 (45人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1127271/" target="_blank" rel="noopener">另类人</a></td><td>[美]科林·威尔逊</td><td>经济日报出版社</td><td>8.3 (100人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1907590/" target="_blank" rel="noopener">从存在到存在者</a></td><td>[法]埃马纽埃尔·列维纳斯</td><td>江苏教育出版社</td><td>8.8 (141人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4314074/" target="_blank" rel="noopener">在生命最深处与人相遇</a></td><td>[美]朱瑟琳·乔塞尔森</td><td>机械工业</td><td>7.8 (186人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1051659/" target="_blank" rel="noopener">我与你</a></td><td>[德] 马丁·布伯</td><td>生活·读书·新知三联书店</td><td>8.9 (489人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2184710/" target="_blank" rel="noopener">生命的悲剧意识</a></td><td>[西]乌纳穆诺</td><td>花城出版社</td><td>8.2 (258人评价)</td></tr></tbody></table></div><h2 id="陀思妥耶夫斯基"><a href="#陀思妥耶夫斯基" class="headerlink" title="陀思妥耶夫斯基"></a>陀思妥耶夫斯基</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1856494/" target="_blank" rel="noopener">卡拉马佐夫兄弟</a></td><td>[俄]陀思妥耶夫斯基</td><td>上海译文出版社</td><td>9.4(7818人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1022632/" target="_blank" rel="noopener">罪与罚</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>9.1(5075人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1859108/" target="_blank" rel="noopener">白痴</a></td><td>[俄]陀思妥耶夫斯基</td><td>上海译文出版社</td><td>8.9(3775人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/21993104/" target="_blank" rel="noopener">白夜</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>8.1(2604人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10759466/" target="_blank" rel="noopener">地下室手记</a></td><td>[俄] 陀思妥耶夫斯基</td><td>漓江出版社</td><td>9.1(1927人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1088418/" target="_blank" rel="noopener">死屋手记</a></td><td>[俄] 陀思妥耶夫斯基</td><td>人民文学出版社</td><td>9.1(1356人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1027002/" target="_blank" rel="noopener">被欺凌与被侮辱的</a></td><td>[俄] 陀思妥耶夫斯基</td><td>人民文学出版社</td><td>8.6(1075人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1437488/" target="_blank" rel="noopener">群魔</a></td><td>[俄] 陀思妥耶夫斯基</td><td>译林出版社</td><td>9.3(691人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5391978/" target="_blank" rel="noopener">作家日记（上下）</a></td><td>[俄] 陀思妥耶夫斯基</td><td>河北教育出版社</td><td>8.4(40人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2140416/" target="_blank" rel="noopener">穷人的美德 : 陀思妥耶夫斯基天才犯罪论集</a></td><td>[俄] 陀思妥耶夫斯基</td><td>天津人民出版社</td><td>7.3(270人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2055794/" target="_blank" rel="noopener">赌徒</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>9.0(217人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3752758/" target="_blank" rel="noopener">少年</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>8.7(165人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3191428/" target="_blank" rel="noopener">舅舅的梦</a></td><td>[俄] 陀思妥耶夫斯基</td><td>山西人民出版社</td><td>8.0(45人评价)</td></tr><tr><td><a href="">人不单靠面包活着 : 陀思妥耶夫斯基书信选</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>8.5(121人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3723571/" target="_blank" rel="noopener">陀思妥耶夫斯基论艺术</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海书店出版社</td><td>8.5(89人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6878082/" target="_blank" rel="noopener">托尔斯泰或陀思妥耶夫斯基</a></td><td>[美]乔治·斯坦纳</td><td>浙江大学出版社</td><td>8.8(215人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4149229/" target="_blank" rel="noopener">托尔斯泰与陀思妥耶夫斯基（上下）</a></td><td>[俄]梅列日科夫斯基</td><td>华夏出版社</td><td>9.3(193人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1031244/" target="_blank" rel="noopener">鬼</a></td><td>[俄] 陀思妥耶夫斯基</td><td>上海译文出版社</td><td>9.3(252人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1083030/" target="_blank" rel="noopener">双重人格 地下室手记</a></td><td>[俄] 陀思妥耶夫斯基</td><td>译林出版社</td><td>9.0(687人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3127208/" target="_blank" rel="noopener">女房东</a></td><td>[俄] 陀思妥耶夫斯基</td><td>文光书店</td><td>8.6(11人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5391972/" target="_blank" rel="noopener">穷人</a></td><td>[俄] 陀思妥耶夫斯基</td><td>河北教育出版社</td><td>8.3(82人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3069267/" target="_blank" rel="noopener">陀思妥耶夫斯基的世界观</a></td><td>[俄]尼·别尔嘉耶夫</td><td>广西师范大学出版社</td><td>9.0(187人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2219824/" target="_blank" rel="noopener">文化的哲学</a></td><td>[俄]尼·别尔嘉耶夫</td><td>上海人民出版社</td><td>8.3(44人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1916659/" target="_blank" rel="noopener">关于陀思妥耶夫斯基的六次讲座</a></td><td>[俄] 陀思妥耶夫斯基</td><td>广西师范大学出版社</td><td>8.6(372人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1937449/" target="_blank" rel="noopener">陀思妥耶夫斯基诗学问题 : 复调小说理论</a></td><td>[俄]巴赫金</td><td>生活·读书·新知三联书店</td><td>9.2(236人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/11442818/" target="_blank" rel="noopener">读书与识字 : 陀思妥耶夫斯基读书随笔</a></td><td>[俄]陀思妥耶夫斯基</td><td>金城出版社</td><td>7.3(32人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/21778431/" target="_blank" rel="noopener">同时代人回忆陀思妥耶夫斯基</a></td><td>[俄罗斯]多利宁</td><td>广西师范大学出版社</td><td>8.7(30人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1023893/" target="_blank" rel="noopener">陀思妥耶夫斯基的三次爱情</a></td><td>[美]马克・斯洛尼姆</td><td>广西师范大学出版社</td><td>7.7(88人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26370027/" target="_blank" rel="noopener">尼采与陀思妥耶夫斯基 : 关于悲剧哲学的随笔</a></td><td>[俄]列夫·舍斯托夫</td><td>华东师范大学出版社</td><td>8.4(55人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1007492/" target="_blank" rel="noopener">在约伯的天平上</a></td><td>[俄]舍斯托夫</td><td>上海人民出版社</td><td>9.0 (163人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1312056/" target="_blank" rel="noopener">陀思妥耶夫斯基哲学 : 系统论述</a></td><td>[德] 赖因哈德·劳特</td><td>广西师范大学出版社</td><td>8.3(64人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2266148/" target="_blank" rel="noopener">伪君子及其崇拜者 : 摘自一个无名氏的回忆录</a></td><td>[俄]陀思妥耶夫斯基</td><td>云南人民出版社</td><td>8.1(30人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25843679/" target="_blank" rel="noopener">陀思妥耶夫斯基（第1卷）</a></td><td>[美] 约瑟夫·弗兰克</td><td>广西师范大学出版社</td><td>8.8(87人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4838110/" target="_blank" rel="noopener">陀思妥耶夫斯基诗学问题</a></td><td>[中]巴赫金</td><td>中央编译出版社</td><td>8.3(73人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1040092/" target="_blank" rel="noopener">忧郁的先知:陀思妥耶夫斯基</a></td><td>[中]冯川</td><td>四川人民出版社</td><td>8.4(32人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1910461/" target="_blank" rel="noopener">陀思妥耶夫斯基小说艺术研究</a></td><td>[中]彭克巽</td><td>北京大学出版社</td><td>7.7(32人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2350321/" target="_blank" rel="noopener">冬天记的夏天印象</a></td><td>[俄]陀思妥耶夫斯基</td><td>人民文学出版社</td><td>8.1(11人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26670936/" target="_blank" rel="noopener">诚实的贼</a></td><td>[俄]陀思妥耶夫斯基</td><td>新星出版社</td><td>8.6(20人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1833520/" target="_blank" rel="noopener">宗教文化语境下的陀思妥耶夫斯基诗学</a></td><td>[中]王志耕</td><td>北京师范大学出版社</td><td>8.4(29人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2297973/" target="_blank" rel="noopener">陀思妥耶夫斯基与世界文学</a></td><td>[俄]弗里德连杰尔</td><td>上海译文出版社</td><td>8.3(11人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10540819/" target="_blank" rel="noopener">巴登夏日 : 关于陀思妥耶夫斯基的一切</a></td><td>[俄]列昂尼德·茨普金</td><td>南海出版公司</td><td>8.1(191人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3546274/" target="_blank" rel="noopener">精神领袖 : 俄罗斯思想家论陀思妥耶夫斯基</a></td><td>[俄]索洛维约夫 等著</td><td>上海译文出版社</td><td>9.4(99人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5269156/" target="_blank" rel="noopener">道德·上帝与人 : 陀思妥耶夫斯基的问题</a></td><td>[中]何怀宏</td><td>北京大学出版社</td><td>8.8(60人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1287628/" target="_blank" rel="noopener">漂泊的灵魂 : 陀思妥耶夫斯基与俄罗斯传统文化</a></td><td>[中]赵桂莲</td><td>北京大学出版社</td><td>8.0(31人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2101439/" target="_blank" rel="noopener">三大师 : 巴尔扎克 狄更斯 陀思妥耶夫斯基</a></td><td>[奥地利]茨威格</td><td>安徽文艺出版社</td><td>8.8(24人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/21778487/" target="_blank" rel="noopener">安娜·陀思妥耶夫斯卡娅回忆录</a></td><td>[俄]安娜·陀思妥耶夫斯卡娅</td><td>广西师范大学出版社</td><td>8.6(80人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/21778060/" target="_blank" rel="noopener">一八六七年日记</a></td><td>[俄]安娜·陀思妥耶夫斯卡娅</td><td>广西师范大学出版社</td><td>7.8(29人评价)</td></tr></tbody></table></div><h2 id="列夫·托尔斯泰"><a href="#列夫·托尔斯泰" class="headerlink" title="列夫·托尔斯泰"></a>列夫·托尔斯泰</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1255288/" target="_blank" rel="noopener">复活</a></td><td>[俄]列夫·托尔斯泰</td><td>人民文学出版社</td><td>8.0(15307人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1013469/" target="_blank" rel="noopener">战争与和平</a></td><td>[俄] 列夫·托尔斯泰</td><td>人民文学出版社</td><td>8.7(4791人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2253380/" target="_blank" rel="noopener">安娜·卡列尼娜</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>9.2(2708人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2266567/" target="_blank" rel="noopener">伊凡·伊里奇的死</a></td><td>[俄] 列夫·托尔斯泰</td><td>山西人民出版社</td><td>9.2(513人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1959124/" target="_blank" rel="noopener">生活之路</a></td><td>[俄] 列夫·托尔斯泰</td><td>中国人民大学出版社</td><td>8.9(274人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4841506/" target="_blank" rel="noopener">忏悔录</a></td><td>[俄] 列夫·托尔斯泰</td><td>中国对外翻译</td><td>8.4(332人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1445012/" target="_blank" rel="noopener">艺术论</a></td><td>[俄] 列夫·托尔斯泰</td><td>中国人民大学出版社</td><td>8.4(80人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1833518/" target="_blank" rel="noopener">生活值得过吗</a></td><td>[俄] 列夫·托尔斯泰</td><td>中国发展出版社</td><td>8.2(107人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6863526/" target="_blank" rel="noopener">克莱采奏鸣曲</a></td><td>[俄] 列夫·托尔斯泰</td><td>译林出版社</td><td>8.7(114人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3076983/" target="_blank" rel="noopener">哈吉穆拉特</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.7(102人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3076990/" target="_blank" rel="noopener">哥萨克</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.8(90人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10742716/" target="_blank" rel="noopener">忏悔录</a></td><td>[俄] 列夫·托尔斯泰</td><td>译林出版社</td><td>8.9(133人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3076988/" target="_blank" rel="noopener">童年·少年·青年</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.4(92人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3076987/" target="_blank" rel="noopener">一个地主的早晨</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.5(59人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1232992/" target="_blank" rel="noopener">托尔斯泰传</a></td><td>罗曼·罗兰</td><td>商务印书馆</td><td>7.7(93人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25894989/" target="_blank" rel="noopener">生活之路</a></td><td>[俄] 列夫·托尔斯泰</td><td>商务印书馆</td><td>8.0(25人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1186367/" target="_blank" rel="noopener">托尔斯泰中短篇小说选</a></td><td>[俄] 列夫·托尔斯泰</td><td>人民文学出版社</td><td>9.2(57人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3741314/" target="_blank" rel="noopener">生活即幸福</a></td><td>[俄] 列夫·托尔斯泰</td><td>长江文艺出版社</td><td>8.3(33人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1896422/" target="_blank" rel="noopener">论科学和艺术的价值</a></td><td>[俄] 列夫·托尔斯泰</td><td>江苏教育出版社</td><td>7.7(18人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3626317/" target="_blank" rel="noopener">家庭的幸福</a></td><td>[俄] 列夫·托尔斯泰</td><td>浙江人民出版社</td><td>9.3(18人评价)</td></tr><tr><td><a href="">谢尔基神父</a></td><td></td><td>四川人民出版社</td><td>8.1(26人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1079617/" target="_blank" rel="noopener">哥萨克</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.8(33人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1327345/" target="_blank" rel="noopener">自画像 : 卡萨诺瓦、司汤达、托尔斯泰</a></td><td>[奥]斯蒂芬 茨威格</td><td>西苑出版社</td><td>8.5(52人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1062826/" target="_blank" rel="noopener">一个地主的早晨</a></td><td>[俄] 列夫·托尔斯泰</td><td>上海文艺出版社</td><td>8.6(25人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1125262/" target="_blank" rel="noopener">托尔斯泰忏悔录</a></td><td>[俄] 列夫·托尔斯泰</td><td>华文出版社</td><td>8.6(203人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/11636793/" target="_blank" rel="noopener">歌德与托尔斯泰</a></td><td>[德]托马斯·曼</td><td>浙江大学出版社</td><td>8.1(51人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/19980346/" target="_blank" rel="noopener">伊万·伊里奇之死</a></td><td>[俄] 列夫·托尔斯泰</td><td>江苏文艺出版社</td><td>9.0(104人评价)</td></tr></tbody></table></div><h2 id="索伦-克尔凯郭尔"><a href="#索伦-克尔凯郭尔" class="headerlink" title="索伦.克尔凯郭尔"></a>索伦.克尔凯郭尔</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3987027/" target="_blank" rel="noopener">非此即彼(上卷)</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>8.6 (306人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3987029/" target="_blank" rel="noopener">非此即彼(下卷)</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>9.3 (91人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1506334/" target="_blank" rel="noopener">论反讽概念 : 以苏格拉底为主线</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>9.2 (158人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/24697397/" target="_blank" rel="noopener">畏惧与颤栗 恐惧的概念 致死的疾病 </a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>9.5 (98人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26285475/" target="_blank" rel="noopener">爱的作为 : 克尔凯郭尔文集7</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>9.3 (29人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/24697574/" target="_blank" rel="noopener">哲学片断</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国社会科学出版社</td><td>8.7 (48人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1015145/" target="_blank" rel="noopener">十八训导书</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国工人出版社</td><td>7.9 (70人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1019043/" target="_blank" rel="noopener">哲学寓言集</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>商务印书馆</td><td>8.3 (117人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3737103/" target="_blank" rel="noopener">克尔凯郭尔</a></td><td>[英]加迪纳</td><td>译林出版社</td><td>7.8 (200人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1044502/" target="_blank" rel="noopener">颤栗与不安</a></td><td>[丹麦] 克尔凯郭尔</td><td>陕西师范大学出版社</td><td>8.0 (275人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1462846/" target="_blank" rel="noopener">克尔凯戈尔日记选</a></td><td>[丹] 彼德·P. 罗德 编</td><td>上海社会科学院出版社</td><td>8.8 (265人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1008757/" target="_blank" rel="noopener">致死的疾病</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中国工人出版社</td><td>9.0 (255人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1020296/" target="_blank" rel="noopener">恐惧与颤栗</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>华夏出版社</td><td>8.6 (408人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1776823/" target="_blank" rel="noopener">勾引家日记</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>作家出版社</td><td>8.3(128人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1011746/" target="_blank" rel="noopener">基督徒的激情</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>中央编译出版社</td><td>7.9(203人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1219658/" target="_blank" rel="noopener">百合·飞鸟·女演员</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>华夏出版社</td><td>7.8(151人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/27052079/" target="_blank" rel="noopener">人生道路诸阶段</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>商务印书馆</td><td>9.2(26人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1848182/" target="_blank" rel="noopener">论怀疑者</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>上海人民出版社</td><td>8.3(94人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25982699/" target="_blank" rel="noopener">克尔凯郭尔日记选</a></td><td>[丹]彼得•P.罗德</td><td>商务印书馆</td><td>8.3(86人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2974191/" target="_blank" rel="noopener">克尔凯郭尔：审美对象的建构</a></td><td>[德]T.W.阿多诺</td><td>人民出版社</td><td>7.6(30人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1784973/" target="_blank" rel="noopener">重复</a></td><td>[丹麦] 索伦.克尔凯郭尔</td><td>百花文艺出版社</td><td>8.1(56人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3243814/" target="_blank" rel="noopener">绝望的一跃 : 孤独天才克尔恺郭尔</a></td><td>[中]林和生</td><td>华文出版社</td><td>7.0(73人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1037836/" target="_blank" rel="noopener">克尔凯戈尔入门</a></td><td>[美]唐纳德・帕尔默</td><td>东方出版社</td><td>8.7(45人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1080005/" target="_blank" rel="noopener">旷野呼告</a></td><td>[俄] 列夫·舍斯托夫</td><td>华夏出版社</td><td>8.5(60人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1199056/" target="_blank" rel="noopener">克尔恺廓尔</a></td><td>[美]苏珊·李·安德森</td><td>中华书局</td><td>8.6(65人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1219218/" target="_blank" rel="noopener">不幸与幸福</a></td><td>[美]尼尔斯・托马森</td><td>华夏出版社</td><td>9.1(23人评价)</td></tr></tbody></table></div><h2 id="卡尔·雅思贝尔斯"><a href="#卡尔·雅思贝尔斯" class="headerlink" title="卡尔·雅思贝尔斯"></a>卡尔·雅思贝尔斯</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1482446/" target="_blank" rel="noopener">生存哲学</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>上海译文出版社</td><td>7.6 (88人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1315260/" target="_blank" rel="noopener">时代的精神状况</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>上海译文出版社</td><td>8.7 (230人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2082154/" target="_blank" rel="noopener">历史的起源与目标</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>华夏出版社</td><td>8.7(129人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1451698/" target="_blank" rel="noopener">什么是教育</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>生活·读书·新知三联书店</td><td>8.9(268人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2068955/" target="_blank" rel="noopener">大学之理念</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>上海人民出版社</td><td>8.9(228人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3878639/" target="_blank" rel="noopener">大哲学家</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>社会科学文献出版社</td><td>9.0(30人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3222032/" target="_blank" rel="noopener">苏格拉底、佛陀、孔子和耶稣</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>安徽文艺出版社</td><td>8.2(28人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1078603/" target="_blank" rel="noopener">尼采 : 其人其说</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>社会科学文献出版社</td><td>8.4(48人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/20387640/" target="_blank" rel="noopener">海德格尔与雅斯贝尔斯往复书简</a></td><td>[德]瓦尔特·比默尔 等编</td><td>上海人民出版社</td><td>8.2(37人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2026930/" target="_blank" rel="noopener">悲剧的超越</a></td><td>[德]卡尔·雅斯贝尔斯</td><td>工人出版社</td><td>8.8(71人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3227944/" target="_blank" rel="noopener">雅斯贝尔斯 : 大哲学家的生活与思想</a></td><td>[德]叔斯勒</td><td>中国人民大学出版社</td><td>7.5(18人评价)</td></tr></tbody></table></div><h2 id="尼采"><a href="#尼采" class="headerlink" title="尼采"></a>尼采</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1949061/" target="_blank" rel="noopener">不合时宜的沉思</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>8.5 (426人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1063852/" target="_blank" rel="noopener">悲剧的诞生 : 尼采美学文选</a></td><td>[德]尼采</td><td>生活·读书·新知三联书店</td><td>8.8(4002人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2359052/" target="_blank" rel="noopener">查拉图斯特拉如是说</a></td><td>[德]尼采</td><td>生活·读书·新知三联书店</td><td>8.9(4885人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1021702/" target="_blank" rel="noopener">偶像的黄昏</a></td><td>[德]尼采</td><td>光明日报出版社</td><td>8.6(1146人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1048672/" target="_blank" rel="noopener">尼采生存哲学</a></td><td>[德]尼采</td><td>九州出版社</td><td>8.0(1476人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2045704/" target="_blank" rel="noopener">权力意志 : 1885-1889年遗稿</a></td><td>[德]尼采</td><td>商务印书馆</td><td>8.9(522人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3016983/" target="_blank" rel="noopener">人性的，太人性的</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>9.1(441人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1949782/" target="_blank" rel="noopener">快乐的科学</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>8.6(667人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1245537/" target="_blank" rel="noopener">苏鲁支语录</a></td><td>[德]尼采</td><td>商务印书馆</td><td>9.2(658人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26264205/" target="_blank" rel="noopener">道德的谱系</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>9.3(148人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1057852/" target="_blank" rel="noopener">疯狂的意义 : 尼采超人哲学集</a></td><td>[德]尼采</td><td>陕西师范大学出版社</td><td>8.4(443人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1958791/" target="_blank" rel="noopener">朝霞</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>9.1(366人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1888070/" target="_blank" rel="noopener">尼采诗集</a></td><td>[德]尼采</td><td>中国文联出版社</td><td>8.3(318人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2008074/" target="_blank" rel="noopener">希腊悲剧时代的哲学</a></td><td>[德]尼采</td><td>商务印书馆</td><td>8.6(261人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10485841/" target="_blank" rel="noopener">作为教育家的叔本华</a></td><td>[德]尼采</td><td>译林出版社</td><td>8.8(267人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1048147/" target="_blank" rel="noopener">反基督 : 尼采论宗教文选</a></td><td>[德]尼采</td><td>河北教育出版社</td><td>8.2(140人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/23020036/" target="_blank" rel="noopener">重估一切价值</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>9.1(81人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/7056695/" target="_blank" rel="noopener">论我们教育机构的未来</a></td><td>[德]尼采</td><td>译林出版社</td><td>9.0(140人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6838057/" target="_blank" rel="noopener">瓦格纳事件 尼采反瓦格纳 : 尼采反瓦格纳</a></td><td>[德]尼采</td><td>商务印书馆</td><td>8.7(101人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26663535/" target="_blank" rel="noopener">善恶的彼岸</a></td><td>[德]尼采</td><td>商务印书馆</td><td>9.3(81人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10862503/" target="_blank" rel="noopener">狄俄尼索斯颂歌 : 经典与解释. 尼采注疏集</a></td><td>[德]尼采</td><td>华东师范大学出版社</td><td>9.0(50人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2134760/" target="_blank" rel="noopener">历史对于人生的利弊</a></td><td>[德]尼采</td><td>商务印书馆</td><td>8.8(64人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1851383/" target="_blank" rel="noopener">哲学与真理 : 尼采1872-1876年笔记选</a></td><td>[德]尼采</td><td>上海社会科学院出版社</td><td>9.2(60人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26782124/" target="_blank" rel="noopener">瞧！这个人</a></td><td>[德]尼采</td><td>商务印书馆</td><td>8.8(98人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4162698/" target="_blank" rel="noopener">生命的意志</a></td><td>[德]尼采</td><td>长江文艺</td><td>8.3(78人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10566744/" target="_blank" rel="noopener">尼采读本</a></td><td>[德]尼采</td><td>作家出版社</td><td>8.0(77人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1079104/" target="_blank" rel="noopener">尼采 : 在世纪的转折点上</a></td><td>周国平</td><td>上海人民出版社</td><td>8.6(3452人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2131382/" target="_blank" rel="noopener">尼采</a></td><td>[丹]乔治·勃兰兑斯</td><td>中国社会科学出版社</td><td>8.7(177人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1027608/" target="_blank" rel="noopener">我妹妹与我 : 尼采佚失的最后告白</a></td><td>[德]尼采</td><td>文化艺术出版社</td><td>8.0(448人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1448961/" target="_blank" rel="noopener">艺术与归家 : 尼采、海德格尔、福柯</a></td><td>余虹</td><td>中国人民大学出版社</td><td>8.9(187人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/19963460/" target="_blank" rel="noopener">与魔鬼作斗争 : 荷尔德林、克莱斯特、尼采</a></td><td>[奥地利] 斯蒂芬·茨威格</td><td>译林出版社</td><td>8.8(150人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1426732/" target="_blank" rel="noopener">尼采反卢梭 : 尼采的道德政治思想研究</a></td><td>凯斯.安塞尔-皮尔逊</td><td>华夏出版社</td><td>8.5(80人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5501445/" target="_blank" rel="noopener">幻觉的哲学 : 尼采八十年代手稿研究</a></td><td>[丹麦]哈斯</td><td>东方出版社</td><td>8.1(34人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1084691/" target="_blank" rel="noopener">墙上的书写 : 尼采与基督教</a></td><td>洛维特</td><td>华夏出版社</td><td>8.1(75人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1315167/" target="_blank" rel="noopener">历史的用途与滥用</a></td><td>[德]尼采</td><td>上海人民出版社</td><td>9.0(449人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1048524/" target="_blank" rel="noopener">尼采传 : 一个特立独行者的一生</a></td><td>丹尼尔・哈列维</td><td>贵州人民出版社</td><td>8.1(581人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1768046/" target="_blank" rel="noopener">从黑格尔到尼采 : 19世纪思维中的革命性决裂</a></td><td>卡尔·洛维特</td><td>生活·读书·新知三联书店</td><td>8.6(233人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1028095/" target="_blank" rel="noopener">缪斯的痛苦与激情 : 尼采、里尔克与萨乐美</a></td><td>周濂</td><td>社会科学文献出版社</td><td>7.3(22人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1531707/" target="_blank" rel="noopener">解读尼采 : 尼采哲学导读图</a></td><td>[法]吉尔·都鲁兹</td><td>百花文艺出版社</td><td>8.6(55人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1020182/" target="_blank" rel="noopener">尼采与柏拉图主义 : 思想与社会丛书</a></td><td>吴增定</td><td>上海人民出版社</td><td>8.5(335人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3097364/" target="_blank" rel="noopener">尼采与形而上学</a></td><td>周国平</td><td>新世界出版社</td><td>8.4(370人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1026171/" target="_blank" rel="noopener">尼采与哲学</a></td><td>[法] 吉尔·德勒兹</td><td>社会科学文献出版社</td><td>8.7(196人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25906249/" target="_blank" rel="noopener">导读尼采</a></td><td>李·斯平克斯</td><td>重庆大学出版社</td><td>8.6(131人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1940994/" target="_blank" rel="noopener">叔本华与尼采 : 一组演讲</a></td><td>格奥尔格·西美尔</td><td>上海译文出版社</td><td>8.8(96人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1958794/" target="_blank" rel="noopener">尼采思想传记</a></td><td>萨弗兰斯基</td><td>华东师范大学出版社</td><td>8.3(178人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1456201/" target="_blank" rel="noopener">施特劳斯与尼采</a></td><td>朗佩特</td><td>上海三联书店</td><td>8.5(91人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2568214/" target="_blank" rel="noopener">尼采与身体</a></td><td>汪民安</td><td>北京大学出版社</td><td>7.5(107人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3344643/" target="_blank" rel="noopener">尼采的使命 : 《善恶的彼岸》绎读</a></td><td>[美]朗佩特</td><td>华夏出版社</td><td>8.6(50人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/21330707/" target="_blank" rel="noopener">尼采传</a></td><td>玛克西米利安</td><td>云南美术出版社</td><td>9.0(42人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1795465/" target="_blank" rel="noopener">悲剧哲学家尼采</a></td><td>陈鼓应</td><td>上海人民出版社</td><td>7.7(169人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26911505/" target="_blank" rel="noopener">尼采：生命之为文学</a></td><td>[美] 亚历山大•内哈马斯</td><td>浙江大学出版社</td><td>9.5(15人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1795466/" target="_blank" rel="noopener">尼采新论</a></td><td>陈鼓应</td><td>上海人民出版社</td><td>7.6(90人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1313148/" target="_blank" rel="noopener">审美主义 : 从尼采到福柯</a></td><td>李晓林</td><td>社会科学文献出版社</td><td>8.0(35人评价)</td></tr></tbody></table></div><h2 id="海德格尔"><a href="#海德格尔" class="headerlink" title="海德格尔"></a>海德格尔</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/20508943/" target="_blank" rel="noopener">海德格尔</a></td><td>乔治·斯坦纳</td><td>浙江大学出版社</td><td>8.4(66人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1054907/" target="_blank" rel="noopener">海德格尔传</a></td><td>吕迪格尔·萨弗兰斯基</td><td>商务印书馆</td><td>8.5(93人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/22690655/" target="_blank" rel="noopener">海德格尔</a></td><td>[英国] 迈克尔·英伍德</td><td>译林出版社</td><td>7.7(50人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25894124/" target="_blank" rel="noopener">海德格尔</a></td><td>帕特里夏·奥坦伯德·约翰逊</td><td>中华书局</td><td>8.2(33人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1783111/" target="_blank" rel="noopener">存在与时间</a></td><td>[德] 马丁·海德格尔</td><td>生活·读书·新知三联书店</td><td>8.7  /  3305人评价</td></tr><tr><td><a href="https://book.douban.com/subject/25865394/" target="_blank" rel="noopener">《存在与时间》释义</a></td><td>张汝伦</td><td>上海人民出版社</td><td></td></tr><tr><td><a href="https://book.douban.com/subject/1030294/" target="_blank" rel="noopener">林中路</a></td><td>[德] 马丁·海德格尔</td><td>上海译文出版社</td><td>8.8  /  913人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1439792/" target="_blank" rel="noopener">形而上学导论</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>8.6  /  565人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1185730/" target="_blank" rel="noopener">海德格尔存在哲学</a></td><td>[德] 马丁·海德格尔</td><td>九州出版社</td><td>8.2 (136人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1052276/" target="_blank" rel="noopener">路标</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>8.9 (352人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1034534/" target="_blank" rel="noopener">人，诗意地安居</a></td><td>[德] 马丁·海德格尔</td><td>广西师范大学出版社</td><td>8.1 (539人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1074329/" target="_blank" rel="noopener">尼采（上下）</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>8.8  /  423人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1228316/" target="_blank" rel="noopener">荷尔德林诗的阐释</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>8.7  /  392人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1005360/" target="_blank" rel="noopener">面向思的事情</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>8.7  /  350人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1444141/" target="_blank" rel="noopener">演讲与论文集</a></td><td>[德] 马丁·海德格尔</td><td>生活·读书·新知三联书店</td><td>9.1  /  310人评价</td></tr><tr><td><a href="https://book.douban.com/subject/3226085/" target="_blank" rel="noopener">论真理的本质  </a></td><td>[德] 马丁·海德格尔</td><td>华夏出版社</td><td>9.3  /  129人评价</td></tr><tr><td><a href="https://book.douban.com/subject/2969222/" target="_blank" rel="noopener">现象学之基本问题</a></td><td>[德] 马丁·海德格尔</td><td>上海译文出版社</td><td>9.0  /  128人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1054203/" target="_blank" rel="noopener">尼采十讲 </a></td><td>[德] 马丁·海德格尔</td><td>中国言实出版社</td><td>7.6  /  108人评价</td></tr><tr><td><a href="https://book.douban.com/subject/4814377/" target="_blank" rel="noopener">同一与差异</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>9.1  /  96人评价</td></tr><tr><td><a href="https://book.douban.com/subject/10748231/" target="_blank" rel="noopener">哲学论稿</a></td><td>[德]马丁·海德格尔</td><td>商务印书馆</td><td>9.3  /  90人评价</td></tr><tr><td><a href="https://book.douban.com/subject/4262651/" target="_blank" rel="noopener">物的追问</a></td><td>[德]马丁·海德格尔</td><td>上海译文出版社</td><td>9.1  /  85人评价</td></tr><tr><td><a href="https://book.douban.com/subject/3277048/" target="_blank" rel="noopener">思的经验</a></td><td>[德]马丁·海德格尔</td><td>人民出版社</td><td>8.0  /  75人评价</td></tr><tr><td><a href="https://book.douban.com/subject/4908875/" target="_blank" rel="noopener">康德与形而上学疑难</a></td><td>[德]马丁·海德格尔</td><td>上海译文出版社</td><td>9.4  /  75人评价</td></tr><tr><td><a href="https://book.douban.com/subject/3587689/" target="_blank" rel="noopener">时间概念史导论</a></td><td>[德]马丁·海德格尔</td><td>商务印书馆</td><td>9.1  /  71人评价</td></tr><tr><td><a href="https://book.douban.com/subject/3507033/" target="_blank" rel="noopener">系于孤独之途</a></td><td>[德]马丁·海德格尔</td><td>天津人民出版社</td><td>8.2  /  62人评价</td></tr><tr><td><a href="https://book.douban.com/subject/1184348/" target="_blank" rel="noopener">荷尔德林的新神话</a></td><td>[德] 马丁·海德格尔</td><td>华夏出版社</td><td>8.2  /  37人评价</td></tr><tr><td><a href="https://book.douban.com/subject/3773128/" target="_blank" rel="noopener">存在论 </a></td><td>[德]马丁·海德格尔</td><td>人民出版社</td><td>8.3  /  37人评价</td></tr><tr><td><a href="https://book.douban.com/subject/26831802/" target="_blank" rel="noopener">根据律</a></td><td>[德] 马丁·海德格尔</td><td>商务印书馆</td><td>9.6  /  16人评价</td></tr><tr><td><a href="https://book.douban.com/subject/26687672/" target="_blank" rel="noopener">在通向语言的途中 </a></td><td>[德]马丁·海德格尔</td><td>商务印书馆</td><td>9.3  /  10人评价</td></tr><tr><td><a href="https://book.douban.com/subject/26641578/" target="_blank" rel="noopener">柏拉图的《智者》</a></td><td>[德]马丁·海德格尔</td><td>商务印书馆</td><td>9.4 (19人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25908551/" target="_blank" rel="noopener">亚里士多德哲学的基本概念</a></td><td>[德] 马丁·海德格尔</td><td>华夏出版社</td><td>9.1(22人评价)</td></tr><tr><td><a href="https://book.douban.com/series/24683" target="_blank" rel="noopener">海德格尔文集</a></td><td>[德] 马丁·海德格尔</td><td>华夏出版社</td><td>9.1  /  22人评价</td></tr><tr><td><a href="https://book.douban.com/subject/4011409/" target="_blank" rel="noopener">阿伦特与海德格尔 : 爱和思的故事</a></td><td>安东尼娅·格鲁嫩贝格</td><td>商务印书馆</td><td>7.6(175人评价)</td></tr><tr><td><a href="http://book.douban.com/subject/1084250/" target="_blank" rel="noopener">《存在与时间》读本</a></td><td>陈嘉映</td><td>三联书店</td><td>8.5(114人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2281398/" target="_blank" rel="noopener">海德格尔思想与中国天道</a></td><td>张祥龙</td><td>生活·读书·新知三联书店</td><td>8.6(153人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4062211/" target="_blank" rel="noopener">还原与给予 : 胡塞尔、海德格尔与现象学研究</a></td><td>[法] 让-吕克·马里翁</td><td>上海译文出版社</td><td>9.5(52人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4230644/" target="_blank" rel="noopener">分道而行 : 卡尔纳普、卡西尔和海德格尔</a></td><td>[美] 迈克尔·弗里德曼 / 张卜天</td><td>北京大学出版社</td><td>8.9(112人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1685331/" target="_blank" rel="noopener">海德格尔哲学概论</a></td><td>陈嘉映</td><td>北京三联书店</td><td>8.5(144人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4891166/" target="_blank" rel="noopener">策兰与海德格尔 : 一场悬而未决的对话：1951－1970</a></td><td>[美] 詹姆斯·K. 林恩</td><td>北京大学出版社</td><td>7.8(92人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3618179/" target="_blank" rel="noopener">海德格尔与其思想的开端 : 海德格尔年鉴 第一卷</a></td><td>[法]阿尔弗雷德·登克尔</td><td>商务印书馆</td><td>9.0(37人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2080776/" target="_blank" rel="noopener">海德格尔的根 : 尼采，国家社会主义和希腊人</a></td><td>[美]查尔斯·巴姆巴赫</td><td>上海书店出版社</td><td>8.0(56人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2117001/" target="_blank" rel="noopener">海德格尔与伦理学问题</a></td><td>韩潮</td><td>同济大学出版社</td><td>8.6(65人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4038589/" target="_blank" rel="noopener">存在的一代 : 海德格尔哲学在法国1927-1961</a></td><td>伊森•克莱因伯格</td><td>新星出版社</td><td>8.5(41人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26334505/" target="_blank" rel="noopener">海德格尔与哲学的开端</a></td><td>王庆节</td><td>生活·读书·新知三联书店</td><td>7.9(77人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1043194/" target="_blank" rel="noopener">说不可说之神秘 : 海德格尔后期思想研究</a></td><td>孙周兴</td><td>生活·读书·新知上海三联出版社</td><td>8.7(31人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25891896/" target="_blank" rel="noopener">论精神 : 海德格尔与问题</a></td><td>[法]雅克·德里达</td><td>上海译文出版社</td><td>9.1(21人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3107666/" target="_blank" rel="noopener">时间性：自身与他者 : 从胡塞尔、海德格尔到列维纳斯</a></td><td>王恒</td><td>江苏人民出版社</td><td>7.7(22人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10523191/" target="_blank" rel="noopener">时间与永恒 : 论海德格尔哲学中的时间问题</a></td><td>黄裕生</td><td>江苏人民出版社</td><td>9.3(24人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/25866227/" target="_blank" rel="noopener">时间与存在 : 胡塞尔与海德格尔现象学的基本问题</a></td><td>方向红</td><td>商务印书馆</td><td>8.4(33人评价)</td></tr></tbody></table></div><h2 id="加缪"><a href="#加缪" class="headerlink" title="加缪"></a>加缪</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1082469/" target="_blank" rel="noopener">加缪全集（全四册）</a></td><td>柳鸣九 / 沈志明 主编</td><td>河北教育出版社</td><td>9.3 (410人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1070246/" target="_blank" rel="noopener">置身于苦难与阳光之间</a></td><td>[法]加缪</td><td>上海三联书店</td><td>8.6 (1147人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2143761/" target="_blank" rel="noopener">西西弗的神话</a></td><td>[法]加缪</td><td>天津人民出版社</td><td>8.6 (770人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2255873/" target="_blank" rel="noopener">局外人 鼠疫</a></td><td>[法]加缪</td><td>译林出版社</td><td>9.0 (1591人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1266588/" target="_blank" rel="noopener">加缪</a></td><td>理查德·坎伯</td><td>中华书局</td><td>7.4 (129人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5951356/" target="_blank" rel="noopener">荒谬的自由</a></td><td>[法]加缪</td><td>江苏文艺出版社</td><td>8.2 (73人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1785371/" target="_blank" rel="noopener">正义者</a></td><td>[法]加缪</td><td>漓江出版社</td><td>9.2 (121人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1032706/" target="_blank" rel="noopener">第一个人</a></td><td>[法]阿尔贝・加缪</td><td>译林出版社</td><td>8.8 (172人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1951131/" target="_blank" rel="noopener">卡里古拉</a></td><td>[法]阿尔贝・加缪</td><td>桂冠</td><td>9.4 (171人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4317958/" target="_blank" rel="noopener">加缪传</a></td><td>[法] 奥利维·托德</td><td>商务印书馆</td><td>8.5 (76人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6021091/" target="_blank" rel="noopener">反与正·婚礼集·夏天集</a></td><td>[法] 阿贝尔·加缪</td><td>译林出版社</td><td>8.8 (451人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1034066/" target="_blank" rel="noopener">加缪文集</a></td><td>[法] 阿尔贝·加缪</td><td>译林出版社</td><td>9.1 (1882人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1320062/" target="_blank" rel="noopener">加缪和萨特</a></td><td>[美] 罗纳德·阿隆森</td><td>华东师范大学出版社</td><td>7.8 (217人评价)</td></tr></tbody></table></div><h2 id="萨特"><a href="#萨特" class="headerlink" title="萨特"></a>萨特</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1398463/" target="_blank" rel="noopener">萨特文集（全八卷）</a></td><td>[法] 让·保尔·萨特</td><td>人民文学出版社</td><td>9.0 (528人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2305738/" target="_blank" rel="noopener">存在与虚无</a></td><td>[法] 让·保尔·萨特</td><td>生活·读书·新知三联书店</td><td></td></tr><tr><td><a href="https://book.douban.com/subject/3040509/" target="_blank" rel="noopener">想象</a></td><td>[法] 让·保尔·萨特</td><td>上海译文出版社</td><td>7.3 (82人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1266117/" target="_blank" rel="noopener">自我的超越性</a></td><td>[法] 让·保尔·萨特</td><td>商务印书馆</td><td>7.8 (42人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1444025/" target="_blank" rel="noopener">存在主义是一种人道主义</a></td><td>[法] 让·保尔·萨特</td><td>上海译文出版社</td><td>8.5 (439人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2139903/" target="_blank" rel="noopener">魔鬼与上帝</a></td><td>[法] 让·保尔·萨特</td><td>漓江出版社</td><td>9.1 (57人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2213965/" target="_blank" rel="noopener">他人就是地狱</a></td><td>[法] 让·保尔·萨特</td><td>天津人民出版社</td><td>8.2 (1476人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1316536/" target="_blank" rel="noopener">萨特读本</a></td><td>[法] 让·保尔·萨特</td><td>人民文学出版社</td><td>8.5 (760人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1019171/" target="_blank" rel="noopener">词语</a></td><td>[法] 让·保尔·萨特</td><td>三联书店</td><td>8.5 (232人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3106705/" target="_blank" rel="noopener">萨特自述</a></td><td>[法] 让·保尔·萨特</td><td>天津人民出版社</td><td>7.3 (216人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1317885/" target="_blank" rel="noopener">寄语海狸</a></td><td>[法] 让·保尔·萨特</td><td>人民文学出版社</td><td>8.0 (201人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1433569/" target="_blank" rel="noopener">萨特的世纪</a></td><td>[法]贝尔纳·亨利·列维</td><td>商务印书馆</td><td>8.5 (85人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1459717/" target="_blank" rel="noopener">萨特研究</a></td><td>柳鸣九主编</td><td>中国社会科学出版社</td><td>7.7 (45人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1536639/" target="_blank" rel="noopener">萨特</a></td><td>[美] 理查德·坎伯</td><td></td><td></td></tr><tr><td><a href="https://book.douban.com/subject/1423369/" target="_blank" rel="noopener">百年萨特</a></td><td>黄忠晶</td><td>中央编译出版社</td><td>7.7 (342人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1665326/" target="_blank" rel="noopener">萨特精选集</a></td><td>[法] 让·保尔·萨特</td><td>北京燕山出版社</td><td>8.9 (186人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1016160/" target="_blank" rel="noopener">不惑之年（自由之路第一部）</a></td><td>[法] 让·保尔·萨特</td><td>中国文学出版社等</td><td>8.5 (74人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1040394/" target="_blank" rel="noopener">萨特论艺术</a></td><td>[法]萨特/ [美]韦德·巴斯金 编</td><td>中国人民大学出版社</td><td>7.6 (216人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1487995/" target="_blank" rel="noopener">文字生涯</a></td><td>[法] 让·保尔·萨特</td><td>人民文学出版社</td><td>8.5 (936人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1874508/" target="_blank" rel="noopener">厌恶及其他</a></td><td>[法] 让·保尔·萨特</td><td>上海译文出版社</td><td>9.1 (122人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4162701/" target="_blank" rel="noopener">超越生命的选择</a></td><td>[法] 让·保尔·萨特</td><td>长江文艺</td><td>7.9 (78人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1316536/" target="_blank" rel="noopener">萨特读本</a></td><td>[法] 让·保尔·萨特</td><td>人民文学出版社</td><td>8.5 (760人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1023557/" target="_blank" rel="noopener">萨特戏剧集(上下)</a></td><td>[法]让·保罗·萨特</td><td>安徽文艺出版社</td><td>9.1 (463人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2149157/" target="_blank" rel="noopener">墙</a></td><td>[法]让·保罗·萨特</td><td>安徽文艺出版社</td><td>8.6 (489人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1030554/" target="_blank" rel="noopener">恶心</a></td><td>[法]让·保罗·萨特</td><td>中国友谊出版公司</td><td>8.6 (1987人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1007824/" target="_blank" rel="noopener">萨特传</a></td><td>[法] 西蒙·波伏娃</td><td>百花洲文艺出版社</td><td>8.1(169人评价)</td></tr></tbody></table></div><h2 id="西蒙·波伏瓦"><a href="#西蒙·波伏瓦" class="headerlink" title="西蒙·波伏瓦"></a>西蒙·波伏瓦</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/4745949/" target="_blank" rel="noopener">第二性</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td>8.7(3568人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1079208/" target="_blank" rel="noopener">名士风流（全二册）</a></td><td>[法] 西蒙·波伏娃</td><td>中国书籍出版社</td><td>8.2 (78人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6310320/" target="_blank" rel="noopener">人都是要死的</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td>8.7(1209人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3081371/" target="_blank" rel="noopener">他人的血</a></td><td>[法] 西蒙·波伏娃</td><td>外国文学出版社</td><td>8.0 (13人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1088395/" target="_blank" rel="noopener">女宾</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td></td></tr><tr><td><a href="https://book.douban.com/subject/3722970/" target="_blank" rel="noopener">波伏娃：激荡的一生</a></td><td>[法] 弗朗西斯 / [法] 贡蒂埃</td><td>广西师范大学出版社</td><td>7.9 (453人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1211533/" target="_blank" rel="noopener">波伏瓦</a></td><td>萨莉·J·肖尔茨</td><td>中华书局</td><td>7.7 (41人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6795314/" target="_blank" rel="noopener">波伏瓦回忆录</a></td><td>[法] 西蒙·波伏娃</td><td>作家出版社</td><td>7.9(80人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/20375518/" target="_blank" rel="noopener">模糊性的道德</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td><a href="https://book.douban.com/subject/20375518/" target="_blank" rel="noopener">https://book.douban.com/subject/20375518/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10563558/" target="_blank" rel="noopener">长征 : 中国纪行</a></td><td>[法] 西蒙·波伏娃</td><td>作家出版社</td><td>7.7(59人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1861319/" target="_blank" rel="noopener">女人是什么</a></td><td>[法] 西蒙·波伏娃</td><td>中国文联出版公司</td><td>8.2(52人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2074937/" target="_blank" rel="noopener">一个与他人相当的人</a></td><td>[法] 西蒙·波伏娃</td><td>光明日报出版</td><td>7.3(94人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1796305/" target="_blank" rel="noopener">面对面 : 让-保罗·萨特与西蒙娜·德·波伏瓦</a></td><td>[美]黑兹尔·罗利</td><td>中信出版社</td><td>8.0(85人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10529773/" target="_blank" rel="noopener">独白</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td>7.9(521人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6310321/" target="_blank" rel="noopener">要焚毁萨德吗</a></td><td>[法] 西蒙·波伏娃</td><td>上海译文出版社</td><td>8.1(228人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1021037/" target="_blank" rel="noopener">波伏瓦 : 一位追求自由的女性</a></td><td>李亚凡</td><td>人民文学出版社</td><td>7.0(277人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1068246/" target="_blank" rel="noopener">越洋情书（上下卷）</a></td><td>[法] 西蒙·波伏娃</td><td>中国书籍出版社</td><td>7.8(165人评价)</td></tr></tbody></table></div><h2 id="梅洛·庞蒂"><a href="#梅洛·庞蒂" class="headerlink" title="梅洛·庞蒂"></a>梅洛·庞蒂</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3299026/" target="_blank" rel="noopener">辩证法的历险</a></td><td>[法]梅洛·庞蒂</td><td>上海译文出版社</td><td>7.8 (55人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1046468/" target="_blank" rel="noopener">知觉的首要地位及其哲学结论</a></td><td>[法]梅洛·庞蒂</td><td>三联书店</td><td>7.6 (44人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1458716/" target="_blank" rel="noopener">知觉现象学</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>7.5 (183人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2141589/" target="_blank" rel="noopener">眼与心</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>8.7 (148人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1135846/" target="_blank" rel="noopener">梅洛·庞蒂</a></td><td>丹尼尔.托马斯.普里莫兹克</td><td>中华书局</td><td>7.6 (33人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1253311/" target="_blank" rel="noopener">符号</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>6.8(52人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3069521/" target="_blank" rel="noopener">可见的与不可见的</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>7.9(43人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/6013775/" target="_blank" rel="noopener">理解梅洛·庞蒂 : 梅洛·庞蒂在当代</a></td><td>[法]梅洛·庞蒂</td><td>北京大学出版社</td><td>8.4(29人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1416721/" target="_blank" rel="noopener">世界的散文</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>9.1(39人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1444014/" target="_blank" rel="noopener">行为的结构</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>7.9(27人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1048338/" target="_blank" rel="noopener">哲学赞词</a></td><td>[法]梅洛·庞蒂</td><td>商务印书馆</td><td>8.0(37人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1488873/" target="_blank" rel="noopener">模糊暧昧的哲学 : 梅洛-庞蒂传</a></td><td>安德烈·罗宾耐</td><td>北京大学出版社</td><td>7.3(18人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2122177/" target="_blank" rel="noopener">隐喻的身体 : 梅洛·庞蒂身体现象学研究</a></td><td>张尧均</td><td>中国美术学院出版社</td><td>7.9(57人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/20444327/" target="_blank" rel="noopener">画与真 : 梅洛-庞蒂与中国山水画境</a></td><td>姜宇辉</td><td>上海人民出版社</td><td>8.3(28人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/24754292/" target="_blank" rel="noopener">表达与存在 : 梅洛-庞蒂现象学研究</a></td><td>宁晓萌</td><td>北京大学出版社</td><td>7.5(20人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1289092/" target="_blank" rel="noopener">感性的诗学 : 梅洛-庞蒂与法国哲学主流</a></td><td>杨大春</td><td>人民出版社</td><td>7.7(19人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/2043104/" target="_blank" rel="noopener">梅罗-庞蒂历史现象学研究</a></td><td>佘碧平</td><td>复旦大学出版社</td><td>7.7(11人评价)</td></tr></tbody></table></div><h2 id="罗洛·梅"><a href="#罗洛·梅" class="headerlink" title="罗洛·梅"></a>罗洛·梅</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3265824/" target="_blank" rel="noopener">存在之发现</a></td><td>[美]罗洛·梅</td><td>中国人民大学出版社</td><td>8.1 (73人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4839259/" target="_blank" rel="noopener">心理学与人类困境</a></td><td>[美]罗洛·梅</td><td>中国人民大学出版社</td><td>8.2 (74人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4839258/" target="_blank" rel="noopener">存在心理学</a></td><td>[美]施耐德/ [美]罗洛·梅</td><td>中国人民大学出版社</td><td>8.4 (49人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3298292/" target="_blank" rel="noopener">存在之发现</a></td><td>[美]罗洛·梅</td><td>中国人民大学出版社</td><td>7.9 (65人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3265210/" target="_blank" rel="noopener">创造的勇气</a></td><td>[美]罗洛·梅</td><td>中国人民大学出版社</td><td>8.3 (169人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4834600/" target="_blank" rel="noopener">自由与命运</a></td><td>[美]罗洛·梅</td><td>中国人民大学出版社</td><td>8.2 (175人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3265827/" target="_blank" rel="noopener">人的自我寻求</a></td><td>[美] 罗洛·梅</td><td>中国人民大学出版社</td><td>8.9 (441人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5361804/" target="_blank" rel="noopener">焦虑的意义</a></td><td>[美] 罗洛·梅</td><td>广西师范大学出版社</td><td>8.3 (469人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4834599/" target="_blank" rel="noopener">爱与意志</a></td><td>[美] 罗洛·梅</td><td>中国人民大学出版社</td><td>8.0(160人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/24720021/" target="_blank" rel="noopener">权力与无知:寻求暴力的根源</a></td><td>[美] 罗洛·梅</td><td>中国人民大学出版社</td><td>8.4(71人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/4839259/" target="_blank" rel="noopener">心理学与人类困境</a></td><td>[美] 罗洛·梅</td><td>中国人民大学出版社</td><td>8.2(74人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/11586652/" target="_blank" rel="noopener">祈望神话 : 祈望神话</a></td><td>[美] 罗洛·梅</td><td>中国人民大学出版社</td><td>8.5(24人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/10517480/" target="_blank" rel="noopener">存在 : 精神病学和心理学的新方向</a></td><td>[美]罗洛·梅，恩斯特·安杰</td><td>中国人民大学出版社</td><td>7.6(35人评价)</td></tr></tbody></table></div><h2 id="欧文·亚隆"><a href="#欧文·亚隆" class="headerlink" title="欧文·亚隆"></a>欧文·亚隆</h2><div class="table-container"><table><thead><tr><th>书名</th><th>作者</th><th>出版社</th><th>豆瓣评分</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2327264/" target="_blank" rel="noopener">日益亲近 : 心理治疗师与来访者的心灵对话</a></td><td>[美]欧文·亚隆</td><td>中国轻工业出版社</td><td>8.5(335人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5999507/" target="_blank" rel="noopener">妈妈及生命的意义</a></td><td>[美]欧文·亚隆</td><td>机械工业出版社</td><td>8.4(452人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3684193/" target="_blank" rel="noopener">叔本华的治疗</a></td><td>[美]欧文·亚隆</td><td>希望出版社</td><td>9.0(928人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/5940553/" target="_blank" rel="noopener">当尼采哭泣</a></td><td>[美]欧文·亚隆</td><td>机械工业出版社</td><td>8.8(2983人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26747834/" target="_blank" rel="noopener">在生命最深处与人相遇：欧文·亚隆思想传记 </a></td><td>[美]欧文·亚隆</td><td>机械工业出版社</td><td>8.2(53人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/3432953/" target="_blank" rel="noopener">爱情刽子手</a></td><td>[美]欧文·亚隆</td><td>希望出版社</td><td>8.9(576人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26304954/" target="_blank" rel="noopener">存在主义心理治疗</a></td><td>[美]欧文·亚隆</td><td>商务印书馆</td><td>9.5(210人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/1936756/" target="_blank" rel="noopener">诊疗椅上的谎言</a></td><td>[美]欧文·亚隆</td><td>四川大学出版社</td><td>8.6(1037人评价)</td></tr><tr><td><a href="https://book.douban.com/subject/26841312/" target="_blank" rel="noopener">给心理治疗师的礼物 </a></td><td>[美]欧文·亚隆</td><td>中国轻工业出版社</td><td>9.4(137人评价)</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存在主义相关书籍整理。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="存在主义" scheme="http://yoursite.com/tags/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（4）：itertools</title>
    <link href="http://yoursite.com/2018/01/25/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9Aitertools/"/>
    <id>http://yoursite.com/2018/01/25/python编程系列（4）：itertools/</id>
    <published>2018-01-25T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器具有惰性求值（Lazy evaluation）的特性，它的返回值是一个迭代对象，只有在对其进行for循环迭代时才真正的进行计算，这使得我们无需将大文件或者无限集合存储到内存中，而只需不断的进行遍历即可。</p><p>python内置的itertools模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，可以使用for循环或者next()来取值。</p><a id="more"></a><p>itertools模块提供的迭代器函数有以下几种类型：</p><ul><li>无限迭代器：生成一个无限序列，比如自然数序列 1、2、3、4、····</li><li>有限迭代器：接受一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；</li><li>组合生成器：序列的排列、组合，求序列的笛卡尔积等；</li></ul><h3 id="一、无限迭代器"><a href="#一、无限迭代器" class="headerlink" title="一、无限迭代器"></a>一、无限迭代器</h3><p>itertools模块提供了三个函数来生成一个无限序列迭代器，分别是：</p><ul><li><p>count(firstval,step=1)</p><ul><li>创建一个从firstval(默认值为0)开始，以step（默认值为1）为步长的无限整数迭代器</li></ul></li><li><p>cycle(iterable)</p><ul><li>对iterable中的元素反复执行循环，返回迭代器</li></ul></li><li><p>repeat(object[,times])</p><ul><li>反复生成object，如果给定times，则重复次数为times，否则为无限。</li></ul></li></ul><h4 id="1-1-count"><a href="#1-1-count" class="headerlink" title="1.1 count"></a>1.1 count</h4><p>count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.count(<span class="number">4</span>,<span class="number">2</span>):</div><div class="line">    print(i)</div><div class="line">    <span class="keyword">if</span> i&gt;<span class="number">10</span>: <span class="keyword">break</span></div><div class="line"></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">12</span></div></pre></td></tr></table></figure><h4 id="1-2-cycle"><a href="#1-2-cycle" class="headerlink" title="1.2 cycle"></a>1.2 cycle</h4><p>cycle() 用于对 iterable 中的元素反复执行循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cnt = 0</div><div class="line">for i in itertools.cycle(&apos;hello&apos;):</div><div class="line">    print(i)</div><div class="line">    cnt+=1</div><div class="line">    if cnt%8==0:break</div><div class="line"></div><div class="line">h</div><div class="line">e</div><div class="line">l</div><div class="line">l</div><div class="line">o</div><div class="line">h</div><div class="line">e</div><div class="line">l</div><div class="line">```   </div><div class="line"></div><div class="line">### 1.3 repeat</div><div class="line">repeat() 用于反复生成一个 object：</div></pre></td></tr></table></figure><p>cnt = 0<br>for i in itertools.repeat([1,2,3]):<br>    print(i)<br>    cnt+=1<br>    if cnt%3==0: break</p><p>[1, 2, 3]<br>[1, 2, 3]<br>[1, 2, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 二、有限迭代器</div><div class="line">itertools模块提供了多个函数（类），接受一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：</div><div class="line"></div><div class="line">- chain()</div><div class="line">- compress()</div><div class="line">- groupby()</div><div class="line">- ifilter()</div><div class="line">- ifilterfalse()</div><div class="line">- islice()</div><div class="line">- imap()</div><div class="line">- starmap()</div><div class="line">- tee()</div><div class="line">- takewhile()</div><div class="line">- izip()</div><div class="line">- izip_longest()</div><div class="line"></div><div class="line"></div><div class="line">#### 2.1 chain</div><div class="line"></div><div class="line">chain的使用形式如下：</div></pre></td></tr></table></figure></p><p>chain(iterable1,iterable2,iterable3,···)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chain接收多个可迭代对象作为参数，将它们连接起来，作为一个新的迭代器返回。</div></pre></td></tr></table></figure></p><p>for i in itertools.chain([1,2,3],[4,5,6]):<br>    print(i)</p><p>1<br>2<br>3<br>4<br>5<br>6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chain还有一个常见的用法：</div></pre></td></tr></table></figure></p><p>chain.from_iterable(iterable)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">接收一个可迭代对象作为参数，返回一个迭代器：</div></pre></td></tr></table></figure></p><p>it = itertools.chain.from_iterable(‘abc’)<br>it.next()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.2 compress</div><div class="line">compress 的使用形式如下：</div></pre></td></tr></table></figure></p><p>compress(data, selectors)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：</div></pre></td></tr></table></figure></p><p>list(itertools.compress([1,2,3],[1,0,1]))<br>[1, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.3 dropwhile</div><div class="line">dropwhile 的使用形式如下：</div></pre></td></tr></table></figure></p><p>dropwhile(predicate, iterable)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。</div></pre></td></tr></table></figure></p><p>list(itertools.dropwhile(lambda x: x&gt;2,[3,4,5,2,3,4,1]))<br>[2, 3, 4, 1]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#### 2.4 groupby</div><div class="line"></div><div class="line">groupby 用于对序列进行分组，它的使用形式如下：</div></pre></td></tr></table></figure></p><p>groupby(iterable[, keyfunc])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。</div></pre></td></tr></table></figure></p><p>for key,value in itertools.groupby(‘aaabbccccss’):<br>    print(key,list(value))</p><p>(‘a’, [‘a’, ‘a’, ‘a’])<br>(‘b’, [‘b’, ‘b’])<br>(‘c’, [‘c’, ‘c’, ‘c’, ‘c’])<br>(‘s’, [‘s’, ‘s’])</p><p>for key,value in itertools.groupby([‘aaa’,’bb’,’cccc’,’ss’],len):<br>    print(key,list(value))</p><p>(3, [‘aaa’])<br>(2, [‘bb’])<br>(4, [‘cccc’])<br>(2, [‘ss’])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 2.5 ifilter</div><div class="line">ifilter 的使用形式如下：</div></pre></td></tr></table></figure></p><p>ifilter(function or None, sequence)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 True 的项。</div></pre></td></tr></table></figure></p><p>list(itertools.ifilter(lambda x:x<4,range(10))) [0,="" 1,="" 2,="" 3]="" list(itertools.ifilter(none,[1,2,3,0,1,2]))="" [1,="" 3,="" 2]="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifilterfalse 的使用形式和 ifilter 类似，作用正好与其相反，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。</div></pre></td></tr></table></4,range(10)))></p><p>list(itertools.ifilterfalse(lambda x:x<4,range(10))) [1,="" 2,="" 3,="" 1,="" 2]="" list(itertools.ifilterfalse(none,[1,2,3,0,1,2]))="" [0]="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.6 islice</div><div class="line">islice 是切片选择，它的使用形式如下：</div></pre></td></tr></table></4,range(10)))></p><p>islice(iterable, [start,] stop [, step])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。</div></pre></td></tr></table></figure></p><p>list(itertools.islice(itertools.count(),5))<br>[0, 1, 2, 3, 4]</p><p>list(itertools.islice(itertools.count(),2,10,2))<br>[2, 4, 6, 8]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.7 imap</div><div class="line">imap 类似 map 操作，它的使用形式如下：</div></pre></td></tr></table></figure></p><p>imap(func, iter1, iter2, iter3, …)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imap 返回一个迭代器，元素为$func(i_1, i_2, i_3, ...)，i_1，i_2 $等分别来源于 iter1, iter2</div></pre></td></tr></table></figure></p><p>list(itertools.imap(lambda x,y:x*y,[1,2,3],[2,3,4]))<br>[2, 6, 12]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 2.8 tee</div><div class="line">tee 的使用形式如下：</div></pre></td></tr></table></figure></p><p>tee(iterable [,n])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。</div></pre></td></tr></table></figure></p><p>a,b,c = itertools.tee(‘asdf’,3)<br>list(a)<br>[‘a’, ‘s’, ‘d’, ‘f’]<br>list(b)<br>[‘a’, ‘s’, ‘d’, ‘f’]<br>a==b<br>False</p><p>itertools.tee(‘asdf’,3)<br>(<itertools.tee at="" 0x7f6bb43608c0="">,<br> <itertools.tee at="" 0x7f6bb4360908="">,<br> <itertools.tee at="" 0x7f6bb43605f0="">)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 2.9 takewhile</div><div class="line">takewhile 的使用形式如下：</div></pre></td></tr></table></figure></itertools.tee></itertools.tee></itertools.tee></p><p>takewhile(predicate, iterable)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。</div></pre></td></tr></table></figure></p><p>list(itertools.takewhile(lambda x:x&gt;3,[4,5,2]))<br>[4, 5]<br>list(itertools.takewhile(lambda x:x&gt;3,[1,4,5,2]))<br>[]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 2.10 izip</div><div class="line">izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：</div></pre></td></tr></table></figure></p><p>izip(iter1, iter2, …, iterN)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果某个可迭代对象不再生成值，则迭代停止。</div></pre></td></tr></table></figure></p><p>for i in itertools.izip([1,2,3],[2,3,4,5]):<br>    print(i)<br>(1, 2)<br>(2, 3)<br>(3, 4)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">izip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：</div></pre></td></tr></table></figure></p><p>izip_longest(iter1, iter2, …, iterN, [fillvalue=None])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。</div></pre></td></tr></table></figure></p><p>for i in itertools.izip_longest([1,2,3],[2,3,4,5]):<br>    print(i)<br>(1, 2)<br>(2, 3)<br>(3, 4)<br>(None, 5)</p><p>for i in itertools.izip_longest([1,2,3],[2,3,4,5],fillvalue=0):<br>    print(i)<br>(1, 2)<br>(2, 3)<br>(3, 4)<br>(0, 5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### 三、组合生成器</div><div class="line"></div><div class="line">itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：</div><div class="line"></div><div class="line">-  product</div><div class="line">- permutations</div><div class="line">- combinations</div><div class="line">- combinations_with_replacement</div><div class="line"></div><div class="line">#### 3.1 product</div><div class="line">product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：</div></pre></td></tr></table></figure></p><p>product(iter1, iter2, … iterN, [repeat=1])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，</div></pre></td></tr></table></figure></p><p>for i in itertools.product(‘ab’,’cd’):<br>    print(i)<br>(‘a’, ‘c’)<br>(‘a’, ‘d’)<br>(‘b’, ‘c’)<br>(‘b’, ‘d’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3.2 permutations</div><div class="line">permutations 用于生成一个排列，它的一般使用形式如下：</div></pre></td></tr></table></figure></p><p>permutations(iterable[, r])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</div></pre></td></tr></table></figure></p><p>list(itertools.permutations(‘ad’,2))<br>[(‘a’, ‘d’), (‘d’, ‘a’)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3.3 combinations</div><div class="line">combinations 用于求序列的组合，它的使用形式如下：</div><div class="line"></div><div class="line">```</div><div class="line">combinations(iterable, r)</div></pre></td></tr></table></figure></p><p>其中，r 指定生成组合的元素的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list(itertools.combinations(&apos;ABC&apos;,2))</div><div class="line">[(&apos;A&apos;, &apos;B&apos;), (&apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;C&apos;)]</div></pre></td></tr></table></figure><p>combinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list(itertools.combinations_with_replacement(&apos;ABC&apos;,2))</div><div class="line">[(&apos;A&apos;, &apos;A&apos;), (&apos;A&apos;, &apos;B&apos;), (&apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;B&apos;), (&apos;B&apos;, &apos;C&apos;), (&apos;C&apos;, &apos;C&apos;)]</div></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://docs.python.org/2/library/itertools.html" target="_blank" rel="noopener">itertools — Functions creating iterators for efficient looping</a></li><li><a href="https://pymotw.com/2/itertools/" target="_blank" rel="noopener">itertools – Iterator functions for efficient looping - Python Module of the Week</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代器具有惰性求值（Lazy evaluation）的特性，它的返回值是一个迭代对象，只有在对其进行for循环迭代时才真正的进行计算，这使得我们无需将大文件或者无限集合存储到内存中，而只需不断的进行遍历即可。&lt;/p&gt;
&lt;p&gt;python内置的itertools模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，可以使用for循环或者next()来取值。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="itertools" scheme="http://yoursite.com/tags/itertools/"/>
    
      <category term="迭代器" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>读书记（10）：高宣扬讲存在主义（四）</title>
    <link href="http://yoursite.com/2018/01/23/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9A%E9%AB%98%E5%AE%A3%E6%89%AC%E8%AE%B2%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/23/读书记（10）：高宣扬讲存在主义（四）/</id>
    <published>2018-01-23T14:20:45.000Z</published>
    <updated>2018-11-05T16:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>一方面，存在主义试图用对存在本身的研究替代传统哲学对存在者的研究，在这个意义上说是抽象的。但是同时它又是富有生命情感的，只要我们深深的热爱自己的生命，不断地对自己的生命能够提出发问，感受自己生命经历中的一切，你就会觉得，存在主义是非常的有吸引力的，而且是跟你的生命是密切相关的</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnjor4hyj30qt0dhgox.jpg" alt=""></p><p>我刚才讲，这个关于语言的问题是海德格尔在谈到诠释学以后，开始进一步去展开的。所以他反复的讲“语言是存在的家”，他经常不断的去引用，运用语言运用到非常惟妙惟肖的高度的，这样一些著名的诗人的语言来说明。我这里在192页，引用了海德格尔对瑞士诗人格奥尔格•特拉克尔，Georg Trakl，这是1887年到1914年的一位诗人。他写了一首诗，题目叫做《一个冬天的夜晚》。我想从头到尾地念一下这首诗。</p><p>《一个冬天的夜晚》<br>正当雪花临窗<br>教堂晚钟长久回响。<br>千家万户摆好餐桌<br>家庭供应丰盛得当。</p><p>不只一个人还在旅程<br>经茫茫道途终临家门。<br>金果硕硕神恩之树，<br>屹立大地郁郁葱葱。</p><p>游子安详入室，<br>心情之哀痛使门槛顿时僵直。<br>一道金光闪耀<br>餐桌上摆设着面包和美酒。</p><p>这首诗非常深刻的，为什么？一方面这首诗用的诗的语言，把人生在世的那种曲折的历程，以及一个人怎么样经受了各种生活的煎熬、各种痛苦和快乐，然后最后在一个大雪纷飞的夜晚，在圣诞节的前夕，好不容易回到了久别的故乡，来到自己的家。这说明什么，感受到人生在世就是一种永远在旅途中游荡和飘荡的、反复不定的、充满着烦和忧虑的生活历程。这个生活历程就好像把人从自己的家给抛出去，然后在世界上经历了动荡波折以后，又到晚年把握了生命的要旨，然后要回到自己的家了，感受到原来生活就是如此。</p><p>这首诗就是以这样一种题目，来表达人生在世是怎么样通过自己的艰苦的经历，然后通过语言的表述，来说明“语言是存在的家”。你如果说往事有感想，但是找不着语言来说出来。那不行的，最后还是懵懵懂懂的。所以这点是海德格尔特别强调说，你要生活有意义，就应该像诗人那样生活在世界上。这就意味着必须要，一方面要对生活、对世界、对存在有一个深刻的把握，但另一方面又要学会通过语言去把握这个世界。这两个是同时存在的，同时必须要下功夫的。</p><p>所以海德格尔在晚年的时候，特别一再的感受到，一再的表示，他对他出生的故乡的怀念。他认为对故乡的怀念和对故乡的爱，他那种乡愁是他一生中，进行哲学思维的一个永远无止境的动力。他认为家乡给他生命的一个开端，家乡的父老兄弟给予他的各种各样，对他的关切和关注。</p><p>所以他特别强调说，在这个意义上说，哲学就是不断的回到原来的出发点，回到我当初出发的老家那边。而这个老家里面，给他感受最深的是老家的父老兄弟所说的语言，他说。那个语言是最亲切的。当我回到我的老家去，听到我老家的那个人讲的话，土话和方言的时候，我突然感受到一种非常的情感，感受到世界原来如此。正是在父老兄弟们，最早的时候自己所接受的母语的训练中，就已经包含着他此后一系列的对生命、对存在的理解，它的种子和芽，发芽的芽。</p><p>所以他特别重视这个，一再强调哲学就是要不断地回来，不断的跟原来的出发点进行对话。而且也特别提到，哲学在本质上就是感谢，就是回答所有的养育他成长，给予他营养，给予他精神启发的老师、故乡、父老兄弟的一种感谢、一种对话。</p><p>那么我想,关于存在主义这样一个东西，我在这里要特别强调说，一方面，存在主义是很抽象的。由于它试图扭转整个哲学研究的方向，把对存在的问题，把它提到本体论的高度。而且等于是把用传统哲学对存在者的研究把它代替，把它替代、改换成为对存在本身的研究，在这个意义上说是很难理解的。</p><p>但是同时它又是特别富有生命的情感的，是一个只要我们去深深的热爱我们自己的生命，只要我们不断地对自己的生命能够提出发问，不断地感受到自己生命经历中的一切一切，大大小小，从大的到最细的部分，到你的每时每刻所发生的脉搏的跳动的感受，很深地去理解的话，你就会觉得，存在主义是非常的有吸引力的，而且是跟你的生命是密切相关的。</p><p>而且人在存在的路上，在存在于世界上的路上，难免进入到危险的境界，他说。有很多风险，甚至会犯错误，会走在存在的错道上去。但是你真正的对存在，对自己的存在很关切的人，他才能够通过不断的反思。慢慢的，最后就好像前面所念的特拉克尔的诗歌《一个冬天的夜晚》所说的，一个流浪者到最后经过了千辛万苦，最后回到了家，也就是说回到了存在本身，把握了存在的奥秘，这样是不容易的。所以人生本质上是流浪的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一方面，存在主义试图用对存在本身的研究替代传统哲学对存在者的研究，在这个意义上说是抽象的。但是同时它又是富有生命情感的，只要我们深深的热爱自己的生命，不断地对自己的生命能够提出发问，感受自己生命经历中的一切，你就会觉得，存在主义是非常的有吸引力的，而且是跟你的生命是密切相关的&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="海德格尔" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%BE%B7%E6%A0%BC%E5%B0%94/"/>
    
      <category term="存在主义" scheme="http://yoursite.com/tags/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（3）：常用python标准库</title>
    <link href="http://yoursite.com/2018/01/23/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8python%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>http://yoursite.com/2018/01/23/python编程系列（3）：常用python标准库/</id>
    <published>2018-01-23T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.python.org/2/library/index.html" target="_blank" rel="noopener"> The Python Standard Library </a><br><a href="https://awesome-python.com/" target="_blank" rel="noopener">awesome-python</a></p><a id="more"></a><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>str</td><td></td><td></td></tr><tr><td>list</td><td></td><td></td></tr><tr><td>tuple</td><td></td><td></td></tr><tr><td>set</td><td></td><td></td></tr><tr><td>dict</td><td></td></tr></tbody></table></div><h3 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>nametuple</td><td></td><td></td></tr><tr><td>deque</td><td></td><td></td></tr><tr><td>Counter</td><td></td><td></td></tr><tr><td>OrderdDict</td><td></td><td></td></tr><tr><td>defaultdict</td><td></td></tr></tbody></table></div><h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>time</td><td></td><td></td></tr><tr><td>datetime</td><td></td><td></td></tr><tr><td>date</td><td></td><td></td></tr><tr><td>timedelta</td><td></td><td></td></tr><tr><td>calendar</td><td></td></tr></tbody></table></div><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>itertools</td><td></td><td></td></tr><tr><td>functools</td><td></td><td></td></tr><tr><td>operator</td><td></td></tr></tbody></table></div><h3 id="线程进程"><a href="#线程进程" class="headerlink" title="线程进程"></a>线程进程</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>threading</td><td></td><td></td></tr><tr><td>multiprocessing</td><td></td><td></td></tr><tr><td>concurrent</td><td></td><td></td></tr><tr><td>queue</td><td></td></tr></tbody></table></div><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>os</td><td></td><td></td></tr><tr><td>io</td><td></td><td></td></tr><tr><td>sys</td><td></td></tr></tbody></table></div><h3 id="综合模块"><a href="#综合模块" class="headerlink" title="综合模块"></a>综合模块</h3><div class="table-container"><table><thead><tr><th>模块</th><th>描述</th><th>方法</th></tr></thead><tbody><tr><td>re</td><td></td><td></td></tr><tr><td>json</td><td></td><td></td></tr><tr><td>math</td><td></td><td></td></tr><tr><td>hashlib</td><td></td><td></td></tr><tr><td>random</td><td></td><td></td></tr><tr><td>logging</td><td></td><td></td></tr><tr><td>unittest</td><td></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/library/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; The Python Standard Library &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://awesome-python.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;awesome-python&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="标准库" scheme="http://yoursite.com/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>读书记（9）：高宣扬讲存在主义（三）</title>
    <link href="http://yoursite.com/2018/01/22/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E9%AB%98%E5%AE%A3%E6%89%AC%E8%AE%B2%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/22/读书记（9）：高宣扬讲存在主义（三）/</id>
    <published>2018-01-22T14:20:45.000Z</published>
    <updated>2018-11-05T16:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>海德格尔一方面强调存在必须要通过此在的自我诠释去把握，另一方面在这个基础上，进一步提出了关于“语言是存在的家”，这样一个基本论断。因为人（此在）是唯一能够通过语言去把握存在的存在者</p><a id="more"></a><p>在海德格尔进行长期的研究之后，他提出了一个非常重要的方法，就是把诠释学纳入到存在哲学里面，纳入到存在论里面的基本的内容，作为存在论的基本内容。希腊神话中赫尔墨斯在传递神谕的时候，赫尔墨斯也承担了对各种神谕进行解释的权利。所以诠释学的原意，就是Hermeneutik，就是从Hermes。这个赫尔墨斯，诠释的神的名字，作为基本的基干、词干，然后衍生出来的。</p><p>但后来，到了基督教统治整个欧洲的时候，诠释学又变成了对《圣经》文本进行诠释的一种方法。这个方法在14到15世纪的时候，由于基督教的改革，特别是后来马丁・路德对《圣经》做了新的诠释。他特别强调，基督教的原意是通过教徒根据他个人的理性和他对自己的生活的体会，对《圣经》的每一句话进行自我诠释。所以教徒不应该把天主教会对《圣经》的诠释，把它作为一个神圣不可侵犯的教条来理解。</p><p>但是到了18世纪的时候，启蒙运动和浪漫主义兴起以后，德国的神学家和哲学家施莱尔马赫（Friedrich Schleiermacher, 1768-1834）又把这样一个原来意义上的，来自古希腊和罗马教会的诠释学改为对于文本的诠释的学问。那是施莱尔马赫所确定的。但是现在到了海德格尔这里，由于海德格尔特别强调，研究存在必须通过此在对存在的体会去进入到存在的本质。所以这就涉及到此在，它作为一个特殊的一个个人的亲在，他对自己的生活经历有自己特殊的体会。而且他有一种特殊的语言表达的能力，把自己亲在所经历的感悟，通过自己的特殊的、充满着自己的情感的语言、生活的语言，来表达出他对生存的经历的感受。这也就是他对存在的理解。</p><p>所以在海德格尔那里，诠释学从此以后，就从对文本的技术性的诠释变成为存在论的诠释。这是一个重大的转折。而且在西方的思想史上，这个贡献是很大的。就是在海德格尔这样的一个思想的指导下，海德格尔的学生,Hans-Georg Gadamer,伽达默尔，后来在20世纪60年代的时候，他进一步明确的提出了关于本体论的诠释学的一个新的转折。而且伽达默尔由于发表了《真理与方法》这本书，把本体论诠释学和哲学诠释学进一步扩大，变成为人文社会科学的一个新的基本逻辑，这是后话。</p><p>但是在这里我要谈到的是此在对亲在的体会，通过他自己的自我诠释来表达对存在的理解。这是在海德格尔的《存在与时间》里面特别强调的。这一点我们要特别重视。也就是说，我们自己也必须要意识到这点，要对存在、对于人生在世有所理解，而且对这种理解能够不断的总结、不断的改进、不断的提升。通过这种提升来进一步感悟自己的对人生的的理解，也就是说提升自己的对存在的理解，那么必须要特别重视，关于对自己的在世过程的诠释，这样一个方法。</p><p>海德格尔特别提到说，“此在”是通过自我言说来表达和不断提升自己对亲在的体验的。因此此在的自我言说、自我诠释，是此在再次生存的一个基本途径、基本方法、基本态度。就在这个诠释过程中，一方面表现了此在对世界的看法，对自己的生存和存在的理解，另一方面也体现了此在通过语言这个通道跟存在发生关系。在这里，就在这一点上，海德格尔特别强调，存在和语言的关系，人是一个唯一的，能够通过存在、能够通过语言去把握存在的这样一个存在者，这样一个存在。</p><p>所以必须要看到，能够如何通过自我表述、自我展现、自我言说来去临近、靠近，越来越靠近存在的本质。这是人有这个本事。他可以通过语言的表述、通过语言的体会的诠释，越来越深入的到存在的神秘的内部，去了解存在到底是什么。因此，海德格尔后来就是，一方面强调存在必须要通过此在的自我诠释去把握，另一方面他进一步在这个基础上，提出了关于“语言是存在的家”，这样一个基本论断。他特别提到说，Die Sprache ist das Haus des Seins。</p><p>“语言是存在的家”这句话，这句话是海德格尔后来在1927年发表他的《存在与时间》之后，在30年代之后，慢慢的进一步对存在、对存在语言的问题，进行了更深入的专门的研究。海德格尔越来越意识到，通过这一点意识到，要了解存在必须研究语言。因为前面已经说了，要了解存在必须通过此在，但是此在是唯一的一种能够同时了解和把握语言的艺术的存在，所以语言就成为了此在进入到存在的内部。它的进入到语言，通过语言进入到存在的家的内部，去了解存在的这样一个唯一的存在。</p><p>他特别强调，为了了解语言是存在的家，有必要对于存在有深刻的把握，同时又对语言有深刻的把握，这样一个存在者进行研究。这样一种对语言和存在同时有深刻把握的是什么呢？是谁呢？他认为是诗人。</p><p>诗人，Le Poète。他说，诗人之所以成为诗人，就在于诗人最懂得通过语言去把握存在。诗人之所以能够通过语言去把握存在，是因为诗人他最深刻的把握了存在的本质，他同时又能够通过他的语言，去把存在的本质表达出来。所以在这个意义上说，他后来，海德格尔特别强调，要特别重视研究诗歌，研究诗的语言。在这当中，海德格尔后来就特别越来越热爱德国天才的诗人――荷尔德林（Hölderlin）。</p><p>《存在主义》这本书的第四章，海德格尔进行哲学思想的有关诗歌的这部分，我在这里写了不少。在这里我顺便列举了一下。海德格尔特别提到，他说“语言就是语言”，这句话好像是同义反复。但是他特别强调“语言就是语言”，但前面的语言和后面的语言不一样。当说“语言就是语言”的时候，前面说的语言是指的一般人所理解的语言，但是后面的“就是语言”那个语言，后一个语言，他强调的是真正的语言。</p><p>所以“语言就是语言”。但是“语言就是语言”并不是所有人都明白。为什么“语言就是语言”？在这里海德格要强调的是说，语言就是那个真正作为存在的语言。语言就是作为存在的家的语言。他要说的是这个。所以当他说，语言本身，既非语言之外之他物，使语言成为语言，语言之为语言才使我们处于无底的深渊之上。所以他说，语言它的奥秘不是通过语言之外的其它物向我们展示，而是语言本身显示了语言的奥秘。</p><p>因为语言这个东西，只要是你有思想的话，当你使用语言的时候，你会感受到语言的那种既容易又难的这样的一个悖论。在语言中，在你使用语言的艺术中，你会体会到语言跟我们的生存，跟我们的生存于世的这样一个感受，有着非常深刻的然而是非常复杂的关系。有的时候我们想要用语言表达我们对生活的感受，但是恰恰是语言本身，又限制我们去表达对生活的感受。因为我们感受到说，用语言不容易，就好像我们生活在世界上不容易一样。你不要以为说，当我遇到一种处境的时候，我好像就可以很自在地表达我的感受。其实不然。你如果要真正地表达你的感受，你就会感受到，用语言去表达你的生活感受是非常难的，难到比登天还难。</p><p>所以他前面引用了哈曼（Johann Georg Hamann）的一封信，他特别提到，语言这个东西别小看它，好像我们人人都在讲话。但实际上语言是当你好好的去体会、去理解的时候，当你把语言跟你的生命连在一起的时候，你会感受到语言是一个无底的深渊，是一个没法把握的一种东西。他引用哈曼的一封信提到说，他说，语言这种东西弄得我们无法表达我们所要表达的东西。在这段话里面，他们特别强调，语言本身的强大的威力和它的价值，就在于它能够为我们人类的思维、精神活动以及一切属于人类属性的因素，提供一个永无边界、永无止境的线索，使得我们进入到一个无限广阔的维域。但是恰恰是因为这样，所以它既没有底基，也没有“他物”的限制，它就是不受一般存在物的时空限制的“存在”本身。</p><p>因此，语言是一个什么呢？是一个既靠近你，但同时又非常远离你。你要把握它，你要使用它，好像随手可得，但是你要真正的用语言去表达你的心里的感受的时候，你就感受到语言又是很难的，是需要一个你对你的生存有深刻的理解，有一种非常恰当的，就好像前面熊伟老师所说的，要对生活对存在一种恬然澄明的一种感受、感悟。就好像佛教所说的，你要真正的能够成佛，跟那个说，人人都能成佛，但是你真的是哪一个时候，你突然感受到，原来生活就是如此的时候，这个时候你才懂得你的这个世界到底是什么。而且也就在这个时候，你才懂得，其实世界的本质，我不用语言表达，我自己都把握了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;海德格尔一方面强调存在必须要通过此在的自我诠释去把握，另一方面在这个基础上，进一步提出了关于“语言是存在的家”，这样一个基本论断。因为人（此在）是唯一能够通过语言去把握存在的存在者&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="海德格尔" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%BE%B7%E6%A0%BC%E5%B0%94/"/>
    
      <category term="存在主义" scheme="http://yoursite.com/tags/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>读书记（8）：高宣扬讲存在主义（二）</title>
    <link href="http://yoursite.com/2018/01/21/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E9%AB%98%E5%AE%A3%E6%89%AC%E8%AE%B2%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/21/读书记（8）：高宣扬讲存在主义（二）/</id>
    <published>2018-01-21T14:20:45.000Z</published>
    <updated>2018-11-05T16:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一个存在者，对存在本身非常关注，而且有所体会。这个存在者就是人。海德格尔将其称之为“此在”。每个人都无可逃脱。在他亲自来到这个世界上，去经历自己的生命历程的时候，他每时每刻都遭遇到，关于你到底做什么选择，你到底要行使什么样的选择的自由的问题。此在的最根本、最基本的状态就是“烦”</p><a id="more"></a><p>因为刚才其实是把一般的问题提出来，就是关于研究存在主义，必须首先把握现象学这个方法。所谓“存在”的现象，就是它能够在被观察的时候，被观察的现象跟我们观察的主体之间的感情，和我们的生命的内部的情感、对生命的感悟，能够相互交流起来。然后使得观察过程中，被观察的对象，能够随着我们的观察者自己的生命的体验的活跃，而使被观察的对象重新地显现出来，再现出来。</p><p>这个再现是再，一再的再，再现，再次地显示出来。所以，在这点上，熊先生特别强调，要准确的、要深刻的把握，关于存在和存在者之间的区别，后来他经过很多的考察，他特别对这个，一方面强调存在者和存在的差异，但同时也去考察存在者和存在的关系。就在研究这个差异和关系的同时，他发现有这么一个存在者是非常特殊的存在者。这个存在者，他对存在本身非常关注，而且有所体会。这个存在者是什么？这个存在者就是人，但这不是传统所说的那种抽象的、一般的人，而是一个一个有特殊的生命经历，有特殊的生命感悟的那个个人。这个个体，每一个都是不一样的。就在这些不同的个体中，他对自身的存在都有自己的特殊的感悟。</p><p>举例子来说，我作为一个经过哲学训练，有过哲学思维能力，而且又对自己的经历特别关切的一个人。我一个特殊的人，不是你，不是他，而是我这个人。我作为这样一个特殊存在者，我对我的每时每刻的经历，我都有自己的经验和体会。不但有这个体会，而且我对它充满了感情，我对它不断的在生命中一再的去反思，一再的去重复的去考虑，每次考虑都有不同的结果。这样一个经历，使得我有资格、有能力、有兴趣去再现我自己的存在。</p><p>用哲学的概念和范畴来说，这样一个特殊的，对自己的存在特别关切，会不断的去关怀自己的存在的，这样一个存在者，特殊的存在者，海德格尔把他称之为“此在”，原文叫做“Dasein”。</p><p>所以每个人都无可逃脱的，在他亲自来到这个世界上，去经历自己的生命历程的时候，他每时每刻都遭遇到，关于你到底做什么选择，你到底要行使什么样的选择的自由的问题。在这个意义上说，也可以说每时每刻，对每个人来说来到这个世界上，他总是要遭遇到生和死的问题。为什么？你选择这个和选择那个，有的时候不是那么，简单地说，只是在一个具体问题上，你选择这个，选择那个，实际上你是在选择你自己要走什么路，你是要怎么生活，你离开你的死亡有多远的问题。这是一个很关键、很重要的一个问题，所以海德格尔特别强调，死亡其实不是一个只有到最后，好像是到年龄老了，好像是活到一定阶段以后，该死，要到没法逃脱自然的安排，你到八九十岁，七八十岁，可能那时候面临死亡。</p><p>其实存在主义认为不是这样，其实死亡天天每时每刻都伴随着你，就是严格意义上说，他的意思就是说，每时每刻你都有选择生命，生和死的问题，但是生和死的问题在不同的时刻，展现出不同的重要性和它的不同的意义。但总之，所有的时刻都是面临着生和死的问题。</p><p>在这个问题上，熊伟认为，他说，这个是他的原话，他说，“真自由必然是反身而诚”。什么叫反身而诚？就是对自己很忠诚、很诚实，是什么就是什么。就是自己能够对自己非常明了，我到底是什么样的人，我应该选择什么样的道路？这应该很清楚。而这种清楚只有你反复的，在每时每刻中，你都非常严格的，非常高标准的去思考自己的问题。思考你要选择什么？思考你面对的这个世界到底是什么样？你都能够不放松任何一个时候，去进行分析，进行反省，那么在这个时候，这叫做真正的，就是反身而诚，对自己诚，就是这个意思。</p><p>他说，“真自由必然是反身而诚，乐莫大焉”。“必须要从‘我在世’开始，以至于‘在到死中去’视死如归”。什么意思？就是这个“在”就是存在，存在到死中去。不但每时每刻，从我在世开始。而且必须要考虑到，每个在世同时又是面临着自己的死亡的问题，关系到自己如何死亡的问题。因为你选择什么，就是意味着你将来怎么死的问题。这是一个非常，也就是说，真正的对自己的存在负责任的一个人，当他去体验自己的亲在的时候，他必须对每一个时刻，他所面临的抉择，做出的选择，看作是自己对生死存亡的一个最大问题。以这样的严肃的心情去看待，你才能够对这个存在，对在世能够有所把握。你才真正的进入到，你是真正的生活，真正的生命，是这样。不然的话你是白过了。</p><p>所以他说，也是特别提到的，他说，我重复说，“现象学必须从‘我在世’开始，以至于‘在到死中去’视死如归，此亦即活的历史”。这也就是活的历史。“一言以蔽之，海德格尔的现象学是‘在者的在的学问，即存在论’”。“此在”是揭示存在的奥秘的一个钥匙，“此在”是进入到存在的神秘世界的一个入口，在这点上要特别注意。</p><p>所以熊伟说，“天地之大，谁能‘恬然澄明’地体会到‘我在’，谁就找到‘在’；”熊伟先生用佛教和道教，和老子所说的“恬然澄明”这四个字，来概括的说明通过对于存在，对自己的生存于世，特别关注的人的这种反思和体验，感觉到世界和我的存在的关键，因而真正的领会到原来世界就是如此，生命就是如此，到那个时候，他就是佛教说的，到了一个全然领悟的新的世界。</p><p>他说“此外在其他任何地方再也找不到‘在’”。再也不找不到存在，“而只能找到‘在者’而已”。在这里，当读者，希望你们在看海德格尔《存在与时间》的部分的时候，要把握此在，但同时也特别提到，这个此在的最根本的、最基本的状态就是“烦”，这个“烦”的原文就是，德文叫做Sorge。熊伟先生特别强调说，“如果说自由属于自己，但也不能忘记与我们‘共在’的‘他人’”。</p><p>也就是说，自由固然是自己可以做决定的时候，我面对着世界的时候，我到底做什么选择。但是当你选择的时候，固然是你自己选择，但是你不得不面对一个他人的问题。你选择你是要从你自己出发，你有你自己选择的自由。但是就是当你去选择自由的时候，你不能不考虑有他人的存在，这就是说，他人跟你永远是共在。刚才我讲到关于“此在”、“在世”、“存在”的时候，它的最基本形态叫做烦，萨特（Sartre）也同样是这样理解。</p><p>所以萨特的第一本著作，关于存在主义的第一本著作，是用小说的形式写的，叫做《呕吐》（La Nausée），在1938年写成的。在1934年以前，从1931年到1934年，萨特研究和学习海德格尔的《存在与时间》，而且也学习了胡塞尔的现象学，试图从现象学里面找到一个研究方法，去揭示人生的奥秘。</p><p>烦就是呕吐的时候的那种感觉，在萨特看来，这是活生生的人，活的个体，对于他在实际生活中所遭遇的每一个现象的这样或那样的生活感应。为什么呕吐？因为我这个个人的在世，在世的每一个时刻，我所面对的各种事情，都不是我这个人所愿意的，都不是符合我个人的喜爱，所以，一切都是令人恶心，令人作呕的。他说，我固然，我作为个体，我此在，我人生在世到这个世界上。但是，我首先是无缘无故的、不知所以然的被我的父母生出来。用他的话来说，被抛在这个世界上。我不知道怎么一回事，我也不知道我父母怎么把我生出来的。把我生出来以后，又面临着一系列的这样一个，我所遭遇到的各种各样，我所不能选择的世界，各种复杂的关系。然后当我自己去选择自己的自由的时候，我又遇到周围的各种各样的他人的约束和他们的干扰。于是，我的存在于世，就成为我不得不选择的那种选择，成为我所讨厌的选择；也就是说，我每时每刻都面临着“被强迫的选择”，我只好在恶心状态中过日子。</p><p>我无法逃脱跟他人的关系，所以他说这种无法逃脱，就好像是，萨特用一个很形象的话，叫做像黏液一样黏在你的身上。他人就像黏液一样粘在你身上，你要你逃避它不行，你关起门来，你以为你自己在屋里很孤孤单单的，你可以不去见别人，不去跟别人说话，好像你可以逃避他人。事实上你逃避不了。</p><p>但是简单的只是说“烦”还不够，所以海德格尔他的深刻之处就在于，在《存在与时间》里面，当他谈到，分析此在的、生存于世的这种“烦”的具体的过程的时候，重要的在于他描述了这个“烦”的细节。这个细节是到现在为止，任何人看了以后都会，当你对你的存在和对你的命运非常关切的话，你会感受到他的描述几乎好像就是真的是切合你的状况一样。这种烦是什么烦？就是他这么一系列的产生了，它这个概念一个一个展开，关于在烦的时候什么样的，叫做情态，感情的情，情态。</p><p>因为欧洲的启蒙运动特别重视理性。19世纪中叶，出现了像波德莱尔这样的一个作家和思想家，对理性的问题提出怀疑，要重新的思考现代性的问题，那么他特别重视关于情感的问题，特别重视情感跟理性之间的矛盾和它的相互渗透。只有通过对情感的深入的去分析，高度重视情感的成分，你才能够更好地理解什么叫理性。因为理性没有孤立的或抽象的、干巴巴的理性。在人生的生命中，所有的理性的发明、理性的思考，都伴随着一系列经历中的情感的变化，带着很深刻的情感。</p><p>所以在海德格尔的《存在与时间》里面，他尤其重视情感的问题。所以他提出了一个新的概念，德文原文叫Befindlichkeit。特别强调理性和人生在世的遭遇当中，所产生的一种非常复杂的感情，一种生活情态；使得每个人都不得不在生活中，带着不同的生活情态，去面对这个“令人烦恼”的生活世界，人们不得不处理感情因素同理性因素的相互关系，要在生活中一再地面临情感与理性的协调问题，使人陷入理性与情感之间相互协调的难题之中，把人的自由问题，变成非常复杂的生活情态难题。这一点，海德格尔在分析中进行了非常恰当的一个分析，而且可以说扭转了当时西方传统的人性论中对人的看法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个存在者，对存在本身非常关注，而且有所体会。这个存在者就是人。海德格尔将其称之为“此在”。每个人都无可逃脱。在他亲自来到这个世界上，去经历自己的生命历程的时候，他每时每刻都遭遇到，关于你到底做什么选择，你到底要行使什么样的选择的自由的问题。此在的最根本、最基本的状态就是“烦”&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="海德格尔" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%BE%B7%E6%A0%BC%E5%B0%94/"/>
    
      <category term="存在主义" scheme="http://yoursite.com/tags/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>读书记（7）：高宣扬讲存在主义（一）</title>
    <link href="http://yoursite.com/2018/01/20/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E9%AB%98%E5%AE%A3%E6%89%AC%E8%AE%B2%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/20/读书记（7）：高宣扬讲存在主义（一）/</id>
    <published>2018-01-20T14:20:45.000Z</published>
    <updated>2018-11-05T16:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>海德格尔在1927年发表《存在与时间》这本书的时候特别提到，他的存在哲学最重要的贡献就在于把“存在”这样一个最基本的哲学问题重新提出来。存在主义特别强调的是研究作为活现象的存在本身的自我显现</p><a id="more"></a><p>我首先要跟大家一起分享的和讨论的，是我刚刚在去年年底出版的《存在主义》这本书，这是因为这本书所谈论的问题比较重要，而且也跟我们每个人的生活的命运和我们的生命的命运，又紧紧相关。更清楚地说，这本《存在主义》所讨论的，都是关于人生的基本问题；这个基本问题，在任何时候以及对任何一个人，都是性命攸关的。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnm5397rj30qt0dhac9.jpg" alt=""></p><p>存在主义这个思潮，早在19世纪末的时候，就已经在欧洲出现了，但那个时候还没有成为一个正式的流行的思潮；当时已经被人们提出来了，主要是结合了当时欧洲社会的动荡和文化的危机，才出现了关于存在主义的一些论题。</p><p>这些论题的提出，首先是在文学界提出来的，当时丹麦的哲学家Søren Kierkegaard（索伦・克尔凯郭尔），他提出了关于存在主义的一些新的命题。他的新命题主要是认为人生是孤独的。这一命题，他是根据基督教的思想的传统，结合当时欧洲的危机，认为人生是很孤独的，而且充满着忧虑，所以关于，存在主义，所讨论的一些关于人生的问题，特别是关于人到底应该怎么样对待自己的生活？怎么样对待人生中遇到的危机，当遭遇到了各种意想不到的命运的时候，如何去处理，如何去面对？这样一个问题，在19世纪末就被突出地提出来了。Søren Kierkegaard在当时提出了这样一个（问题），能够把它从哲学上加以总结并提出来，宣示了存在主义的最早的呼声。</p><p>与此同时，俄国的著名小说家陀思妥耶夫斯基（Фёдор  Михайлович  Достоевский），也在他的好几本重要的小说里面，特别是《卡拉马佐夫兄弟》（братъя  карамазовы）这本书里面，已经很深刻的描述了，人生在世所遭遇的各种苦难，各种经历，以及这种经历给予人的心理的冲击，使得人对人生的基本态度，产生了所谓忧虑，所谓各种各样的烦恼。</p><p>所以存在主义应该说是很早就提出来，但是只有到了第一次世界大战爆发的时候，也就是说在1914年到1918年，第一次世界大战的战争的浩劫，给欧洲人带来了极大的冲击的情况下，存在主义才进一步被哲学家重新的进行讨论，并且加以系统的总结。</p><p>达达主义和超现实主义同样的，都是一个类似存在主义的思潮，跟存在主义几乎是有一个同样的基调，都认为人生不可把握，而且认为社会是很黑暗的。他们几乎都是采取对社会进行否定和颠覆的这样一种态度，而且对人生感到，要活着就必须要反抗，这样一个问题。</p><p>这样一个思潮产生以后，首先集中在德国和法国，一直到现在，一直在流传开来，而且它在理论上成为了哲学的一个派别以后，它更加深入人心，因为它触动了人类的灵魂本身。所以它不是一个，单纯只是在一个历史阶段中短期的一种思潮。而是已经可以说，把握了人心的最薄弱的那个环节，使得它能够很赤裸裸的，揭露人性中的那些最脆弱的部分。这一点是具有普遍意义的。</p><p>这本书是为了纪念我的老师熊伟先生。熊伟先生诞辰105年了，这本书的第一章的照片里面，我特别把熊伟老师在跟我合照的照片，把它登在那里面。因为熊伟先生是中国第一位，直接的聆听存在主义大师德国的海德格尔（Martin Heidegger）的中国学者。他30年代在弗莱堡听课以后，又在40年代回到中国。当时也是第一个，把海德格尔的基本思想、他的存在哲学传播到中国的著名学者。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnmajl00j30qt0dh772.jpg" alt=""><br>熊伟先生作出了重要的贡献，就是他能够把海德格尔用德语表述的艰难的、很艰涩的一些思想，结合中国的传统思想，特别是道家的思想、老子的思想，关于自然无为的思想，结合在一起，然后用中国的语言很准确地表达了。但是现象学尽管难懂，只有把握了现象学的原则，你才能够懂得存在主义。</p><p>在传统的科学思维、传统的哲学思维中，那些现象是固定不变的一个客观的对象，它是什么就是什么。一个杯子，高度、长度、宽度、形式等等，这都是现成的在那。所以我们的任务似乎就是要去测定它到底是什么样的。是什么样，我们就说什么样。但现象学不是这样，现象学要是让它“现象”出来。所谓要“现象”出来，（熊伟）他说就是，要使得它成为我们的感性的眼睛或智慧的眼睛的对象。感性的眼睛和智慧的眼睛什么意思？</p><p>后面他又讲，实际上所谓感性的和智慧的眼睛，就是我们的有它自身的生命力的眼睛，我们的眼睛是有它自己的生命的，这样的有生命的眼睛在观看现象的时候，总是带有感情的去看它；而且，在不同的时候看，眼睛所看到的现象，就不一样。所以，我们的眼睛所看到的现象，已经不是一个不动的“主体”去孤立地观看那些“客观”存在于外界，单纯地作为一种与我们无关的“对象”，而是通过我们的有生命力的眼睛的观看，</p><p>我们所看到的现象，实际上是已经在我们的眼睛与外界现象之间，在我们的有生命的眼睛与同样有自身生命的现象之间，建立了一种活生生的关联。用胡塞尔（Husserl）的话来说，就是构成了活的主体与同样活的客体之间的相互联系，这种联系，既不是单纯的主体性，也不是单纯的客体性，而是在两者之间的相互关系性，是在不同场合中产生的相互关系性；后来，胡塞尔由此特别强调一种“生活世界”的概念，强调任何观察，都是在特定的生活世界中发生，以此试图克服传统主观主义与客观主义的简单对立。这样一来，通过现象学的研究，把观察中的人与被观察的世界现象，搭起一个相互连接的桥梁，强调不同的人在不同的环境中所观察到的现象的差异性和连贯性。</p><p>海德格尔举例子，梵谷（梵高）画了一幅画，这幅画画得很简单，就是画了一支农靴，一个农民用过的靴子。然后，海德格尔就分析说，因为梵谷自己出身很贫寒，他自己经历了很多的曲折。他做过贫苦的工人，做过煤矿工人，做过给神父做服务的那些，在教会里面服务的小生，总之他经历了很多苦难。而且他后来到巴黎以后，住在巴黎北郊，郊区的农村里，他特别注意到，他所住的很贫寒的咖啡店的楼阁，用很便宜的房租在那边住。梵谷住在那里，对那里产生了感情，喜欢那个地方，虽然远离市中心，但是他能够亲眼看到，在他的咖啡店的小阁楼，看到的一片的麦田，他感到很亲切，因为什么？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxnmgh47bj30qt0dhmyz.jpg" alt=""><br>因为他经常看到，来了到麦田里劳作的那些农民，他们的辛劳，他们怎么样从夏天到秋天到冬天到春天，这么一年春夏秋冬的，一年又一年的辛勤劳作。经历了风雨的吹袭，然后他们的靴子里面，靴子上留下了许许多多的泥巴，这些泥巴记载了穿这个靴子的农民，他怎么样辛劳的劳动。而且同时的也在那里，等于是把辛苦劳动的农民，跟天地之间进行交流，这样一来，农民在种地的时候，他自己的这种生活的经历，他的情感，对这个世界的看法，都活生生的展现在那个靴子上。靴子上的每一个洞，每一个泥土，每个不同的痕迹，它的水汽也好，它的灰尘也好，都很形象地显示了、再现了农民的、他亲历的生活。</p><p>所以这就是，通过这个靴子，海德格尔做了很深刻的分析，说那个靴子不是死的，不是仅仅作为对象的靴子。因为作为对象的靴子，人人都看出是一个靴子，但是那个靴子当我看的时候，当梵谷看的时候，你看的时候都不一样。因为你们不同的人生、经验，使得你对出现在你面前的这个靴子，产生了不同的效果。那么这个靴子就很自然的在你面前，好像是一个活生生的在那边，一个活的物，在那边展现出来。这就是它所谓的现象，是吧？现象，每次在不同的时候，在不同的人面前，都以不同的人和不同的生活经历作为不同的背景，以不同的方式“显现”出来。这就是现象学的一个非常重要的原理。只有把握了这个原理，你才能够懂得，为什么存在主义研究人生的时候，必须要通过现象学这个方法，所以这是一个很重要的（原理）。</p><p>所以他说，这就是现象学所提到的，关于现象学研究的是“事情本身”。因为胡塞尔曾经对现象学做了一个概括，说现象学无非就是要回到“事情本身”。所以现象学的“事情本身”，就是要使各种不同的现象，在我们面前和当下“现象出来”，活生生地“显现”出来。</p><p>熊伟先生把这个“现象出来”，用他的自己的话把它说出来。让我们再说一遍，他说，所谓“现象出来”，就是，他说了，“要让现象‘在出来’”。“在出来”三个字，这个“在”就是“存在”，把它简写叫“在”。因此，“在”是活的，是因时因地而变的。要现象“在出来”，就是要现象存在出来。所谓现象存在出来，就是现象自己显现自己。所以在这个意义上说，所以，我说在，也就是存在，是自我生成的显现过程。而“在”的这种自我显现，就是存在本身。一切存在，都是自我显现的现象，也正因为这样，一切现象，通过它自己的自我显现，显示出它的活生生的性质；不仅在不同的环境，而且，对不同的观察者，面对不同的现象，这个观察者，他都以不同的姿态和不同的方式，把不同的或现象，“显现出来”。</p><p>由此可见，一切现象，由于都是自我显现，绝不是如同自然科学所研究的“客观对象”那样，都是统一的客观对象；这样一来，真正的现象，它们不可能都是千遍一律的，更不是死板不变的“客体”。</p><p>他特别强调，熊伟先生说，只有通过“在”的自我显现，一切在者才有可能存在于世。这句话又是很重要，因为在这里面涉及到，存在主义所说的“存在”这个概念和“存在者”的区别。存在者，注意，就多一个字。存在和存在者的区别等于是，现象学和存在主义同传统的形而上学思考、同传统的科学思考的区别。为什么这么说？存在主义和现象学特别强调的是，现象学和存在主义都是研究存在本身，研究作为活现象的存在的自我显现。在这里，存在本身自我显现，所以它特别强调存在是活的，是有生命的，是存在自己存在出来；它既不是存在者，也不是被传统形而上学所扭曲的那种从现实的存在抽象出来的某种“本体”。存在它自己显出来，而它这个显出来，是在我跟它的关系中发生的。这是现象学和存在主义的基本原则。</p><p>但是科学思维不是这样。科学思维把它当作认识的对象，认为这个“在”不是存在，而是存在者，它用存在者来代替存在。为什么？因为这个杯子，如果说在科学研究中，可是我一再说，这个杯子是作为对象，它不是存在本身，在科学思维面前，它是一个存在者，一个已经在那里存在的存在者，作为一个客观的对象，它存在在那里。现象学和存在主义所关心的，不是作为存在者的现象，而是作为存在本身的现象。</p><p>所以海德格尔在1927年发表《存在与时间》（SEIN UND ZEIT）这本书的时候，他特别提到，他的存在哲学的最重要的贡献就在于，把存在这样一个最基本的哲学问题，重新提出来。而“存在”这个问题，从古希腊，就是公元前六世纪以后，由于苏格拉底和柏拉图，把他们之前，希腊的自然哲学的那种自然思考的方式，把它给篡改成为，改变成为以人为主体的一种认识真理的方式，存在就因此变成了作为对象的存在者。</p><p>由于柏拉图等人的这种旋转，把“存在”最重要的一个哲学问题，把它变成为存在者的问题。这样一来，就把“存在”这样一个原来最基本的希腊的最早的问题，把它给忘记了2000年。所以存在主义的问题，就是要重新的把这个存在提出来，要去一再强调，哲学研究的对象不是存在者，不是现成的现象，而是存在本身。而所谓存在本身就是，这个“存在”是靠它自己“在”出来，靠它自己的显现显象出来，是这样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;海德格尔在1927年发表《存在与时间》这本书的时候特别提到，他的存在哲学最重要的贡献就在于把“存在”这样一个最基本的哲学问题重新提出来。存在主义特别强调的是研究作为活现象的存在本身的自我显现&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="海德格尔" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%BE%B7%E6%A0%BC%E5%B0%94/"/>
    
      <category term="存在主义" scheme="http://yoursite.com/tags/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（2）：JSON</title>
    <link href="http://yoursite.com/2018/01/20/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9AJSON/"/>
    <id>http://yoursite.com/2018/01/20/python编程系列（2）：JSON/</id>
    <published>2018-01-20T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Json简介"><a href="#一、Json简介" class="headerlink" title="一、Json简介"></a>一、Json简介</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。</p><a id="more"></a><p>存储在SQL数据库中的数据往往是规整的，比如这里有一个SQLite数据库的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id|code|name|area|area_land|area_water|population|population_growth|birth_rate|death_rate|migration_rate|created_at|updated_at</div><div class="line">1|af|Afghanistan|652230|652230|0|32564342|2.32|38.57|13.89|1.51|2015-11-01 13:19:49.461734|2015-11-01 13:19:49.461734</div><div class="line">2|al|Albania|28748|27398|1350|3029278|0.3|12.92|6.58|3.3|2015-11-01 13:19:54.431082|2015-11-01 13:19:54.431082</div><div class="line">3|ag|Algeria|2381741|2381741|0|39542166|1.84|23.67|4.31|0.92|2015-11-01 13:19:59.961286|2015-11-01 13:19:59.961286</div></pre></td></tr></table></figure><p>上述的数据由行和列组成，其中每列映射到一个已定义的属性，如id或者name。其中每一行代表一个国家，每一列代表了这个国家一些特征。但随着数据量的增加，在存储的时候我们通常不知道数据的确切的结构，这被称为非结构化数据。一个很好的例子就是网站上的访客列表，下面是发送到服务器的事件列表的示例:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;'event_type': 'started-mission',</div><div class="line"> 'keen': &#123;'created_at': '2015-06-12T23:09:03.966Z',</div><div class="line">  'id': '557b668fd2eaaa2e7c5e916b',</div><div class="line">  'timestamp': '2015-06-12T23:09:07.971Z'&#125;,</div><div class="line"> 'sequence': 1&#125;</div><div class="line"> </div><div class="line">&#123;'event_type': 'started-screen',</div><div class="line"> 'keen': &#123;'created_at': '2015-06-12T23:09:03.979Z',</div><div class="line">  'id': '557b668f90e4bd26c10b6ed6',</div><div class="line">  'timestamp': '2015-06-12T23:09:07.987Z'&#125;,</div><div class="line"> 'mission': 1,</div><div class="line"> 'sequence': 4,</div><div class="line"> 'type': 'code'&#125;</div><div class="line"> </div><div class="line">&#123;'event_type': 'started-screen',</div><div class="line"> 'keen': &#123;'created_at': '2015-06-12T23:09:22.517Z',</div><div class="line">  'id': '557b66a246f9a7239038b1e0',</div><div class="line">  'timestamp': '2015-06-12T23:09:24.246Z'&#125;,</div><div class="line"> 'mission': 1,</div><div class="line"> 'sequence': 3,</div><div class="line"> 'type': 'code'&#125;,</div></pre></td></tr></table></figure><p>上面列出了三个独立事件。每个事件都有不同的字段，有些字段嵌套在其他字段中。这种类型的数据很难在常规的SQL数据库中存储。所以这种非结构化数据通常以JavaScript对象表示法(JSON)格式存储。JSON是一种将列表和字典等数据结构编码成字符串的方法，这样来确保它们易于被机器读取。尽管JSON以Javascript开头，但它实际上只是一种格式，可以通过任何语言读取。</p><p>Json对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。</p><p>它的值可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv0jz5owyg30gm07qgli.gif" alt=""></p><h2 id="二、Python编码和解析Json"><a href="#二、Python编码和解析Json" class="headerlink" title="二、Python编码和解析Json"></a>二、Python编码和解析Json</h2><p>Python有很大的JSON支持。我们可以将列表和字典转换为JSON，并将字符串转换为列表和字典。JSON数据看起来很像Python中的字典（dictionary），其中存储了键和值。</p><p>使用 JSON 函数需要导入 json 库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import json</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>json.dumps</td><td>将 Python 对象编码成 JSON 字符串</td></tr><tr><td>json.loads</td><td>将已编码的 JSON 字符串解码为 Python 对象</td></tr></tbody></table></div><p>将Python的字典结构导出到json使用<code>json.dumps()</code>，将json读成Python的字典结构，使用<code>json.loads()</code>。<br>如果不是针对string操作而是对文件操作，分别使用<code>json.load()</code>函数和<code>json.dump()</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line">from pprint import pprint </div><div class="line">  </div><div class="line">data = [</div><div class="line"> &#123;&apos;event_type&apos;: &apos;started-mission&apos;,</div><div class="line"> &apos;keen&apos;: &#123;&apos;created_at&apos;: &apos;2015-06-12T23:09:03.966Z&apos;,</div><div class="line">  &apos;id&apos;: &apos;557b668fd2eaaa2e7c5e916b&apos;,</div><div class="line">  &apos;timestamp&apos;: &apos;2015-06-12T23:09:07.971Z&apos;&#125;,</div><div class="line"> &apos;sequence&apos;: 1&#125;,</div><div class="line"> </div><div class="line">&#123;&apos;event_type&apos;: &apos;started-screen&apos;,</div><div class="line"> &apos;keen&apos;: &#123;&apos;created_at&apos;: &apos;2015-06-12T23:09:03.979Z&apos;,</div><div class="line">  &apos;id&apos;: &apos;557b668f90e4bd26c10b6ed6&apos;,</div><div class="line">  &apos;timestamp&apos;: &apos;2015-06-12T23:09:07.987Z&apos;&#125;,</div><div class="line"> &apos;mission&apos;: 1,</div><div class="line"> &apos;sequence&apos;: 4,</div><div class="line"> &apos;type&apos;: &apos;code&apos;&#125;</div><div class="line">]</div><div class="line"></div><div class="line"></div><div class="line">json_str = json.dumps(data, sort_keys=True, indent=1, separators=(&apos;,&apos;, &apos;: &apos;))</div><div class="line"></div><div class="line">data = json.loads(json_str)</div><div class="line"></div><div class="line">print type(json_str)</div><div class="line">print type(data)</div><div class="line">pprint(data)</div><div class="line"></div><div class="line"># Writing JSON data to file</div><div class="line">with open(&apos;data.json&apos;, &apos;w&apos;) as f:</div><div class="line">    json.dump(data, f)</div><div class="line">    </div><div class="line"># Reading data back</div><div class="line">with open(&apos;data.json&apos;, &apos;r&apos;) as f:</div><div class="line">    data = json.load(f)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;type &apos;str&apos;&gt;</div><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">[&#123;u&apos;event_type&apos;: u&apos;started-mission&apos;,</div><div class="line">  u&apos;keen&apos;: &#123;u&apos;created_at&apos;: u&apos;2015-06-12T23:09:03.966Z&apos;,</div><div class="line">            u&apos;id&apos;: u&apos;557b668fd2eaaa2e7c5e916b&apos;,</div><div class="line">            u&apos;timestamp&apos;: u&apos;2015-06-12T23:09:07.971Z&apos;&#125;,</div><div class="line">  u&apos;sequence&apos;: 1&#125;,</div><div class="line"> &#123;u&apos;event_type&apos;: u&apos;started-screen&apos;,</div><div class="line">  u&apos;keen&apos;: &#123;u&apos;created_at&apos;: u&apos;2015-06-12T23:09:03.979Z&apos;,</div><div class="line">            u&apos;id&apos;: u&apos;557b668f90e4bd26c10b6ed6&apos;,</div><div class="line">            u&apos;timestamp&apos;: u&apos;2015-06-12T23:09:07.987Z&apos;&#125;,</div><div class="line">  u&apos;mission&apos;: 1,</div><div class="line">  u&apos;sequence&apos;: 4,</div><div class="line">  u&apos;type&apos;: u&apos;code&apos;&#125;]</div></pre></td></tr></table></figure><p>在编码JSON的时候，这里我们为了获得漂亮的格式化字符串，可以使用 json.dumps() 的indent参数。 它会使得输出和pprint()函数效果类似。</p><p>默认的类型对应如下：</p><div class="table-container"><table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td>object</td><td>dict</td></tr><tr><td>array</td><td>list</td></tr><tr><td>string</td><td>unicode</td></tr><tr><td>number (int)</td><td>int, long</td></tr><tr><td>number (real)</td><td>float</td></tr><tr><td>true</td><td>True</td></tr><tr><td>false</td><td>False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table></div><h2 id="三、其他数据类型与Json之间的编码和解码"><a href="#三、其他数据类型与Json之间的编码和解码" class="headerlink" title="三、其他数据类型与Json之间的编码和解码"></a>三、其他数据类型与Json之间的编码和解码</h2><p>一般来讲，JSON解码会根据提供的数据创建dicts或lists。 如果你想要创建其他类型的对象，可以给 json.loads() 传递object_pairs_hook或object_hook参数。 例如，下面是演示如何解码JSON数据并在一个OrderedDict中保留其顺序的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from collections import OrderedDict</div><div class="line">s = &apos;&#123;&quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 50, &quot;price&quot;: 490.1&#125;&apos;</div><div class="line">data = json.loads(s, object_pairs_hook=OrderedDict)</div><div class="line">data</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OrderedDict([(u&apos;name&apos;, u&apos;ACME&apos;), (u&apos;shares&apos;, 50), (u&apos;price&apos;, 490.1)])</div></pre></td></tr></table></figure><p>下面是如何将一个JSON字典转换为一个Python对象例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s = &apos;&#123;&quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 50, &quot;price&quot;: 490.1&#125;&apos;</div><div class="line"></div><div class="line">class JSONObject:</div><div class="line">    def __init__(self, d):</div><div class="line">        self.__dict__ = d</div><div class="line">        </div><div class="line">data = json.loads(s, object_hook=JSONObject)</div></pre></td></tr></table></figure><p>这里，JSON解码后的字典作为一个单个参数传递给 <code>__init__()</code> 。 然后，就可以随心所欲的使用了，比如作为一个实例字典来直接使用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data.name</div><div class="line">data.price</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ACME</div><div class="line">490.1</div></pre></td></tr></table></figure><p>对象实例通常并不是JSON可序列化的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point:</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line"></div><div class="line">p = Point(2, 3)</div><div class="line">json.dumps(p)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: &lt;__main__.Point instance at 0x10aa97c20&gt; is not JSON serializable</div></pre></td></tr></table></figure><p>如果你想序列化对象实例，你可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def serialize_instance(obj):</div><div class="line">    d = &#123; &apos;__classname__&apos; : type(obj).__name__ &#125;</div><div class="line">    d.update(vars(obj))</div><div class="line">    return d</div></pre></td></tr></table></figure><p>下面是如何使用这些函数的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def serialize_instance(obj):</div><div class="line">    d = &#123; &apos;__classname__&apos; : type(obj).__name__ &#125;</div><div class="line">    d.update(vars(obj))</div><div class="line">    return d</div><div class="line"></div><div class="line"></div><div class="line">p = Point(2,3)</div><div class="line">s = json.dumps(p, default=serialize_instance)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;&#123;&quot;y&quot;: 3, &quot;x&quot;: 2, &quot;__classname__&quot;: &quot;instance&quot;&#125;&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Json简介&quot;&gt;&lt;a href=&quot;#一、Json简介&quot; class=&quot;headerlink&quot; title=&quot;一、Json简介&quot;&gt;&lt;/a&gt;一、Json简介&lt;/h2&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>python编程系列（1）：正则表达式</title>
    <link href="http://yoursite.com/2018/01/19/python%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/19/python编程系列（1）：正则表达式/</id>
    <published>2018-01-19T12:20:45.000Z</published>
    <updated>2018-11-04T00:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>对文本进行处理在数据科学实践中必不可少的一环，业界的文本数据往往杂乱无章，而且数量及其庞大，当我们需要对文本进行片段匹配时，就要求我们利用计算机来批量地在文本中检索某种模式。正则表达式（Regular Expression）就是可以进行文本匹配的一种高级模式，它是一些由字符和特殊符号组成的字符串，它可以按照某种模式匹配一系列有相似特征的字符串。</p><a id="more"></a><p>最简单的正则表达式就是普通字符串，它仅仅可以匹配其自身。比如正则表达式“python”只可以匹配字符串“python”。正则表达式的强大之处在于特殊符号的应用，特殊符号定义了字符集合、子组匹配以及模式的重复次数。正是这些特殊符号使得一个正则表达式可以匹配字符串集合而不只是一个字符串。</p><h2 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h2><p>下图列出了Python支持的正则表达式元字符和语法：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv37yccg5j30rb0qr13k.jpg" alt=""></p><h3 id="1-1-择一匹配符号“-”"><a href="#1-1-择一匹配符号“-”" class="headerlink" title="1.1 择一匹配符号“|”"></a>1.1 择一匹配符号“|”</h3><p>表示从多个模式中选择一个，用于分割不同的正则表达式，可以匹配不止一个字符串，等同于逻辑“或”。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bat | bet | bit    # 可以匹配字符串bat或者bet或者bit</div></pre></td></tr></table></figure><h3 id="1-2-任意字符匹配符号“-”"><a href="#1-2-任意字符匹配符号“-”" class="headerlink" title="1.2 任意字符匹配符号“.”"></a>1.2 任意字符匹配符号“.”</h3><p>“.”号可以匹配除了换行符以为的任何字符（Python正则表达式有一个编译标记[S或DOTALL]能够使“.”匹配换行符），要匹配“.”号自身，必须使用反斜线转译符号“.”。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f.o  #能够匹配f和o之间加上任意一个字符的样式，如：fao、f9o、f#o</div><div class="line">..   #能够匹配任意两个字符</div></pre></td></tr></table></figure><h3 id="1-3-匹配字符串开始“-”或结尾“-”"><a href="#1-3-匹配字符串开始“-”或结尾“-”" class="headerlink" title="1.3 匹配字符串开始“^”或结尾“$”"></a>1.3 匹配字符串开始“^”或结尾“$”</h3><p>匹配字符串以什么开始的，可以使用脱字符“^”或\A;<br>匹配字符串以什么结束的，可以使用美元符“$”或\Z;<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^From  #任何以From开始的字符串</div><div class="line">tcsh$  #任何以tcsh结尾的字符串</div><div class="line">^subject:hi$   #任何由单独的字符串subject：hi构成的字符串</div></pre></td></tr></table></figure><h3 id="1-4-匹配单词边界：“-b”、“-B”"><a href="#1-4-匹配单词边界：“-b”、“-B”" class="headerlink" title="1.4 匹配单词边界：“\b”、“\B”"></a>1.4 匹配单词边界：“\b”、“\B”</h3><p>\b：匹配单词的边界（单词前或后），而不在乎单词中间的字符<br>\B：匹配单词中间的字符，而不在乎单词边界的字符<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">er\b   #可以匹配“never”中的“er”，但不能匹配“verb”中的“er”，只关心后边</div><div class="line">er\B   #能匹配“verb”中的“er”，但不能匹配“never”中的“er”,只关心中间</div><div class="line">\bthe  #匹配任何以the开头的字符串</div></pre></td></tr></table></figure><h3 id="1-5-字符集“-”"><a href="#1-5-字符集“-”" class="headerlink" title="1.5 字符集“[ ]”"></a>1.5 字符集“[ ]”</h3><p>当想要匹配指定的某些字符的时候，使用字符集是很方便的。<br>注意：字符集只适用于单字符的情况。也就是说[ab]表示只从ab中选择一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b[ae]t  #匹配bat、或bet</div><div class="line">[01][ab]  #匹配0a、0b、1a、1b</div></pre></td></tr></table></figure><h3 id="1-6-字符集中的范围“-”和否定“”"><a href="#1-6-字符集中的范围“-”和否定“”" class="headerlink" title="1.6 字符集中的范围“-”和否定“”"></a>1.6 字符集中的范围“-”和否定“<sup><a href="#fn_" id="reffn_"></a></sup>”</h3><p>-:表示一个字符的范围<br>^:不匹配指定字符集里的任意字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">z.[0-9]   #字母z后面跟着任何一个字符，然后跟着一个数字</div><div class="line">[^aeiou]  #一个非元音字符</div><div class="line">[^\t\n]   #不匹配制表符或\n</div><div class="line">[&quot;-a]   #在一个ASCII系统中，位于“&quot;”和“a”之间的字符，即34-97之间的字符</div></pre></td></tr></table></figure><h3 id="1-7-特殊符号（-，-，？，-）"><a href="#1-7-特殊符号（-，-，？，-）" class="headerlink" title="1.7 特殊符号（*，+，？，{}）"></a>1.7 特殊符号（*，+，？，{}）</h3><p>*：匹配其左边的正则表达式出现零次或多次的情况。<br>+：匹配一次或多次出现的正则表达式。<br>？：匹配零次或一次出现的正则表达式。<br>{N}、{M,N}: 匹配前面的正则表达式N次或M～N次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[dn]ot?  #字母d或n后面跟一个o，然后后面最多再跟一个t。例如：do、no、dot、not</div><div class="line">0？[1-9] #一个1到9的数字，前面跟或不跟一个0</div><div class="line">[0-9]&#123;15,16&#125;  #匹配15或16个数字。例如信用卡号码</div><div class="line">&lt;/?[^&gt;]+&gt;  #匹配全部有效的（和无效的）HTML标签</div></pre></td></tr></table></figure><h3 id="1-8-特殊字符"><a href="#1-8-特殊字符" class="headerlink" title="1.8 特殊字符"></a>1.8 特殊字符</h3><p>\d：十进制数字，相当于[0-9]<br>\D：非十进制数字的字符，相当于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup><br>\w：全部字母数字，相当于[A-Za-z0-9]<br>\W：非字母数字的字符,相当于<sup><a href="#fn_A-Za-z0-9" id="reffn_A-Za-z0-9">A-Za-z0-9</a></sup><br>\s: 空格字符<br>\S: 非空格字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">\w+-\d+  #一个由字母数字组成的字符串和一串由连字符分隔的数字</div><div class="line">[A-Za-z]\w* #第一个是字母，其余是字母或数字</div><div class="line">\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;  #美国电话号码格式，例如800-555-1212</div><div class="line">\w+@\w+\.com  #以xxx@yyy.com格式表示的简单电子邮件地址</div></pre></td></tr></table></figure><h3 id="1-9-圆括号指定分组"><a href="#1-9-圆括号指定分组" class="headerlink" title="1.9 圆括号指定分组"></a>1.9 圆括号指定分组</h3><p>有时候除了进行匹配操作外，我们还想要提取所匹配的子组，例如：\w+-\d+,这个正则表达式想要分别保存第一部分的字母和第二部分的数字，该怎么实现？我们可能这样做的原因是对于任何成功的匹配，我们想要看到匹配的字符串究竟是什么。如果为两个子模块都加上圆括号，例如(\w+)-(\d),然后就能够分别访问每一个匹配的子组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\d+(\.\d*)?  #匹配浮点数的字符串，如：“5”、“5.”、“5.009”等</div></pre></td></tr></table></figure><h3 id="1-10-扩展表示法"><a href="#1-10-扩展表示法" class="headerlink" title="1.10 扩展表示法"></a>1.10 扩展表示法</h3><p>可以参考上面表格的讲解结合下面的例子就能懂了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Windows(?=95|98|NT|2000)  #能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”</div><div class="line">Windows(?!95|98|NT|2000)  #能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”</div><div class="line">(?&lt;=95|98|NT|2000)Windows  #能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”</div><div class="line">(?&lt;!95|98|NT|2000)Windows  #能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”</div><div class="line">industr(?:y|ies)  #就是一个比“industry|industries”更简略的表达式</div><div class="line"> </div><div class="line">(?:\w+\.)*  #以点结尾的字符串，如google.</div><div class="line">(?#comment)  #不做匹配，只做注释</div><div class="line">(?=.com)  #一个字符串后面跟着.com才做匹配</div><div class="line">(?!.net)  #一个字符串后面跟的不是.net才做匹配</div><div class="line">(?&lt;=800-)  #字符串前面出现800-才做匹配</div><div class="line">(?&lt;!192\.168\.)  # 字符串前面不是192.168。才做匹配，过滤掉一类ip地址</div><div class="line">(?(1)y|x)  #如果匹配组1（\1）存在，就与y匹配，否则就与x匹配</div></pre></td></tr></table></figure><h2 id="二、re模块"><a href="#二、re模块" class="headerlink" title="二、re模块"></a>二、re模块</h2><p>Python语言中使用re模块的方法支持正则表达式。这里列出re模块常见的函数以方便查询（后面会介绍主要的函数使用方法）</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvqsevfulj30y90ggdj1.jpg" alt=""></p><p>下面将分开解释上面的部分函数：</p><h3 id="2-1-使用match-和search-匹配字符串，使用group-查看结果"><a href="#2-1-使用match-和search-匹配字符串，使用group-查看结果" class="headerlink" title="2.1 使用match()和search()匹配字符串，使用group()查看结果"></a>2.1 使用match()和search()匹配字符串，使用group()查看结果</h3><p>re.match() :从字符串开始的位置匹配，成功返回匹配的对象，失败返回None<br>re.search(): 扫描整个字符串来进行匹配，成功返回匹配的对象，失败返回None</p><blockquote><p>例1：比较match() 和 search()的区别</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">m = re.match(&apos;foo&apos;, &apos;seafood&apos;)</div><div class="line">if m is not None: print(&quot;match-&quot; + m.group())</div><div class="line"></div><div class="line">m = re.search(&apos;foo&apos;, &apos;seafood&apos;)</div><div class="line">if m is not None: print(&quot;search-&quot; + m.group())</div><div class="line"></div><div class="line">#结果是：search-foo</div></pre></td></tr></table></figure><blockquote><p>例2: match()函数从起始位开始匹配</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">m = re.match(&apos;foo&apos;, &apos;foo&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;能匹配-&quot; + m.group())</div><div class="line"></div><div class="line">m = re.match(&apos;foo&apos;, &apos;bar&apos;)</div><div class="line">if m is not None: print(&quot;不能匹配-&quot; + m.group())</div><div class="line"></div><div class="line">m = re.match(&apos;foo&apos;, &apos;food on the table&apos;)</div><div class="line">if m is not None: print(&quot;从开始位置进行匹配-&quot; + m.group())</div><div class="line"></div><div class="line">#能匹配-foo</div><div class="line">#从开始位置进行匹配-foo</div></pre></td></tr></table></figure><blockquote><p>例3: 匹配多个值（使用择一表达式”|”）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">bt = &apos;bat|bet|bit&apos;</div><div class="line"></div><div class="line">m = re.match(bt, &apos;bat&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;1能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(bt, &apos;blt&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;2能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(bt, &apos;he bit me&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;3能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.search(bt, &apos;he bit me&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;4能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">#结果：</div><div class="line">#   1能匹配-bat</div><div class="line">#   4能匹配-bit</div></pre></td></tr></table></figure><blockquote><p>例4: 匹配任何单个字符。点号”.”除了换行符\n和非字符，都能匹配</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">bt = &quot;.end&quot;</div><div class="line"></div><div class="line">m = re.match(bt, &apos;bend&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;bend能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(bt, &apos;end&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;end能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(bt, &apos;\nend&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;\nend能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.search(bt, &apos;the end.&apos;)</div><div class="line">if m is not None:</div><div class="line">    print(&quot;the end.能匹配-&quot; + m.group())</div><div class="line"></div><div class="line">#结果：</div><div class="line">#   bend能匹配-bend</div><div class="line">#   the end.能匹配- end</div></pre></td></tr></table></figure><blockquote><p>例5: 匹配小数点</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">bt = &quot;3.14&quot;</div><div class="line">pi_bt = &quot;3\.14&quot;  #表示字面量的点号 （dec.point）</div><div class="line"></div><div class="line">m = re.match(bt, &apos;3.14&apos;)    #点号匹配</div><div class="line">if m is not None:</div><div class="line">    print(&quot;3.14能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(pi_bt, &apos;3.14&apos;)  #精确匹配</div><div class="line">if m is not None:</div><div class="line">    print(&quot;精确匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">m = re.match(bt, &apos;3014&apos;)    #点号匹配0</div><div class="line">if m is not None:</div><div class="line">    print(&quot;3014能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">#结果：</div><div class="line"># 3.14能匹配-3.14</div><div class="line"># 精确匹配-3.14</div><div class="line"># 3014能匹配-3014</div></pre></td></tr></table></figure><blockquote><p>例6： 使用字符集”[ ]”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">bt = &quot;[cr][23][dp][o2]&quot;</div><div class="line"></div><div class="line">m = re.match(bt, &apos;c3po&apos;)    #点号匹配</div><div class="line">if m is not None:</div><div class="line">    print(&quot;c3po能匹配-&quot; + m.group())</div><div class="line"></div><div class="line"></div><div class="line">#结果：</div><div class="line"># c3po能匹配-c3po</div></pre></td></tr></table></figure><blockquote><p>例7: 重复、特殊字符</p></blockquote><p>正则表达式: \w+@\w+.com可以匹配类似nobody@xxx.com的邮箱地址，但是类似nobody@xxx.yyy.aaa.com的地址就不能匹配了。这时候我们可以使用<em> 操作符来表示该模式出现零次或者多次：\w+@(\w+.)</em>\w+.com</p><blockquote><p>例8: 分组</p></blockquote><p>group()可以访问每个独立的子组<br>groups()获取一个包含所有匹配子组的元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re</div><div class="line">&gt;&gt;&gt; m = re.match(&apos;(\w\w\w)-(\d\d\d)&apos;, &apos;abc-123&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">&apos;abc-123&apos;</div><div class="line">&gt;&gt;&gt; m.group(1)</div><div class="line">&apos;abc&apos;</div><div class="line">&gt;&gt;&gt; m.group(2)</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; m.groups()</div><div class="line">(&apos;abc&apos;, &apos;123&apos;)</div><div class="line"></div><div class="line">&gt;&gt;&gt; m = re.match(&apos;ab&apos;, &apos;ab&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">&apos;ab&apos;</div><div class="line">&gt;&gt;&gt; m.groups()</div><div class="line">( )</div></pre></td></tr></table></figure><blockquote><p>例9: 匹配字符串起始和结尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">m = re.search(&apos;^the&apos;,&apos;the end.&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">&apos;the&apos;</div><div class="line">&gt;&gt;&gt; m = re.search(&apos;^the&apos;,&apos;sthe end.&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;</div><div class="line">&gt;&gt;&gt; m = re.search(r&apos;\bthe&apos;,&apos;bite the dog&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">&apos;the&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; m = re.search(r&apos;\bthe&apos;,&apos;bitethe dog&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; m = re.search(r&apos;\Bthe&apos;,&apos;bitethe dog&apos;)</div><div class="line">&gt;&gt;&gt; m.group()</div><div class="line">&apos;the&apos;</div></pre></td></tr></table></figure><h3 id="2-2-使用findall-、finditer-查找每一次出现的位置"><a href="#2-2-使用findall-、finditer-查找每一次出现的位置" class="headerlink" title="2.2 使用findall()、finditer()查找每一次出现的位置"></a>2.2 使用findall()、finditer()查找每一次出现的位置</h3><p>final() 以列表的形式返回所有能匹配的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re</div><div class="line">&gt;&gt;&gt; re.findall(&apos;car&apos;, &apos;car sscare&apos;)</div><div class="line">[&apos;car&apos;, &apos;car&apos;]</div></pre></td></tr></table></figure><p>finaliter()返回一个顺序访问每一个匹配结果（Match对象）的迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.finditer(r&apos;(th\w+) and (th\w+)&apos;,s, re.I).next().group(1)</div><div class="line">&apos;This&apos;</div><div class="line">&gt;&gt;&gt; re.finditer(r&apos;(th\w+) and (th\w+)&apos;,s, re.I).next().group(2)</div><div class="line">&apos;That&apos;</div></pre></td></tr></table></figure><h3 id="2-3-使用sub-和subn-搜索和替换"><a href="#2-3-使用sub-和subn-搜索和替换" class="headerlink" title="2.3 使用sub()和subn()搜索和替换"></a>2.3 使用sub()和subn()搜索和替换</h3><p>两个函数都可以实现搜索和替换功能，将某字符串中所有匹配正则表达式的部分进行某种形式的替换。不同点是subn()还返回一个表示替换了多少次的总数，和返回结果一起以元组的形式返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.sub(&apos;[ae]&apos;,&apos;X&apos;,&apos;abcdef&apos;)</div><div class="line">&apos;XbcdXf&apos;</div><div class="line">&gt;&gt;&gt; re.subn(&apos;[ae]&apos;,&apos;X&apos;,&apos;abcdef&apos;)</div><div class="line">(&apos;XbcdXf&apos;, 2)</div></pre></td></tr></table></figure><p>进行替换的时候，还可以指定替换的顺序，原理是使用匹配对象的group()方法除了能够获取匹配分组编号外，还可以使用\N，其中N表示要替换字符串中的分组的编号，通过编号就能指定替换的顺序。<br>例如：将美式日期MM/DD/YY{,YY}格式转换成DD/MM/YY{,YY}格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.sub(r&apos;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;2&#125;|\d&#123;4&#125;)&apos;,r&apos;\2/\1/\3&apos;,&apos;2/20/91&apos;)</div><div class="line">&apos;20/2/91&apos;</div><div class="line">&gt;&gt;&gt; re.sub(r&apos;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;2&#125;|\d&#123;4&#125;)&apos;,r&apos;\2/\1/\3&apos;,&apos;2/20/1991&apos;)</div><div class="line">&apos;20/2/1991&apos;</div></pre></td></tr></table></figure><h3 id="2-4-在限定模式上使用split-分隔字符串"><a href="#2-4-在限定模式上使用split-分隔字符串" class="headerlink" title="2.4 在限定模式上使用split()分隔字符串"></a>2.4 在限定模式上使用split()分隔字符串</h3><p>re模块的split（）可以基于正则表达式的模式分隔字符串。但是当处理的不是特殊符号匹配多重模式的正则表达式时，re.split()和str.split()的工作方式相同，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.split(&apos;:&apos;, &apos;str1:str2&apos;)</div><div class="line">[&apos;str1&apos;, &apos;str2&apos;]</div><div class="line">&gt;&gt;&gt; &apos;str1:str2&apos;.split(&apos;:&apos;)</div><div class="line">[&apos;str1&apos;, &apos;str2&apos;]</div></pre></td></tr></table></figure><p>但当处理复杂的分隔时，就需要比普通字符串分隔更强大的处理方式,例如下面匹配复杂情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; DATA = (&apos;Mountation View, CA 94040&apos;, &apos;sunnyvale, CA&apos;, &apos;Los Altos, 94023&apos;, &apos;Palo Alto CA&apos;,&apos;Cupertino 95014&apos;)</div><div class="line">&gt;&gt;&gt; for datum in DATA: print(re.split(&apos;, |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) &apos;,datum))</div><div class="line">... </div><div class="line">[&apos;Mountation View&apos;, &apos;CA&apos;, &apos;94040&apos;]</div><div class="line">[&apos;sunnyvale&apos;, &apos;CA&apos;]</div><div class="line">[&apos;Los Altos&apos;, &apos;94023&apos;]</div><div class="line">[&apos;Palo Alto&apos;, &apos;CA&apos;]</div><div class="line">[&apos;Cupertino&apos;, &apos;95014&apos;]</div></pre></td></tr></table></figure><p>上述的正则表达式：当一个空格紧跟在5个数字或2个字母后面时就用split语句分隔。当遇到“，”也用split函数分隔。</p><h3 id="2-5-扩展符号"><a href="#2-5-扩展符号" class="headerlink" title="2.5 扩展符号"></a>2.5 扩展符号</h3><p>通过使用(?iLmsux)系列选项，可以直接在正则表达式里面指定一个活着多个标记。以下是使用re.I/IGNORECASE的示例，第二个是使用re.M/MULTILINE实现多行混合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.findall(r&apos;(?i)yes&apos;,&apos;yes? Yes. YES!!!&apos;)</div><div class="line">[&apos;yes&apos;, &apos;Yes&apos;, &apos;YES&apos;]</div><div class="line">&gt;&gt;&gt; re.findall(r&apos;(?i)th\w+&apos;,&apos;The quickest way is through this tunnel.&apos;)</div><div class="line">[&apos;The&apos;, &apos;through&apos;, &apos;this&apos;]</div><div class="line">&gt;&gt;&gt; re.findall(r&apos;(?im)(^th[\w ]+)&apos;, &quot;&quot;&quot;</div><div class="line">... This is the first,</div><div class="line">... another line,</div><div class="line">... that line,it&apos;s the best</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">[&apos;This is the first&apos;, &apos;that line&apos;]</div></pre></td></tr></table></figure><p>通过使用“多行”，能够在目标字符串中实现跨行搜索，而不必将整个字符串视为单个实体。</p><p>下一个例子用来演示re.S/DOTALL，该标记表示点号（.）能够用来表示\n符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.findall(r&apos;th.+&apos;,&quot;&quot;&quot;</div><div class="line">... The first line</div><div class="line">... the second line</div><div class="line">... the third line</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">[&apos;the second line&apos;, &apos;the third line&apos;]</div><div class="line">&gt;&gt;&gt; re.findall(r&apos;(?s)th.+&apos;,&quot;&quot;&quot;</div><div class="line">... The first line</div><div class="line">... the second line</div><div class="line">... the third line</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">[&apos;the second line\nthe third line\n&apos;]</div></pre></td></tr></table></figure><p>re.X/VERBOSE标记允许用户通过抑制在正则表达式中使用空白符来创建更易读的正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.search(r&apos;&apos;&apos;(?x)</div><div class="line">... \((\d&#123;3&#125;)\) #区号</div><div class="line">... [ ]  #空白符</div><div class="line">... (\d&#123;3&#125;) #前缀</div><div class="line">... -  #横线</div><div class="line">... (\d&#123;4&#125;) #终点数字</div><div class="line">... &apos;&apos;&apos;,&apos;(800) 555-1212&apos;).groups()</div><div class="line">(&apos;800&apos;, &apos;555&apos;, &apos;1212&apos;)</div></pre></td></tr></table></figure><p>(?:…)符号可以对部分正则表达式进行分组，但是不会保存该分组用于后续的检索或应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.findall(r&apos;http://(?:\w+\.)*(\w+\.com)&apos;,</div><div class="line">... &apos;http://google.com http://www.google.com http://code.google.com&apos;)</div><div class="line">[&apos;google.com&apos;, &apos;google.com&apos;, &apos;google.com&apos;]</div><div class="line">&gt;&gt;&gt; re.search(r&apos;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?:\d&#123;4&#125;)&apos;,</div><div class="line">... &apos;(800) 555-1212&apos;).groupdict()</div><div class="line">&#123;&apos;areacode&apos;: &apos;800&apos;, &apos;prefix&apos;: &apos;555&apos;&#125;</div></pre></td></tr></table></figure><p>可以同时使用(?P<name>)和(?P=name)符号。前者通过使用一个名称标识符而不是使用从1开始增加到N的增量数字来保存匹配，如果使用数字来保存匹配结果，我们就可以通过使用\1、\2、…,\N来索引，如下所示，可以使用一个类似风格的\g<name>来检索它们。</name></name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.sub(r&apos;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?:\d&#123;4&#125;)&apos;,</div><div class="line">... &apos;(\g&lt;areacode&gt;) \g&lt;prefix&gt;-xxxx&apos;, &apos;(800) 555-1212&apos;)</div><div class="line">&apos;(800) 555-xxxx&apos;</div></pre></td></tr></table></figure><p>使用后者，可以在同一个正则表达式中重用模式。例如，验证一些电话号码的规范化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bool(re.match(r&apos;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?P&lt;number&gt;\d&#123;4&#125;) (?P=areacode)-(?P=prefix)-(?P=number) 1(?P=areacode)(?P=prefix)(?P=number)&apos;, &apos;(800) 555-1212 800-555-1212 18005551212&apos;))</div><div class="line">True</div></pre></td></tr></table></figure><p>使用（？x）使代码更易读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bool(re.match(r&apos;&apos;&apos;(?x)</div><div class="line">... \((?P&lt;areacode&gt;\d&#123;3&#125;)\)[ ](?P&lt;prefix&gt;\d&#123;3&#125;)-(?P&lt;number&gt;\d&#123;4&#125;)</div><div class="line">... [ ]</div><div class="line">... (?P=areacode)-(?P=prefix)-(?P=number)</div><div class="line">... [ ]</div><div class="line">... 1(?P=areacode)(?P=prefix)(?P=number)</div><div class="line">... &apos;&apos;&apos;,&apos;(800) 555-1212 800-555-1212 18005551212&apos;))</div><div class="line">True</div></pre></td></tr></table></figure><p>可以使用(?=…)和(?!…)符号在目标字符串中实现一个前视匹配：</p><p>(?=…)字符串后面跟着…才适配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.findall(r&apos;\w+(?= van Rossum)&apos;,</div><div class="line">... &apos;&apos;&apos;</div><div class="line">... Guido van Rossum</div><div class="line">... Tim Peters</div><div class="line">... Alex Martelli</div><div class="line">... Just van Rossum</div><div class="line">... Raymond Hettinger</div><div class="line">... &apos;&apos;&apos;)</div><div class="line">[&apos;Guido&apos;, &apos;Just&apos;]</div></pre></td></tr></table></figure><p>(?!…)字符串后面不跟着…才适配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; re.findall(r&apos;(?m)^\s+(?!noreply|postmaster)(\w+)&apos;,</div><div class="line">... &apos;&apos;&apos;</div><div class="line">...  sales@phptr.com</div><div class="line">...  postmaster@phptr.com</div><div class="line">...  eng@phptr.com</div><div class="line">...  noreply@phptr.com</div><div class="line">...  admin@phptr.com</div><div class="line">... &apos;&apos;&apos;)</div><div class="line">[&apos;sales&apos;, &apos;eng&apos;, &apos;admin&apos;]</div></pre></td></tr></table></figure><p>比较re.findall()和re.finditer()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [&apos;%s@awcom&apos; % e.group(1) for e in re.finditer(r&apos;(?m)^\s+(?!noreply|postmaster)(\w+)&apos;,</div><div class="line">... &apos;&apos;&apos;</div><div class="line">...  postmaster@phptr.com</div><div class="line">...  noreply@phptr.com</div><div class="line">...  admin@phptr.com</div><div class="line">...  eng@phptr.com</div><div class="line">...  sales@phptr.com</div><div class="line">... &apos;&apos;&apos;)]</div><div class="line">[&apos;admin@awcom&apos;, &apos;eng@awcom&apos;, &apos;sales@awcom&apos;]</div></pre></td></tr></table></figure><p>条件正则表达式匹配，假定拥有一个特殊字符，它仅仅包含字母x和y，两个字母必须由一个跟着另外一个，不能同时拥有相同的两个字母：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bool(re.search(r&apos;(?:(x)|y)(?(1)y|x)&apos;, &apos;xy&apos;))</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(re.search(r&apos;(?:(x)|y)(?(1)y|x)&apos;, &apos;xx&apos;))</div><div class="line">False</div></pre></td></tr></table></figure><h2 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h2><p>在UNIX系统中，who命令会展示登录的用户信息。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ who</div><div class="line">sl       console  Nov 21 08:59 </div><div class="line">sl       ttys000  Nov 21 09:09 </div><div class="line">sl       ttys001  Nov 21 10:30 </div><div class="line">➜  ~</div></pre></td></tr></table></figure><p>如果想按照空格（多个，数量不确定）分隔的话，可以使用\s\s+，下面创建一个程序，将保存在文件whodata.txt中的数据读出来：<br>先将who的数据保存在whodata.txt文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ who &gt; /Users/sl/Desktop/whodata.txt</div></pre></td></tr></table></figure><p>然后执行下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">f = open(&apos;whodata.txt&apos;,&apos;r&apos;)</div><div class="line">for eachLine in f:</div><div class="line">    print(re.split(r&apos;\s\s+&apos;, eachLine))</div><div class="line">f.close()</div></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[&apos;sl&apos;, &apos;console&apos;, &apos;Nov 21 08:59&apos;, &apos;&apos;]</div><div class="line">[&apos;sl&apos;, &apos;ttys000&apos;, &apos;Nov 21 09:09&apos;, &apos;&apos;]</div><div class="line">[&apos;sl&apos;, &apos;ttys001&apos;, &apos;Nov 21 10:30&apos;, &apos;&apos;]</div></pre></td></tr></table></figure><p>优化上面的程序：</p><p>上面的程序，who命令是在脚本外部执行的，每次手动重复做这件事让人很厌倦，我们可以通过调用os.popen()命令（现在已经被subprocess模块替代）将这个命令的执行在脚本内部实现。另外我们使用str.rstrip()去除尾部的\n，程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import os</div><div class="line"></div><div class="line">f = os.popen(&apos;who&apos;, &apos;r&apos;)</div><div class="line">for eachLine in f:</div><div class="line">    print(re.split(r&apos;\s\s+|\t&apos;, eachLine.rstrip()))</div><div class="line">f.close()</div><div class="line">#结果：</div><div class="line">[&apos;sl&apos;, &apos;console&apos;, &apos;Nov 21 08:59&apos;]</div><div class="line">[&apos;sl&apos;, &apos;ttys000&apos;, &apos;Nov 21 09:09&apos;]</div><div class="line">[&apos;sl&apos;, &apos;ttys001&apos;, &apos;Nov 21 10:30&apos;]</div></pre></td></tr></table></figure><p>还可以使用with语句，可以使上下文管理对象变得更简易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import os</div><div class="line"></div><div class="line">with os.popen(&apos;who&apos;, &apos;r&apos;) as f:</div><div class="line">    for eachLine in f:</div><div class="line">        print(re.split(r&apos;\s\s+|\t&apos;, eachLine.rstrip()))</div></pre></td></tr></table></figure><p>如果要适配python2和python3的话，可以避免使用print（）,而使用两个版本中都有的函数distutils.log.warn()，并将其转换成printf名来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import os</div><div class="line">from distutils.log import warn as printf</div><div class="line">with os.popen(&apos;who&apos;, &apos;r&apos;) as f:</div><div class="line">    for eachLine in f:</div><div class="line">        printf(re.split(r&apos;\s\s+|\t&apos;, eachLine.rstrip()))</div></pre></td></tr></table></figure><p>生成随机数的例子，用于希望练习从中匹配、搜索正则表达式使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from random import randrange, choice</div><div class="line">from string import ascii_lowercase as lc</div><div class="line">from sys import maxsize</div><div class="line">from time import ctime</div><div class="line"></div><div class="line">tlds = (&apos;com&apos;, &apos;edo&apos;, &apos;net&apos;, &apos;org&apos;, &apos;gov&apos;)</div><div class="line"></div><div class="line">for i in range(randrange(5, 11)):</div><div class="line">    dtint = randrange(maxsize) / 3000000000</div><div class="line">    dtstr = ctime(dtint)</div><div class="line">    llen = randrange(4, 8)</div><div class="line">    login = &apos;&apos;.join(choice(lc) for j in range(llen))</div><div class="line">    dlen = randrange(llen, 13)</div><div class="line">    dom = &apos;&apos;.join(choice(lc) for j in range(dlen))</div><div class="line">    print(&apos;%s::%s@%s.%s::%d-%d-%d&apos; % (dtstr, login, dom, choice(tlds), dtint, llen, dlen))</div><div class="line"></div><div class="line">#随机产生的结果</div><div class="line">Mon Jun 24 08:07:21 2024::nunzkre@iqdhccpw.gov::1719187641-7-8</div><div class="line">Sun May 21 12:23:33 2062::dxlyq@kupbixskweqj.edo::2915411013-5-12</div><div class="line">Thu Sep  2 18:27:12 1999::vuhihly@hdgaimdma.com::936268032-7-9</div><div class="line">Mon Jul 30 16:45:03 2007::vygxw@diwdeqkq.net::1185785103-5-8</div><div class="line">Thu Jul  8 01:50:54 1971::mjxs@dmcuo.com::47757054-4-5</div><div class="line">Thu Sep  1 03:02:30 2005::djld@eohculuz.gov::1125514950-4-8</div><div class="line">Sun Nov 27 01:23:35 2011::cjvf@atvmdgxupi.gov::1322328215-4-10</div><div class="line">Thu Aug  1 18:36:36 2024::phasko@flcfkvb.org::1722508596-6-7</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对文本进行处理在数据科学实践中必不可少的一环，业界的文本数据往往杂乱无章，而且数量及其庞大，当我们需要对文本进行片段匹配时，就要求我们利用计算机来批量地在文本中检索某种模式。正则表达式（Regular Expression）就是可以进行文本匹配的一种高级模式，它是一些由字符和特殊符号组成的字符串，它可以按照某种模式匹配一系列有相似特征的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>读书记（6）：西方哲学前沿~新古典自由主义的破冰之旅</title>
    <link href="http://yoursite.com/2018/01/17/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%89%8D%E6%B2%BF%20%E2%80%94%E2%80%94%20%E6%96%B0%E5%8F%A4%E5%85%B8%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89%E7%9A%84%E7%A0%B4%E5%86%B0%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/01/17/读书记（6）：西方哲学前沿 —— 新古典自由主义的破冰之旅/</id>
    <published>2018-01-17T12:20:28.000Z</published>
    <updated>2018-11-07T15:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间：2018年3月12日<br>地点：中国人民大学国学馆228<br>主讲：周濂</p></blockquote><p>德鲁克在《经济人的末日》1994年的再版序言中说：“可以确定的是，我们现在的世界，或许跟之前的所有社会一样，疯狂错乱。但偏执不是治愈疯狂世界的良方。相反，要在疯狂的环境中生存，更需要保持清醒。”现代性的根本宗旨就是凭借人类理性去营建和维系一个理性、有序。可控和可理解的社会秩序。虽然二十世纪的历史充满灾难和无序，但在一个上帝盾形的时代，我们只能将现代性的自由平等理想坚持下去，让自己的行为理性起来，正如的德鲁克所言，唯有如此，我们才有机会拥有一个正直的、有意义的、有成就感的人生和一个正直的社会。</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwzwuu14wkj31400p00vk.jpg" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.50.40.png" alt="屏幕快照 2018-03-12 下午4.50.40"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.12.png" alt="屏幕快照 2018-03-12 下午4.52.12"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.17.png" alt="屏幕快照 2018-03-12 下午4.52.17"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.24.png" alt="屏幕快照 2018-03-12 下午4.52.24"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.28.png" alt="屏幕快照 2018-03-12 下午4.52.28"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.30.png" alt="屏幕快照 2018-03-12 下午4.52.30"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.33.png" alt="屏幕快照 2018-03-12 下午4.52.33"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.38.png" alt="屏幕快照 2018-03-12 下午4.52.38"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.51.41.png" alt="屏幕快照 2018-03-12 下午4.51.41"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.45.png" alt="屏幕快照 2018-03-12 下午4.52.45"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.48.png" alt="屏幕快照 2018-03-12 下午4.52.48"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.52.png" alt="屏幕快照 2018-03-12 下午4.52.52"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.52.58.png" alt="屏幕快照 2018-03-12 下午4.52.58"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.04.png" alt="屏幕快照 2018-03-12 下午4.53.04"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.07.png" alt="屏幕快照 2018-03-12 下午4.53.07"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.13.png" alt="屏幕快照 2018-03-12 下午4.53.13"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.17.png" alt="屏幕快照 2018-03-12 下午4.53.17"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.19.png" alt="屏幕快照 2018-03-12 下午4.53.19"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.23.png" alt="屏幕快照 2018-03-12 下午4.53.23"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.28.png" alt="屏幕快照 2018-03-12 下午4.53.28"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.32.png" alt="屏幕快照 2018-03-12 下午4.53.32"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.36.png" alt="屏幕快照 2018-03-12 下午4.53.36"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.38.png" alt="屏幕快照 2018-03-12 下午4.53.38"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.44.png" alt="屏幕快照 2018-03-12 下午4.53.44"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.48.png" alt="屏幕快照 2018-03-12 下午4.53.48"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.50.png" alt="屏幕快照 2018-03-12 下午4.53.50"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.56.png" alt="屏幕快照 2018-03-12 下午4.53.56"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.53.57.png" alt="屏幕快照 2018-03-12 下午4.53.57"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.01.png" alt="屏幕快照 2018-03-12 下午4.54.01"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.05.png" alt="屏幕快照 2018-03-12 下午4.54.05"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.09.png" alt="屏幕快照 2018-03-12 下午4.54.09"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.12.png" alt="屏幕快照 2018-03-12 下午4.54.12"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.16.png" alt="屏幕快照 2018-03-12 下午4.54.16"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.21.png" alt="屏幕快照 2018-03-12 下午4.54.21"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.24.png" alt="屏幕快照 2018-03-12 下午4.54.24"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.29.png" alt="屏幕快照 2018-03-12 下午4.54.29"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.33.png" alt="屏幕快照 2018-03-12 下午4.54.33"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.39.png" alt="屏幕快照 2018-03-12 下午4.54.39"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.42.png" alt="屏幕快照 2018-03-12 下午4.54.42"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.47.png" alt="屏幕快照 2018-03-12 下午4.54.47"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.50.png" alt="屏幕快照 2018-03-12 下午4.54.50"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.52.png" alt="屏幕快照 2018-03-12 下午4.54.52"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.54.57.png" alt="屏幕快照 2018-03-12 下午4.54.57"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.00.png" alt="屏幕快照 2018-03-12 下午4.55.00"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.03.png" alt="屏幕快照 2018-03-12 下午4.55.03"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.05.png" alt="屏幕快照 2018-03-12 下午4.55.05"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.08.png" alt="屏幕快照 2018-03-12 下午4.55.08"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.10.png" alt="屏幕快照 2018-03-12 下午4.55.10"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.14.png" alt="屏幕快照 2018-03-12 下午4.55.14"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.17.png" alt="屏幕快照 2018-03-12 下午4.55.17"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.19.png" alt="屏幕快照 2018-03-12 下午4.55.19"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.21.png" alt="屏幕快照 2018-03-12 下午4.55.21"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.26.png" alt="屏幕快照 2018-03-12 下午4.55.26"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.29.png" alt="屏幕快照 2018-03-12 下午4.55.29"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.33.png" alt="屏幕快照 2018-03-12 下午4.55.33"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.36.png" alt="屏幕快照 2018-03-12 下午4.55.36"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.38.png" alt="屏幕快照 2018-03-12 下午4.55.38"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.45.png" alt="屏幕快照 2018-03-12 下午4.55.45"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.49.png" alt="屏幕快照 2018-03-12 下午4.55.49"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.52.png" alt="屏幕快照 2018-03-12 下午4.55.52"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.54.png" alt="屏幕快照 2018-03-12 下午4.55.54"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.55.56.png" alt="屏幕快照 2018-03-12 下午4.55.56"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.00.png" alt="屏幕快照 2018-03-12 下午4.56.00"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.02.png" alt="屏幕快照 2018-03-12 下午4.56.02"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.07.png" alt="屏幕快照 2018-03-12 下午4.56.07"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.09.png" alt="屏幕快照 2018-03-12 下午4.56.09"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.14.png" alt="屏幕快照 2018-03-12 下午4.56.14"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2018-03-12 下午4.56.28.png" alt="屏幕快照 2018-03-12 下午4.56.28"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间：2018年3月12日&lt;br&gt;地点：中国人民大学国学馆228&lt;br&gt;主讲：周濂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;德鲁克在《经济人的末日》1994年的再版序言中说：“可以确定的是，我们现在的世界，或许跟之前的所有社会一样，疯狂错乱。但偏执不是治愈疯狂世界的良方。相反，要在疯狂的环境中生存，更需要保持清醒。”现代性的根本宗旨就是凭借人类理性去营建和维系一个理性、有序。可控和可理解的社会秩序。虽然二十世纪的历史充满灾难和无序，但在一个上帝盾形的时代，我们只能将现代性的自由平等理想坚持下去，让自己的行为理性起来，正如的德鲁克所言，唯有如此，我们才有机会拥有一个正直的、有意义的、有成就感的人生和一个正直的社会。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="新古典自由主义" scheme="http://yoursite.com/tags/%E6%96%B0%E5%8F%A4%E5%85%B8%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89/"/>
    
      <category term="哈耶克" scheme="http://yoursite.com/tags/%E5%93%88%E8%80%B6%E5%85%8B/"/>
    
      <category term="罗尔斯" scheme="http://yoursite.com/tags/%E7%BD%97%E5%B0%94%E6%96%AF/"/>
    
      <category term="诺齐克" scheme="http://yoursite.com/tags/%E8%AF%BA%E9%BD%90%E5%85%8B/"/>
    
      <category term="德鲁克" scheme="http://yoursite.com/tags/%E5%BE%B7%E9%B2%81%E5%85%8B/"/>
    
      <category term="自由" scheme="http://yoursite.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="平等" scheme="http://yoursite.com/tags/%E5%B9%B3%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>读书记（5）：《伯林谈话录》摘</title>
    <link href="http://yoursite.com/2018/01/15/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E3%80%8A%E4%BC%AF%E6%9E%97%E8%B0%88%E8%AF%9D%E5%BD%95%E3%80%8B%E6%91%98/"/>
    <id>http://yoursite.com/2018/01/15/读书记（5）：《伯林谈话录》摘/</id>
    <published>2018-01-15T12:20:28.000Z</published>
    <updated>2018-11-08T11:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h3><p>他反对那种以为可以依据科学的、政治的、甚至美学的价值在人世间创造一个乌托邦的主张。鉴于人类历史实际上是各种经常相互碰撞的价值和思想的产生地及其变化发展的实验场所这一事实，伯林追溯多元论在伦理学、政治学和美学等领域的出现。</p><a id="more"></a><p>但是，如果我说的不错，不光最终解决这个概念本身是不切实际的，而且，各种价值之间也不可避免地是相互碰撞的、不可协调的。最终解决的可能性（即使我们忘记了这个词组带有希特勒时期的恐怖感）会制造出一种幻觉，一种非常危险的幻觉。因为，如果人们真的相信这种解决是可能的，那么，为了达到这个目标付出多少都绝不为过：为了使人类永远公正、幸福、富于创造性以及和谐协调，有什么不可以为此付出的呢？为了做成这样的蛋卷，我们可以打破无限数量的鸡蛋，这就是列宁、托洛茨基以及我们所了解的波尔布特的信念。既然我知道通往社会问题最终解决的唯一正确道路，我也就知道人类车队必须沿着什么路线走；因为你没有我这种知识，你就不能有选择自由，哪怕是最低限度的选择自由，否则你就达不到目的地。你声明采取某种方式将使你更幸福、更自由，或将使你有自由呼吸的空间，而我知道你这样想是错误的。我知道你需要什么，人民大众需要什么。如果出现由于无知或恶意而酿成的反抗，那就必须振亚下去，为了大多数人永远幸福，消灭成千上万人也许是必要的。除了心甘情愿地将他们全都牺牲掉，我们，明白此中道理的我们，又有什么选择？“（扭曲的人性之材）</p><p>《往事与随想》赫尔岑  选择概念（关键地位）</p><p>在思想史的工作中，伯林研究了那些勇敢地、公开地跟占统治地位的理性体系作斗争的思想，赞赏他们的观点和立场。他特别重视这些思想家的自由思想。正式对这种普遍存在的自由思想的肯定和褒赏，显示了他的思想史研究具有重要意义。通过他的研究工作，伯林向我们宣示，在人类历史上没有绝对的价值，而且，人类历史与众多悲剧性后果相伴，充满着那些企图通过坚信最终绝对真理而避免做出悲剧性选择的人们的困苦。</p><p>普列汉诺夫   伯林：”普列汉诺夫的确是一位富有才华的马克思主义著作家。我完全被他的书迷住了，因为他学识渊博，说理精辟，行文机智，情趣横生，极富吸引力。他是真正的马克思主义之父“</p><p>赫尔岑  伯林：”赫尔岑成了我的人生楷模。他是一个非常杰出的作家，一个敏锐的真正的政治思想家，非常有独创性。他的自传大概是我一生中度过的最精彩的自传，比卢梭的自传还要好。正是赫尔岑使我爱上了社会思想史和政治思想史，这就是我研究思想史的真正的开端。“</p><p>《日瓦戈医生》  帕斯捷尔纳克  伯林：”他当然是一位伟大的诗人。这么说吧，诗人可以有两种类型。第一种诗人，写诗时是诗人，而写散文诗是作家，像普希金。第二种诗人，写诗时是诗人，而写散文时也是诗人。帕斯捷尔纳克就属于第二种类型的诗人。他的散文总是诗化的散文，我看他本质上不是一个散文作家。他是晚近俄罗斯伟大的诗人之一，他的小说是伟大的诗化小说。尽管他置身于那虚浮造作的时代中心，却能诚实地描写爱——男主人公对女主人公的爱，极少有作家能够做到这点。正是他的诗使他赢得俄国人和阅读俄文作品的外国人的广泛钦佩，实际上，只有约瑟夫·布罗茨基的成就可与他相媲美。阿赫玛托娃和曼德尔施塔姆都差得远。依我看，帕斯捷尔纳克在各方面都堪称是活着的最优秀的俄国诗人。但是并非所有天才都表里如一，帕斯捷尔纳克也同样如此。他谈起话来稀奇古怪，经常让听者捉摸不透，但总让你感到才气逼人。再也没有比听他谈话更迷人的事了。据我的体会，只有弗吉尼亚·伍尔夫谈到某些东西时像他那样迷人。当然弗吉尼亚·伍尔夫有点狂妄。“</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxncp2mb3j30go0ao750.jpg" alt=""></p><p>马雅可夫斯基  伯林：”他是一个大胆的革新者，一个惊人的雄辩家，一个真正的革命者，但是，他的诗作我看比不上帕斯捷尔纳克、曼德尔施塔姆和阿赫玛托娃。“</p><p>如果你对某些思想有兴趣，并引起你思考一些问题，那么你就不能不考虑这些思想的历史。因为思想不是单子，他们不是在真空中产生的，而跟人们的信念、生活方式、人生观和世界观紧密相连。思想之间相互碰撞和影响，并不断呈现，成为所谓”智性气候“的组成部分，他和物质因素一样，形成人们的行为和感情，并且历史地变迁着。</p><p>哲学不是一种积累性的学科。古代那些基本的哲学思想、观点、理论和见解现在仍然是哲学的中心内容。他们有其特定的横贯历史的生命。</p><p>哲学，如果教得好的话，其用处之一就是让人透过政治上冠冕堂皇的辞藻，识别各种谬论、欺骗、恶作剧、赘疣、感情上的讹诈，以及各种各样的诡辩和伪装，他能大大增强人们的批判能力。</p><p>哲学不外是要在看不到办法的地方力图去寻找问题的答案。自我理解是哲学的主要目的之一，哲学的目标就是要理解人、事物、词语三者之间的相互关系。</p><p>在叔本华那里我没有发现包罗万象的形而上学大厦那样的东西。人们可能对叔本华的体系一无所知，但照样能从他许多尖锐的有时是深刻的见解中获得教益。黑格尔的体系在我看来，似乎是希腊神话中的独眼巨人波吕斐摩斯的阴森森的黑洞，一进去就出不来，每一个脚印都指示一条道路，正如拉丁诗人所说的那样。</p><p>伯林：”他（指施特劳斯）和他的门生都相信，善于恶、对与错都直接得自某种先天的启示，某种”形而上学之眼“，也就是靠使用柏拉图式的那种无缘分享的理性官能。柏拉图、亚里士多德、《圣经》、犹太教法典、迈蒙尼德，也许还有阿奎那和中世纪的其他经院哲学家，都通晓什么样的人生才是最美好的，他们的门生现在也执着于此，而我却没有这种荣幸。“</p><h3 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h3><p>世界上存在的一切不外乎就是人、物和人脑中的观念————目标、情感、希望、畏惧、选择、想象的情景和所有其他形式的人类经验。这就是我所认识的全部东西。我无法做到无所不知。也许有一个永恒真理和永恒价值的世界，有一种只有真正的思想家才能具有的魔眼，而这只属于恐怕我永远无法进入的极少数精英的领地。</p><p>在关键时期，在历史转折关头，当各种因素大体上平衡地出现的时候，个人以及他们的抉择的行动，本身不一定可被预见（确实很少被预见），但却能决定历史的进程。我不相信历史是一部戏剧（这是赫尔岑使用的概念，他认为历史不是一部多幕剧，一部由上帝或大自然赋予主题的演出，不是有图像可辨的地毯）。而马克思和黑格尔都认为历史是一部有结局的多幕剧，它在达到高潮之后（在马克思看来，要经过可怕的冲突、苦难、灾祸）天堂之门将会启开，那就是戏剧的收场，历史（马克思称为史前时期）便会从此结束，一切事物都永恒协调，人们将合乎理性地合作共事。</p><p>维科和赫尔德相信历史进程有一定的形式，但不相信历史是一部有结局的戏剧。</p><p>我感兴趣的是维科和赫尔德的文化多元性的信念。实际上，每种文化都有自己的重心，各种文化有着各不相同的、新颖的、不可预见的思想及其互相冲突的倾向。维科最先理解到，文化就是世界相对于社会的意义，就是男男女女对于他们自身与别人和环境发生关联的集体意识；文化影响思想、情感、行为、举动的特定形式；文化是多种多样的。维科划分不同时期的文化，赫尔德则对不同时代的不同民族的文明做了区分。</p><p>我认为历史不是一个呆板的单线条的进步过程。伏尔泰说，历史是理性、知识和艺术品创造不断进步的过程，有时被可怕的干扰所打破，突然陷入野蛮状态。</p><p>预言是一种普遍却难以信赖的活动。我在维科和赫尔德的著作中经所读到的，是人类历史固有的文化多样性的观点。历史并不直线行走，不同文化之间相互作用，有时就是因果性质的作用。通向未来或过去的道路不存在唯一的钥匙，他不好跟自然科学作类比。后者的定律对重复出现的因果链是开放的，这样的因果链能总结为一般的规律。</p><p>我们能够理解不同民族和地区人们的生活方式（即使他们的生活方式跟我们的差异很大，即使他们憎恨我们或有时候被我们所谴责），这样的事实表明，我们大家能够穿越时空进行沟通。当我们认了理解了那些与我们在文化上有很大差别的群体的时候，即意味着某种强大的富于同情心的理解、洞察和共感的存在。即便其他文化排斥我们，依靠移情的想象力，我们也可以设想，为什么他们会产生这样的思想和感情，并采取相应的行动达到预定的目标。</p><p>一般性的价值观是有的，这是关于人类的经验事实，莱布尼茨称为事实的真理而不是原理性的真理。不同时空的芸芸众生，绝大多数人都共同拥有某些价值观，不论这些价值观是否自觉明晰，也不论他们在态度、举止和行动上的表现如何。另一方面，人与人之间、社会与社会之间，又确实存在着很大的差异。如果你确实了解了个人之间、团体之间、民族之间、各个完整的文明之间所存在的差异，运用想象进入他们的思想、情感世界、设想你自己置身于他们的生存环境中会怎样认知世界并审视自己与他们的关系，那么，即使你对所观察到的东西很反感（全部了解当然并不等于全部谅解），也肯定会减少盲目的偏执和狂热。想象会产生狂热，但通过想象洞察了不同于自己的境况，结果必定能减少狂热。</p><p>我认为，人们在把一个有思考里的人称为疯子或神经错乱者时务必小心谨慎。迫害不是来自神经错乱，而产生于把骇人听闻的谬误深信为真理，进而导致罄竹难书的恶果。</p><p>了解自己及他人，懂得理性的方法，掌握作为知识和全部科学基础的证据，以及力图验证直观确定性，这些对我们来说都有着根本的重要性。人权这个观念建立在一个正确的信念之上，那就是普遍存在着某种特定的品性。自由、正义、对幸福的追求、真诚、爱。这符合整个人类的利益，而不只是符合作为这个或那个民族、宗教、职业、身份的成员的利益。满足这些要求，保护人们这些要求不被忽视或否认，都是正当的。</p><p>你必须懂得什么是正义，什么是自由，什么是社会契约，并对不同类别的自由、权威、义务作出区分等等。政治理论的分野往往围绕“为什么有些人要服从理你些人”这个中心问题来展开。多数政治理论都是对这个问题的回答。实质上不是为什么服从，而是为什么应该服从和服从到什么程度。</p><p>关于消极自由的问题是：拦在我面前有什么障碍要排除？其他人怎样妨碍着我？其他人这样做是有意的还是无意的？是间接的还是有制度依据的？</p><p>关于积极自由的问题是：谁管我？别人管还是自己管？如果是别人，他凭借什么权利？什么权威？如果我有权自主，自己管自己，那么，我会不会失去这个权利？能不能丢掉这个权利？放弃这个权利再恢复这个权利？具体怎么做？还有，谁制定法律？或谁执行法律？征求过我的意见吗？是多数人在统治吗？为什么？是因为上帝、牧师、还是党？是出于公共舆论的压力？传统的压力？还是摄于什么权威？</p><p>积极自由在正常生活中虽然更重要，但与消极自由相比更频繁地被歪曲和滥用。历史上虚伪的积极自由所造成的危害比现代虚伪的消极自由所造成的危害更大。</p><p>真诚地相信错误的东西是很危险的，是没有道德价值或精神价值的，至少是令人遗憾的。</p><p>自由社会的好处在于容许各种各样相互冲突的意见存在而不被压制。</p><p>多元论确认：既然对于道德和政治问题以至任何价值问题不可能有一个最终的解答，并且，人们给出的或有权给出的某些解答是相互矛盾的，那么，在实际生活的某些领域，有些价值便可能变得互不相容，这样，如果要避免破坏性的冲突的话，就应该妥协，而最低限度的宽容，不管你情不情愿，都是必不可少的。</p><p>人们可以选择一种生活或另一张生活，而不能同时过两种生活；没有更为根本的标准用来决定正确的选择；既然选择这种也行，选择那种也行，在客观上就不能说一种生活优于另一种生活。它是人们想做什么和成为什么的问题。</p><p>浪漫主义认为，价值不是发现而是创造出来的，生活的目的就是生活本身。生活就是生活，没有目的。</p><p>政治哲学的任务是审视生活。要做的事就是审查为实现各种社会目标而提出的种种主张的合理性，检查为确定和实现这些目标而采取的种种方法的正当性。政治哲学要力图澄清构成有关观点的词和概念，使人们能理解自己相信的是什么，自己的行动表示什么。政治哲学还对那些维护或者反对人们所追求的各种目标的辩论作出评价，并防止麦克米兰所引述的胡说八道。</p><p>对人类的问题，追求一种唯一的、最后的、普遍的解决，无异于是追求海市蜃楼。对于人类生活破坏严重的，莫过于那种迷信了：凡美好生活都是跟政治或者军事力量相联结的。</p><p>多数英国哲学家似乎都太单薄、太技术化；跟英国哲学家相比，多数法国哲学家似乎都太含糊、太夸饰。</p><p>我认为马基雅维利是指出现实的各种价值是相互冲突的第一人。依照马基雅维利的观点，你可以选择做一个罗马人或一个基督教徒和殉道者，或者起码可以做一个当权者统治下的受害者。</p><p>任何真正的问题在某种意义上都是当代的问题。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxncvtrsdj309q09qdfv.jpg" alt=""></p><p>我认为维科是理解了并告诉我们什么是人类文化的第一人。他不自觉地确立了文化的观念。就我所知，在他之前没有谁有过这样的想法，要努力去重构人们是如何看待生活在周围环境中的自己，如何看待（或感受）与自己发生关联的自然界和其他人————作为在时间中持续存在下来的一类生灵。他反思思想、情感、世界观等各类行为以及肉体的、情绪的、理智的、精神的等多种反应的本质，而正是这些行为和反应构成了文化。如果你想了解人们怎样生活，你必须了解他们的崇拜仪式，文字的内涵，他们通常运用什么类型的想象、明喻、隐喻，他们如何吃、喝、抚养小孩，如何看待自己，如何过私人的、社会的、经济的和政治的生活等等。作为一种模式的文化不是一个孤立的有机体，而是一种存在方式，树立这种理念正是维科对思想史的主要贡献。维科的值得重视的观点是：各不相同的人类思想、行为、感情和行动是互相联结和互相启发的。</p><p>米什莱按照维科的思路，认为历史就是社会跟自然力量作斗争并力图运用自然力量去创造让人们能生存和发展的生活方式的历史。人的历史是跟自然界，跟各种力量，跟一切人为的和非人为的障碍进行斗争的历史，这就是米什莱关于人类从各种羁绊中朝向自我解放不断进步的观点。</p><p>我们谈论自然界，但我们所知道的自然界仅是我们在外部世界所发现的东西。我们也看见和感触我们的身体，但我们还能说出他作为人之具体化有什么样的感受，这是一种“内在的审视”；人既是观察者，又是行动者。这就是“新科学”的大概意思。理解对于意图、感情、希望、恐惧、努力、意识和无意识的认识，而科学是对处在空间中的物体的认识。换句话说，我们可以看见桌子是什么样的，但我们看不见桌子为什么是这样的。理解过去的文化就是去理解前任所追求的东西；他们怎样看待与他人发生关联的自己，怎样看待世界以及生活在这个世界中的自己。</p><h3 id="其三"><a href="#其三" class="headerlink" title="其三"></a>其三</h3><p>在赫尔德看来，“归属于”的意思是，你说什么，不必多做解释，大家就能了解；你的姿态、语言、所有参与交流的因素，不需敬你熟悉的人作介绍，大家都能把握。是语言、习惯、姿态或本能的反应创造了联合和团结，即创造了具有自己特色的观点、文化和社会共同体。</p><p>我一开始读维科的著作简直就被他迷住了。我总是从接受邀请做讲演或写文章开始研究的。</p><p>唯一真实的东西是精神，是人与上帝的关系，人与人的关系，别无其他了。内在的精神，个人的灵魂的底蕴，内心世界，这是唯一实在的东西，至于礼节、学问和教阶制度，统统不在话下。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxnd1itmkj30dc0j1aaj.jpg" alt=""></p><p>赫尔德乐观地相信，人类大花园中的所有花卉都能和谐地生长，各种文化都能相互激励，为创造这种和谐的境界作出自己的贡献。绝不主张政治上的民族主义，政治上的民族主义必然大致侵略和培植民族自豪感。一个民族不是一个国家，而是一个文华实体，同一民族的人说共同的语言，生活在共同的地域，有着共同的习惯、共同的历史额共同的传统。</p><p>依我的看法，强烈的民族主义不过是耻辱心理的表现。高度发达的民族不会产生民族主义。民族主义是对伤害的反应。民资注意对一切事物均构成威胁。民族主义就等于我们对自己说，因为我们是德国人或法国人，所以我们是最优秀的人，我们完全有权做我们要做的事，一旦你把一切行为的根据放在民族这个超越个人的权威上，那就会扩展到政党，到阶级，到教会，通往压迫的道路便从此打开了。</p><p>你不能阻止科学的进步，造成灾难的不是武器，而在于使用武器的人。智能的进步是不能阻止的，人们所能做的是防止科学的滥用。廓清腐败的社会，荡涤一切污泥浊水，然后再向前进。</p><p>熊彼特正确的说过，那些相信观念必定绝对不变的人是偶像崇拜者。文明意味着必须允许变化的可能，意味着永不停息地去追求自己信奉的理想，为之献身也在所不惜。</p><p>不同的个人、集团。文化之间可以沟通，因为人的价值并非无限地多；他们共属于一条水平线，即客观的常常又相互矛盾的人类价值，在他们之间必须进行（常常是痛苦的）选择。</p><p>我自己感觉不到有这种既在现实生活之内又超越现实生活的实在。我不是宗教徒。但我对信教者的宗教体验评价颇高。我深深地被犹太教堂也包括基督教堂和伊斯兰教寺院中的宗教仪式所打动。我想，不理解信教是怎么一回事的人恐怕也不理解人为什么而活着。因此干巴巴的无神论者都是瞎子聋子，不了解人生的深刻体验，或者说不了解人生的内在底蕴，就像瞎子不能欣赏美景一样。光有感觉能力的人不能充分理解他人，包括信教者、不信教者、神秘主义者、儿童、诗人、艺术家等等。</p><p>我有一种深信不疑的看法，有些道德的、社会的和政治的价值是相互抵触的，任何一个社会总有一些价值是不能彼此调和的。换句话说，人们爱以生存的某种最终的价值，不光在实践上而且在原则上、在概念上都是不可兼得的，或者说不可彼此结合的。没有哪一个精于心机的人，同时又是无所计较，一切都听其自然的人。你不能把充分的自由跟充分的平等结合起来。给狼充分自由就不能同时也给羊有充分自由。正义和慈悲，知识和幸福，如此等等，都可能相互冲突，不可兼得。既然是这样，人类的问题（归根到底是如何生活的问题）就不可能全都求得完满的解决。这不是因为实际上有困难，找不到妥善的解决方法，而是因为这些价值本身在概念性质上都是有缺陷的。乌托邦式的解决在原则上没有缺陷，可以成立，但这样的解决是企图把不可结合的东西结合起来。某些人类的价值之所以不能相互结合，就因为他们本身是不能并存的。因此只能在彼此之间进行选择。选择可能很痛苦，如果你选择A，你就得忍痛失去B。在最终的各种人类价值之间不可避免要作出这样的选择。在任何可以想象的社会，选择都可能是痛苦而且是不可避免的。互不相容的价值本身始终是不能相容的。我们所能做的是防止选择太痛苦，这就意味着，我们需要有一种机制，使得人们对各种价值的追求尽可能不违背自己深刻的道德信念。在多元化的自由社会里，不可避免要作出各种妥协和折中，经过权衡利弊而避免最坏的情况。再三斟酌，取其一方。平等多重要？自有多重要？正义多重要？慈悲多重要？善良对重要？真理多重要？掂量掂量就知道了。知识和幸福也不总是牢牢结合的。一个知道自己患了癌症的人不会因为有了这种知识而感到幸福；无知会使他少一些自由，但同时却使他觉得多了一些幸福。这就是说，人生问题的某种最终解决，没有普遍适用的始终不变的可行保准。那些相信可能有完美无缺的社会的人必定以为，为了实现这种美好的社会，作出多大牺牲都是必要的，为了达到这种理想的目标，付出多大的代价都是值得的。他们想，如果必须要流血才能创造这种美好的社会，那么就流血吧，不管流谁的血，也不管流多少血。不打破鸡蛋怎么能做出上等的蛋卷，课时人们一旦养成打破鸡蛋的习惯，他们久不久罢手，鸡蛋打破了，蛋卷却没有做成。凡是以为对人生问题可以求得最终解决的这种狂热的信念，不能把导致灾难、痛苦、流血和可怕的压迫。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=5191751&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;其一&quot;&gt;&lt;a href=&quot;#其一&quot; class=&quot;headerlink&quot; title=&quot;其一&quot;&gt;&lt;/a&gt;其一&lt;/h3&gt;&lt;p&gt;他反对那种以为可以依据科学的、政治的、甚至美学的价值在人世间创造一个乌托邦的主张。鉴于人类历史实际上是各种经常相互碰撞的价值和思想的产生地及其变化发展的实验场所这一事实，伯林追溯多元论在伦理学、政治学和美学等领域的出现。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="以赛亚·伯林" scheme="http://yoursite.com/tags/%E4%BB%A5%E8%B5%9B%E4%BA%9A%C2%B7%E4%BC%AF%E6%9E%97/"/>
    
  </entry>
  
  <entry>
    <title>读书记（4）：增长黑客的炼成</title>
    <link href="http://yoursite.com/2018/01/13/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E7%9A%84%E7%82%BC%E6%88%90/"/>
    <id>http://yoursite.com/2018/01/13/读书记（4）：增长黑客的炼成/</id>
    <published>2018-01-13T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是《增长黑客》的思维导图整理。</p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/第一章：增长黑客.png" alt="第一章：增长黑客"><br><img src="http://omu7tit09.bkt.clouddn.com/第二章：正确的产品.png" alt="第二章：正确的产品"><br><img src="http://omu7tit09.bkt.clouddn.com/第三章：获取用户 .png" alt="第三章：获取用户 "><br><img src="http://omu7tit09.bkt.clouddn.com/第四章：激发活跃.png" alt="第四章：激发活跃"><br><img src="http://omu7tit09.bkt.clouddn.com/第五章：提高留存.png" alt="第五章：提高留存"><br><img src="http://omu7tit09.bkt.clouddn.com/第六章：增加收入.png" alt="第六章：增加收入"><br><img src="http://omu7tit09.bkt.clouddn.com/第七章：病毒传播.png" alt="第七章：病毒传播"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是《增长黑客》的思维导图整理。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/tags/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7/"/>
    
      <category term="活跃" scheme="http://yoursite.com/tags/%E6%B4%BB%E8%B7%83/"/>
    
      <category term="留存" scheme="http://yoursite.com/tags/%E7%95%99%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>读书记（3）：娱乐时代的疾呼</title>
    <link href="http://yoursite.com/2018/01/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E5%A8%B1%E4%B9%90%E6%97%B6%E4%BB%A3%E7%9A%84%E7%96%BE%E5%91%BC/"/>
    <id>http://yoursite.com/2018/01/11/读书记（3）：娱乐时代的疾呼/</id>
    <published>2018-01-11T14:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在地铁上看完了<a href="https://book.douban.com/subject/1062193/" target="_blank" rel="noopener">《娱乐至死》</a>，写点感想，做个串讲。</p><p>如果仅仅从书名“娱乐至死”的字面意思理解，我们或许都会误解，以为作者在书中定会着力指责那些活跃于电视荧幕的娱乐节目的缔造者们，将这个时代的浅薄与庸俗归咎于嬉皮笑脸的闪亮明星们，因为他们集体攻陷了普罗大众的闲暇时间，把他们一个个变成了“娱乐时代”的俘虏，从而变相地“奴役”了我们。</p><a id="more"></a><p>但其实波兹曼真正的意图并不在此。</p><p><div align="center"><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2wsiotrj30gt0ciwin.jpg" alt="100229-2"></div></p><p>开篇，波兹曼满怀激情地拥泵并阐释了麦克卢汉的“媒介即隐喻”的理论，我们会因为媒介的存在形式的更替变化（诸如纸媒、电媒）而在一个相当长的时期内受到其影响，这个过程是潜移默化的，最终触及到人类社会的生活方式。因为特定的媒介形式会偏好特定的内容，长期来讲，这些“特定媒介形式提供的特定内容”就会慢慢地塑造出人的新的生活方式甚至是整个人类社会的文化特征。</p><p>再者，波兹曼在此基础上阐发了“媒介即认识论”，我们每个人日常获得的信息大都是经过媒介报道的，因为自身的限制我们无法跳脱出媒介所呈现的信息，久而久之，就会在不知不觉中认为媒介中传递的信息便是对我们身处的社会真实的描绘，但事实上这仅仅是我们的一厢情愿，那些有态度的媒体们会因为其价值倾向或者利益诱导等等原因，对取材于“客观世界”的信息进行层层筛选把关之后，再进行“滤镜式”报道。这就导致了我们的“内心直观世界”和“客观的社会环境”之间不仅仅隔着不可知的成分，还因为有偏倚的媒体中介的存在而变得“扑朔迷离”。因此“真理的定义至少有一部分来自传递信息的媒体的性质，进而影响我们对“真理”或者是“外部世界”的定义与评价。</p><p>随后，波兹曼用了大量的篇幅描述了在印刷机统治下的社会环境与思想市场，在那个年代，文学家狄更斯访问美国时所得到的待遇简直可以和当代最引人注目的明星相媲美；开创美国的元勋都是学养高深的知识分子，他们深受印刷术带来的深度思考的福利；整个社会环境推崇的是严肃的、有序的、观点明确的、具有逻辑性的公众对话；美国人用白纸黑字来表明态度、表达思想、制定法律、销售商品、创造文学和宣扬宗教。而这一切都是通过印刷术实现的，印刷文字有语义、可释义的、有逻辑，建立在其上文化也正因为如此而变得稳重而成熟。波兹曼把那个时代叫做“阐释年代”，阐释是一种思想的模式，一种学习的方法，一种表达的图解。所有成熟的话语所拥有的特征，都被偏爱阐释的印刷术发扬光大；富有逻辑的复杂思维、高度的理性和秩序、超常的冷静与客观都在印刷术的带领下变得触手可及。印刷机不仅仅是一种机器，它更代表着一种话语结构。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2wsxeluj30gt0be76h.jpg" alt="104121"></div></p><p>然而让波兹曼深感缅怀的是，印刷术媒介在时代更迭中逐渐被电报、电视取代，再也回不到那个“阐释时代”。电报出现之时，便携带着无知无序无能的基因，它让公众话语变得无聊散乱，让我们的时间支离破碎，使我们的注意力被割裂。因为电报本身的性质就注定了它只适合于传播转瞬即逝的信息，各种各样的信息排着队被报道，一个报道完了便是下一个，很快就会被取代。新闻就是电报这个媒介所衍生出来的媒体内容，新闻往往是危言耸听、结构零散、没有目标受众，它就像一个个口号，毫无连贯性地进入读者的视野。在这样的语言中，没有关联，没有语境，没有历史，没有任何意义，它们拥有的是用趣味代替复杂而连贯的思想。读者们都随之变成了“知道分子”，他们知道很多事，但他们并不深入分析。</p><p>随后，电视来了，它成了新认识论的指挥中心。所有人都可以在电视中寻找一隅之地，所有公众感兴趣的话题都可以在电视上呈现。而电视的思维方式和印刷术的思维方式是格格不入的，电视对话会助长语无伦次和无聊琐碎；“严肃的电视”本来就是一个自相矛盾的表述，因为电视因为其本身的性质，注定了它只有一个声音——娱乐。</p><p>对，电视是娱乐性的，但这完全不会对文化造成任何的威胁，如果电视只是单纯地展示娱乐的内容，这是一件皆大欢喜的事情；但潜伏在背后的危机，我们或许很难察觉，那就是当所有的内容都已娱乐的方式表现出来，就完全变味了。这种变味发生在当严肃的思想被搬到荧幕面前被娱乐性地思考，发生在当需要严谨对话的社会话题以娱乐化的形式呈现在电视前。当思想、社会、文化、哲学、政治、经济这些厚重的语词和娱乐性的电视挂起钩的时候，“虚无主义”便出现了。波兹曼毫不客气地以轻蔑的语调嘲笑那些妄想利用电视机来提高文化修养的人，电视无法延伸或扩展文字文化，相反，电视只能攻击他们。毫不掩饰的揭示掩藏在电视节目超现实外壳下的，是反交流的理论，它抛弃逻辑、理性和秩序。他戏谑地说道，在美学中，这种理论被称为“达达主义”；在哲学中，它被称为“虚无主义”；在精神病学中，它被称为“精神分裂症”；如果用舞台术语来说，它可以被称为“杂耍”。</p><p>究竟电视是如何引致这种娱乐性的？因为人们喜欢看到有动感的画面，稍纵即逝但却斑斓夺目，正因为此决定了电视无法容忍思想，它必须来迎合人们对视觉快感的需求，来适应娱乐业的发展。电视新闻一切以简短为宜，做到不让观众有精神紧张之感，反之，要以富于变化和新奇的动作不断刺激观众的感官。你不必注意概念和角色，不要在同一个问题上多停留几秒。因为这种种的原因，严肃、连贯、缜密的思考天生与电视就是不相容的。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2wtdo4nj30gt0bpq5u.jpg" alt="104803"></div></p><p>电视的这种娱乐性渗透进了教育：电视通过控制人们的时间、注意力和认知习惯获得了控制人们教育的权力，但这种控制是无力，因为不像阅读获得的往往和我们原来储存的知识相关，而由电视上获得的往往是一些具体的片段，不具备推断性。它也同样渗透进了宗教：电视最大的长处是它让具体的形象进入我们的心里，电视里的宗教形象往往会因为电视的这种长处而惹人注目，这就违背了传教的本意：他本是将一些教义深入人心，而电视压根没有这种将抽象的概念留在我们脑海中的功能，他把我们的目光转置那些传教者的仪态和举止，他们成了受教者的上帝，而不是在教义中的上帝。</p><p>在最后波兹曼借由赫胥黎发出警告，有两种方法可以让文化精神枯萎，一种是奥威尔式的——文化成为一个监狱，另一种是赫胥黎式的——文化成为一场滑稽戏。我们应该借助赫胥黎而不是奥威尔来理解电视和其他图像形式对于民主国家的基础所造成的威胁，更明确地说，是对信息自由所造成的威胁。我们要担心的是电视信息的过剩，而不是政府的限制；我们的文化部是赫胥黎式的，而不是奥威尔式的，它想尽一切办法让我们不断地看电视，但是我们看到的是使信息简单化的一种媒介，它使信息变得没有内容、没有历史、没有语境，也就是说，信息被包装成为娱乐。在一个科技发达的时代里，造成精神毁灭的敌人更可能是一个满面笑容的人，而不是那种一眼看上去就让人心生怀疑和仇恨的人。</p><p>波兹曼开始大声呼喊：在弥尔顿、培根、伏尔泰、歌德和杰弗逊这些前辈的精神的激励下，我们一定会拿起武器保卫和平。但是，如果我们没有听到痛苦的哭声呢？谁会拿起武器去反对娱乐？当严肃的话语变成了玩笑，我们该向谁抱怨，该用什么样的语气抱怨？对于一个因为大笑过度而体力衰竭的文化，我们能有什么救命良方？</p><p>但似乎只有深刻而持久地意识到信息的结构和效应，消除对媒介的神秘感，我们才有可能对电视，或电脑，或任何其他媒介获得某种程度的控制。刻意地疏远那些信息形式还不足够，我们要学会用理性去解读文化中的象征，用思维去抵御那些虚假的思想面孔，当这个时代每个人都自觉的意识到，赫胥黎的预言正在悄然上演，那电视就或许真的可以做回它最擅长的事情——真正的娱乐，而严肃的思想也会回归本位，躺在在厚重的书卷里等待读者的共鸣。</p><p><div align="center"><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2wuc6xej30gt0f076y.jpg" alt="104992"></div></p><blockquote><p>补：</p></blockquote><p>前几天在看菲利普·罗斯的文章时，也看到类似的担忧：“捷克斯洛伐克成了一个自由民主的消费社会的时候，你们这些作家就会发现自己受到了许多新的对手的折磨，而再奇怪不过的是，那个压迫人的、枯燥无味的极权社会曾保护你们免于这些折磨。特别让人不安的将是威胁文学、教育和语言的那个无处不在的、威力无比的主要对手。我可以向你保证，不会再有对抗的人群在瓦茨拉夫广场集合起来去推翻暴政，也不会有哪位剧作家知识分子被愤怒的群众抬举来救赎民族之魂，使其脱离因对手将所有人类话语减弱之后而使之所处的昏聩状态。我正在谈论的是将所有一切变得浅薄无聊的商业电视——并不是说因为被愚蠢的国家审查所控制才没有人想看的少数频道，而是说十几、二十几个因为娱乐性才被众多人整日观看的乏味的陈词滥调的频道。你和作家同行们最终摆脱了极权体制下的知识监狱。欢迎你们进入全部娱乐的世界。你们不知道失去了什么。或者说你们知道吗？”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在地铁上看完了&lt;a href=&quot;https://book.douban.com/subject/1062193/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《娱乐至死》&lt;/a&gt;，写点感想，做个串讲。&lt;/p&gt;
&lt;p&gt;如果仅仅从书名“娱乐至死”的字面意思理解，我们或许都会误解，以为作者在书中定会着力指责那些活跃于电视荧幕的娱乐节目的缔造者们，将这个时代的浅薄与庸俗归咎于嬉皮笑脸的闪亮明星们，因为他们集体攻陷了普罗大众的闲暇时间，把他们一个个变成了“娱乐时代”的俘虏，从而变相地“奴役”了我们。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="娱乐至死" scheme="http://yoursite.com/tags/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/"/>
    
      <category term="波兹曼" scheme="http://yoursite.com/tags/%E6%B3%A2%E5%85%B9%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>读书记（2）：一七年十二月读书月记</title>
    <link href="http://yoursite.com/2018/01/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E9%98%85%E8%AF%BB%E6%9C%88%E8%AE%B0%E3%80%902017.12%E3%80%91/"/>
    <id>http://yoursite.com/2018/01/05/读书记（2）：阅读月记【2017.12】/</id>
    <published>2018-01-05T14:20:45.000Z</published>
    <updated>2019-02-13T15:17:19.823Z</updated>
    
    <content type="html"><![CDATA[<p>这个月利用上下班乘坐地铁的时间阅读了五本书，分别是波兹曼的《娱乐至死》、黑塞的《悉达多》、菲利普·罗斯的《人性的污秽》和《行话》，还有一本池建强的《MacTalk：人生元编程》。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0q52hdnj316i0c676d.jpg" alt=""></p><a id="more"></a><p>这篇文章只对《娱乐至死》写了一些感想和串讲，其他几本就相应做了一下摘录。</p><h2 id="一、波兹曼《娱乐至死》"><a href="#一、波兹曼《娱乐至死》" class="headerlink" title="一、波兹曼《娱乐至死》"></a>一、波兹曼《娱乐至死》</h2><h2 id="二、黑塞《悉达多》"><a href="#二、黑塞《悉达多》" class="headerlink" title="二、黑塞《悉达多》"></a>二、黑塞《悉达多》</h2><p>摘录了一些句子：</p><ol><li>读海涅的诗，我要成为社会民主党人，我要学习海涅</li><li>他的杯子没有满，他的智怀没有饱，他的灵魂不安宁，他的心情不平静。</li><li>在他的身上看不到寻求，看不到欲望，看不到刻意，没有任何努力的痕迹——有的只是光明与安详。</li><li>但是这个清晰可敬的教导有一样东西没有包含到，它没有包含大智大慧的世尊自己经历的秘密——有别于千千万万个人的他独自的秘密。这就是在听您讲道的时候我想到并意识到的。这就是为什么我要继续走我自己的路的原因。我不再寻找另外的更好的教导了，因为我知道这样的教导是没有的。我要离开所有的教导和所有的教师，我要单独去达到我的目标，不然，就死掉。</li><li>思考的本质就是认识根源，只有通过思考，种种感觉才会变成知识，变成真实，开始成熟，不致迷失。</li><li>他必须自己去亲身体验。</li><li>除了一件小小的东西，一件极其微小的东西之外，凡是圣贤和思想家所有的一切，他们一概都不缺乏。他所缺乏的那个小小的东西，就是对于所有生命圆融统一的认识。有许多次，悉达多甚至怀疑这个知识，这个思想，怀疑它是不是真有这么大的价值，是不是它或许仅仅是思想家们天真的自我陶醉的说辞，因为思想家们也许不过是一批会思想的孩子而已。</li><li>他感觉到这位一动也不动的倾听者是在吸收他的自白，如同一棵大树吸收雨水一样。他感觉到这位静坐倾听的人就是河流的本身，就是神与梵天永恒的化身。</li><li>它们互相融入彼此，思念者的悲叹、聪明者的欢笑、愤慨者的哭泣、垂死者的呻吟，全都是互相交织在一起，互相连锁在一起，以千百种不同的方式纠缠在一起。所有的声音、所有的目标、所有的怀念、所有的悲哀、所有的欢乐、所有的善良和邪恶，这一切一切交汇在一起，就是生活之流，就是人生的音乐。</li><li>每一个真理的反面也同样是真实的。举例来说，一个真理，如果它是片面的真理，就只能以文字表达出来，也只能局限在文字能力的范围内。每一样事物，要是用思想来思考和用文字来表达，都是单方面的，都只是一半的真理，它缺乏完全、圆满和统一。</li><li>歌文达，这个世界不是不完美的，也不是在沿着一条漫长的途径逐渐向着完美发展。不，每个瞬间世界都是完美的，每一个罪恶都已经在它之中携含了恩赦，所有的孩童都是潜在的老人，所有的婴儿在身上都带着死亡，所有垂死的人必获得永恒的生命。</li><li>语言无法将思想完全表达出来，思想一旦被语言表达出来，总是会与心中的原意有所不同，有所曲解，显得有点愚蠢。</li><li>每一张面孔都是最后难免一死的生物，都是整个空幻界中的一个激情的、痛苦的例子。然而他们却没有一个死掉，他们只是不断地变幻，不断地重生，不断地有新的面孔，只有作为纽带的时间站在一张面孔和另一张面孔之间。</li></ol><h2 id="三、菲利普·罗斯《人性的污秽》"><a href="#三、菲利普·罗斯《人性的污秽》" class="headerlink" title="三、菲利普·罗斯《人性的污秽》"></a>三、菲利普·罗斯《人性的污秽》</h2><p>摘录了一些句子：</p><ol><li>1998年的夏天,在新英格兰应该是酷暑加骄阳,而在棒球场上,则该是一个白色本垒打战神和一个褐色本垒打战神之间所进行的神话般的比拼,然而那个夏天席卷全美的却是虔诚与贞洁的大狂欢,因为突然,恐怖主义被口交所代替:一位精力旺盛、面相年轻的中年总统和一个举止轻狂、使人神魂颠倒的二十一岁雇员在白宫的椭圆形办公室里,像两个十来岁孩子在停车场上调情似的。这使得美国最古老的公众再次燃起了激情,从历史的角度来看,也许是它最为不可靠、最具颠覆性的快感:伪君子的狂喜。</li><li>我自己则梦到一面大旗,仿佛是一幅基督画像,以达达派手法,将白宫从东到西包裹起来,上面撰写着如下铭文:这里住着的是一个人。这就是那个夏天,即使破烂摊、残害他人肢体罪或大杂烩都被十亿次地证明比这个人的思想或那个人的道德更为精妙。就是在那个夏天,人们脑子里想的都是一位总统的阳具,而他的生活,以其所有无耻的污秽,又一次使得美国不知所措。</li><li>我把所有一切的颠鸾倒凤和快乐都归功于伟哥。没有伟哥,这一切都不会发生。没有伟哥,我就会对世界有一个与我年龄相称的看法以及全然不同的生活目标。没有伟哥,我就不会受情欲干扰,而拥有举止规范的年长绅士的尊严。我就不会做没意思的事。我就不会做不体面的、草率的、考虑不周的,而且对所有相关的人都有着潜在危害的事。没有伟哥,我就可以继续在我的晚年发展一个有经验的、受过教育的、荣誉退休的,并早已放弃声色犬马享乐的老年人的那种客观、包容的视角,我就可以继续做深刻的哲理性总结,并一如既往地对青年人进行坚定不移的道德感化,而不至于将自己推回到不断出现的性冲动的紧急状态之中。感谢伟哥,我终于明白了宙斯缘何需要各种多情的化身。他们应当给伟哥起那个名字。他们应当叫伟哥宙斯。”</li><li>诀窍便是从(又是霍桑)“一个孤独的大脑与它自己的交流”中寻得养分。秘诀在于从诸如霍桑那样的人身上觅得养分,从才华横溢的已逝者身上觅得养分。</li><li>越战老兵是些在战后岁月里亲身经受了生活中一切罪孽的人:离婚、酗酒、毒品、犯罪、警察、牢房、毁灭性的精神压抑、无可控制的哭泣、想尖叫、要砸东西、双手颤抖、身体痉挛、面部紧绷、从头到脚大汗淋漓。由于重温枪林弹雨、刺眼的爆炸、血肉横飞的场面</li><li>父亲从不发脾气。父亲有另外的办法叫你服输。用言词。用话语。用他所谓的“乔叟的、莎士比亚的、狄更斯的语言”,用任何人都别想从你身上夺走的英语,用西尔克先生以浑厚的嗓音说出的始终完美、清晰、满怀激情的英语道白,仿佛即使在日常对话中他也是在朗诵马克·安东尼在恺撒尸体旁发表的演说。</li><li>有些人只是一味捶打沙袋,科尔曼不,科尔曼思索,与他在学校里或在赛跑时所用的方式一样:把一切不相干的东西都排除出去,不让任何不相干的东西钻进来,一心一意只关注这一件事,题目,比赛,考试——不论必须掌握的是什么,一律成为这一件事。他能够在学习生物学时那样做,他能在短跑时那样做,他能在拳击时那样做。不仅不受任何外部动静的干扰,任何内心活动也都置之度外。如果赛场上人群中有人冲他喊叫,他能充耳不闻,如果与之相斗的人是他最好的朋友,他也可以视而不见。比赛过后,他们有的是时间重修旧好。他设法强制自己无视感情,不论是恐惧、犹豫,甚至友谊——要有这些感情,但和他自己脱钩。比方说,当他进行假想拳斗时,他并不仅仅是全身放松,他同时还设想有另外一个人存在,在脑子里和另外一个人进行一场秘密打斗。临赛时,即使另外那人完全是真实的——臭气熏天的,鼻涕满脸的,汗流浃背的,正在眼前挥拳的——那家伙仍然无从得知你在想什么。没有一名教师要求得到对这个问题的答案。你在场上获得的答案你秘而不宣,当你的秘密大白于天下时,它可以出自各种渠道,唯独不经过你的嘴巴。</li><li>懦夫在未死以前,就已经死过好多次;勇士一生只死一次。在我所听到过的一切怪事之中,人们的贪生怕死是一件最奇怪的事情,因为死本来是一个人免不了的结局,它要来时谁也不能叫它不来。</li><li>随着两大防护墙的消失——大哥在海外,父亲死了——他重新充电,自由自在地想当什么就当什么,自由自在地追求最高的目标,他骨子里有信心当独特的我,自由到他父亲无从想象的地步,自由得正如他父亲不自由一般。不仅摆脱了他父亲,而且摆脱了他父亲忍受的一切。强迫。羞辱。阻挠。伤痛和故作姿态和羞耻。内心饱尝的失败及挫折的煎熬。自由地走上大舞台。自由地勇往直前,从事大事业。自由地上演无拘无束、自我定位的有关我们、他们和我的戏剧。</li><li>他自童年起所向往的就是自由:不当黑人,甚至不当白人——就当他自己,自由自在。他不想以自己的选择侮辱任何人,也不是在企图模仿他心目中的哪一位优等人物,或对他的或她的种族提出某种抗议。他知道,在循规蹈矩的人眼中,世上的一切都早有安排,都是一成不变的,他们永远也不会认为他做得对。但不敢越雷池一步、固守正确的界限向来不是他的目标,他的目标是决不将自己的命运交由一个敌视他的世界以愚昧和充满仇恨的意图主宰,必须由他自己的意志决定。</li><li>社会之所以成其为社会的一切——它不断变动的力量、无处不在的利与害的潜网、激烈的争权夺利的战斗、无休无止的吞并降服、派系的纵横捭阖、狡诈的道德术语、习以为常的仁厚独裁、变幻不定的稳定的幻觉——社会之成其为社会的一切,始终如此、必须如此的一切,对他们而言,居然跟康涅狄格的扬基人眼中的亚瑟王朝一样陌生。</li><li>心平气和地接受不如自我放逐宏伟辉煌的东西,并放弃对自身力量压倒性的挑战。与自己的失败以一种谦和的态度共处,重新以理性作为生活准则,抹去伤痛和愤怒。倘若不屈服,则静静地不屈服——平静地。带着尊严的沉思冥想</li><li>欲望乃万变之源。一切毁灭都可从中找到答案。</li><li>突然开始用傻瓜的思维模式思考问题:突然把每件事和每个人都往最好的方面想,完全抛弃对别人的怀疑、自我谨慎、自我怀疑,以为自己的一切困难都迎刃而解了,一切的困扰都不复存在了,不仅忘记了自己身在何处,而且忘记了自己是如何到达的,拱手交出勤勉、纪律、寸土必争的韧劲……就好像每个人的单斗都可以放弃了,就好像一个人可以随手捡回和扔掉自我——独具个性的、不可改变的、从一开始战斗就是为了它而进行的自我。</li><li>因为他的信条,因为他目空一切的、傲慢的“我不是你们中的一分子,我不能容忍你们,我不属于你们黑人的我们”的信条。反对他们的我们的伟大英勇的斗争——瞧他现在的德性!为争取宝贵的个性而进行的激烈斗争,他为反对黑人命运所进行的单枪匹马的反抗——瞧,这个蔑视一切的伟人落到了什么地步!这就是你,科尔曼,来寻找生活深层意义的地方。一个充满爱的世界,那是你原来拥有的,可是你却为了这个而抛弃了那个!你所作的悲剧性、鲁莽的行为!而且不仅对你自己——对我们大家,对欧内斯廷,对瓦特,对母亲,对我,对在坟墓中的我,对在坟墓中的我父亲。</li><li>“美国海军”,文身只说了这些,高度仅有四分之一英寸的几个字,用蓝色颜料刺在一个蓝色铁锚的两个蓝色臂膀之间,铁锚本身有两三英尺长。就军人的文身而言,是个非常简朴的图案,而且谨慎地、恰恰安置在右胳膊肩关节下,无疑是个相当容易隐藏的文身。但当他回想他如何将它刺上去时,它不仅成为一个唤起他生命中最糟糕夜晚狂乱情景的标记,而且成为一个唤起潜伏在狂乱背后之一切的标记——它是他全部的历史,他的英雄主义与羞耻不可分割性的缩影。镶嵌在那个文身里的正是他的一个真实、完整的自我形象,其中可见无法磨灭的身世,如同根深蒂固事物的原型,因为文身恰恰象征着永远无可变更的一切,其中也包含着巨大的业绩,包含着外部势力,不可预知未来的整个链接,一切暴露的危险,以及一切隐藏的危险——甚至生命的无意义性都隐含在那个小小的、傻乎乎的蓝色文身之中。</li><li>她在他们那个年龄早看过了所有的黑泽明,所有的塔科夫斯基,所有的费利尼,所有的安东尼奥尼,所有的法斯宾德,所有的沃特缪勒,所有的撒提亚吉特·雷,所有的雷内·克莱尔,所有的文·温德斯,所有的特吕福、戈达尔、夏布罗尔、利斯奈、罗米尔、雷诺阿,而这些孩子只看过星球大战。</li><li>他在里面,正和福妮雅一起,相互保护着对方,不受任何外人的侵扰——彼此,对对方而言,构成了整个世界。他们在里面跳舞,很可能光着身子,超越人世的苦难,置身于一个植根于世俗欲望的非凡的天堂里,在那里他们的结合是一出他们倾注生命中所有的愤怒与失望的戏剧。</li><li>音乐家们的确揭示了我们生命中最年轻、最天真的思想以及对于非现实、不可能实现的东西的根深蒂固的渴望。</li><li>他将假装说世界属于我们,而我会让他这么假装,然后我也会假装。但是,为什么不呢？我能跳……但他得记住。</li><li>我们留下污秽,我们留下踪迹,我们留下我们的印记。污染、残酷、欺凌、谬误、粪便、精液——要待在这儿就别无二致。和反抗无关。和恩赐或救赎无关。在每个人的身上。存储于内心。与生俱来。无可描述。污秽先于印记。没有留下印记之前便已存在。污秽完全是内在的,不需留印记。污秽先于反抗,是包围反抗并扰乱一切的解释与理解。这就是为什么所有的净化行为纯属玩笑,而且还是个野蛮的玩笑。纯洁的幻想是极其可怕的,是疯狂的。对纯洁的追求其实质倘若不是更严重的不纯洁,又会是什么呢？她所有关于污秽的话归结起来无非是说它是不可逃避的。这,自然,便是福妮雅的阐释:我们无可避免地都是被污染的角色。心甘情愿地接受这可怕的、原始的不纯净状态吧。她像希腊人,像科尔曼的希腊人,像他们供奉的神。无人不是小心眼。争吵。械斗。恨。谋杀。交媾。他们的宙斯成天只想操女的——女神,女人,母牛,母熊——不仅以他自身的形象出现,还更为令人兴奋地将自己装扮成兽类,作为一头公牛气势雄劲地凌驾于女性之上,化做一只扑打着双翼的白天鹅以异乎寻常的方式进入她的身体。对这位众神之王而言,肌肤之乐永无穷尽,花样翻新也层出不穷。欲望所带来的一切疯狂。放荡。堕落。最粗野的欢乐。还有妻子的怒气。不要那绝对孤独,绝对隐晦,作为现在、过去以及永远唯一主宰的穷极无聊地整日为犹太人操心的希伯来上帝。不要那完全无性别的基督神人和他降孕怀胎的母亲以及所有某种精致的超凡性所激发的罪恶感与羞耻感,而选择纠缠于冒险之中、具有鲜活表达力、朝秦暮楚、沉醉于声色犬马、精力充沛地与他丰富多彩的生活联姻、从不单独行事、从不偷偷摸摸的希腊的宙斯。而选择神圣的污秽。对福妮雅·法利来说,伟大的反映现实的宗教,倘若,通过科尔曼她有所了解的话,如同希伯来幻象所言,是以上帝的形象创造的,好吧,但并不是我们的上帝——是他们的。上帝淫荡。上帝腐败。如果真有过上帝的话,是个活生生的神,是以人的形象出现的上帝。</li><li>虽然世上满是那种自以为他们将你或你的邻居看透了的人,实际上未知的东西却深不可测。关于我们的真相是无穷无尽的,谎言也同样如此。</li></ol><h2 id="四、菲利普·罗斯《行话》"><a href="#四、菲利普·罗斯《行话》" class="headerlink" title="四、菲利普·罗斯《行话》"></a>四、菲利普·罗斯《行话》</h2><ol><li>与我们闭着眼睛什么也看不见，光溜溜地呱呱坠地不同，罗斯先生一出场，指甲、毛发、牙齿都已长齐，他说话流利，技巧娴熟，机智幽默，富有生气，具有名家风范。</li><li>卡夫卡的“小说一直所坚持的就是，看上去似乎难以想象的幻觉和毫无希望的诡论其实正是构成我们现实的东西”。</li><li>他们都在小说里直露地描写了性，但并不认为那是渲染色情，而是认为性是人的最深层的东西，最能体现人的本质，最能放射出异常强烈的光芒。</li><li>他在倾听时专心、安静，就像金花鼠在石墙上发现了陌生的东西一样。</li><li>正常人在生理构造上注定要从事具有目的的活动，无所事事或者无目标的工作（如奥斯威辛集中营的工作）则导致痛苦和萎缩症。</li><li>这部分及整部书给我留下深刻印象的是，一颗实际、高尚的科学心灵的思考在多大程度上使你得以生存。在我看来，你的幸存并非由兽性的生物力量或者难以置信的运气所决定，而是由你的专业性格所决定：讲究精确的人，追求秩序原理的实验控制者，他所重视的一切都被颠覆。就算你是恶魔般的机器中一个编了号的部件，你也是一个总在用一颗系统化的心灵去理解的部件。在奥斯威辛集中营里，你自语道“我思考得太多”以抵制，“我过于开化”。但对我而言，那位思考太多的开化人与那位幸存者是分不开的。科学家与幸存者是同一个人。</li><li>卡夫卡依仗的是内在的精神世界，企图对现实达到某种掌握，而我经历了集中营和森林这样实实在在、具体细致的经验世界。</li><li>第二次世界大战中的犹太人经历并非属于“历史”范畴。我们遭遇到了原始神秘的力量，一种神秘的潜意识。我们对其中所含的意义没有任何了解，时至今日我们仍然无法了解。这个世界似乎是理性的（有火车、发车时间、火车站和工程师），但这些只是想象的旅行、谎言和诡计，只有深奥的非理性冲动才能虚构出来。</li><li>他们的目盲和耳聋，以及他们只全神贯注于自己的事务等构成了他们单纯的一部分。那些凶手是功利主义者，知道他们需要什么。单纯的人总是不幸、滑稽的受害者，从没有及时听到危险的信号，混杂起来，乱糟糟一堆，最后掉在了陷阱里。那些缺陷使我感到陶醉。我爱上了它们。犹太人施用诡计统治世界的神话原来是被在某种程度上夸大了。</li><li>捷克斯洛伐克地下出版所产生的环境有其独特性。由外国军队支持的政权——由占领者建立的政权知道，这个政权只有符合占领者的意愿才能存在——害怕批评。它还知道，任何一种精神生活最终都导致对自由的向往。所以，它毫不犹豫地禁止实际上所有捷克斯洛伐克文化，使作家无法写作，画家无法展览，科学家——特别是社会科学领域——无法进行独立的研究；它摧毁大学，大多数情况下任命俯首帖耳的职员当教授。突然间被投入到这个大灾难之中的国家被动地接受着这一切，至少一度如此，无奈地看着最近崇拜的人物一个接一个地消失。</li><li>文学没有必要四处搜寻政治现实或者担忧兴衰更替的统治体系；文学可以超越这些，而且仍然可以回答统治体系在人们心中所激发出来的问题。</li><li>捷克斯洛伐克成了一个自由民主的消费社会的时候，你们这些作家就会发现自己受到了许多新的对手的折磨，而再奇怪不过的是，那个压迫人的、枯燥无味的极权社会曾保护你们免于这些折磨。特别让人不安的将是威胁文学、教育和语言的那个无处不在的、威力无比的主要对手。我可以向你保证，不会再有对抗的人群在瓦茨拉夫广场集合起来去推翻暴政，也不会有哪位剧作家知识分子被愤怒的群众抬举来救赎民族之魂，使其脱离因对手将所有人类话语减弱之后而使之所处的昏聩状态。我正在谈论的是将所有一切变得浅薄无聊的商业电视——并不是说因为被愚蠢的国家审查所控制才没有人想看的少数频道，而是说十几、二十几个因为娱乐性才被众多人整日观看的乏味的陈词滥调的频道。你和作家同行们最终摆脱了极权体制下的知识监狱。欢迎你们进入全部娱乐的世界。你们不知道失去了什么。或者说你们知道吗？</li><li>如同卡夫卡独身一人一样，据说舒尔茨与女性保持着长期热烈的联系，通过信函过着大部分的色情生活。</li><li>作为一个文化史概念，东欧是俄罗斯，其具体的历史位居拜占庭世界。波希米亚、波兰、匈牙利，就如奥地利一样，从来就不是东欧的一部分。从最初起，他们就参与了西欧文明伟大的冒险，如哥特文化、文艺复兴、宗教改革——这一运动的摇篮之地确切地说就在这一地区。而现代文化的最伟大的脉搏在中欧跳动——心理分析、结构主义、十二音技术、巴托克音乐、卡夫卡和穆西尔的小说新美学等。战后中欧被俄罗斯文明吞并（或者至少是其主要部分），致使西方文化失去了其关键的重心</li><li>幽默感是辨认的可靠标志。从那时起，我就对一个没有幽默感的世界感到恐惧。</li><li>人们的愚蠢在于为一切都提供一个答案，小说的智慧在于对一切都提出一个问题</li><li>小说家教育读者把世界当成一个问题来看。这种态度中包含着智慧和宽容。在一个建立于极度神圣的肯定之上的世界里，小说就无法存在。极权主义的世界，无论是建立在什么主义之上，都是一个答案的世界，而不是问题的世界。在这个世界里，小说没有地位。不管怎么说，在我看来，似乎全世界的人当今都喜欢判断而不喜欢理解，喜欢回答而不喜欢提问，结果小说的声音被人类吵闹的、愚蠢的肯定声音所淹没。</li><li>这就是作为作家的代价，对过去始终难以忘怀——痛苦、激动、拒绝，所有的一切。我坚信，这种抱着过去不放的思想，虽然没有希望，但它充满热情地渴望重构过去，使它发生变化。医生、律师，还有其他许多稳定的公民不会被一种持之以恒的记忆所折磨。他们以自己的方式和我们一样受到烦扰，只不过他们不知就里，因为他们不探究。</li><li>我秘密参与周围世界的一切，关注每一个人的每一点历史，这些材料都是故事和小说的必备基础。</li><li>你一旦长大成人，离开家庭，选择了作家这种孤独的生活，性爱就不可避免地成为你可以继续进入的最重要经验领域？</li><li>性爱的兴奋在很大程度上是与痛苦和分离联系在一起的。我的性生活对我来说是最重要的，相信对于每个人也如此。思考和完成它要花费很多的时间，但思考性爱是令人自豪的部分。对于我来说，它主要是秘密的，包含着神秘和劫掠的成分。我的日常生活和性生活不是一个整体——它们是分离的</li><li>贝娄推翻了一切：基于和谐、有序的叙述原则之上的写作选择，受惠于卡夫卡的《审判》、陀思妥耶夫斯基的《双重人格》（The Double）和《永久的丈夫》（The Eternal Husband）的小说家社会精神气质，以及一种很难说是因为喜欢闪光、色彩和足够的实体而产生的道德视角</li><li>《赫索格》是贝娄写作生涯中首部涉及性这个广泛领域并进行长时间探讨的小说。赫索格的女人对他来说至关重要，因为她们勾起了他的虚荣，激发了他的肉欲，引导了他的爱，引起了他的好奇。还因为可以表现出男人的聪明、魅力和俊美容颜从而使他滋生了男童般的快乐和喜悦——在她们的爱慕中他得到了确认。她们骂出的每一句难听的话，杜撰的每一个称号，头颅的每一次迷人的转动，手的每一次安慰性的触摸，嘴巴每一次愤怒的扭曲，他的女人们都以异性特有的他者性使赫索格神魂颠倒。</li><li>对无法预料的展现就是一切。把错误转变方向，那残酷的难料之事就是我们学童所学的无害的‘历史’，一切当时的难料之事被当做历史的必然编入历史，难以名状的恐怖被历史所掩盖，灾难转换成了史诗。</li></ol><h2 id="五、池建强《MacTalk：人生元编程》"><a href="#五、池建强《MacTalk：人生元编程》" class="headerlink" title="五、池建强《MacTalk：人生元编程》"></a>五、池建强《MacTalk：人生元编程》</h2><p><a href="https://plushunter.github.io/2018/01/05/日知录（8）：MacTips%20/" target="_blank" rel="noopener">日知录（8）：MacTips</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个月利用上下班乘坐地铁的时间阅读了五本书，分别是波兹曼的《娱乐至死》、黑塞的《悉达多》、菲利普·罗斯的《人性的污秽》和《行话》，还有一本池建强的《MacTalk：人生元编程》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fwv0q52hdnj316i0c676d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
      <category term="娱乐至死" scheme="http://yoursite.com/tags/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/"/>
    
      <category term="悉达多" scheme="http://yoursite.com/tags/%E6%82%89%E8%BE%BE%E5%A4%9A/"/>
    
      <category term="人生的污秽" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%B1%A1%E7%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>日知录（4）：启发式认知偏差</title>
    <link href="http://yoursite.com/2018/01/02/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%884%EF%BC%89%EF%BC%9A%E5%90%AF%E5%8F%91%E5%BC%8F%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE/"/>
    <id>http://yoursite.com/2018/01/02/日知录（4）：启发式认知偏差/</id>
    <published>2018-01-02T15:14:45.000Z</published>
    <updated>2018-11-03T16:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在不确定条件下，人类会采用一种启发式的思维方法，即根据以往（相同的或类似的甚至无关的）的经验来对当前情况进行判断。这是一种思考上的捷径，是解决问题的简单、笼统的策略，也称之为经验法则或拇指法则。</p><a id="more"></a><p>因为人类是认知的“吝啬鬼”，任性、懒惰。启发式推理会简化信息处理的过程。因此，当人们面对大量的信息和不确定性进行判断时，往往并不遵循贝叶斯法则，而是凭借直觉或者以往的经验进行判断。依赖“启发法”做出的决策带有不确定性，只能说可能是正确的结论，但如果所遗漏的因素和现象很重要，那么信息的缺损就会导致产生判断和估计上的严重偏差。</p><p>Kahneman和Tversky指出人们通常具有三种启发式推理方式：</p><ul><li>代表性启发法</li><li>可得性启发法</li><li>锚定与调整启发法</li></ul><p>这三种方法既可以得出正确的推理结果,也有可能导致错误的结论。</p><h2 id="一、代表性启发法"><a href="#一、代表性启发法" class="headerlink" title="一、代表性启发法"></a>一、代表性启发法</h2><p>在使用启发法时，首先会考虑到借鉴要判断事件本身或事件的同类事件以往的经验即以往出现的结果，这种推理过程称之为代表性启发法。</p><p>　　一般情况下，代表性是一个有用的启发法，但在分析以往经验，寻找规律或结果的概率分布的过程中,可能会产生严重的偏差,从而得到错误的启示，导致判断错误。</p><h3 id="1-1-代表性启发法的定义"><a href="#1-1-代表性启发法的定义" class="headerlink" title="1.1 代表性启发法的定义"></a>1.1 代表性启发法的定义</h3><ol><li>代表性会导致忽略样本大小。在分析事件特征或规律时，人们往往不能正确理解统计样本大小的意义，对总体进行统计的结果才是真正的结果，样本的数量愈接近真实的数量，统计的结果也就愈可信，样本愈小,与真实数量相差愈大,统计的结果愈不能反映真实的结果情况。代表性启发法是对同类事件以往所出现的各种结果进行统计分析，得到结果的概率分布，从而找出发生概率最大的结果即最可能发生的结果。 因此必须考察所有同类事件这个总体或者考察尽量多同类事件(大样本)但人们往往趋向于在很少的数据基础上很快地得出结论。</li><li>代表性会忽略判断的难易程度，即使面对的是一个复杂的难以判断的问题，也简单地去作出判断，或经常根据不规范的和与判断无关的描述轻易地作出判断，或经常会忽略掉不熟悉或是看不懂的信息，只凭自己能够理解和熟悉的信息去作出判断，这些忽略掉的信息可能对判断是关键的。　　</li></ol><blockquote><p>代表性启发出现的背景</p></blockquote><ul><li>没有时间认真思考某个问题</li><li>负载信息过多以至于无法充分对其进行加工</li><li>认为问题不十分重要以至于不必太过思虑</li><li>缺乏做决策所需的可靠知识或者信息</li></ul><h3 id="1-2-Tom-W-实验"><a href="#1-2-Tom-W-实验" class="headerlink" title="1.2 Tom W 实验"></a>1.2 Tom W 实验</h3><p>1973年Kahneman及Tversky进行了一个名为“Tom W ”的著名实验，大概如下：给被试以下一段关于Tom W.的描述：“Tom W.智商很高，但是缺乏真正的创造力。他喜欢按部就班，把所有事情都安排得井然有序，写的文章无趣、呆板，但有时也会闪现一些俏皮的双关语和科学幻想。他很喜欢竞争，看起来不怎么关心别人的感情，也不喜欢和其他人交往。虽然以自我为中心，但也有很强的道德感。”</p><p>然后要被试估计，Tom W.最有可能是以下哪个专业的学生：企业管理，工程，教育，法律，图书，医学，社会学？想象一下如果你是其中一名被试，你会怎么回答。</p><p>结果，绝大多数被试都认为Tom W.最有可能是工程系学生。为什么呢？很有可能是因为Tom W.最像一个学工程学的学生。也就是说，对Tom W.的以上描述，与我们心目中一个理工科学生所应当具有的形象完全吻合（或者说代表了一个理工科学生的形象），所以我们认为Tom W.最有可能是工程系的学生。这就是典型的代表性启发式思维方式。当面对不确定的事件，我们往往根据其与过去经验的相似程度来进行判断或预测。说简单一点，就是基于（过去经验的）相似性来预测（当前事件的）可能性。到底个体A是否归属于群体B？如果个体A具有群体B的某些特征（具有相似性、代表性），则认为个体Ａ归属于群体Ｂ。</p><p>如果我们在公共汽车上看到一个人鬼鬼祟祟，像个小偷，则我们会认为他就是一个小偷，并提高警惕性。有时相似性确实和可能性有关，因此这种判断是正确的，但有时则可能会因此忽略其它相关信息而做出错误的判断。</p><p>比如在Tom W.的实验当中，被试就完全忽略了学生在各个专业中的基础比率（base rate）。就算上述7个专业的学生都一样多，那么任何一个学生是工程系的学生的概率和他是其它任何一个专业的学生的概率是一样的，即1/7。根据另外一组被试对所有学生在各个专业中所占的比率的估计，学工程学的学生应该比学其他专业的学生要更少，即还占不到1/7。如果考虑到这一点，那么任意抽一个学生出来（比如Tom W.），他是学工程学的可能性应该是很低的。这种在判断时忽略基础比率而导致的谬误就是所谓的基础比率谬误（base rate fallacy） 。</p><p>再看另外一个问题 ，Linda，31岁，单身、坦率，活泼，她学的专业是哲学。当她还是个学生时，就非常关注歧视和社会公正的问题，并且参加过反核武的示威游行活动。（Linda is 31 years old, single, outspoken, and very bright. She majored in philosophy. As a student, she was deeply concerned with issues of discrimination and social justice, and also participated in anti-nuclear demonstrations.）问Linda更有可能是什么样的人？</p><ol><li>Linda是一个银行出纳员。</li><li>Linda是一个崇尚女权主义的银行出纳员。</li></ol><p>很多人都会选第二项。因为从对Linda描述更符合我们心目中女权主义者的形象（或者说代表了我们心目中女权主义者的形象），所以我们就更倾向于认为Linda是一个崇尚女权主义的银行出纳员。我们在这里就运用了启发式的判断，却没有注意到这样一个基本道理：两个独立的事件同时发生的概率不可能高于其中单个事件单独发生的概率，从而犯了一个所谓的结合谬误（conjunction falalcy）。Linda是崇尚女权主义的概率可能很高，Linda是一个银行出纳员的概率可能不高，但Linda同时既是银行出纳员又崇尚女权主义的概率就肯定低于前二者的概率了 。这个道理说出来很简单，大家心里都清楚，但一到实际中人们往往就不会运用。我们会犯这样一种错误的原因可能是因为对事件描述得越详尽，就越容易让我们产生联想，进而导致我们误以为事件越容易发生。</p><h3 id="1-3-赌徒谬误"><a href="#1-3-赌徒谬误" class="headerlink" title="1.3 赌徒谬误"></a>1.3 赌徒谬误</h3><p>在运用代表性启发法进行判断时还有可能会导致赌徒谬误（gambler’s fallacy），也称为蒙地卡罗谬误（The Monte Carlo Fallacy ），主要来源于这样一个故事 ：</p><p> 1913年8月18日，在蒙地卡罗的一间赌场里的轮盘 游戏中，黑色不可思议的连续出现了十五次，人们开始近乎疯狂的冲着去押红色。当黑色连续出现了二十次以后，人们还进一步加大了他们的赌注，因为大家都认为在黑色连续出现了二十次以后再出现黑色的可能性已经不到百万分之一了。结果黑色是创纪录的连续出现了二十六次！这间赌场因此挣得盆缽满盈。</p><p>大家都有这种感觉：似乎黑色已经连续出现太多次，不可能再出现了。这种想法很普遍。比如玩抛硬币，我告诉你前面抛的五次结果都是“正”，要你猜一猜，下一次会出现哪一面？肯定很多人会倾向于“反”面。前面已经出现过那么多次“正”面了，不可能还是“正”吧？连续出现6次“正”面的概率太低了。又比如人们在买彩票的时候，一般都不会选择上一次中奖已经出现过的号码，不可能连续两次中奖都有同一个号码。其实这也是支撑赌徒一直赌下去的重要心理原素之一：我已经输了那么多次了，无论怎么样也应该会赢一次吧。</p><p>这其实也是一种启发式的思维模式。我们认为不可能连续出现6次“正”面或是极端的连续26次黑色，或者连续两次中奖号码都有同一个数字，因为抛硬币、赌博、彩票等事件是随机的，这样的概率实在是太低了，根本就不像是随机事件，一个随机事件怎么可能有这么多巧合？  </p><p>但到底怎么样才叫“随机”？到底是“正反反正反正”还是”正正正正正正”更有可能出现？其实现实生活中随机事件看起来往往都不像是随机的，或者说随机事件并没有你想象的那么随机。所谓随机也就意味着事件与事件之间在统计学意义上是独立的（what makes a sequence random is that its members are statistically independent of each other），一件事情的发生在统计学意义上对另一件事情的发生没有任何影响。（the occurrence of one has no statistical effect upon the occurrence of the other）。随机事件是没有倾向性的，是不可预测的，是没有记忆功能的。因此，就算黑色已经连续出现了N次，下一次是红还是黑都是随机的，认为黑色不太可能再出现而疯狂的去押红色是没有道理的；不管“正”面已经连续出现了多少次，下一次的结果要不是正面就是反面，二者出现的概率都是50％。</p><p>但是竟然会出现连续26次黑色或者连续6次正面这种情况，还是让人难以接受。这是因为有时小样本不具有代表性，样本越小，与真实的数量相差越大，统计的结果越不能反映真实的情况。只有对总体进行统计的结果才是真正的结果，也就是说样本的数量越接近真实的数量，统计的结果也就越可信。如果只抛十次硬币，正反面出现的概率不一定是50%，什么情况都有可能发生，只有抛足够多次，才能得出正反面的概率是50%的结果。这提醒我们有时不要匆忙的作出判断或下结论，很有可能你看到的只不过是一个小样本。</p><h2 id="二、可得性启发法"><a href="#二、可得性启发法" class="headerlink" title="二、可得性启发法"></a>二、可得性启发法</h2><p>人们在什么情况下更愿意买地震保险？想象在汶川地震以前有位保险销售人员向你推销地震保险，相信你是打死都不会买。因为地震这个事情离你的生活实在是太遥远了，那是八竿子打不着的事情。但在发生汶川地震以后，情况就截然不同了，特别是你在电视上看到了地震的各种惨状以后，如果再有保险销售人员向你推销地震保险的话，你肯定会比以前更愿意掏钱。现在很多人去买房，总喜欢问这样一个问题：这房子能抗几级地震啊？如果我们仔细想想的话，人们的这种反应其实是非常可笑的，因为恰恰是因为刚刚发生过地震，所以在一段时间内再次发生的地震的可能性是很小很小的。那么为什么人们反而会在地震以后更愿意买地震保险呢？这就是可得性启发法（Availability heuristic）的影响。</p><p>很多时候我们做出判断是情绪性的、无意识的，非理性的。人们对于越容易想起来的事情（即在脑海中的印象更为深刻），会觉得越容易发生，这就是所谓的可得性启发，通过易得性来判断其可能性，即“<strong>人们倾向于根据客体或事件在知觉或记忆中的可得性程度来评估其相对频率，容易知觉到的或回想起的客体或事件被判定为更常出现 </strong>”。比如我们在判断是否要买地震保险时，脑海中首先浮现到的就是不久前发生的地震以及我们在电视上目睹的各种惨状，于是就会觉得地震确实很可怕，并且似乎离我们很近或者说很有可能会发生在我们自己的身上，因此就更愿意购买地震保险了。</p><p>对于可得性启发经常被提及的一个实验是这样的，问：以字母k开头的英文单词和第三个字母是K的英文单词相比，二者谁更多？大多数人认为以字母k开头的英文单词更多。因为人们很容易就想到以字母k开头的英文单词，比如keep,kill,kitchen等，但要想起第三个字母是K的英文单词就有些困难了，于是人们就会认为以字母k开头的英文单词会更多。实际上，第三个字母是k的单词是以k字母开头的单词的3倍。</p><p>有时候可得性启发式是正确的，越容易回想起来的事情确实越有可能发生，因为不断重复（容易）发生的事情，自然更容易在我们的脑海中留下深刻的印象。但是我们不仅仅只会记住那些经常发生的事情，事实证明，我们更喜欢那些生动的、形象的、具有情绪感染力的事件。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvc5zwpstj308r0bbglq.jpg" alt=""></p><p>大家都应该见过这张希望工程的宣传图片，相信许多人在看到这张照片以后，都会被深深的感动，可能本来没打算捐钱的结果也捐一点钱，本来打算只捐5块钱的结果捐了10块钱。我们通过这张图片，对贫困失学儿童有了更为直观的、生动的认识。</p><p>这就是所谓的一张图片胜过千言万语。不管我们是说帮助中国的失学儿童有多么多么的重要，还是说中国有多少多少的失学儿童并列举一堆统计数字，都不如一张具有视觉冲击力的图片更能打动我们的心。我们的行为很容易因此而受到影响——比如多捐一点钱，当然这是好的方面。（这也就是为什么在禁毒宣传或者交通安全宣传的时候总是喜欢摆一些恶心的照片出来）</p><p>此外，我们对自己亲身经历过的事情印象也会特别深刻。一个死于骑摩托车的亲戚比大量的统计数据更能影响你对摩托车的态度。结了婚的年轻人经常会为干家务的事情发生争吵，总认为自己干的家务活要比对方干得多。美国的心理学家做过这样一个调查，让妻子和丈夫各自评估自己所干的事占所有家务的比例，然后将两人的比例加起来，结果总是超过100%。这其实很好理解，这一方面是因为自利归因，另一方面也是因为自己干的家务活自己总是能记住，所以就总觉得自己干的要比对方多。</p><p>可得性启发会导致我们做出错误的决策。因为受可得性启发的影响，我们做出判断决策时，依据的可能就仅仅是一些经过我们头脑选择过的、印象最为深刻的例子。正如道金斯在《自私的基因》里说到的：经过选择的例子对于任何有价值的概括从来就不是重要的证据（Chosen examples are never serious evidence for any worthwhile generalization.）。因为例子永远都只能是一个例子，不具有任何的代表性。如果你遇到一个河南人把你的钱都骗光了，你能因此而得出结论说所有的河南人都是骗子，都是不可靠的吗？如果你不是遇到一个河南人如此，而是十个、一百个河南人都如此呢？那么也仅仅说明这十个、一百个河南人是不可靠的，但不能说所有河南人都是不可靠。</p><p>此外我们在举例时很容易忽略那些与我们已有观念不一致的信息，从而导致所谓的证实性偏差。塔布勒在《黑天鹅》中把过度举例称为“无知的经验主义”。想象一只火鸡，每天都被喂得饱饱的，每次的喂食都使它更加相信生命的一般法则在于每天得到“为他的最大利益着想”的友善人类的喂食。日子一天天的过去，它的信心也越来越充足。但感恩节也是一天天的临近，它被屠杀的危险也越来越大。当危险最大时它的安全感却达到了最大值。直到感恩节的前一天，它才真正的明白过来，它过去获得的知识和经验都是无关痛痒的甚至是虚假的。在某种程度上，我们所有人都是这只火鸡。</p><p>所以例子不应该作为论据来使用的。那么有人会说，你这篇文章里不就通篇都是例子吗？例子在这里只能是为了把更好的把一个道理解释清楚、使人更容易理解。也就是说我们应该用例子来阐释说明而非证明。但现实恰恰是人们很喜欢用例子来证明自己的观点——特别是那些最容易想到的例子。</p><p>比如有一次你乘坐A航空公司的航班，结果A航空公司把你的行李给弄丢了，你火冒三丈，觉得A公司的服务怎么这么差，以后再也不要坐这间公司的航班了。这其实和河南人的例子差不多，一次不愉快的经历可能只是一宗个案，并不具有任何代表性。</p><p>但有的人就会认为，保障乘客的行李安全是航空运输的最基本要求之一，如果连这一点都做不到的话，那么我们还有什么理由来相信它，就算是个案，这样的事情只要经历一次就足够了，难道还要再丢一次行李吗！这种想法是可以理解的，但却是没有道理的。在某种程度上，错误其实是不可避免的。管理学上有所谓的六西格玛质量管理法，我总是很怀疑这是否能够真的做到。就算是DNA复制这种高度精确的事件，都会不可避免的出现偏差（这正是进化的源泉之一），更何况人为的事件？因此，航空公司把乘客的行李弄丢其实是一个不可避免的错误，只是很不幸碰巧被你遇上了。这是一个负面的影响，导致你对整体产生了负面的认识。但是想象如果是一件正面的事件，比如你买彩票，一不小心中了五百万，那么你会如何认识中奖这样一件事情呢？难道你会因此而觉得彩票中奖是很容易，或者别人也应该中奖，或者你以后会更容易中奖吗？</p><p>当然我不是说航空公司把你行李弄丢是和中彩票一样的低概率事件，或者说是可以原谅的。而是要看到，不能仅仅因为一次丢失行李的不愉快的经历而对该公司的服务水平完全否定。如果真的要想知道A公司的服务水平到底怎么样？我们就需要调查不同航线准时到达率和行李丢失率的统计数据。只有统计数据才能相对真实的反映出客观情况。（这也让我想到了所谓的一票否决制，某些领导如果在某些事情上没有达标或者出了什么问题，那么就一概否决，这是不够科学的。没有被否决可能仅仅是运气好罢了。）</p><p>在现代传媒的作用下，可得性启发对人们判断决策的影响更加的大。因为媒体为了追求收视率，吸引眼球，总是喜欢过度报道一些特别的事件。正如人们戏言：狗咬人不是新闻，人咬狗才是新闻。但是如果你看电视看的太多并且懒得去想的话，那么你就会很容易认为满大街的人都在咬狗。比如人们总认为坐飞机很危险，事实上大量的统计数据表明，飞机并不会比坐汽车更危险，但为什么人们会有这样一种错误的判断？很大程度上是因为飞机失事更有新闻价值。如果是一宗普通的交通事故，媒体就不会有太多的报道，但如果是一架飞机坠毁了，那么媒体必定是连篇累牍的大肆报道。结果这些事情在人们的脑海里留下了极其深刻的印象，当我们需要作出判断时脑海中首先浮现的就是这些飞机失事的场景，因此就会得出结论：飞机非常的危险。当然人么更害怕坐飞机也有其他方面的原因，比如人类的生物本能，人们对于自己不能控制的事物的恐惧等等。</p><p>《魔鬼经济学》里有一个例子：假设有个一个8岁大的叫莫莉的孩子，她有两个最好的朋友，一个叫艾米，一个叫伊玛尼，两个朋友都住在附近。莫莉的父母知道艾米的家里放着一把枪，于是他们不许莫莉到艾米家玩。所以莫莉就经常跑到伊玛尼家玩，伊玛尼家的后院有个游泳池。莫莉的父母觉得自己的做法上是在保护莫莉，这样做是对的。</p><p>可根据统计资料显示，这种做法一点都不明智。平均来说，美国每1.1万个家庭游泳池就能溺死一个孩子。美国一共有600万个这样的游泳池，这也就是说，每年将近有550个不到10岁的孩子是溺死在游泳池里。相比之下，在美国，每100多万支枪才会杀死一个孩子。据估计，美国一共有2亿支枪，这就是说美国平均每年死于枪口下的孩子数量大约为175名。所以对于美国孩子来说，他们死于游泳池里的概率（1：11000）要远远大于死于枪口的概率（1：1000000）：也就是说莫莉在伊玛尼家的危险程度是在艾米家的100倍。</p><p>问题就在于为什么莫莉的父母会觉得枪会比游泳池更危险？这和人们对飞机的态度的原因是一样的。媒体更愿意报道一名丧心病狂的家伙开枪打死一名孩子而不是一名孩子在游泳池里淹死。各种奇闻异事更容易在人们的脑海中留下深刻的印象。因此在某种程度上我们对世界的认识是扭曲的，我们的身边充斥着各路媒体和大量信息，我们以为自己很清楚自己在想什么，实际上我们的世界观价值观已被他人所左右。从这个角度来看，信息越多误差越大。</p><p>我们如何摆脱可得性启发带来的偏差？这其实是不可能的，因为启发法是一种无意识的思维，也就意味着有时候我们连自己已经运用了启发法都不知道，更别说避免其错误了。但如果我们对启发法有更深入的了解，那么还是有助于我们减少在这一方面的错误的。感觉往往是不可靠的，不要轻易的下结论。当我们做出判断或得出一个结论时，必须要问自己：我的依据（论据）是什么？这些依据是否足以支撑我的判断？我们对那些感人或者骇人的一切生动的故事都必须保持足够的警惕，不要被我们的情绪所主宰，要更加注重统计数据，很多时候只有统计数据才能相对真实的反映出客观情况。</p><h2 id="三、锚定与调整启发法"><a href="#三、锚定与调整启发法" class="headerlink" title="三、锚定与调整启发法"></a>三、锚定与调整启发法</h2><p>这是一个地球人都知道的故事。一条巷子里有两家卖粥的小店。左边一个，右边一个，两家店的生意都很好，每天都是顾客盈门。可是，晚上盘点的时候，左边这个店总是比右边那个店每天多赚两三百块钱，而且每天都是这样，让人心生不解。</p><p>细心的人终于发现了其中的秘密。如果你走进右边那个粥店，服务员微笑着把你迎进去，给你盛好一碗粥，热情地问你：“您好!加不加鸡蛋?”一般情况下，喜欢吃鸡蛋的人，就会说加一个吧!于是服务员就会拿来一个鸡蛋;不喜欢吃鸡蛋的人，就会说不加，喝完粥结了帐就走了。可是，如果你走进左边那个粥店，服务员同样也是微笑着把你迎进去，给你盛好一碗粥，然后热情地问你：“您好!加一个鸡蛋还是加两个鸡蛋?”一般情况下，喜欢吃鸡蛋的人，就会说加两个;不喜欢吃鸡蛋的人，就会说加一个。就这样，一天下来，左边的这个粥店比右边的那个粥店每天要多卖出很多个鸡蛋，这就是它每天多出多出两三百块的原因。</p><p>大凡讲这个故事的人，都是在讲左边那家粥店的生意经。其实，粥店的生意经里蕴含着十分深刻的心理学道理。左边的那个粥店其实是在运用心理学中的锚定法，诱导消费者在不经意间做出有利于店家的选择。如果你是它的顾客，你的决策则是受到了心理锚定效应的影响，你不自觉地在粥店设定的条件下进行了决策选择。<br>　　<br>也许，多吃一个鸡蛋并没有什么大的问题，但是，如果在商业交易或谈判中，你多付出了10万或者100万，可能就是一个大问题，或者说是一个大损失。左边小店的服务员把顾客“锚定”在“加几个鸡蛋”上，而右边小店的服务员则把顾客“锚定”在“要不要加鸡蛋”上。在前一种情况下，顾客是在“加一个鸡蛋还是加两个鸡蛋”上进行选择或调整，而后一种情况下，顾客是在“加不加鸡蛋”上进行选择或调整，顾客有限的理性使很多的顾客没有充分地调整，使两个小店的生意大相径庭。</p><p>心理学家曾经运用一个随机转盘对人们进行测试。当转盘的指针停留在65%这个刻度时，要求被试回答：非洲国家的数量在联合国国家总数中，所占的百分比是大于65%还是小于65%?对于这个常识性的问题，大部分被试都会回答小于65%。实验者接着又问：“具体的比例是多少?”多数被试回答45%左右。</p><p>接下来，研究者又对一些从来没有参加这类测试活动的人进行了测试。当转盘的指针指向10%的时候，要求被试回答：非洲国家的数量在联合国国家总数中，所占的百分比是大于10%还是小于10%?</p><p>这也是一个常识性的问题，大部分被试会回答大于10%。实验者接着又问：“具体的比例是多少?”多数被试回答在25%左右。所有的被试都知道，转盘的数字是随机出现的，但是，他们的回答却明显地受到转盘先前给出的数字的影响——即使这些数字是无关的。也就是说，被试的答案被“锚定”在先前给出的无关数字上了。</p><p>外出旅游的时候，你看中了一件标价为3000元的紫砂壶，但你对紫砂壶的情况又不是很了解，结果你动用了所有的智慧与店主讨价还价，最终以 1500元成交，你感到很满意。因为，你花了1500元的价钱买了3000元的东西，而不是花了4000元的价钱买了3000元的东西。店主也很高兴，因为他把价值500元的东西随意标成了3000元，而店主的这个前置标价，对于你来说就是一种“锚定”，他让你始终围绕着这个似乎是随机的数字3000元来思维，这也就是为什么商家在一开始就标价很高的原因，因为，这种方法能够实现“双赢”：商家赚了钱，顾客“捡了便宜”。</p><p>这些现象也会出现在商业谈判之中，在信息不对称的情况下，你可能会“锚定”谈判对手，也可能会被对方所“锚定”。有一种十分简单的方法就可以打破这种思维锚定，那就是货比三家，充分地了解标的物的相关信息。</p><p>Kahneman和Tversky认为，无论是初出茅庐的新手，还是经验丰富的决策者，在面对复杂和模糊的问题时，经常会发生启发式认知偏差，只是偏差的几率、幅度大小不同而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在不确定条件下，人类会采用一种启发式的思维方法，即根据以往（相同的或类似的甚至无关的）的经验来对当前情况进行判断。这是一种思考上的捷径，是解决问题的简单、笼统的策略，也称之为经验法则或拇指法则。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="启发式认知偏差" scheme="http://yoursite.com/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE/"/>
    
      <category term="代表性启发法" scheme="http://yoursite.com/tags/%E4%BB%A3%E8%A1%A8%E6%80%A7%E5%90%AF%E5%8F%91%E6%B3%95/"/>
    
      <category term="可得性启发法" scheme="http://yoursite.com/tags/%E5%8F%AF%E5%BE%97%E6%80%A7%E5%90%AF%E5%8F%91%E6%B3%95/"/>
    
      <category term="锚定与调整启发法" scheme="http://yoursite.com/tags/%E9%94%9A%E5%AE%9A%E4%B8%8E%E8%B0%83%E6%95%B4%E5%90%AF%E5%8F%91%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书记（1）：读书清单</title>
    <link href="http://yoursite.com/2018/01/01/%E8%AF%BB%E4%B9%A6%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2018/01/01/读书记（1）：读书清单/</id>
    <published>2018-01-01T12:20:28.000Z</published>
    <updated>2019-01-22T08:52:25.661Z</updated>
    
    <content type="html"><![CDATA[<p>这是我本科实习期间利用闲暇时间整理出来的一系列清单，包含涉及人文社科各个学科的经典书籍。</p><p>我有很多渴望，而这其中尤为让我感受到歌德所说的“静谧的激情”的是这样一种渴望。我渴望深入人类文明最澄明精要的思想脉络，渴望与人类历史上最迷人的灵魂相伴，渴望在漫长的岁月中被这些浪漫的精神“缠绕”，而我相信，它们留下的书，正是我们通向这种渴望的路途中最朴实的一条。这份清单正是始于这种渴望，我期许通过它们去谋合我对文字的控制欲以及统领知识的野心，形成人文社科的阅读图景与思想路径，依循这条规定好的路径，边走边想，争取到那半点光辉。</p><a id="more"></a><p>翁贝托·艾科在他的《无限的清单》里，带着极度的痴狂带领着我们发现隐藏在伟大的作品中的迷人的清单，将那些本来漫无秩序的事物赋予秩序。在第十七章《混乱的枚举》中提及到博尔赫斯式的作品清单时说：“他们之所以开清单，并不是因为他们技穷，不晓得要如何说他们想说的事情，他们以开清单的方式来说他们想说的话，是出于他们对过度的喜爱，是出于骄傲，以及对文字的贪婪，还有，对多元、无限的知识——快乐的知识——贪求。”正是这些伟大的人和他们伟大的作品，在引诱着我们去探求更为鲜活的真理、更为纯粹的思想，也正因为每个人身上都携带着对知识渴求的基因，才会让这些随着伟大的头脑的消逝便无法生效的纸质文字在每个时代熠熠生辉。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv37x9fdkj31400e5775.jpg" alt="hahha"></p><p>但之后的事情并没有按照规定好的方式前行，我时常感觉到我被这些“狂妄的清单”奴役了，甚至很长时间无法摆脱他们整齐划一的身影，它们赤裸裸地暴露了我对多元、无限和过度的探求欲望，他们就像是一位看似博学实则浅薄的教授在我指手画脚，指挥我、支使我、调度我的行动，让我失去了阅读的趣味，失去那种在无边无际的森林中肆意游荡然后发现原本看不见的风景的趣味，我就像是一只困兽，被这些并非观念、并非思想的索然无味的家伙给囚禁了。</p><p>我也曾有过很多类似的美学体验，当我一人徜徉于图书馆之中时，看到成千上万本归好类别的书层层叠叠的放置在书架上，尽管这是一个有限的空间，只能容纳下有限的纸张，但面对这些扑面而来的携带着无限知识模块的书籍，我感受到的是一种“不安的快感”，甚至是一种“绝望的快感”，一种即将窒息的无力感，就如同溺水之际一眼看不到海岸之时的垂死挣扎。于是索性就暂时“抛弃”了它们，用力挣脱它们的身影，离开它们，把它们闲置、一劳永逸地拖入垃圾箱，让他们荒芜，让他们丢失我最初给予它们的热忱与痴迷。</p><p>之后在没有清单梦魇困扰的的日子里，我逐渐醒悟，原来清单它只是一种有限的表达形式，它仅仅代表了一种无序生活中寻找各种秩序生活的可能性。而思想与精神无法像清单一样清晰地罗列排开，它们是无需安排的，它们有其内在的环路，我开始告诫自己，沿着思想走，而不是沿着书本走。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3zcw62vj30nc08c751.jpg" alt=""><br>但如果这些清单最终的用途仅仅是满足我的私欲和揭露我狂妄的野心，那它的命运也过于浅薄灰暗了，我不该让它们被我自私的占有，它们的命运也不绝于此，它们本该有更多的触角去和更多的读者相遇，见到更多的光与热爱，与更多美妙的灵魂互动。于是便有了这一系列的整理。</p><p>下面是它们的目录及链接，简单介绍一下，我把他们归类成了以下几个篇章：哲学篇、文学篇、诗歌篇、社会学篇、政治学篇、心理学篇、人类学篇、经济学篇、法学篇，每一个类目包含了该领域下经典的作品，主要按照作者来进行细分，当然也包含了一些比较不错的系列丛书，每一个作者或者系列都链接到了百度网盘，里面就是那些伟大的作品了，基本上是PDF格式，当初选择PDF格式也是因为阅读的时候可以看到纸质书的原貌，在选择的时候也尽量挑选了相对比较清晰的版本，尽量提升阅读体验。</p><p>最后，我想引用歌德的一句话：“阅读是读者与作者间的一次合谋。书已经翻开，你已经边缘性地进入这场阴谋，除了主动乃至假装愉快地参与，似乎别无选择······”</p><p>如果您有任何问题，请联系我的邮箱<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x31;&#56;&#x38;&#49;&#48;&#x36;&#x39;&#56;&#57;&#x32;&#x33;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#x31;&#56;&#x38;&#49;&#48;&#x36;&#x39;&#56;&#57;&#x32;&#x33;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a>。</p><hr><h3 id="清单的艺术：哲学篇"><a href="#清单的艺术：哲学篇" class="headerlink" title="清单的艺术：哲学篇"></a><strong>清单的艺术：哲学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1cygFt8" target="_blank" rel="noopener">阿多诺</a></th><th><a href="https://pan.baidu.com/s/1ge3LSAJ" target="_blank" rel="noopener">阿尔都塞</a></th><th><a href="https://pan.baidu.com/s/1i5xm0qL" target="_blank" rel="noopener">阿甘本</a></th><th><a href="https://pan.baidu.com/s/1pLl4S5P" target="_blank" rel="noopener">阿奎那</a></th><th><a href="https://pan.baidu.com/s/1i47L8yD" target="_blank" rel="noopener">艾耶尔</a></th><th><a href="https://pan.baidu.com/s/1eSKtdkA" target="_blank" rel="noopener">奥古斯丁</a></th><th><a href="https://pan.baidu.com/s/1slG8Qwl" target="_blank" rel="noopener">巴迪欧</a></th><th><a href="https://pan.baidu.com/s/1slC5kwl" target="_blank" rel="noopener">巴赫金</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1i4UMgaL" target="_blank" rel="noopener">柏格森</a></td><td><a href="https://pan.baidu.com/s/1dF8jO9j" target="_blank" rel="noopener">柏拉图</a></td><td><a href="https://pan.baidu.com/s/1c232lsk" target="_blank" rel="noopener">查尔斯.泰勒</a></td><td><a href="https://pan.baidu.com/s/1boMQPiB" target="_blank" rel="noopener">陈嘉映</a></td><td><a href="https://pan.baidu.com/s/1qYvCmWs" target="_blank" rel="noopener">德勒兹</a></td><td><a href="https://pan.baidu.com/s/1kVINcsZ" target="_blank" rel="noopener">德里达</a></td><td><a href="https://pan.baidu.com/s/1jI4BR7o" target="_blank" rel="noopener">詹姆士</a></td><td><a href="https://pan.baidu.com/s/1i5ncXtb" target="_blank" rel="noopener">张汝伦</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1dEGblQT" target="_blank" rel="noopener">邓安庆</a></td><td><a href="https://pan.baidu.com/s/1kU9dyDL" target="_blank" rel="noopener">邓晓芒</a></td><td><a href="https://pan.baidu.com/s/1qYQey8s" target="_blank" rel="noopener">狄尔泰</a></td><td><a href="https://pan.baidu.com/s/1c15nX08" target="_blank" rel="noopener">笛卡尔</a></td><td><a href="https://pan.baidu.com/s/1gfGnw7T" target="_blank" rel="noopener">蒂利希</a></td><td><a href="https://pan.baidu.com/s/1i5cTGih" target="_blank" rel="noopener">杜威</a></td><td><a href="https://pan.baidu.com/s/1nuCxh5v" target="_blank" rel="noopener">福柯</a></td><td><a href="https://pan.baidu.com/s/1hs1smck" target="_blank" rel="noopener">伽达默尔</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c2kvKU" target="_blank" rel="noopener">哈贝马斯</a></td><td><a href="https://pan.baidu.com/s/1bGNly2" target="_blank" rel="noopener">海德格尔</a></td><td><a href="https://pan.baidu.com/s/1hsH7jZA" target="_blank" rel="noopener">何怀宏</a></td><td><a href="https://pan.baidu.com/s/1b2AeIE" target="_blank" rel="noopener">何兆武</a></td><td><a href="https://pan.baidu.com/s/1qXPilf2" target="_blank" rel="noopener">黑格尔</a></td><td><a href="https://pan.baidu.com/s/1c1ILcQG" target="_blank" rel="noopener">胡塞尔</a></td><td><a href="https://pan.baidu.com/s/1i44xEXv" target="_blank" rel="noopener">怀特海</a></td><td><a href="https://pan.baidu.com/s/1o83NNzs" target="_blank" rel="noopener">张世英</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1i5q0PJf" target="_blank" rel="noopener">霍克海默</a></td><td><a href="https://pan.baidu.com/s/1o8QO3xC" target="_blank" rel="noopener">江怡</a></td><td><a href="https://pan.baidu.com/s/1i5tOCzN" target="_blank" rel="noopener">金观涛</a></td><td><a href="https://pan.baidu.com/s/1miL2QX6" target="_blank" rel="noopener">卡西尔</a></td><td><a href="https://pan.baidu.com/s/1miy2l8s" target="_blank" rel="noopener">康德</a></td><td><a href="https://pan.baidu.com/s/1boOSHtH" target="_blank" rel="noopener">柯林伍德</a></td><td><a href="https://pan.baidu.com/s/1nvvIrlZ" target="_blank" rel="noopener">克尔凯郭尔</a></td><td><a href="https://pan.baidu.com/s/1mhRsqKC" target="_blank" rel="noopener">克里希那穆提</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1nuAvpFz" target="_blank" rel="noopener">莱布尼茨</a></td><td><a href="https://pan.baidu.com/s/1boIhhKj" target="_blank" rel="noopener">赖尔</a></td><td><a href="https://pan.baidu.com/s/1minCWm0" target="_blank" rel="noopener">朗西埃</a></td><td><a href="https://pan.baidu.com/s/1skNKpWT" target="_blank" rel="noopener">勒维纳斯</a></td><td><a href="https://pan.baidu.com/s/1geUQn7P" target="_blank" rel="noopener">利科</a></td><td><a href="https://pan.baidu.com/s/1o7HKKiQ" target="_blank" rel="noopener">刘小枫</a></td><td><a href="https://pan.baidu.com/s/1boOSHtX" target="_blank" rel="noopener">卢克莱修</a></td><td><a href="https://pan.baidu.com/s/1hrBlyzq" target="_blank" rel="noopener">罗蒂</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1o8MeKm2" target="_blank" rel="noopener">罗兰.巴特</a></td><td><a href="https://pan.baidu.com/s/1ge63IZx" target="_blank" rel="noopener">罗素</a></td><td><a href="https://pan.baidu.com/s/1hsw85Ru" target="_blank" rel="noopener">洛克</a></td><td><a href="https://pan.baidu.com/s/1kVb3AHT" target="_blank" rel="noopener">马克思</a></td><td><a href="https://pan.baidu.com/s/1kVvM1qn" target="_blank" rel="noopener">梅洛.庞蒂</a></td><td><a href="https://pan.baidu.com/s/1i4E7iAh" target="_blank" rel="noopener">莫罗阿</a></td><td><a href="https://pan.baidu.com/s/1slHoVFJ" target="_blank" rel="noopener">尼采</a></td><td><a href="https://pan.baidu.com/s/1o8xcoaQ" target="_blank" rel="noopener">张一兵</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c2tsOHq" target="_blank" rel="noopener">倪梁康</a></td><td><a href="https://pan.baidu.com/s/1c1Zab08" target="_blank" rel="noopener">帕斯卡尔</a></td><td><a href="https://pan.baidu.com/s/1nvOiDXf" target="_blank" rel="noopener">培根</a></td><td><a href="https://pan.baidu.com/s/1nvilosL" target="_blank" rel="noopener">皮亚杰</a></td><td><a href="https://pan.baidu.com/s/1miEbudU" target="_blank" rel="noopener">齐泽克</a></td><td><a href="https://pan.baidu.com/s/1hs6HTcS" target="_blank" rel="noopener">萨特</a></td><td><a href="https://pan.baidu.com/s/1nuBHjeh" target="_blank" rel="noopener">塞涅卡</a></td><td><a href="https://pan.baidu.com/s/1cnruqE" target="_blank" rel="noopener">舍斯托夫</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1jIktmDo" target="_blank" rel="noopener">石里克</a></td><td><a href="https://pan.baidu.com/s/1jI4BSs2" target="_blank" rel="noopener">叔本华</a></td><td><a href="https://pan.baidu.com/s/1gfm1hdh" target="_blank" rel="noopener">斯宾诺莎</a></td><td><a href="https://pan.baidu.com/s/1nvAB1lJ" target="_blank" rel="noopener">唐君毅</a></td><td><a href="https://pan.baidu.com/s/1ctwU5K" target="_blank" rel="noopener">王元化</a></td><td><a href="https://pan.baidu.com/s/1bpuGOWZ" target="_blank" rel="noopener">维科</a></td><td><a href="https://pan.baidu.com/s/1c1Gdphm" target="_blank" rel="noopener">维特根斯坦</a></td><td><a href="https://pan.baidu.com/s/1hrQK2OW" target="_blank" rel="noopener">俞吾金</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1cM3iCu" target="_blank" rel="noopener">西蒙娜·薇依</a></td><td><a href="https://pan.baidu.com/s/1i5y8vD7" target="_blank" rel="noopener">西塞罗</a></td><td><a href="https://pan.baidu.com/s/1jI7tIIE" target="_blank" rel="noopener">休谟</a></td><td><a href="https://pan.baidu.com/s/1jIeT0Q6" target="_blank" rel="noopener">雅斯贝尔斯</a></td><td><a href="https://pan.baidu.com/s/1skY9Dox" target="_blank" rel="noopener">亚当斯密</a></td><td><a href="https://pan.baidu.com/s/1miQSzY4" target="_blank" rel="noopener">亚里士多德</a></td><td><a href="https://pan.baidu.com/s/1gflfpcv" target="_blank" rel="noopener">杨祖陶</a></td><td><a href="https://pan.baidu.com/s/1bEf1uu" target="_blank" rel="noopener">于连</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1hsAfABi" target="_blank" rel="noopener">美学</a></td><td><a href="https://pan.baidu.com/s/1hsH7kgO" target="_blank" rel="noopener">科学哲学</a></td><td><a href="https://pan.baidu.com/s/1jIeT0Se" target="_blank" rel="noopener">政治哲学</a></td><td><a href="https://pan.baidu.com/s/1c2pUZr6" target="_blank" rel="noopener">道德哲学</a></td><td><a href="https://pan.baidu.com/s/1geOK9Fl" target="_blank" rel="noopener">逻辑学</a></td><td><a href="https://pan.baidu.com/s/1pLcbzo3" target="_blank" rel="noopener">现象学</a></td><td><a href="https://pan.baidu.com/s/1qYmiOzU" target="_blank" rel="noopener">心灵哲学</a></td><td><a href="https://pan.baidu.com/s/1pLFraUB" target="_blank" rel="noopener">分析哲学</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1bp0MxrD" target="_blank" rel="noopener">二十世纪西方哲学译丛</a></td><td><a href="https://pan.baidu.com/s/1mh9HuEs" target="_blank" rel="noopener">国外经典哲学教材译丛</a></td><td><a href="https://pan.baidu.com/s/1i5tiAPZ" target="_blank" rel="noopener">世纪人文系列丛书</a></td><td><a href="https://pan.baidu.com/s/1c2jPwAk" target="_blank" rel="noopener">西方名著入门</a></td><td><a href="https://pan.baidu.com/s/1b9vGBG" target="_blank" rel="noopener">西方社会科学读本</a></td><td><a href="https://pan.baidu.com/s/1nv67DG1" target="_blank" rel="noopener">人文译丛</a></td><td><a href="https://pan.baidu.com/s/1i4QIwE5" target="_blank" rel="noopener">人文与社会译丛</a></td><td><a href="https://pan.baidu.com/s/1eSaXUSi" target="_blank" rel="noopener">后现代交锋丛书</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c2lRqe8" target="_blank" rel="noopener">当代西方哲学家评传</a></td><td><a href="https://pan.baidu.com/s/1c2EX3FE" target="_blank" rel="noopener">德国哲学 辑刊</a></td><td><a href="https://pan.baidu.com/s/1hsgZ13Y" target="_blank" rel="noopener">汉译哲学</a></td><td><a href="https://pan.baidu.com/s/1jI8FFWa" target="_blank" rel="noopener">哲学工具书系列</a></td><td><a href="https://pan.baidu.com/s/1pKWBKM3" target="_blank" rel="noopener">西方哲学史</a></td><td><a href="https://pan.baidu.com/s/1dFHDuF3" target="_blank" rel="noopener">通识系列</a></td><td><a href="https://pan.baidu.com/s/1o87R582" target="_blank" rel="noopener">现代性研究译丛</a></td><td><a href="https://pan.baidu.com/s/1eShJ6tc" target="_blank" rel="noopener">余英时</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1i4QczU9" target="_blank" rel="noopener">孔子</a></td><td><a href="https://pan.baidu.com/s/1pLoSDGv" target="_blank" rel="noopener">老子</a></td><td><a href="https://pan.baidu.com/s/1gfzsvKn" target="_blank" rel="noopener">梁漱溟</a></td><td><a href="https://pan.baidu.com/s/1mhUFZ3i" target="_blank" rel="noopener">孟子</a></td><td><a href="https://pan.baidu.com/s/1nvqsDNr" target="_blank" rel="noopener">牟宗三</a></td><td><a href="https://pan.baidu.com/s/1eS6LTuy" target="_blank" rel="noopener">王阳明</a></td><td><a href="https://pan.baidu.com/s/1c2pplN6" target="_blank" rel="noopener">熊十力</a></td><td><a href="https://pan.baidu.com/s/1nvh5rT3" target="_blank" rel="noopener">朱熹</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1gfm1hh5" target="_blank" rel="noopener">庄子</a></td><td><a href="https://pan.baidu.com/s/1jItgI4u" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：文学篇"><a href="#清单的艺术：文学篇" class="headerlink" title="清单的艺术：文学篇"></a><strong>清单的艺术：文学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1c2pplRi" target="_blank" rel="noopener">D.H.劳伦斯</a></th><th><a href="https://pan.baidu.com/s/1ge7PC8V" target="_blank" rel="noopener">E.M.福斯特</a></th><th><a href="https://pan.baidu.com/s/1kUBfr3h" target="_blank" rel="noopener">J.M.库切</a></th><th><a href="https://pan.baidu.com/s/1sl4xDPr" target="_blank" rel="noopener">T·S·艾略特</a></th><th><a href="https://pan.baidu.com/s/1mi25Xwc" target="_blank" rel="noopener">V.S.奈保尔</a></th><th><a href="https://pan.baidu.com/s/1jIjDpxs" target="_blank" rel="noopener">阿·托尔斯泰</a></th><th><a href="https://pan.baidu.com/s/1pLEBc4F" target="_blank" rel="noopener">阿波利奈尔</a></th><th><a href="https://pan.baidu.com/s/1i5tOCAT" target="_blank" rel="noopener">阿多尼斯</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1o7AZkYA" target="_blank" rel="noopener">阿赫玛托娃</a></td><td><a href="https://pan.baidu.com/s/1o7UBZCm" target="_blank" rel="noopener">阿克萨科夫</a></td><td><a href="https://pan.baidu.com/s/1pLDVn9x" target="_blank" rel="noopener">阿来</a></td><td><a href="https://pan.baidu.com/s/1gf4IgKF" target="_blank" rel="noopener">德波顿</a></td><td><a href="https://pan.baidu.com/s/1pLNyC23" target="_blank" rel="noopener">阿摩司·奥兹</a></td><td><a href="https://pan.baidu.com/s/1jI9v9OU" target="_blank" rel="noopener">阿瑟·库斯勒</a></td><td><a href="https://pan.baidu.com/s/1c2pplRE" target="_blank" rel="noopener">阿斯塔菲耶夫</a></td><td><a href="https://pan.baidu.com/s/1pLywhS3" target="_blank" rel="noopener">耶利内克</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1dF74a21" target="_blank" rel="noopener">埃利蒂斯</a></td><td><a href="https://pan.baidu.com/s/1kVrcE4B" target="_blank" rel="noopener">艾丽丝·默多克</a></td><td><a href="https://pan.baidu.com/s/1pLkOWyB" target="_blank" rel="noopener">艾丽斯·沃克</a></td><td><a href="https://pan.baidu.com/s/1i5AJ5PV" target="_blank" rel="noopener">艾特玛托夫</a></td><td><a href="https://pan.baidu.com/s/1dF95S4p" target="_blank" rel="noopener">爱伦堡</a></td><td><a href="https://pan.baidu.com/s/1mi9r9Ja" target="_blank" rel="noopener">爱伦坡</a></td><td><a href="https://pan.baidu.com/s/1kVrcE4R" target="_blank" rel="noopener">爱默生</a></td><td><a href="https://pan.baidu.com/s/1kUZ1ISJ" target="_blank" rel="noopener">安.兰德</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1geFXccV" target="_blank" rel="noopener">安德烈.纪德</a></td><td><a href="https://pan.baidu.com/s/1kUDNfbL" target="_blank" rel="noopener">安德烈耶夫</a></td><td><a href="https://pan.baidu.com/s/1i5cTGvb" target="_blank" rel="noopener">安东尼·伯吉斯</a></td><td><a href="https://pan.baidu.com/s/1hsEj3Hq" target="_blank" rel="noopener">安妮·普鲁</a></td><td><a href="https://pan.baidu.com/s/1csGZwy" target="_blank" rel="noopener">安徒生</a></td><td><a href="https://pan.baidu.com/s/1kUOC6kn" target="_blank" rel="noopener">奥尔罕.帕慕克</a></td><td><a href="https://pan.baidu.com/s/1pLFrbab" target="_blank" rel="noopener">巴别尔</a></td><td><a href="https://pan.baidu.com/s/1jIEftD8" target="_blank" rel="noopener">巴尔扎克</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1hs8dJCC" target="_blank" rel="noopener">巴塞尔姆</a></td><td><a href="https://pan.baidu.com/s/1i53sfid" target="_blank" rel="noopener">邦达列夫</a></td><td><a href="https://pan.baidu.com/s/1kU6vAeV" target="_blank" rel="noopener">保罗.策兰</a></td><td><a href="https://pan.baidu.com/s/1kVQo5an" target="_blank" rel="noopener">保罗·科埃略</a></td><td><a href="https://pan.baidu.com/s/1hrKEJdy" target="_blank" rel="noopener">朱利安.巴恩斯</a></td><td><a href="https://pan.baidu.com/s/1c1WsoH6" target="_blank" rel="noopener">朱天文</a></td><td><a href="https://pan.baidu.com/s/1pLOe86v" target="_blank" rel="noopener">张炜</a></td><td><a href="https://pan.baidu.com/s/1pLFrbIV" target="_blank" rel="noopener">张贤亮</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1sl0tXU1" target="_blank" rel="noopener">贝克特</a></td><td><a href="https://pan.baidu.com/s/1jImvgnc" target="_blank" rel="noopener">本·奥克瑞</a></td><td><a href="https://pan.baidu.com/s/1gfH9s9H" target="_blank" rel="noopener">本哈德·施林克</a></td><td><a href="https://pan.baidu.com/s/1qYzadcg" target="_blank" rel="noopener">本雅明</a></td><td><a href="https://pan.baidu.com/s/1gfcrH1x" target="_blank" rel="noopener">彼得·阿克罗伊德</a></td><td><a href="https://pan.baidu.com/s/1b7tRUe" target="_blank" rel="noopener">别尔嘉耶夫</a></td><td><a href="https://pan.baidu.com/s/1slBPkJV" target="_blank" rel="noopener">波德莱尔</a></td><td><a href="https://pan.baidu.com/s/1o85jIUu" target="_blank" rel="noopener">波德里亚</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1kUSGouz" target="_blank" rel="noopener">勃兰兑斯</a></td><td><a href="https://pan.baidu.com/s/1cCtKKI" target="_blank" rel="noopener">勃留索夫</a></td><td><a href="https://pan.baidu.com/s/1nvrE8pr" target="_blank" rel="noopener">勃洛克</a></td><td><a href="https://pan.baidu.com/s/1c2waF08" target="_blank" rel="noopener">博尔赫斯</a></td><td><a href="https://pan.baidu.com/s/1eSplaJg" target="_blank" rel="noopener">布尔加科夫</a></td><td><a href="https://pan.baidu.com/s/1bpCXFSb" target="_blank" rel="noopener">布莱希特</a></td><td><a href="https://pan.baidu.com/s/1gfANIJx" target="_blank" rel="noopener">布朗肖</a></td><td><a href="https://pan.baidu.com/s/1jHWLZfg" target="_blank" rel="noopener">蔡骏</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1pL63ESr" target="_blank" rel="noopener">陈忠实</a></td><td><a href="https://pan.baidu.com/s/1mhBJmDq" target="_blank" rel="noopener">迟子建</a></td><td><a href="https://pan.baidu.com/s/1i5H5mYx" target="_blank" rel="noopener">川端康成</a></td><td><a href="https://pan.baidu.com/s/1o83NNCY" target="_blank" rel="noopener">茨维塔耶娃</a></td><td><a href="https://pan.baidu.com/s/1cfjPWa" target="_blank" rel="noopener">村上春树</a></td><td><a href="https://pan.baidu.com/s/1qXKy6rq" target="_blank" rel="noopener">达夫妮.杜穆里埃</a></td><td><a href="https://pan.baidu.com/s/1mi69F2w" target="_blank" rel="noopener">达里奥·福</a></td><td><a href="https://pan.baidu.com/s/1hrOIA4s" target="_blank" rel="noopener">大江健三郎</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1pKS7Wkb" target="_blank" rel="noopener">但丁</a></td><td><a href="https://pan.baidu.com/s/1slOa5K5" target="_blank" rel="noopener">狄更斯</a></td><td><a href="https://pan.baidu.com/s/1hspgTne" target="_blank" rel="noopener">东野圭吾</a></td><td><a href="https://pan.baidu.com/s/1jHYNNOq" target="_blank" rel="noopener">董桥</a></td><td><a href="https://pan.baidu.com/s/1i5H5mZV" target="_blank" rel="noopener">杜鲁门·卡波特</a></td><td><a href="https://pan.baidu.com/s/1eRIbegU" target="_blank" rel="noopener">多丽丝莱辛</a></td><td><a href="https://pan.baidu.com/s/1eS0awbo" target="_blank" rel="noopener">菲利普·罗斯</a></td><td><a href="https://pan.baidu.com/s/1kVteC31" target="_blank" rel="noopener">费定</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1bp12xK7" target="_blank" rel="noopener">马卡宁</a></td><td><a href="https://pan.baidu.com/s/1slV1Z57" target="_blank" rel="noopener">迪伦马特</a></td><td><a href="https://pan.baidu.com/s/1qY3JJ4o" target="_blank" rel="noopener">孚希特万格</a></td><td><a href="https://pan.baidu.com/s/1hs8dJEG" target="_blank" rel="noopener">福克纳</a></td><td><a href="https://pan.baidu.com/s/1miJ0Ywg" target="_blank" rel="noopener">冈察尔</a></td><td><a href="https://pan.baidu.com/s/1sl5dDgx" target="_blank" rel="noopener">冈察洛夫</a></td><td><a href="https://pan.baidu.com/s/1jIjDp2I" target="_blank" rel="noopener">高尔基</a></td><td><a href="https://pan.baidu.com/s/1bpsETMB" target="_blank" rel="noopener">高尔斯华绥</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c26Qfza" target="_blank" rel="noopener">高行健</a></td><td><a href="https://pan.baidu.com/s/1boVEsY7" target="_blank" rel="noopener">戈迪默</a></td><td><a href="https://pan.baidu.com/s/1slC5luP" target="_blank" rel="noopener">歌德</a></td><td><a href="https://pan.baidu.com/s/1miafEdE" target="_blank" rel="noopener">格非</a></td><td><a href="https://pan.baidu.com/s/1gf0Erjd" target="_blank" rel="noopener">格雷厄姆·格林</a></td><td><a href="https://pan.baidu.com/s/1o8KIOFg" target="_blank" rel="noopener">格列科娃</a></td><td><a href="https://pan.baidu.com/s/1hrDnnUk" target="_blank" rel="noopener">果戈理</a></td><td><a href="https://pan.baidu.com/s/1qYtAueC" target="_blank" rel="noopener">哈珀·李</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1i53XXWD" target="_blank" rel="noopener">海明威</a></td><td><a href="https://pan.baidu.com/s/1cucU7s" target="_blank" rel="noopener">海涅</a></td><td><a href="https://pan.baidu.com/s/1o8FZiKM" target="_blank" rel="noopener">海因里希.伯尔</a></td><td><a href="https://pan.baidu.com/s/1nvxKsad" target="_blank" rel="noopener">韩松</a></td><td><a href="https://pan.baidu.com/s/1i4RyyDB" target="_blank" rel="noopener">荷尔德林</a></td><td><a href="https://pan.baidu.com/s/1csaZgE" target="_blank" rel="noopener">赫尔岑</a></td><td><a href="https://pan.baidu.com/s/1i5AdH3J" target="_blank" rel="noopener">赫塔·米勒</a></td><td><a href="https://pan.baidu.com/s/1jIOoNDO" target="_blank" rel="noopener">黑塞</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1i5b7J6X" target="_blank" rel="noopener">亨利.米勒</a></td><td><a href="https://pan.baidu.com/s/1i5Eh4OH" target="_blank" rel="noopener">亨利希·曼</a></td><td><a href="https://pan.baidu.com/s/1geQg80b" target="_blank" rel="noopener">科塔萨尔</a></td><td><a href="https://pan.baidu.com/s/1o8vayxk" target="_blank" rel="noopener">华兹华斯</a></td><td><a href="https://pan.baidu.com/s/1bCJ1dc" target="_blank" rel="noopener">惠特曼</a></td><td><a href="https://pan.baidu.com/s/1dE9V8Y1" target="_blank" rel="noopener">霍达</a></td><td><a href="https://pan.baidu.com/s/1dFCnIRB" target="_blank" rel="noopener">霍夫曼</a></td><td><a href="https://pan.baidu.com/s/1c2IvwFQ" target="_blank" rel="noopener">霍普特曼</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1sl9Nr7f" target="_blank" rel="noopener">济慈</a></td><td><a href="https://pan.baidu.com/s/1nvpCFqx" target="_blank" rel="noopener">加缪</a></td><td><a href="https://pan.baidu.com/s/1skHECvr" target="_blank" rel="noopener">加西亚.马尔克斯</a></td><td><a href="https://pan.baidu.com/s/1nuM66yl" target="_blank" rel="noopener">贾平凹</a></td><td><a href="https://pan.baidu.com/s/1pKVpVvl" target="_blank" rel="noopener">蒋勋</a></td><td><a href="https://pan.baidu.com/s/1hsLAUWG" target="_blank" rel="noopener">杰弗里·尤金尼德斯</a></td><td><a href="https://pan.baidu.com/s/1hshF1PU" target="_blank" rel="noopener">芥川龙之介</a></td><td><a href="https://pan.baidu.com/s/1nvT8r6T" target="_blank" rel="noopener">金庸</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1jH4vIJW" target="_blank" rel="noopener">聚斯金德</a></td><td><a href="https://pan.baidu.com/s/1kVCbw9L" target="_blank" rel="noopener">君特.格拉斯</a></td><td><a href="https://pan.baidu.com/s/1b7ZNEA" target="_blank" rel="noopener">卡夫卡</a></td><td><a href="https://pan.baidu.com/s/1qYHWQN6" target="_blank" rel="noopener">富恩特斯</a></td><td><a href="https://pan.baidu.com/s/1hsKpgG0" target="_blank" rel="noopener">卡内蒂</a></td><td><a href="https://pan.baidu.com/s/1miIfcZQ" target="_blank" rel="noopener">卡萨诺瓦</a></td><td><a href="https://pan.baidu.com/s/1c11QiTa" target="_blank" rel="noopener">卡赞扎基斯</a></td><td><a href="https://pan.baidu.com/s/1eSrSRJk" target="_blank" rel="noopener">科尔姆.托宾</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1cjT5BS" target="_blank" rel="noopener">科马克·麦卡锡</a></td><td><a href="https://pan.baidu.com/s/1hsvm7qs" target="_blank" rel="noopener">克莱斯特</a></td><td><a href="https://pan.baidu.com/s/1mhBJnfE" target="_blank" rel="noopener">克里斯塔·沃尔夫</a></td><td><a href="https://pan.baidu.com/s/1c1WsoCS" target="_blank" rel="noopener">冯内古特</a></td><td><a href="https://pan.baidu.com/s/1miiTlDe" target="_blank" rel="noopener">库普林</a></td><td><a href="https://pan.baidu.com/s/1pL3LNvl" target="_blank" rel="noopener">拉·艾里森</a></td><td><a href="https://pan.baidu.com/s/1c2nnoY0" target="_blank" rel="noopener">拉斯普京</a></td><td><a href="https://pan.baidu.com/s/1hrYmbOS" target="_blank" rel="noopener">莱蒙特</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1sll0H5N" target="_blank" rel="noopener">莱蒙托夫</a></td><td><a href="https://pan.baidu.com/s/1eSlhn4A" target="_blank" rel="noopener">莱辛</a></td><td><a href="https://pan.baidu.com/s/1pKHcKFh" target="_blank" rel="noopener">兰波</a></td><td><a href="https://pan.baidu.com/s/1qXJI8Ao" target="_blank" rel="noopener">劳伦斯·斯特恩</a></td><td><a href="https://pan.baidu.com/s/1qYvCo36" target="_blank" rel="noopener">勒克莱齐奥</a></td><td><a href="https://pan.baidu.com/s/1eRR45JO" target="_blank" rel="noopener">勒萨日</a></td><td><a href="https://pan.baidu.com/s/1o8FtkWM" target="_blank" rel="noopener">雷巴科夫</a></td><td><a href="https://pan.baidu.com/s/1c2MzcXE" target="_blank" rel="noopener">雷马克</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1qYiKYmS" target="_blank" rel="noopener">雷蒙德卡佛</a></td><td><a href="https://pan.baidu.com/s/1dEXCeNR" target="_blank" rel="noopener">李欧梵</a></td><td><a href="https://pan.baidu.com/s/1o8eLviq" target="_blank" rel="noopener">里尔克</a></td><td><a href="https://pan.baidu.com/s/1pLHsVHL" target="_blank" rel="noopener">理查·赖特</a></td><td><a href="https://pan.baidu.com/s/1eRDrv2q" target="_blank" rel="noopener">列夫.托尔斯泰</a></td><td><a href="https://pan.baidu.com/s/1hsF5w80" target="_blank" rel="noopener">列斯科夫</a></td><td><a href="https://pan.baidu.com/s/1qXM0y3i" target="_blank" rel="noopener">林贤治</a></td><td><a href="https://pan.baidu.com/s/1c2qBb6S" target="_blank" rel="noopener">刘慈欣</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1nvSSt7N" target="_blank" rel="noopener">鲁迅</a></td><td><a href="https://pan.baidu.com/s/1jIMmTxk" target="_blank" rel="noopener">路遥</a></td><td><a href="https://pan.baidu.com/s/1dEDZxfF" target="_blank" rel="noopener">伦茨</a></td><td><a href="https://pan.baidu.com/s/1sl9Nr9j" target="_blank" rel="noopener">罗伯.格里耶</a></td><td><a href="https://pan.baidu.com/s/1kVEJpqB" target="_blank" rel="noopener">罗伯特.波拉尼奥</a></td><td><a href="https://pan.baidu.com/s/1eRP2DuM" target="_blank" rel="noopener">罗曼罗兰</a></td><td><a href="https://pan.baidu.com/s/1bzmvRw" target="_blank" rel="noopener">洛扎诺夫</a></td><td><a href="https://pan.baidu.com/s/1bo6BOh5" target="_blank" rel="noopener">骆以军</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1bo7XNBp" target="_blank" rel="noopener">马丁·瓦尔泽</a></td><td><a href="https://pan.baidu.com/s/1mh9bsHM" target="_blank" rel="noopener">马尔罗</a></td><td><a href="https://pan.baidu.com/s/1geQg82v" target="_blank" rel="noopener">马家辉</a></td><td><a href="https://pan.baidu.com/s/1i4G9d8h" target="_blank" rel="noopener">马拉默德</a></td><td><a href="https://pan.baidu.com/s/1i4NuG3F" target="_blank" rel="noopener">略萨</a></td><td><a href="https://pan.baidu.com/s/1o8FtkX8" target="_blank" rel="noopener">马雅可夫斯基</a></td><td><a href="https://pan.baidu.com/s/1gfrkXOJ" target="_blank" rel="noopener">玛·金·罗琳斯</a></td><td><a href="https://pan.baidu.com/s/1c2LJdJU" target="_blank" rel="noopener">阿特伍德</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1kURuqN1" target="_blank" rel="noopener">杜拉斯</a></td><td><a href="https://pan.baidu.com/s/1c2zy7eC" target="_blank" rel="noopener">迈克尔·翁达杰</a></td><td><a href="https://pan.baidu.com/s/1qY83zMs" target="_blank" rel="noopener">迈克尔·坎宁安</a></td><td><a href="https://pan.baidu.com/s/1eSm3mfw" target="_blank" rel="noopener">麦尔维尔</a></td><td><a href="https://pan.baidu.com/s/1jImvgJc" target="_blank" rel="noopener">麦家</a></td><td><a href="https://pan.baidu.com/s/1mhQClsO" target="_blank" rel="noopener">曼德尔施塔姆</a></td><td><a href="https://pan.baidu.com/s/1miquIMk" target="_blank" rel="noopener">毛姆</a></td><td><a href="https://pan.baidu.com/s/1i58bL1j" target="_blank" rel="noopener">梅列日科夫斯基</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1eSD77Tw" target="_blank" rel="noopener">梅特林克</a></td><td><a href="https://pan.baidu.com/s/1jIAHCDS" target="_blank" rel="noopener">蒙田</a></td><td><a href="https://pan.baidu.com/s/1dFjNz1J" target="_blank" rel="noopener">弥尔顿</a></td><td><a href="https://pan.baidu.com/s/1hsChCgO" target="_blank" rel="noopener">米兰·昆德拉</a></td><td><a href="https://pan.baidu.com/s/1bpFF9Hd" target="_blank" rel="noopener">米沃什</a></td><td><a href="https://pan.baidu.com/s/1kVkXiAV" target="_blank" rel="noopener">莫迪亚诺</a></td><td><a href="https://pan.baidu.com/s/1kVf7wEV" target="_blank" rel="noopener">莫里亚克</a></td><td><a href="https://pan.baidu.com/s/1kVb3B4V" target="_blank" rel="noopener">穆齐尔</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1qYSMres" target="_blank" rel="noopener">那多</a></td><td><a href="https://pan.baidu.com/s/1kVKOWB1" target="_blank" rel="noopener">纳博科夫</a></td><td><a href="https://pan.baidu.com/s/1c2Nfb6S" target="_blank" rel="noopener">纳丁·戈迪默</a></td><td><a href="https://pan.baidu.com/s/1c2uEL0G" target="_blank" rel="noopener">娜塔莉·萨洛特</a></td><td><a href="https://pan.baidu.com/s/1miTArkk" target="_blank" rel="noopener">涅克拉索夫</a></td><td><a href="https://pan.baidu.com/s/1pLtCv4B" target="_blank" rel="noopener">聂鲁达</a></td><td><a href="https://pan.baidu.com/s/1dFdbSiP" target="_blank" rel="noopener">诺曼·梅勒</a></td><td><a href="https://pan.baidu.com/s/1c2LdnJa" target="_blank" rel="noopener">帕斯捷尔纳克</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1dFlPrax" target="_blank" rel="noopener">帕特里克·怀特</a></td><td><a href="https://pan.baidu.com/s/1dFgzE17" target="_blank" rel="noopener">帕乌斯托夫斯基</a></td><td><a href="https://pan.baidu.com/s/1mhBdoLU" target="_blank" rel="noopener">潘海天</a></td><td><a href="https://pan.baidu.com/s/1c1VCv0c" target="_blank" rel="noopener">培根</a></td><td><a href="https://pan.baidu.com/s/1bppreRt" target="_blank" rel="noopener">菲兹杰拉德</a></td><td><a href="https://pan.baidu.com/s/1dE3kbst" target="_blank" rel="noopener">皮兰德娄</a></td><td><a href="https://pan.baidu.com/s/1eSs8Q6e" target="_blank" rel="noopener">蒲宁</a></td><td><a href="https://pan.baidu.com/s/1jH9f4Vk" target="_blank" rel="noopener">普里什文</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1boUswEV" target="_blank" rel="noopener">普鲁斯特</a></td><td><a href="https://pan.baidu.com/s/1nvilpdJ" target="_blank" rel="noopener">普吕多姆</a></td><td><a href="https://pan.baidu.com/s/1dEMgJ7b" target="_blank" rel="noopener">普希金</a></td><td><a href="https://pan.baidu.com/s/1kVgTyQz" target="_blank" rel="noopener">契诃夫</a></td><td><a href="https://pan.baidu.com/s/1pK8VrlD" target="_blank" rel="noopener">恰佩克</a></td><td><a href="https://pan.baidu.com/s/1c1Bt7Ja" target="_blank" rel="noopener">乔纳森·弗兰岑</a></td><td><a href="https://pan.baidu.com/s/1hsLAUZ6" target="_blank" rel="noopener">乔伊斯·奥兹</a></td><td><a href="https://pan.baidu.com/s/1qYMaFxi" target="_blank" rel="noopener">丘特切夫</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1miiTlFE" target="_blank" rel="noopener">邱妙津</a></td><td><a href="https://pan.baidu.com/s/1i5itxfJ" target="_blank" rel="noopener">裘帕・拉希莉</a></td><td><a href="https://pan.baidu.com/s/1i5jFszj" target="_blank" rel="noopener">让.雅克.卢梭</a></td><td><a href="https://pan.baidu.com/s/1hs2EkAw" target="_blank" rel="noopener">萨冈</a></td><td><a href="https://pan.baidu.com/s/1eS8hWn4" target="_blank" rel="noopener">萨特</a></td><td><a href="https://pan.baidu.com/s/1eR3hZkI" target="_blank" rel="noopener">塞弗尔特</a></td><td><a href="https://pan.baidu.com/s/1dFLHiQ9" target="_blank" rel="noopener">塞林格</a></td><td><a href="https://pan.baidu.com/s/1boFzuNX" target="_blank" rel="noopener">塞普尔维达</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1o7UCarK" target="_blank" rel="noopener">塞万提斯</a></td><td><a href="https://pan.baidu.com/s/1pLIEWeZ" target="_blank" rel="noopener">三岛由纪夫</a></td><td><a href="https://pan.baidu.com/s/1qY83zOS" target="_blank" rel="noopener">莎士比亚</a></td><td><a href="https://pan.baidu.com/s/1mhJQIe8" target="_blank" rel="noopener">舍斯托夫</a></td><td><a href="https://pan.baidu.com/s/1jHDjkCQ" target="_blank" rel="noopener">沈从文</a></td><td><a href="https://pan.baidu.com/s/1cfjQCA" target="_blank" rel="noopener">施尼茨勒</a></td><td><a href="https://pan.baidu.com/s/1cBDPUY" target="_blank" rel="noopener">施托姆</a></td><td><a href="https://pan.baidu.com/s/1mi9rAys" target="_blank" rel="noopener">张爱玲</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1kVOmEMV" target="_blank" rel="noopener">石黑一雄</a></td><td><a href="https://pan.baidu.com/s/1b1UkG2" target="_blank" rel="noopener">菲茨杰拉德</a></td><td><a href="https://pan.baidu.com/s/1gfhH4Gz" target="_blank" rel="noopener">司汤达</a></td><td><a href="https://pan.baidu.com/s/1eSlhn7W" target="_blank" rel="noopener">斯蒂芬.茨威格</a></td><td><a href="https://pan.baidu.com/s/1cHJyu6" target="_blank" rel="noopener">斯特林堡</a></td><td><a href="https://pan.baidu.com/s/1hrQK3Co" target="_blank" rel="noopener">苏珊.桑塔格</a></td><td><a href="https://pan.baidu.com/s/1nvh5s7n" target="_blank" rel="noopener">苏童</a></td><td><a href="https://pan.baidu.com/s/1hs5wcBi" target="_blank" rel="noopener">苏伟贞</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1slmMKu5" target="_blank" rel="noopener">梭罗</a></td><td><a href="https://pan.baidu.com/s/1kU9d0r1" target="_blank" rel="noopener">索尔·贝娄</a></td><td><a href="https://pan.baidu.com/s/1geDpteV" target="_blank" rel="noopener">索尔仁尼琴</a></td><td><a href="https://pan.baidu.com/s/1slgbppj" target="_blank" rel="noopener">太宰治</a></td><td><a href="https://pan.baidu.com/s/1pKXXLYb" target="_blank" rel="noopener">泰戈尔</a></td><td><a href="https://pan.baidu.com/s/1bpdfTGb" target="_blank" rel="noopener">唐·德里罗</a></td><td><a href="https://pan.baidu.com/s/1eS50dFW" target="_blank" rel="noopener">唐诺</a></td><td><a href="https://pan.baidu.com/s/1nv5RMlV" target="_blank" rel="noopener">特兰斯特勒默</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1jIy6sjc" target="_blank" rel="noopener">铁凝</a></td><td><a href="https://pan.baidu.com/s/1bZKeHS" target="_blank" rel="noopener">屠格涅夫</a></td><td><a href="https://pan.baidu.com/s/1hsF5wDA" target="_blank" rel="noopener">托马斯.哈代</a></td><td><a href="https://pan.baidu.com/s/1jHUKkz8" target="_blank" rel="noopener">托马斯曼</a></td><td><a href="https://pan.baidu.com/s/1hsOsKok" target="_blank" rel="noopener">托马斯·品钦</a></td><td><a href="https://pan.baidu.com/s/1pKIyGaf" target="_blank" rel="noopener">托妮·莫里森</a></td><td><a href="https://pan.baidu.com/s/1qYDTjze" target="_blank" rel="noopener">陀思妥耶夫斯基</a></td><td><a href="https://pan.baidu.com/s/1ge3fP9D" target="_blank" rel="noopener">瓦·格罗斯曼</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1hsmzdOg" target="_blank" rel="noopener">王安忆</a></td><td><a href="https://pan.baidu.com/s/1i52CiGX" target="_blank" rel="noopener">王德威</a></td><td><a href="https://pan.baidu.com/s/1bp56kWJ" target="_blank" rel="noopener">王尔德</a></td><td><a href="https://pan.baidu.com/s/1pLj3fuj" target="_blank" rel="noopener">王晋康</a></td><td><a href="https://pan.baidu.com/s/1miKgRva" target="_blank" rel="noopener">王蒙</a></td><td><a href="https://pan.baidu.com/s/1gfNEPij" target="_blank" rel="noopener">王小波</a></td><td><a href="https://pan.baidu.com/s/1jIpIN3K" target="_blank" rel="noopener">威廉·格纳齐诺</a></td><td><a href="https://pan.baidu.com/s/1miIfdgc" target="_blank" rel="noopener">维·贡布罗维奇</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1miJ0YZe" target="_blank" rel="noopener">维科</a></td><td><a href="https://pan.baidu.com/s/1i5itxdz" target="_blank" rel="noopener">翁贝托.艾柯</a></td><td><a href="https://pan.baidu.com/s/1c1ZGf1e" target="_blank" rel="noopener">伍尔夫</a></td><td><a href="https://pan.baidu.com/s/1gfpOW7p" target="_blank" rel="noopener">西奥多.德莱塞</a></td><td><a href="https://pan.baidu.com/s/1geYTVgv" target="_blank" rel="noopener">西尔维娅・普拉斯</a></td><td><a href="https://pan.baidu.com/s/1eSMvdZG" target="_blank" rel="noopener">西格斯</a></td><td><a href="https://pan.baidu.com/s/1qYPy3Kg" target="_blank" rel="noopener">张大春</a></td><td><a href="https://pan.baidu.com/s/1eSET1Pw" target="_blank" rel="noopener">张洁</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1i4Pw6pf" target="_blank" rel="noopener">希梅内斯</a></td><td><a href="https://pan.baidu.com/s/1o7BFl0I" target="_blank" rel="noopener">席勒</a></td><td><a href="https://pan.baidu.com/s/1nvBXyfZ" target="_blank" rel="noopener">夏多布里昂</a></td><td><a href="https://pan.baidu.com/s/1skFCHLN" target="_blank" rel="noopener">萧伯纳</a></td><td><a href="https://pan.baidu.com/s/1cuIPTs" target="_blank" rel="noopener">萧红</a></td><td><a href="https://pan.baidu.com/s/1nv9p4Vn" target="_blank" rel="noopener">新井一二三</a></td><td><a href="https://pan.baidu.com/s/1eRUSjxK" target="_blank" rel="noopener">雪莱</a></td><td><a href="https://pan.baidu.com/s/1jIL6Xcq" target="_blank" rel="noopener">亚历克斯·哈里</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1kVmsXT1" target="_blank" rel="noopener">亚马多</a></td><td><a href="https://pan.baidu.com/s/1i5fB8Eh" target="_blank" rel="noopener">阎连科</a></td><td><a href="https://pan.baidu.com/s/1nuFeWaP" target="_blank" rel="noopener">叶赛宁</a></td><td><a href="https://pan.baidu.com/s/1mhYJGe8" target="_blank" rel="noopener">叶芝</a></td><td><a href="https://pan.baidu.com/s/1c4SpRo" target="_blank" rel="noopener">伊迪丝·华顿</a></td><td><a href="https://pan.baidu.com/s/1skFCHM9" target="_blank" rel="noopener">伊恩·麦克尤恩</a></td><td><a href="https://pan.baidu.com/s/1slgbprn" target="_blank" rel="noopener">伊凡·克里玛</a></td><td><a href="https://pan.baidu.com/s/1pL41JtT" target="_blank" rel="noopener">伊夫林·沃</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1qXJcBj2" target="_blank" rel="noopener">内米洛夫斯基</a></td><td><a href="https://pan.baidu.com/s/1jIMSLsa" target="_blank" rel="noopener">伊姆雷</a></td><td><a href="https://pan.baidu.com/s/1nu6XwrJ" target="_blank" rel="noopener">卡达莱</a></td><td><a href="https://pan.baidu.com/s/1dFexJVV" target="_blank" rel="noopener">卡尔维诺</a></td><td><a href="https://pan.baidu.com/s/1qXTRYd2" target="_blank" rel="noopener">伊沃.安德里奇</a></td><td><a href="https://pan.baidu.com/s/1bplnvIn" target="_blank" rel="noopener">易卜生</a></td><td><a href="https://pan.baidu.com/s/1o8USh2U" target="_blank" rel="noopener">尤瑟纳尔</a></td><td><a href="https://pan.baidu.com/s/1gfetI0N" target="_blank" rel="noopener">约翰.厄普代克</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1gfetI0N" target="_blank" rel="noopener">约翰·肯尼迪·图尔</a></td><td><a href="https://pan.baidu.com/s/1slHoWyD" target="_blank" rel="noopener">约翰·韦恩</a></td><td><a href="https://pan.baidu.com/s/1c2rXahy" target="_blank" rel="noopener">约瑟夫.海勒</a></td><td><a href="https://pan.baidu.com/s/1miTArpu" target="_blank" rel="noopener">布罗茨基</a></td><td><a href="https://pan.baidu.com/s/1i4YPXel" target="_blank" rel="noopener">扎米亚京</a></td><td><a href="https://pan.baidu.com/s/1o7XtQTO" target="_blank" rel="noopener">詹姆斯.乔伊斯</a></td><td><a href="https://pan.baidu.com/s/1bpjR13x" target="_blank" rel="noopener">鲍德温</a></td><td><a href="https://pan.baidu.com/s/1mikpi1y" target="_blank" rel="noopener">文化生活译丛</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1qYWjXHM" target="_blank" rel="noopener">文学批评理论</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：诗歌篇"><a href="#清单的艺术：诗歌篇" class="headerlink" title="清单的艺术：诗歌篇"></a><strong>清单的艺术：诗歌篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1i5tOCAT" target="_blank" rel="noopener">阿多尼斯</a></th><th><a href="https://pan.baidu.com/s/1jH9f5wM" target="_blank" rel="noopener">阿赫玛托娃</a></th><th><a href="https://pan.baidu.com/s/1i5ncZqd" target="_blank" rel="noopener">艾略特</a></th><th><a href="https://pan.baidu.com/s/1dEOOILb" target="_blank" rel="noopener">奥登</a></th><th><a href="https://pan.baidu.com/s/1qYr81dU" target="_blank" rel="noopener">拜伦</a></th><th><a href="https://pan.baidu.com/s/1eSzux4u" target="_blank" rel="noopener">波德莱尔</a></th><th><a href="https://pan.baidu.com/s/1eRBp3jk" target="_blank" rel="noopener">茨维塔耶娃</a></th><th><a href="https://pan.baidu.com/s/1pKArjLp" target="_blank" rel="noopener">张枣</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1o8KIP9g" target="_blank" rel="noopener">狄金森</a></td><td><a href="https://pan.baidu.com/s/1cbLTsq" target="_blank" rel="noopener">谷川俊太郎</a></td><td><a href="https://pan.baidu.com/s/1nuRqhgH" target="_blank" rel="noopener">哈维尔</a></td><td><a href="https://pan.baidu.com/s/1bpi59O7" target="_blank" rel="noopener">海涅</a></td><td><a href="https://pan.baidu.com/s/1skCoUQD" target="_blank" rel="noopener">荷尔德林</a></td><td><a href="https://pan.baidu.com/s/1dFsAVPB" target="_blank" rel="noopener">惠特曼</a></td><td><a href="https://pan.baidu.com/s/1jIEL07G" target="_blank" rel="noopener">济慈</a></td><td><a href="https://pan.baidu.com/s/1ge5hMPP" target="_blank" rel="noopener">亚非诗选</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1hrOIBI0" target="_blank" rel="noopener">莱蒙托夫</a></td><td><a href="https://pan.baidu.com/s/1kUSaojP" target="_blank" rel="noopener">兰波</a></td><td><a href="https://pan.baidu.com/s/1c4Sq30" target="_blank" rel="noopener">里尔克</a></td><td><a href="https://pan.baidu.com/s/1miiTmre" target="_blank" rel="noopener">马雅可夫斯基</a></td><td><a href="https://pan.baidu.com/s/1hsiv0w8" target="_blank" rel="noopener">曼德尔施塔姆</a></td><td><a href="https://pan.baidu.com/s/1b1Ulo6" target="_blank" rel="noopener">聂鲁达</a></td><td><a href="https://pan.baidu.com/s/1gfpOXft" target="_blank" rel="noopener">帕斯捷尔纳克</a></td><td><a href="https://pan.baidu.com/s/1jHJUNn4" target="_blank" rel="noopener">泰戈尔</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1o7NQwsE" target="_blank" rel="noopener">托马斯.哈代</a></td><td><a href="https://pan.baidu.com/s/1pLbv5xx" target="_blank" rel="noopener">王尔德</a></td><td><a href="https://pan.baidu.com/s/1i57vPAX" target="_blank" rel="noopener">希梅内斯</a></td><td><a href="https://pan.baidu.com/s/1miGJlyC" target="_blank" rel="noopener">席勒</a></td><td><a href="https://pan.baidu.com/s/1dFKviOp" target="_blank" rel="noopener">雪莱</a></td><td><a href="https://pan.baidu.com/s/1mi25YD6" target="_blank" rel="noopener">叶赛宁</a></td><td><a href="https://pan.baidu.com/s/1kVel7Ll" target="_blank" rel="noopener">叶芝</a></td><td><a href="https://pan.baidu.com/s/1sln2KGH" target="_blank" rel="noopener">域外诗丛</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1nvHxg6H" target="_blank" rel="noopener">域外诗歌精品评析</a></td><td><a href="https://pan.baidu.com/s/1hs8JNpi" target="_blank" rel="noopener">20世纪世界诗歌译丛</a></td><td><a href="https://pan.baidu.com/s/1skTPNC5" target="_blank" rel="noopener">西葡诗选</a></td><td><a href="https://pan.baidu.com/s/1qY61AmK" target="_blank" rel="noopener">德语诗选</a></td><td><a href="https://pan.baidu.com/s/1bp12yS3" target="_blank" rel="noopener">英诗选集</a></td><td><a href="https://pan.baidu.com/s/1pK8VrSZ" target="_blank" rel="noopener">拉美诗选</a></td><td><a href="https://pan.baidu.com/s/1qYV4dyc" target="_blank" rel="noopener">俄罗斯诗选</a></td><td><a href="https://pan.baidu.com/s/1jInGU7W" target="_blank" rel="noopener">诺贝尔获得者诗选</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c2Gt5zq" target="_blank" rel="noopener">日本诗选</a></td><td><a href="https://pan.baidu.com/s/1c1Gdq0o" target="_blank" rel="noopener">法国诗选</a></td><td><a href="https://pan.baidu.com/s/1mhNU1mw" target="_blank" rel="noopener">美国诗选</a></td><td><a href="https://pan.baidu.com/s/1pLEBd8n" target="_blank" rel="noopener">二十世纪外国大诗人丛书</a></td><td><a href="https://pan.baidu.com/s/1jIrKI0Y" target="_blank" rel="noopener">十位外国诗人</a></td><td><a href="https://pan.baidu.com/s/1nvGbgfB" target="_blank" rel="noopener">外国文学名家诗篇</a></td><td><a href="https://pan.baidu.com/s/1o87R6NC" target="_blank" rel="noopener">世界诗库</a></td><td><a href="https://pan.baidu.com/s/1qXRQjaW" target="_blank" rel="noopener">诗苑译林</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1dEJyZ0d" target="_blank" rel="noopener">外国诗歌丛书</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：法学篇"><a href="#清单的艺术：法学篇" class="headerlink" title="清单的艺术：法学篇"></a><strong>清单的艺术：法学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1i5MUOE5" target="_blank" rel="noopener">波斯纳</a></th><th><a href="https://pan.baidu.com/s/1bpLfiI7" target="_blank" rel="noopener">德沃金</a></th><th><a href="https://pan.baidu.com/s/1gfu8Cr5" target="_blank" rel="noopener">德肖维茨</a></th><th><a href="https://pan.baidu.com/s/1jIAbCO2" target="_blank" rel="noopener">哈特</a></th><th><a href="https://pan.baidu.com/s/1dF74bkP" target="_blank" rel="noopener">贺卫方</a></th><th><a href="https://pan.baidu.com/s/1jI08lUm" target="_blank" rel="noopener">卡尔·施米特</a></th><th><a href="https://pan.baidu.com/s/1kV27YHh" target="_blank" rel="noopener">梁治平</a></th><th><a href="https://pan.baidu.com/s/1clVyUi" target="_blank" rel="noopener">刘星</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1gf91Gpd" target="_blank" rel="noopener">苏力</a></td><td><a href="https://pan.baidu.com/s/1jIy6som" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：心理学篇"><a href="#清单的艺术：心理学篇" class="headerlink" title="清单的艺术：心理学篇"></a><strong>清单的艺术：心理学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1mhZzJ9A" target="_blank" rel="noopener">荣格</a></th><th><a href="https://pan.baidu.com/s/1pLUQhWB" target="_blank" rel="noopener">阿德勒</a></th><th><a href="https://pan.baidu.com/s/1c1J1fGW" target="_blank" rel="noopener">陈鹤琴</a></th><th><a href="https://pan.baidu.com/s/1slNu2Yx" target="_blank" rel="noopener">弗洛姆</a></th><th><a href="https://pan.baidu.com/s/1dFlPrgP" target="_blank" rel="noopener">弗洛伊德</a></th><th><a href="https://pan.baidu.com/s/1gfnNcm3" target="_blank" rel="noopener">卡伦霍妮</a></th><th><a href="https://pan.baidu.com/s/1jIlFcSe" target="_blank" rel="noopener">拉康</a></th><th><a href="https://pan.baidu.com/s/1nu8tytF" target="_blank" rel="noopener">马斯洛</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1i5itxjB" target="_blank" rel="noopener">20世纪西方现代心理学</a></td><td><a href="https://pan.baidu.com/s/1gfbBQP9" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：社会学篇"><a href="#清单的艺术：社会学篇" class="headerlink" title="清单的艺术：社会学篇"></a><strong>清单的艺术：社会学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1nuLkAxj" target="_blank" rel="noopener">鲍德里亚</a></th><th><a href="https://pan.baidu.com/s/1qY619VY" target="_blank" rel="noopener">鲍曼</a></th><th><a href="https://pan.baidu.com/s/1qYoQIz6" target="_blank" rel="noopener">彼得·伯格</a></th><th><a href="https://pan.baidu.com/s/1kVnEWrd" target="_blank" rel="noopener">布迪厄</a></th><th><a href="https://pan.baidu.com/s/1mi1QckC" target="_blank" rel="noopener">迪尔凯姆</a></th><th><a href="https://pan.baidu.com/s/1i51qi5B" target="_blank" rel="noopener">福柯</a></th><th><a href="https://pan.baidu.com/s/1jIrKHXO" target="_blank" rel="noopener">福山</a></th><th><a href="https://pan.baidu.com/s/1nuQApOP" target="_blank" rel="noopener">格尔茨</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1gf5xYtP" target="_blank" rel="noopener">哈耶克</a></td><td><a href="https://pan.baidu.com/s/1dEOiHdZ" target="_blank" rel="noopener">吉登斯</a></td><td><a href="https://pan.baidu.com/s/1ca0kyi" target="_blank" rel="noopener">雷蒙.阿隆</a></td><td><a href="https://pan.baidu.com/s/1sll0HGh" target="_blank" rel="noopener">马克思.舍勒</a></td><td><a href="https://pan.baidu.com/s/1o7FIRpg" target="_blank" rel="noopener">马克思.韦伯</a></td><td><a href="https://pan.baidu.com/s/1nvUomzn" target="_blank" rel="noopener">曼海姆</a></td><td><a href="https://pan.baidu.com/s/1qY3dOug" target="_blank" rel="noopener">米德</a></td><td><a href="https://pan.baidu.com/s/1slT0muD" target="_blank" rel="noopener">西美尔</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1bo9ZC3X" target="_blank" rel="noopener">殷海光</a></td><td><a href="https://pan.baidu.com/s/1bpe1Q6j" target="_blank" rel="noopener">郑杭生</a></td><td><a href="https://pan.baidu.com/s/1i5H5nKx" target="_blank" rel="noopener">亚历山大</a></td><td><a href="https://pan.baidu.com/s/1o8wwnuq" target="_blank" rel="noopener">科塞</a></td><td><a href="https://pan.baidu.com/s/1kU8xxMR" target="_blank" rel="noopener">其他</a></td><td><a href="https://pan.baidu.com/s/1dE67NgP" target="_blank" rel="noopener">社会学家茶座</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：政治学篇"><a href="#清单的艺术：政治学篇" class="headerlink" title="清单的艺术：政治学篇"></a><strong>清单的艺术：政治学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1mhYdQgo" target="_blank" rel="noopener">德沃金</a></th><th><a href="https://pan.baidu.com/s/1pLDpo4j" target="_blank" rel="noopener">福山</a></th><th><a href="https://pan.baidu.com/s/1bBxD2e" target="_blank" rel="noopener">国际政治</a></th><th><a href="https://pan.baidu.com/s/1i4Oa91r" target="_blank" rel="noopener">哈贝马斯</a></th><th><a href="https://pan.baidu.com/s/1qYsUz3u" target="_blank" rel="noopener">哈耶克</a></th><th><a href="https://pan.baidu.com/s/1kVkrltX" target="_blank" rel="noopener">汉娜.阿伦特</a></th><th><a href="https://pan.baidu.com/s/1o7JgGOU" target="_blank" rel="noopener">亨廷顿</a></th><th><a href="https://pan.baidu.com/s/1o7PSsXG" target="_blank" rel="noopener">吉登斯</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1mi1kdmg" target="_blank" rel="noopener">刘军宁</a></td><td><a href="https://pan.baidu.com/s/1i4JqRKp" target="_blank" rel="noopener">刘瑜</a></td><td><a href="https://pan.baidu.com/s/1c1Bt7Uw" target="_blank" rel="noopener">卢梭</a></td><td><a href="https://pan.baidu.com/s/1pL7jCAv" target="_blank" rel="noopener">罗尔斯</a></td><td><a href="https://pan.baidu.com/s/1c2uELEg" target="_blank" rel="noopener">马克思.韦伯</a></td><td><a href="https://pan.baidu.com/s/1jIhBvCU" target="_blank" rel="noopener">秦晖</a></td><td><a href="https://pan.baidu.com/s/1nuFKUG5" target="_blank" rel="noopener">施特劳斯</a></td><td><a href="https://pan.baidu.com/s/1jH9f5jw" target="_blank" rel="noopener">汪晖</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1bpg3Kcv" target="_blank" rel="noopener">许纪霖</a></td><td><a href="https://pan.baidu.com/s/1bpg3Kcv" target="_blank" rel="noopener">以赛亚.伯林</a></td><td><a href="https://pan.baidu.com/s/1nuRqgFf" target="_blank" rel="noopener">政治法律社会</a></td><td><a href="https://pan.baidu.com/s/1qYgJfNA" target="_blank" rel="noopener">周保松</a></td><td><a href="https://pan.baidu.com/s/1nvR6vZr" target="_blank" rel="noopener">刘擎</a></td><td><a href="https://pan.baidu.com/s/1hsmzea4" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：人类学篇"><a href="#清单的艺术：人类学篇" class="headerlink" title="清单的艺术：人类学篇"></a><strong>清单的艺术：人类学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1kUTwlsr" target="_blank" rel="noopener">博厄斯</a></th><th><a href="https://pan.baidu.com/s/1c17VHao" target="_blank" rel="noopener">布迪厄</a></th><th><a href="https://pan.baidu.com/s/1eR3NWC6" target="_blank" rel="noopener">迪尔凯姆</a></th><th><a href="https://pan.baidu.com/s/1c2ffLJE" target="_blank" rel="noopener">格尔茨</a></th><th><a href="https://pan.baidu.com/s/1i58bLI1" target="_blank" rel="noopener">马林诺夫斯基</a></th><th><a href="https://pan.baidu.com/s/1o7PmrdK" target="_blank" rel="noopener">马塞尔·莫斯</a></th><th><a href="https://pan.baidu.com/s/1slSKpK5" target="_blank" rel="noopener">米德</a></th><th><a href="https://pan.baidu.com/s/1hr5fMRi" target="_blank" rel="noopener">普理查德</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1pLaF1Bd" target="_blank" rel="noopener">人物传记</a></td><td><a href="https://pan.baidu.com/s/1nuHMN6T" target="_blank" rel="noopener">萨林斯</a></td><td><a href="https://pan.baidu.com/s/1c2o9l76" target="_blank" rel="noopener">斯特劳斯</a></td><td><a href="https://pan.baidu.com/s/1hr4zPEs" target="_blank" rel="noopener">特纳</a></td><td><a href="https://pan.baidu.com/s/1gfB3Hr9" target="_blank" rel="noopener">王铭铭</a></td><td><a href="https://pan.baidu.com/s/1eSaXVP4" target="_blank" rel="noopener">庄孔韶</a></td><td><a href="https://pan.baidu.com/s/1c2FD8fI" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div><hr><h3 id="清单的艺术：经济学篇"><a href="#清单的艺术：经济学篇" class="headerlink" title="清单的艺术：经济学篇"></a><strong>清单的艺术：经济学篇</strong></h3><div class="table-container"><table><thead><tr><th><a href="https://pan.baidu.com/s/1mi5nRs8" target="_blank" rel="noopener">阿玛蒂亚.森</a></th><th><a href="https://pan.baidu.com/s/1pLedspX" target="_blank" rel="noopener">博弈论</a></th><th><a href="https://pan.baidu.com/s/1pLFXgyn" target="_blank" rel="noopener">布坎南</a></th><th><a href="https://pan.baidu.com/s/1nuSChr7" target="_blank" rel="noopener">丹尼尔·卡尼曼</a></th><th><a href="https://pan.baidu.com/s/1miN4JTQ" target="_blank" rel="noopener">周其仁</a></th><th><a href="https://pan.baidu.com/s/1nv7nBxn" target="_blank" rel="noopener">哈耶克</a></th><th><a href="https://pan.baidu.com/s/1sl4xEO1" target="_blank" rel="noopener">加里.贝克尔</a></th><th><a href="https://pan.baidu.com/s/1i55ZXWD" target="_blank" rel="noopener">卡尔·门格尔</a></th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1mhAxv0O" target="_blank" rel="noopener">科斯</a></td><td><a href="https://pan.baidu.com/s/1kU4ZEkB" target="_blank" rel="noopener">约瑟夫·阿罗</a></td><td><a href="https://pan.baidu.com/s/1dF8POIH" target="_blank" rel="noopener">茅于轼</a></td><td><a href="https://pan.baidu.com/s/1dEYYdxR" target="_blank" rel="noopener">米尔顿.弗里德曼</a></td><td><a href="https://pan.baidu.com/s/1jI1UdJw" target="_blank" rel="noopener">米塞斯</a></td><td><a href="https://pan.baidu.com/s/1pLn6Pv1" target="_blank" rel="noopener">庞巴维克</a></td><td><a href="https://pan.baidu.com/s/1mhI4Pja" target="_blank" rel="noopener">钱颖一</a></td><td><a href="https://pan.baidu.com/s/1i4BjsB7" target="_blank" rel="noopener">斯蒂格勒</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1c2k5wPy" target="_blank" rel="noopener">斯蒂格利茨</a></td><td><a href="https://pan.baidu.com/s/1pLHsWaB" target="_blank" rel="noopener">托马斯·谢林</a></td><td><a href="https://pan.baidu.com/s/1eSD78kE" target="_blank" rel="noopener">汪丁丁</a></td><td><a href="https://pan.baidu.com/s/1skAnhIt" target="_blank" rel="noopener">韦森</a></td><td><a href="https://pan.baidu.com/s/1hso0X3A" target="_blank" rel="noopener">行为经济学</a></td><td><a href="https://pan.baidu.com/s/1o8IbbnW" target="_blank" rel="noopener">张维迎</a></td><td><a href="https://pan.baidu.com/s/1bp0MypL" target="_blank" rel="noopener">张五常</a></td><td><a href="https://pan.baidu.com/s/1jIKlbLk" target="_blank" rel="noopener">新制度经济学</a></td></tr><tr><td><a href="https://pan.baidu.com/s/1b1oqmE" target="_blank" rel="noopener">当代世界十大经济学派丛书</a></td><td><a href="https://pan.baidu.com/s/1slE7eMx" target="_blank" rel="noopener">其他</a></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我本科实习期间利用闲暇时间整理出来的一系列清单，包含涉及人文社科各个学科的经典书籍。&lt;/p&gt;
&lt;p&gt;我有很多渴望，而这其中尤为让我感受到歌德所说的“静谧的激情”的是这样一种渴望。我渴望深入人类文明最澄明精要的思想脉络，渴望与人类历史上最迷人的灵魂相伴，渴望在漫长的岁月中被这些浪漫的精神“缠绕”，而我相信，它们留下的书，正是我们通向这种渴望的路途中最朴实的一条。这份清单正是始于这种渴望，我期许通过它们去谋合我对文字的控制欲以及统领知识的野心，形成人文社科的阅读图景与思想路径，依循这条规定好的路径，边走边想，争取到那半点光辉。&lt;/p&gt;
    
    </summary>
    
      <category term="读书记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>日知录（3）：心理账户</title>
    <link href="http://yoursite.com/2017/12/12/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%883%EF%BC%89%EF%BC%9A%E5%BF%83%E7%90%86%E8%B4%A6%E6%88%B7/"/>
    <id>http://yoursite.com/2017/12/12/日知录（3）：心理账户/</id>
    <published>2017-12-12T15:14:45.000Z</published>
    <updated>2018-11-05T16:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2002年10月9日，瑞典皇家科学院将诺贝尔经济学奖授予普林斯顿大学心理学教授DannielKahneman和乔治·梅森大学经济学教授VernonSmith。根据瑞典皇家科学院的新闻公报，卡尼曼“将心理学的深入分析融入到了经济学中，从而为一个崭新的经济学研究领域奠定了基础”。1981年，DannielKahneman及其合作者AmosTversky在《科学》杂志发表论文，研究人们决策过程的认知心理规律。文章介绍了“演出实验”</p><a id="more"></a><ul><li>【实验情境A】：你打算去剧院看一场演出，票价是10美元，在你到达剧院的时候，发现自己丢了一张10美元的钞票。你是否会买票看演出？实验表明：88%的调查对象选择会；12%的调查对象选择不会。（调查对象为183人）</li><li>【实验情境B】：你打算去看一场演出而且花10美元钱买了一张票。在你到达剧院的时候，发现门票丢了。如果你想看演出，必须再花10美元，你是否会买票？实验结果表明：46%的调查对象选择会，54%的调查对象不会。（调查对象为200人）</li></ul><p>Kahneman和Tversky认为:两种实验情境出现明显不同结果的原因在于:在考虑情境A的决策结果时，人们把丢失的10美元钞票和买演出票的10美元分别考虑；而在情境B中，则把已经购买演出票的钱和后来买票的钱放在同一个账户估价，一部分人觉得“太贵了”改变自己的选择。为此，Kahneman和Tversky引入理查德·萨勒教授（RichardThaler）提出的“心理账户”概念，对实验结果进行了深入的分析。</p><h2 id="一、概念发展"><a href="#一、概念发展" class="headerlink" title="一、概念发展"></a>一、概念发展</h2><h3 id="1-1-理查德·萨勒"><a href="#1-1-理查德·萨勒" class="headerlink" title="1.1 理查德·萨勒"></a>1.1 理查德·萨勒</h3><p>1980年，芝加哥大学著名行为金融和行为经济学家理查德·萨勒（RichardThaler）首次提出“Psychic Accounting（心理账户）”概念，用于解释个体在消费决策时为什么会受到“沉没成本效应（sunk cost effert）”的影响。萨勒认为：人们在消费行为中之所以受到“沉没成本”的影响，一个可能的解释是卡尼曼教授等提出的“前景理论”，另一个可能的解释就是推测个体潜意识中存在的“心理账户系统”（Psychic Accounting system）。人们在消费决策时把过去的投入和现在的付出加在一起作为总成本，来衡量决策的后果。这种对金钱分门别类的分账管理和预算的心理过程就是“心理账户”的估价过程。</p><h3 id="1-2-丹尼尔·卡尼曼"><a href="#1-2-丹尼尔·卡尼曼" class="headerlink" title="1.2 丹尼尔·卡尼曼"></a>1.2 丹尼尔·卡尼曼</h3><p>1981年，丹尼尔·卡尼曼和特韦尔斯基(Amos Tversky)在对“演出实验”的分析中使用“Psychological Account(心理账户)”概念，表明消费者在决策时根据不同的决策任务形成相应的心理账户。卡尼曼认为，心理账户是人们在心理上对结果(尤其是经济结果)的分类记账、编码、估价和预算等过程。</p><p>1984年，卡尼曼教授和特韦尔斯基教授认为“心理账户”概念用“mental account”表达更贴切。卡尼曼认为:人们在做出选择时，实际上就是对多种选择结果进行估价的过程。究竟如何估价，最简单也最基本的估价方式就是把选择结果进行获益与损失(得失)的评价。因此，他提出了“值函数”假设和“决策权重”函数来解释人们内在的得失评价机制。</p><h3 id="1-3-理查德·萨勒"><a href="#1-3-理查德·萨勒" class="headerlink" title="1.3 理查德·萨勒"></a>1.3 理查德·萨勒</h3><p>1985年，萨勒教授发表“心理账户与消费者行为选择”一文，正式提出“心理账户”理论，系统地分析了心理账户现象，以及心理账户如何导致个体违背最简单的经济规律。萨勒认为:小到个体、家庭，大到企业集团，都有或明确或潜在的心理账户系统。在作经济决策时，这种心理账户系统常常遵循一种与经济学的运算规律相矛盾的潜在心理运算规则，其心理记账方式与经济学和数学的运算方式都不相同。因此经常以非预期的方式影响着决策，使个体的决策违背最简单的理性经济法则。萨勒列举了4个典型现象阐明心理账户对传统经济规律的违背，并提出了心理账户的“非替代性”特征。</p><h3 id="1-4-特韦尔斯基"><a href="#1-4-特韦尔斯基" class="headerlink" title="1.4 特韦尔斯基"></a>1.4 特韦尔斯基</h3><p>1996年Tversky提出，心理账户是一种认知幻觉，这种认知幻觉影响金融市场的投资者，使投资者们失去对价格的理性关注，从而产生非理性投资行为。Kivetz(1999)认为，心理账户是人们根据财富的来源不同进行编码和归类的心理过程，在这一编码和分类过程中“重要性-非重要性”是人们考虑的一个维度。有学者从行为的角度对“心理账户”进行定义，认为心理账户是个人或家庭用来管理、评估和记录经济活动的一套认知操作系统，这套认知操作系统导致一系列非理性的“心理账户”决策误区。</p><h3 id="1-5-理查德·萨勒"><a href="#1-5-理查德·萨勒" class="headerlink" title="1.5 理查德·萨勒"></a>1.5 理查德·萨勒</h3><p>1999年，萨勒发表“mental accounting matters”一文，这是对近20年“心理账户”研究的一个总结。在文章中，萨勒认为:心理账户的三个部分最受关注，首先是对于决策结果的感知以及决策结果的制定及评价，心理账户系统提供了决策前后的损失——获益分析;第二个部分涉及特定账户的分类活动，资金根据来源和支出划分成不同的类别(住房、食物等)，消费有时要受制于明确或不明确的特定账户的预算;第三个部分涉及账户评估频率和选择框架，账户可以是以每天、每周或每年的频率进行权衡，时间限定可宽可窄。因此，“心理账户”是人们在心理上对结果(尤其是经济结果)的编码、分类和估价的过程，它揭示了人们在进行(资金)财富决策时的心理认知过程。</p><h2 id="二、心理账户的非替代性（non-fungibility）"><a href="#二、心理账户的非替代性（non-fungibility）" class="headerlink" title="二、心理账户的非替代性（non-fungibility）"></a>二、心理账户的非替代性（non-fungibility）</h2><p>按照传统的微观经济学理论，金钱不会被贴上标签，它具有替代性(fungibility)，事实上，越来越多的实证研究表明:</p><blockquote><p>人们并不是把所有的财富放在一个整体账户进行管理，每一元钱与每一元钱可以很好的替换与转移。相反，人们根据财富来源与支出划分成不同性质的多个分账户，每个分账户有单独的预算和支配规则，金钱并不能容易地从一个账户转移到另一个账户。</p></blockquote><p>萨勒将这种金钱不能很好转移，不能完全替换的特点称之为“非替代性”。萨勒教授在研究中发现金钱非替代性的一些表现:</p><ol><li>【不同来源】：由不同来源的财富而设立的心理账户之间具有非替代性，例如意外之财和辛苦得来的钱不具替代性。一般来说，人们会把辛苦挣来的钱存起来不舍得花，而如果是一笔意外之财，可能很快就花掉。</li><li>【不同消费项目】：不同消费项目而设立的心理账户之间具有非替代性。我们来看一个案例:王先生非常中意商场的一件羊毛衫，价格为1250元，他觉得贵而舍不得买。月底的时候他妻子买下羊毛衫作为生日礼物送给他，他非常开心。尽管王先生的钱和他的妻子的钱是同一家庭的钱，为什么同样的钱以不同的理由开支心理感觉不同?研究表明:自己花费购买羊毛衫，属于生活必需开支，1250元太贵了;而作为生日礼物送给丈夫，属于情感开支。因此人们欣然接受昂贵的礼品却未必自己去买昂贵的物品。可见，为不同的消费项目设立的心理账户之间具有非替代性。</li><li>【不同存储方式】：不同存储方式导致心理账户的非替代性。萨勒教授举的一个实例。约翰先生一家存了15000美元准备买一栋理想的别墅，他们计划在5年以后购买，这笔钱放在商业账户上的利率是10%;可最近他们刚刚贷款11000美元买了一部新车，新车贷款3年的利率是15%，为什么他不用自己的15000美元存款买新车呢?通常，人们对已经有了预定开支项目的金钱，不愿意由于临时开支挪用这笔钱，对这个家庭来说，存起来买房的钱，已经放在了购房这一预定账户上，如果另外一项开支(买车)挪用了这笔钱，这笔钱就不存在了。从理性上说，家庭的总财富不变。但因为财富改变了存放的位置，固定账户和临时账户具有非替代性，人们的心理感觉不一样。</li></ol><h2 id="三、心理账户的运算规则"><a href="#三、心理账户的运算规则" class="headerlink" title="三、心理账户的运算规则"></a>三、心理账户的运算规则</h2><p>在日常经济活动中，人们是如何操纵和管理心理账户，这些经济交易在人们心里是如何评估和被体验的呢?萨勒认为:人们在进行各个账户的心理运算时，实际上就是对各种选择的损失-获益进行估价，称之为“得与失的构架(the framing of gains and losses)”，人们在心理运算的过程中并不是追求理性认知上的效用最大化，而是追求情感上的满意最大化。</p><p>情感体验在人们的现实决策中起着重要的作用，他将这种运算称之为“享乐主义的加工”（hedonic editing）</p><h3 id="3-1-值函数的假设"><a href="#3-1-值函数的假设" class="headerlink" title="3.1 值函数的假设"></a>3.1 值函数的假设</h3><p>为了更好地探讨心理账户的价值运算如何影响人们的经济决策行为，卡尼曼教授在“前景理论”中提出了“值函数”(value function)这一概念。与以往经济理论中的“效用函数”(utility function)相比，值函数有三个重要的特征。</p><ol><li>值函数是人们在决策行为时对于某个参照点的相对得失的详细说明，人们的“得与失”是个相对概念而不是期望效用理论的绝对概念。人们对某一决策结果的主观判断是相对于某个自然参照点而言，而不是绝对的财富或经济。因此，参照点的变化会引起人们主观估价的变化，人们更关注的是围绕参照点引起的改变而不是绝对水平。</li><li>“得与失”都表现出敏感性递减的规律。值函数的曲线是一条近似“S”形的曲线，右上角的盈利曲线为下凹形(concave)，左下角的亏损曲线为上凸形(convex)(如图所示)。离参照点(坐标交叉的原点)愈近的差额人们愈加敏感，越是远离参照点的差额越不敏感。因此，不管是获得还是损失，人们感觉到10元到20元的差额似乎比1000元到1010元的差额更大，这反映了价值曲线的边际递减特征。</li><li>损失规避。卡尼曼教授认为:同等数量的损失比获益对人的影响更大，因此在决策的时候人们尽量回避损失，表现在价值函数曲线上，损失曲线的斜率比获益曲线的斜率更大(如图1所示)，用公式表示为V(X)&lt;-V(-X)。例如损失1000元钱所带来的痛苦比获得1000元奖金而带来的愉悦更强烈。因此，面临损失时，人们是风险偏好的;面临获得时，人们是风险规避的。</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnb7se4oj30fy0fsjrh.jpg" alt=""></p><p>由于值函数的三个典型特征，对心理账户的运算规则至少有三个启示:</p><ol><li>相同的决策结果表述为损失或者获益会改变人们的风险决策偏好;</li><li>设计不同的参照点会改变人们对决策结果的认知;</li><li>同样的价格差额在不同的原始价格下，影响作用是不同的。</li></ol><h3 id="3-2-得与失的编码规则"><a href="#3-2-得与失的编码规则" class="headerlink" title="3.2 得与失的编码规则"></a>3.2 得与失的编码规则</h3><p>根据上述值函数的特点，萨勒在关于心理账户的研究中，将值函数在得与失的不同组合结果中的偏好情况作了分析。</p><blockquote><p>规则一：两笔盈利应分开</p></blockquote><p>假如两笔收入X、Y均为正，分开价值为$V(X)+V(Y)$，整合值为$V(X+Y)$。因价值曲线在右上角为凸形，所以$V(X)+V(Y)&gt;V(X+Y)$，个体更偏好分开体验(如图)。假如想送朋友两件礼物——一套衣服和一个健身器，最好分两次送。每次送一件礼物所带来的心理体验比一次送两件礼物的心理体验高。</p><blockquote><p>规则二：两笔损失应整合</p></blockquote><p>两笔支出对个体而言是“损失”，因价值曲线在左下角为凹形，所以$V(-X)+V(-Y)&lt;V(-X-Y)$，个体更偏好整合价值。这一规律可以解释生活中的很多现象，比如开会收取会务费时，最好一次收齐并留有余地，若有额外开支一次次增收，虽然数量不多，会员仍会牢骚满腹。</p><blockquote><p>规则三:大得小失应整合</p></blockquote><p>两笔收入一正一负:X，-Y，且余额为正，即$X&gt;Y$，从价值曲线看应是$V(X)+V(-Y)&lt;V(X-Y)$，所以人们更偏好整合。这条规则给人们的启示是，如果你有一个大的好消息和一个小的坏消息，应该把这两个消息一起告诉别人。如此整合，坏消息带来的痛苦会被好消息带来的快乐所冲淡，负面效应也就小得多。</p><blockquote><p>规则四:小得大失应具体分析</p></blockquote><p>两笔收入一正一负:X，-Y，且余额为负，即X&lt;Y，此时应分两种情况:</p><p>其一，小得大失且悬殊很大，应分开估价。从图中看出$V(X)+V(-Y)&gt;V(X-Y)$，因此，分开估价的心理体验要好，这种现象称为“银衬里(silver lining)”规则。例如(40，-6000)，人们更愿意分开估价，因为价值曲线在-6000元附近相对较平缓，40元的获得与6000元的损失相比几乎没有减少损失的作用，分开估价还能得到40元收益的感觉。</p><p>其二，小得大失且悬殊不大，应整合。如(40，-50)，人们更偏好整合价值。表现为$V(X-Y)&gt;V(X)+V(-Y)$。整合估价时，人们在心理会把损失从50元降低到10元，这样的损失就显得小了，心理体验更好，整合估价的作用体现出来。</p><p>萨勒进一步把这四条规则概括为:</p><ol><li>分离收益;</li><li>整合损失;</li><li>把小损失与大收益整合一起;</li><li>把小收益从大损失中分离出来。</li></ol><p>以上心理账户的运算规则对于理解和解释现实经济决策行为有重要的指导意义。</p><h2 id="四、应用研究"><a href="#四、应用研究" class="headerlink" title="四、应用研究"></a>四、应用研究</h2><h3 id="4-1-价格感知——绝对值优惠与相对值优惠"><a href="#4-1-价格感知——绝对值优惠与相对值优惠" class="headerlink" title="4.1 价格感知——绝对值优惠与相对值优惠"></a>4.1 价格感知——绝对值优惠与相对值优惠</h3><p>1982年，特维尔斯基教授和卡尼曼教授通过设计以下情景实验引入“心理账户”与消费者购买决策行为的研究。</p><ul><li>【实验情景A】:假定你要买一件夹克和一个计算器。在某商场夹克的价格是125美元，计算器的价格是15美元。这时候有人告诉你，开车二十分钟后另一个街区的一家商场计算器的价格是10美元。请问:你会去另一个商场买计算器吗?</li><li>【实验情景B】:假定你要买一件夹克和一个计算器。在某商场夹克的价格是15美元，计算器的价格是125美元。这时候有人告诉你，开车二十分钟后另一个街区的一家商场计算器的价格是120美元。请问:你会去另一个商场买计算器吗?</li></ul><p>在这两个情境中，其实都是对“是否开车20分钟从140美元的总购物款中节省5美元”做出选择。然而，实验对象在两个情境中的回答却不一样。在情境A中，68%的实验对象选择去另一家商场;而在情境B中，只有29%的实验对象选择开车去另一家商场。选择偏好发生了逆转。</p><p>卡尼曼提出，消费者在感知价格的时候，是从三个不同的心理账户进行得失评价的。一个是最小账户(minimal account)，就是不同方案所优惠的绝对值。在本实验中的最小账户就是5美元。另一个是局部账户(topical account)，也可称为相对值账户。例如，在实验情境A中开车前往另一家店的“局部账户”表现为计算器价格从15美元降为10美元(相对差额为1/3);而在实验情境B中的“局部账户”表现为计算器价格从125美元降为120美元(相对差额为1/25)。第三个是综合账户(comprehensive account)，综合账户就是总消费账户，该实验的综合账户为140美元。</p><p>卡尼曼认为，在上面的实验中，消费者是自发运用了局部账户，即通过相对优惠值来感知价格。情境A有33.3%的优惠;而情境B仅有4%的优惠。因此，人们的购买行为发生了反转。表现为在实验情境A中，68%的实验对象选择去另一家商场;而在实验情境B中，却只有29%。</p><p>此后，Philip Moon,Kevin Keasey,Darren Duxbury对卡尼曼的研究进行了重复实验并且提出，当优惠超过某个阈限值的时候，消费者对绝对优惠值同样非常敏感。绝对值优惠与相对值优惠之间存在一种关系。</p><h3 id="4-2-行为生命周期理论——心理账户在消费领域的应用"><a href="#4-2-行为生命周期理论——心理账户在消费领域的应用" class="headerlink" title="4.2 行为生命周期理论——心理账户在消费领域的应用"></a>4.2 行为生命周期理论——心理账户在消费领域的应用</h3><p>经典的生命周期假说和持久收入假说是凯恩斯以后消费函数理论最重要的发展，但他们的理论是建立在完全理性人的假设之上的。例如，生命周期假说就认为:人总是能够深谋远虑，在任何时候都会考虑几十年以后的长远利益，并站在这种高度，根据一生的总财富来合理安排一生中每个阶段的消费，使一生的总效用达到最大。这显然和人们实际的消费行为不符，这种过于理性化的理论也无法解释现实中的许多经济现象。</p><p>1988年Shefrin和Thaler提出行为生命周期理论(behavior life cycle hypothesis)修正了传统的生命周期假说，使之能更好地描述现实中人们的消费行为。行为生命周期理论的两个最重要的概念是自我控制和心理账户。</p><p>行为生命周期理论引入“心理账户”理论解释消费行为。消费者根据生命周期不同财富的来源和形式，将它们划分为三个心理账户:现期可花费的现金收入账户(I)，现期资产账户(A)和未来收入账户(F)。行为生命周期理论认为:不同账户的财富对消费者的决策行为是不同的。现金收入账户消费的诱惑力最大，因此，将这个账户的收入不消费而储蓄起来的心理成本也最大;现期资产账户的诱惑力和储蓄的心理成本居中;未来收入账户的诱惑力和储蓄的心理成本最小。由于不同的心理账户对消费者的诱惑不同，所以，消费者倾向于较多地通过现金收入账户消费，而较少通过现期资产账户消费，几乎不通过未来收入账户消费。不仅不同的心理账户对消费者的诱惑是不同的，而且同一个心理账户，其中的财富余额不同，对消费者的诱惑也不同。财富余额越多，诱惑越大。</p><p>行为生命周期理论的消费函数可表示为$C=f(I,A,F)$，且有:$1≈C/I&gt;C/A&gt;C/F≈0$。这就是说，现金收入账户的边际消费倾向最大，接近于1;现期资产账户次之;未来收入账户最小，接近0。和生命周期持久收入假说的消费函数相比，行为生命周期理论在分析消费者行为时强调的是心理方面的因素，这些心理因素主要是通过心理账户加以描述。所以，心理账户的划分及其性质是理解行为生命周期理论的关键。</p><h3 id="4-3-关于消费预算的研究"><a href="#4-3-关于消费预算的研究" class="headerlink" title="4.3 关于消费预算的研究"></a>4.3 关于消费预算的研究</h3><p>1994年Heath和Soll发现，消费者有为不同的消费支出账户设置心理预算的倾向，并且严格控制该项目支出不超过合适的预算。例如，每个月的娱乐支出300元，每个月的日常餐饮消费1000元等。如果一段时间购买同一支出项目的总消费额超过了预算，人们会停止购买该类产品。即使在同一个消费项目中，不同的消费有不同的预算标准，同是娱乐消费，看电影的消费是200元人民币，买一本武打小说的消费是50元人民币。他们通过实验证明:人们当前在某一类项目的消费支出会减少他们未来在同一类项目的支出，而对其他项目的支出几乎没有什么影响。这是心理账户对每个消费项目会设定一个预算控制。</p><p>1996年，Chip和Soll研究认为，心理账户通过心理预算调节人们的消费行为。表现在:人们会为不同的消费设置预算，但预算通常会低估或者高估购买特定商品的价格，因此常使人们产生“穷鬼”和“大富翁”的认知错觉，从而出现消费不足和过度消费的消费误区。他们通过三个实验证明了心理账户的分类预算对消费决策的重要作用。</p><p>2006年，EldarShafir和RichardThaler发表Investnow,drinklater,spendnever一文，研究表明:在购买和消费暂时分离的商品交易中，人们会建构多种框架的心理账户。奢侈品的购买更多的被认为是一种“投资”而不是一种消费，因此，当消费很早以前购买的高档产品时，通常被编码为“免费”的或者是储蓄。但如果消费方式不是按原意愿进行时，对该产品的消费预算就会发挥作用。</p><h3 id="4-4-行为资产组合理论（BPT）——心理账户在金融投资领域的应用"><a href="#4-4-行为资产组合理论（BPT）——心理账户在金融投资领域的应用" class="headerlink" title="4.4 行为资产组合理论（BPT）——心理账户在金融投资领域的应用"></a>4.4 行为资产组合理论（BPT）——心理账户在金融投资领域的应用</h3><p>心理账户在金融投资决策领域最广泛的应用是投资组合结构的运用。根据理性投资组合理论，投资者应该只关心他们投资组合的期望收益，而不应该关注某个特定投资部分的收益。可事实相反，投资者倾向于把他们的资金分成安全账户(保障他们的财富水平)和风险账户(试图作风险投机的买卖)。</p><p>1997 年 Fisher 和 Statman 提出:人们在投资时会把 资金分别放在不同的投资账户中，即使是基金公司 也建议投资者建立一个资产投资的金字塔，把现金放在金字塔的最低层，把基金放在中间层，把股票放在金字塔的最高层。2000年，Shefrin和Statman提出了行为资产组合理论（Behavioral portfolio theory，BPT-MA）下图就是一个典型的分层金字塔结构，从底端到顶端是按照其风险程度由低到高排列的，从右到左是按其收入价值由低到高 的顺序排列[14]。模型中的每层是根据安全性、潜力 性和期望值这三者相关的投资需求设计的。底层是 为投资者提供安全性而设计的证券，包括货币市场 基金和银行存款保证，上一层是债券，再上一层是 股票和房地产。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxnbgcdxqj30fc0bq0t4.jpg" alt=""></p><p>在行为金融理论中，行为投资组合理论是建立 在卡尼曼和特维尔斯基的前景理论之上的一个框架 体系。它认为投资者的资产结构应该是金字塔式的 分层结构(这里的层就是心理账户)，投资者对其 资产分层进行管理，每一层对应投资者的一个目标。 底层是投资者为避免贫穷而设立的，所以，其投资 对象通常是短期国债、大额可转让存单、货币市场 基金等有稳定收益、风险小的证券;高层是为使其 富有而设立的，其投资对象通常是外国股票、成长 性股票、彩票等高风险、高收益证券。Shefrin 和 Statman 设计了投资者只有一个心理账户和两个心 理账户的行为资产组合模型，并给出了模型的最优 解。当投资者有两个心理账户时，他们分别在低期 望水平和高期望水平两个心理账户建立投资模型， 并在两个账户之间分配资金。</p><p>此外，巴比雷斯和黄明(Barberis and Ming Huang)于 2001 年发表了题为“心理账户、损失规 避与个股回报”的论文，提出了一个较为完整的、 具体的刻画投资者心态的投资模型。并研究了在 两种心理账户下公司股票的均衡回报:一种是投资 者只对所持有的个股价格波动损失规避;另一种是 投资者对所持有的证券组合价格波动损失规避。该 模型在结合心理学、信息学和社会学研究成果的基 础上，对投资者与外部信息之间的互动关系做了崭 新的诠释，对投资者的心态及其决策过程做了具体 的刻画。为人们对投资决策的研究和资产定价的研 究提供了新的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2002年10月9日，瑞典皇家科学院将诺贝尔经济学奖授予普林斯顿大学心理学教授DannielKahneman和乔治·梅森大学经济学教授VernonSmith。根据瑞典皇家科学院的新闻公报，卡尼曼“将心理学的深入分析融入到了经济学中，从而为一个崭新的经济学研究领域奠定了基础”。1981年，DannielKahneman及其合作者AmosTversky在《科学》杂志发表论文，研究人们决策过程的认知心理规律。文章介绍了“演出实验”&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="卡尼曼" scheme="http://yoursite.com/tags/%E5%8D%A1%E5%B0%BC%E6%9B%BC/"/>
    
      <category term="行为经济学" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
      <category term="心理账户" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E8%B4%A6%E6%88%B7/"/>
    
      <category term="理查德·萨勒" scheme="http://yoursite.com/tags/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%90%A8%E5%8B%92/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（1）：词向量和语言模型</title>
    <link href="http://yoursite.com/2017/12/10/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%8D%E5%90%91%E9%87%8F%E5%92%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/12/10/自然语言处理系列（1）：词向量和语言模型/</id>
    <published>2017-12-10T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://licstar.net/archives/328#comment-1630" target="_blank" rel="noopener">LICSTAR的博客</a></p><p>这篇博客是我看了半年的论文后，自己对Deep Learnimng在NLP领域中应用的理解和总结，在此分享。其中必然有局限性，欢迎各种交流，随便拍。</p><a id="more"></a><p>Deep Learning算法已经在图像和音频领域取得了惊人的成果，但是在NLP领域中尚未见到如此激动人心的结果。关于这个原因，引一条我比较赞同的微博。</p><blockquote><p>@王威廉：Steve Renals算了以下icassp录取文章题目中包含deep learning 的数量，发现有44偏，而naacl则有0篇。有一种说法是，语言（词、句子、篇章等）属于人类认知过程中产生的高层认知抽象实体，而语言和图像属于较为底层的原始输入信号，所以后两者更适合做deep learning来学习特征。</p></blockquote><p>第一句就先不用管了，毕竟今年的 ACL 已经被灌了好多 Deep Learning 的论文了。第二句我很认同，不过我也有信心以后一定有人能挖掘出语言这种高层次抽象中的本质。不论最后这种方法是不是 Deep Learning，就目前而言，Deep Learning 在 NLP 领域中的研究已经将高深莫测的人类语言撕开了一层神秘的面纱。</p><p>我觉得其中最有趣也是最基本的，就是“词向量”了。</p><p>将词用“词向量”的方式表示可谓是将 Deep Learning 算法引入 NLP 领域的一个核心技术。大多数宣称用了 Deep Learning 的论文，其中往往也用了词向量。</p><h2 id="一、词向量是什么？"><a href="#一、词向量是什么？" class="headerlink" title="一、词向量是什么？"></a>一、词向量是什么？</h2><p>自然语言理解的问题要转化为机器学习的问题，第一步肯定是要找一种方法把这些符号数学化。</p><p>NLP中最直观，也是到目前为止最常用的词表示方法是One-Hot Representation，这种方法把没歌词表示为一个很长的向量，这个向量的维度是词表大小，其中绝大多数元素为0，只有一个维度的值为1，这个维度就代表了当前的词。</p><p>举个例子：</p><p>“话筒”表示为[0 0 0 1 0 0 0  0 0 0 0  0 0 0 0····]<br>“麦克”表示为[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0·····]<br>每个词都是茫茫0海中的一个1。</p><p>这种One-Hot Representation如果采用稀疏方式存储，会是非常的简介：也就是给每个词分配一个数字ID。比如刚才的例子中，话筒记为3，麦克记为8（假设从0开始记）。如果要编程实现的话，用Hash表给每个词分配一个编号就可以了。这么简洁的表示方式配合上最大熵、SVM、CRF等等算法已经很好地完成了NLP领域的各种主流任务。</p><p>当然这种表示方法也存在一个重要的问题就是“词汇鸿沟”现象：任意两个词之间都是孤立的。光从这俩个向量中看不出两个词是否有关系，哪怕是话筒和麦克这样的同义词也不能幸免于难。</p><p>Deep Learning中一般用到的词向量并不是刚才提到的用One-Hot Representation表示的那种很长很长的词向量，而是用Distrubuted Representation（不知道这个该怎么翻译，因为还存在一种叫“Distributional Representation”的表示方法，又是另一个不同的概念）表示的一种低维实数向量、这种向量一般长这个样子：[0.792,-0.177,-0.107,0.109,-0.542,…]。维度以50维和100维比较常见。这种向量的表示不是唯一的，后文会提到目前计算这种向量的主流方法。</p><p>（个人认为）DIstributed representation最大的贡献是让相关或者相似的词，在距离上更接近了。向量的距离可以用最传统的欧氏距离来衡量，也可以用cos夹角来衡量。用这种方式表示的向量，“麦克”和“话筒”的距离会远远小于“麦克”和“天气”。可能理想情况下“麦克”和“话筒”的表示应该是完全一样的，但是由于有些人会把英文名“迈克”也写成“麦克”，导致“麦克”一词带上了一些人名和语义，因此不会和“话筒”完全一致。</p><h2 id="二、词向量的来历"><a href="#二、词向量的来历" class="headerlink" title="二、词向量的来历"></a>二、词向量的来历</h2><p>Distributed representation最早是Hinton在1986年的论文《Learning distributed representation of concepts》中提出的。虽然这篇文章没有说要将词做Distributed representation，（甚至我很无厘头地猜想那篇文章是为了给他刚提出的BP网络打广告）但至少这种先进的思想在那个时候就在人们的心中埋下了火种，到2000年之后开始逐渐被人重视。</p><p>Distributed representation用来表示词，通常被称为“Word Representation”或“Word Embedding”，中文俗称“词向量”。这的只能叫俗称，算不上翻译。半年前我本想翻译的，但是硬是想不出Embedding应该怎么翻译的，后来就这么叫习惯了，如果有好的翻译欢迎提出。（更新：@南大周志华给出了一个合适的翻译：词嵌入）Embedding一次的意义可以参考维基百科的相应页面。后文提到的所有“词向量”都是指用Distributed Representation表示的词向量。</p><p>如果用传统的稀疏表示法表示词，在解决某些任务的时候（比如构建语言模型）会造成维数灾难[Bengio 2003]。使用低维的词向量就没这样的问题。同时从实践上看，高维的特征如果要套用Deep Learning，其复杂度几乎是难以接受的，因此低维的词向量在这里也饱受追捧。</p><p>同时如上一节提到的，相似词的词向量距离相近，这就让基于词向量设计的一些模型自带平滑功能，让模型看起来非常的漂亮。</p><h2 id="三、词向量的训练"><a href="#三、词向量的训练" class="headerlink" title="三、词向量的训练"></a>三、词向量的训练</h2><p>要介绍词向量是怎么训练的到的，就不得不提到语言模型。到目前为止我了解到的所有训练方法都是在训练语言模型的同时，顺便得到词向量的。</p><p>这也比较容易理解，要从一段无标注的自然文本中学习出一些东西，无非就是统计出词频、词的共现、词的搭配之类的信息。而要从自然文本中统计并建立一个语言模型，无疑是要求最为精确的一个任务（也不排除以后有人创造出更好更有用的方法）。既然构建语言模型这一任务要求这么高，其中必然也需要对语言进行更精细的统计和分析，同时也会需要更好的模型，更大的数据来支撑。目前最好的词向量都来自于此，也就不难理解了。</p><p>这里介绍的工作均为从大量未标注的普通文本数据中无监督地学习出词向量（语言模型本来就是基于这个想法而来的），可以猜测，如果用上了有标注的语料，训练词向量的方法肯定会更多。不过视目前的语料规模，还是使用未标注的方法靠谱一些。</p><p>词向量的训练最经典的有三个工作，C&amp;W 2008、M&amp;H 2008、Mikolov 2010。当然在说这些工作之前，不得不介绍一下这一系列中Bengio的经典之作。</p><h3 id="3-1-语言模型简介"><a href="#3-1-语言模型简介" class="headerlink" title="3.1 语言模型简介"></a>3.1 语言模型简介</h3><p>语言模型其实就是看一句话是不是正常人说出来的。这玩意儿很有用，比如机器翻译、语音识别得到若干候选之后，可以利用语言模型挑一个尽量靠谱的结果。在NLP的其他任务里也都能用到。</p><p>语言模型形式化的描述就是给定一个字符串，看它是自然语言的概率$P(w_1,w_2,···,w_t)$。$w_1$到$w_t$依次表示这句话中的各个词。有个很简单的推论是$P(w_1,w_2,…,w_t)=P(w_1)✖️P(w_2|w_1)✖️P(w_3|w_1,w_2)✖️…✖️P(w_t|w_1,w_2,…w_{t-1})$</p><p>常用的语言模型都是在近似地求$P(w_t|w_1,w_2,···,w_{t-1})$，比如$n-gram$模型就是用$P(w_t|w_{t-n+1},…,w_{t-1})$近似表示前者。</p><p>顺便提一句，由于后面要接受煎熬的每篇论文使用的符号差异太大，本博文尝试统一使用Bengio 2003的符号系统（略作简化），以便在各方法之间做对比和分析。</p><h3 id="3-2-Bengio的经典之作"><a href="#3-2-Bengio的经典之作" class="headerlink" title="3.2 Bengio的经典之作"></a>3.2 Bengio的经典之作</h3><p>用神经网络训练语言模型的思想最早由百度IDL的徐伟于2000提出。其论文《Can Artificial Neural Networks Learn Language Model？》提出一种用神经网络构建二元语言模型（即$P(w_t|w_{t-1})$）的方法。文中的基本思路和后续的语言模型的差别已经不大了。</p><p>训练语言模型的最经典之作，要数Bengio等人在2001年发表在NIPS上的文章《A Neural Probabilistic Language Model》。当然现在要看的话，肯定是要看他在2003年投到JMLR上的同名论文了。</p><p>Bengio用了一个三层的神经网络来构建语言模型，同样也是n-gram模型。如图<img src="http://omu7tit09.bkt.clouddn.com/15118521612179.png" alt=""></p><p>图中最下方的$w_{t-n+1}，…，w_{t-2},w_{t-1}$就是前$n-1$个词。现在需要根据这已知的$n-1$个词预测下一个词$w_t$。$C(w)$表示词$w$所对应的词向量，整个模型中使用的是一套唯一的词向量，存在矩阵$C$(一个$|V|×m$的矩阵)中。其中$|V|$表示词表的大小（语料中的总词数），m表示词向量的维度。$w$到$C(w)$的转化就是从矩阵中取出一行。</p><p>网络的第一层（输入层）是将$C(w_{t-n+1})，…，C(w_{t-2}),C(w_{t-1})$这n-1个向量首尾相拼接起来，形成一个$(n-1)m$维的向量，下面记为x。</p><p>网络的第二层（隐藏层）就如同普通的神经网络，直接使用$d+Hx$计算得到。d是一个偏置项。在此之后，使用tanh作为激活函数。</p><p>网络的第三层（输出层）一共$|V|$个节点，每个节点$y_i$表示下一个词为$i$的未归一化log概率。最后使用softmax激活函数将输出值y归一化成概率。最终，y的计算公式为：</p><script type="math/tex; mode=display">y=b+Wx+Utanh(d+Hx)</script><p>式子中的$U$(一个$V×h$的矩阵)是隐藏层到输出层的参数，整个模型的多数计算集中在U和隐藏层的矩阵乘法中。后文的提到的3个工作，都有对这一环节的简化，提升计算的速度。</p><p>式子中还有一个矩阵$W(|V|×(n-1)m)$,这个矩阵包含了从输入层到输出层的直连边。直连边就是从输入层直接到输出层的一个线性变换，好像也是神经网络中的一种常用技巧。如果不需要直连边的话，将W置为0就可以了。在最后的实验中，Bengio发现直连边虽然不能提升模型效果，但是可以少一半的迭代次数。同时他也猜想如果没有直连边，可能可以生成更好的词向量。</p><p>现在万事俱备，用随机梯度下降法把这个模型优化出来就可以了。需要注意的是，一般神经网络的输入层只是一个输入值，而在这里，输入层x也是参数（存在C中），也是需要优化的。优化结束之后，词向量有了，语言模型也有了。</p><p>这样得到的语言模型自带平滑，无需传统n-gram模型中那些复杂的平滑算法。Bengio在APNews数据集上做的对比试验也表明他的模型效果比精心设计平滑算法的普通n-gram算法要好10%到20%。</p><p>在结束介绍 Bengio 大牛的经典作品之前再插一段八卦。在其 JMLR 论文中的未来工作一段，他提了一个能量函数，把输入向量和输出向量统一考虑，并以最小化能量函数为目标进行优化。后来 M&amp;H 工作就是以此为基础展开的。</p><p>他提到一词多义有待解决，9 年之后 Huang 提出了一种解决方案。他还在论文中随口（不是在 Future Work 中写的）提到：可以使用一些方法降低参数个数，比如用循环神经网络。后来 Mikolov 就顺着这个方向发表了一大堆论文，直到博士毕业。</p><p>大牛就是大牛。</p><h3 id="3-3-C-amp-W的SENNA"><a href="#3-3-C-amp-W的SENNA" class="headerlink" title="3.3 C&amp;W的SENNA"></a>3.3 C&amp;W的SENNA</h3><p>Ronan Collobert 和 Jason Weston 在 2008 年的 ICML 上发表的《A Unified Architecture for Natural Language Processing: Deep Neural Networks with Multitask Learning》里面首次介绍了他们提出的词向量的计算方法。和上一篇牛文类似，如果现在要看的话，应该去看他们在 2011 年投到 JMLR 上的论文《Natural Language Processing (Almost) from Scratch》。文中总结了他们的多项工作，非常有系统性。这篇 JMLR 的论文题目也很霸气啊：从头开始搞 NLP。</p><p>他们还把论文所写的系统开源了，叫做 SENNA（<a href="http://ml.nec-labs.com/senna/" target="_blank" rel="noopener">主页链接</a>），3500 多行纯 C 代码也是写得非常清晰。我就是靠着这份代码才慢慢看懂这篇论文的。可惜的是，代码只有测试部分，没有训练部分。</p><p>实际上 C&amp;W 这篇论文主要目的并不是在于生成一份好的词向量，甚至不想训练语言模型，而是要用这份词向量去完成 NLP 里面的各种任务，比如词性标注、命名实体识别、短语识别、语义角色标注等等。</p><p>由于目的的不同，C&amp;W 的词向量训练方法在我看来也是最特别的。他们没有去近似地求 $P(w_t|w_1,w_2,…,w_{t−1})$，而是直接去尝试近似 $P(w_1,w_2,…,w_t)$。在实际操作中，他们并没有去求一个字符串的概率，而是求窗口连续 n 个词的打分 $f(w_{t−n+1},…,w_{t−1},w_t)$。打分 f 越高的说明这句话越是正常的话；打分低的说明这句话不是太合理；如果是随机把几个词堆积在一起，那肯定是负分（差评）。打分只有相对高低之分，并没有概率的特性。</p><p>有了这个对 f 的假设，C&amp;W 就直接使用 pair-wise 的方法训练词向量。具体的来说，就是最小化下面的目标函数。</p><script type="math/tex; mode=display">∑_{x∈𝔛}∑_{w∈𝔇}max \{0,1−f(x)+f(x^{(w)})\}</script><p>$𝔛$为训练集中的所有连续的n元短语，$𝔇$是整个字典。第一个求和枚举了训练语料中的所有的n元短语，作为正样本。第二个对字典的枚举是构建负样本。$x^{(w)}$是将短语x的最中间的那个词，替换成w。在大多数情况下，在一个正常短语的基础上随便找个词替换掉中间的词，最后得到的短语肯定不是正确的短语，所以这样构造的负样本是非常可用的（多数情况下确实是负样本，极少数情况下把正常短语当做负样本也不影响大局）。同时，由于负样本仅仅是修改了正样本中的一个词，也不会让分类面距离负样本太远而影响分类。再回顾这个式子，x是正样本，$x^{(w)}$是负样本，$f(x)$是对正样本的打分，$f(x^{(w)})$是对负样本的打分。最后希望正样本的打分要比负样本的打分至少高一分。</p><p>$f$函数的结构和Bengio 2003中提到的网络结构基本一致。同样是把窗口中的 nn 个词对应的词向量串成一个长的向量，同样是经过一层网络（乘一个矩阵）得到隐藏层。不同之处在于 C&amp;W 的输出层只有一个节点，表示得分，而不像 Bengio 那样的有 $|V|$个节点。这么做可以大大降低计算复杂度，当然有这种简化还是因为 C&amp;W 并不想做一个真正的语言模型，只是借用语言模型的思想辅助他完成 NLP 的其它任务。（其实 C&amp;W 的方法与 Bengio 的方法还有一个区别，他们为了程序的效率用 HardTanh代替 tanh 激活函数。）</p><p>他们在实验中取窗口大小 n=11，字典大小 |V|=130000，在维基百科英文语料和路透社语料中一共训练了 7 周，终于得到了这份伟大的词向量。</p><p>如前面所说 C&amp;W 训练词向量的动机与其他人不同，因此他公布的词向量与其它词向量相比主要有两个区别：</p><ul><li>1.他的词表中只有小写单词。也就是说他把大写开头的单词和小写单词当作同一个词处理。其它的词向量都是把他们当作不同的词处理的。</li><li>2.他公布的词向量并不直接是上述公式的优化结果，而是在此基础上进一步跑了词性标注、命名实体识别等等一系列任务的 Multi-Task Learning 之后，二次优化得到的。也可以理解为是半监督学习得到的，而非其他方法中纯无监督学习得到的。</li></ul><p>不过好在 Turian 在 2010 年对 C&amp;W 和 M&amp;H 向量做对比时，重新训练了一份词向量放到了网上，那份就没上面的两个“问题”（确切的说应该是差别），也可以用的更放心。后面会详细介绍 Turian 的工作。</p><p>关于这篇论文其实还是有些东西可以吐槽的，不过训练词向量这一块没有，是论文其他部分的。把吐槽机会留给下一篇博文了。</p><h3 id="3-4-M-amp-H-的-HLBL"><a href="#3-4-M-amp-H-的-HLBL" class="headerlink" title="3.4 M&amp;H 的 HLBL"></a>3.4 M&amp;H 的 HLBL</h3><p>Andriy Mnih 和 Geoffrey Hinton 在 2007 年和 2008 年各发表了一篇关于训练语言模型和词向量的文章。2007 年发表在 ICML 上的《Three new graphical models for statistical language modelling》表明了 Hinton 将 Deep Learning 战场扩展到 NLP 领域的决心。2008 年发表在 NIPS 上的《A scalable hierarchical distributed language model》则提出了一种层级的思想替换了 Bengio 2003 方法中最后隐藏层到输出层最花时间的矩阵乘法，在保证效果的基础上，同时也提升了速度。下面简单介绍一下这两篇文章。</p><p>Hinton 在 2006 年提出 Deep Learning 的概念之后，很快就来 NLP 最基础的任务上试了一把。果然，有效。M&amp;H 在 ICML 2007 上发表的这篇文章提出了“Log-Bilinear”语言模型。文章标题中可以看出他们其实一共提了 3 个模型。从最基本的 RBM 出发，一点点修改能量函数，最后得到了“Log-Bilinear”模型。</p><p>模型如果用神经网络的形式写出来，是这个样子：</p><script type="math/tex; mode=display">h = ∑_{i=1}^{t-1}H_iC(w_i)</script><script type="math/tex; mode=display">y_j=C(w_j)^Th</script><p>这里的两个式子可以合写成一个$y_j=∑_{i=1}^{n-1}C(w_j)^TH_iC(w_i)$。$C(w)$是词 w 对应的词向量，形如 $x^TMy$ 的模型叫做 Bilinear 模型，也就是 M&amp;H 方法名字的来历了。</p><p>为了更好地理解模型的含义，还是来看这两个拆解的式子。h 在这里表示隐藏层，这里的隐藏层比前面的所有模型都更厉害，直接有语义信息。首先从第二个式子中隐藏层能和词向量直接做内积可以看出，隐藏层的维度和词向量的维度是一致的（都是 m维）。$H_i$就是一个 $m×m$的矩阵，该矩阵可以理解为第 i个词经过 $H_i$ 这种变换之后，对第 t个词产生的贡献。因此这里的隐藏层是对前 $t−1$个词的总结，也就是说隐藏层 $h$ 是对下一个词的一种预测。</p><p>再看看第二个式子，预测下一个词为 $w_j$ 的 log 概率是 $y_j$，它直接就是 $C(w_j)$和 $h$ 的内积。内积基本上就可以反应相似度，如果各词向量的模基本一致的话，内积的大小能直接反应两个向量的 cos 夹角的大小。这里使用预测词向量 h 和各个已知词的词向量的相似度作为 log 概率，将词向量的作用发挥到了极致。这也是我觉得这次介绍的模型中最漂亮的一个。</p><p>这种“Log-Bilinear”模型看起来每个词需要使用上文所有的词作为输入，于是语料中最长的句子有多长，就会有多少个 H 矩阵。这显然是过于理想化了。最后在实现模型时，还是迫于现实的压力，用了类似 n-gram 的近似，只考虑了上文的 3 到 5 个词作为输入来预测下一个词。</p><p>M&amp;H 的思路如前面提到，是 Bengio 2003 提出的。经过大牛的实现，效果确实不错。虽然复杂度没有数量级上的降低，但是由于是纯线性模型，没有激活函数（当然在做语言模型的时候，最后还是对 $y_j$ 跑了一个 softmax），因此实际的训练和预测速度都会有很大的提升。同时隐藏层到输出层的变量直接用了词向量，这也就几乎少了一半的变量，使得模型更为简洁。最后论文中 M&amp;H 用了和 Bengio 2003 完全一样的数据集做实验，效果有了一定的提升。</p><p>2008 年 NIPS 的这篇论文，介绍的是“hierarchical log-bilinear”模型，很多论文中都把它称作简称“HLBL”。和前作相比，该方法使用了一个层级的结构做最后的预测。可以简单地设想一下把网络的最后一层变成一颗平衡二叉树，二叉树的每个非叶节点用于给预测向量分类，最后到叶节点就可以确定下一个词是哪个了。这在复杂度上有显著的提升，以前是对 $|V|$ 个词一一做比较，最后找出最相似的，现在只需要做 $log_2(|V|)$ 次判断即可。</p><p>这种层级的思想最初可见于 Frederic Morin 和 Yoshua Bengio 于 2005 年发表的论文《Hierarchical probabilistic neural network language model》中。但是这篇论文使用 WordNet 中的 IS-A 关系，转化为二叉树用于分类预测。实验结果发现速度提升了，效果变差了。</p><p>有了前车之鉴，M&amp;H 就希望能从语料中自动学习出一棵树，并能达到比人工构建更好的效果。M&amp;H 使用一种 bootstrapping 的方法来构建这棵树。从随机的树开始，根据分类结果不断调整和迭代。最后得到的是一棵平衡二叉树，并且同一个词的预测可能处于多个不同的叶节点。这种用多个叶节点表示一个词的方法，可以提升下一个词是多义词时候的效果。M&amp;H 做的还不够彻底，后面 Huang 的工作直接对每个词学习出多个词向量，能更好地处理多义词。</p><h3 id="3-5-Mikolov-的-RNNLM"><a href="#3-5-Mikolov-的-RNNLM" class="headerlink" title="3.5 Mikolov 的 RNNLM"></a>3.5 Mikolov 的 RNNLM</h3><p>前文说到，Bengio 2003 论文里提了一句，可以使用一些方法降低参数个数，比如用循环神经网络。Mikolov 就抓住了这个坑，从此与循环神经网络结下了不解之缘。他最早用循环神经网络做语言模型是在 INTERSPEECH 2010 上发表的《Recurrent neural network based language model》里。Recurrent neural network 是循环神经网络，简称 RNN，还有个 Recursive neural networks 是递归神经网络（Richard Socher 借此发了一大堆论文），也简称 RNN。看到的时候需要注意区分一下。不过到目前为止，RNNLM 只表示循环神经网络做的语言模型，还没有歧义。</p><p>在之后的几年中，Mikolov 在一直在RNNLM 上做各种改进，有速度上的，也有准确率上的。现在想了解 RNNLM，看他的博士论文《Statistical Language Models based on Neural Networks》肯定是最好的选择。</p><p>循环神经网络与前面各方法中用到的前馈网络在结构上有比较大的差别，但是原理还是一样的。网络结构大致如图。</p><p>左边是网络的抽象结构，由于循环神经网络多用在时序序列上，因此里面的输入层、隐藏层和输出层都带上了“(t)”。$w(t)$ 是句子中第 t 个词的 One-hot representation 的向量，也就是说 $w$ 是一个非常长的向量，里面只有一个元素是 1。而下面的 $s(t−1)$ 向量就是上一个隐藏层。最后隐藏层计算公式为：</p><script type="math/tex; mode=display">s(t)=sigmoid(Uw(t)+W_s(t−1))</script><p>从右图可以看出循环神经网络是如何展开的。每来一个新词，就和上一个隐藏层联合计算出下一个隐藏层，隐藏层反复利用，一直保留着最新的状态。各隐藏层通过一层传统的前馈网络得到输出值。</p><p>$w(t)$ 是一个词的 One-hot representation，那么 $Uw(t)$ 也就相当于从矩阵 $U $中选出了一列，这一列就是该词对应的词向量。</p><p>循环神经网络的最大优势在于，可以真正充分地利用所有上文信息来预测下一个词，而不像前面的其它工作那样，只能开一个 n 个词的窗口，只用前 n 个词来预测下一个词。从形式上看，这是一个非常“终极”的模型，毕竟语言模型里能用到的信息，他全用上了。可惜的是，循环神经网络形式上非常好看，使用起来却非常难优化，如果优化的不好，长距离的信息就会丢失，甚至还无法达到开窗口看前若干个词的效果。Mikolov 在 RNNLM 里面只使用了最朴素的 BPTT 优化算法，就已经比 n-gram 中的 state of the art 方法有更好的效果，这非常令人欣慰。如果用上了更强的优化算法，最后效果肯定还能提升很多。</p><p>对于最后隐藏层到输出层的巨大计算量，Mikolov 使用了一种分组的方法：根据词频将$|V|$个词分成 $\sqrt{|V|}$组，先通过$\sqrt{|V|}$次判断，看下一个词属于哪个组，再通过若干次判断，找出其属于组内的哪个元素。最后均摊复杂度约为 $o(\sqrt{|V|})$，略差于 M&amp;H 的 $o(log(|V|))$，但是其浅层结构某种程度上可以减少误差传递，也不失为一种良策。</p><p>Mikolov 的 RNNLM 也是开源的（<a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/" target="_blank" rel="noopener">网址</a>）。非常算法风格的代码，几乎所有功能都在一个文件里，工程也很好编译。比较好的是，RNNLM 可以完美支持中文，如果语料存成 UTF-8 格式，就可以直接用了。</p><p>最后吐槽一句，我觉得他在隐藏层用 sigmoid 作为激活函数不够漂亮。因为隐藏层要和输入词联合计算得到下一个隐藏层，如果当前隐藏层的值全是正的，那么输入词对应的参数就会略微偏负，也就是说最后得到的词向量的均值不在 0 附近。总感觉不好看。当然，从实验效果看，是我太强迫症了。</p><h3 id="3-6-Huang的语义强化"><a href="#3-6-Huang的语义强化" class="headerlink" title="3.6 Huang的语义强化"></a>3.6 Huang的语义强化</h3><p>与前几位大牛的工作不同，Eric H. Huang 的工作是在 C&amp;W 的基础上改进而成的，并非自成一派从头做起。他这篇发表在 ACL 2012 上的《Improving Word Representations via Global Context and Multiple Word Prototypes》试图通过对模型的改进，使得词向量富含更丰富的语义信息。他在文中提出了两个主要创新来完成这一目标：（其实从论文标题就能看出来）第一个创新是使用全文信息辅助已有的局部信息，第二个创新是使用多个词向量来表示多义词。下面逐一介绍。</p><p>Huang 认为 C&amp;W 的工作只利用了“局部上下文（Local Context）”。C&amp;W 在训练词向量的时候，只使用了上下文各 5 个词，算上自己总共有 11 个词的信息，这些局部的信息还不能充分挖掘出中间词的语义信息。Huang 直接使用 C&amp;W 的网络结构计算出一个得分，作为“局部得分”。</p><p>然后 Huang 提出了一个“全局信息”，这有点类似传统的词袋子模型。词袋子模型是把文章中所有词的 One-hot Representation 加起来，形成一个向量（就像把词全都扔进一个袋子里），用来表示文章。Huang 的全局模型是将文章中所有词的词向量求个加权平均（权重是词的 idf），作为文章的语义。他把文章的语义向量和当前词的词向量拼接起来，形成一个两倍长度的向量作为输入，之后还是用 C&amp;W 的网络结构算出一个打分。</p><p>有了 C&amp;W 方法的得到的“局部得分”，再加上在 C&amp;W 方法基础上改造得到的“全局得分”，Huang 直接把两个得分相加，作为最终得分。最终得分使用 C&amp;W 提出的 pair-wise 目标函数来优化。</p><p>加了这个全局信息有什么用处呢？Huang 在实验中发现，他的模型能更好地捕捉词的语义信息。比如 C&amp;W 的模型中，与 markets 最相近的词为 firms、industries；而 Huang 的模型得到的结果是 market、firms。很明显，C&amp;W 的方法由于只考虑了临近词的信息，最后的结果是词法特征最相近的词排在了前面（都是复数形式）。不过我觉得这个可能是英语才有的现象，中文没有词形变化，如果在中文中做同样的实验还不知道会有什么效果。</p><p>Huang 论文的第二个贡献是将多义词用多个词向量来表示。Bengio 2003 在最后提过这是一个重要的问题，不过当时他还在想办法解决，现在 Huang 给出了一种思路。</p><p>将每个词的上下文各 5 个词拿出来，对这 10 个词的词向量做加权平均（同样使用 idf 作为权重）。对所有得到的上下文向量做 k-means 聚类，根据聚类结果给每个词打上标签（不同类中的同一个词，当作不同的词处理），最后重新训练词向量。</p><p>当然这个实验的效果也是很不错的，最后 star 的某一个表示最接近的词是 movie、film；另一个表示最接近的词是 galaxy、planet。</p><p>这篇文章还做了一些对比实验，在下一章评价里细讲。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><p>讲完了大牛们的各种方法，自己也忍不住来总结一把。当然，为了方便对比，我先列举一下上面提到的各个系统的现有资源，见下表。对应的论文不在表中列出，可参见最后的参考文献。</p><p>Turian 的工作前面只是提了一下，他在做 C&amp;W 向量与 H&amp;M 向量的对比实验时，自己按照论文重新实现了一遍他们的方法，并公布了词向量。后来 C&amp;W 在主页上强调了一下：尽管很多论文把 Turian 实现的结果叫做 C&amp;W 向量，但是与我发布的词向量是不同的，我这个在更大的语料上训练，还花了两个月时间呢！</p><p>Turian 公布的 H&amp;M 向量是直接请 Andriy Mnih 在 Turian 做好的语料上运行了一下 HLBL，所以没有代码公布。同时 Turian 自己实现了一份 LBL模型，但是没有公布训练出来的词向量。（这是根据他主页上描述推测的结果，从 Turian 的论文中看，他应该是实现了 HLBL 算法并且算出词向量的。）</p><p>RCV1 的词数两篇文章中所写的数据差距较大，还不知道是什么原因。</p><p>Holger Schwenk 在词向量和语言模型方面也做了一些工作，看起来大体相似，也没仔细读过他的论文。有兴趣的读者可以直接搜他的论文。</p><p>事实上，除了 RNNLM 以外，上面其它所有模型在第一层（输入层到隐藏层）都是等价的，都可以看成一个单层网络。可能形式最为特别的是 M&amp;H 的模型，对前面的每个词单独乘以矩阵 HiHi，而不是像其它方法那样把词向量串接起来乘以矩阵 HH。但如果把 HH 看成 HiHi 的拼接： $[H1H2…Ht]$，则会有以下等式：</p><p>这么看来还是等价的。</p><p>所以前面的这么多模型，本质是非常相似的。都是从前若干个词的词向量通过线性变换抽象出一个新的语义（隐藏层），再通过不同的方法来解析这个隐藏层。模型的差别主要就在隐藏层到输出层的语义。Bengio 2003 使用了最朴素的线性变换，直接从隐藏层映射到每个词；C&amp;W 简化了模型（不求语言模型），通过线性变换将隐藏层转换成一个打分；M&amp;H 复用了词向量，进一步强化了语义，并用层级结构加速；Mikolov 则用了分组来加速。</p><p>每种方法真正的差别看起来并不大，当然里面的这些创新，也都是有据可循的。下一章就直接来看看不同模型的效果如何。</p><h2 id="四、词向量的评价"><a href="#四、词向量的评价" class="headerlink" title="四、词向量的评价"></a>四、词向量的评价</h2><p>词向量的评价大体上可以分成两种方式，第一种是把词向量融入现有系统中，看对系统性能的提升；第二种是直接从语言学的角度对词向量进行分析，如相似度、语义偏移等。</p><h3 id="4-1-提升现有系统"><a href="#4-1-提升现有系统" class="headerlink" title="4.1 提升现有系统"></a>4.1 提升现有系统</h3><p>词向量的用法最常见的有两种：</p><ul><li>1）直接用于神经网络模型的输入层。如 C&amp;W 的 SENNA 系统中，将训练好的词向量作为输入，用前馈网络和卷积网络完成了词性标注、语义角色标注等一系列任务。再如 Socher 将词向量作为输入，用递归神经网络完成了句法分析、情感分析等多项任务。</li><li>2）作为辅助特征扩充现有模型。如 Turian 将词向量作为额外的特征加入到接近 state of the art 的方法中，进一步提高了命名实体识别和短语识别的效果。</li></ul><p>具体的用法理论上会在下一篇博文中细讲。</p><p>C&amp;W 的论文中有一些对比实验。实验的结果表明，使用词向量作为初始值替代随机初始值，其效果会有非常显著的提升（如：词性标注准确率从 96.37% 提升到 97.20%；命名实体识别 F 值从 81.47% 提升到 88.67%）。同时使用更大的语料来训练，效果也会有一些提升。</p><p>Turian 发表在 ACL 2010 上的实验对比了 C&amp;W 向量与 M&amp;H 向量用作辅助特征时的效果。在短语识别和命名实体识别两个任务中，C&amp;W 向量的效果都有略微的优势。同时他也发现，如果将这两种向量融合起来，会有更好的效果。除了这两种词向量，Turian 还使用 Brown Cluster 作为辅助特征做了对比，效果最好的其实是 Brown Cluster，不过这个已经超出本文的范围了。</p><h3 id="4-2-语言学评价"><a href="#4-2-语言学评价" class="headerlink" title="4.2 语言学评价"></a>4.2 语言学评价</h3><p>Huang 2012 的论文提出了一些创新，能提升词向量中的语义成分。他也做了一些实验对比了各种词向量的语义特性。实验方法大致就是将词向量的相似度与人工标注的相似度做比较。最后 Huang 的方法语义相似度最好，其次是 C&amp;W 向量，再然后是 Turian 训练的 HLBL 向量与 C&amp;W 向量。这里因为 Turian 训练词向量时使用的数据集（RCV1）与其他的对比实验（Wiki）并不相同，因此并不是非常有可比性。但从这里可以推测一下，可能更大更丰富的语料对于语义的挖掘是有帮助的。</p><p>还有一个有意思的分析是 Mikolov 在 2013 年刚刚发表的一项发现。他发现两个词向量之间的关系，可以直接从这两个向量的差里体现出来。向量的差就是数学上的定义，直接逐位相减。比如 $C(king)−C(queen)≈C(man)−C(woman)$。更强大的是，与 $C(king)−C(man)+C(woman)$最接近的向量就是 $C(queen)$。</p><p>为了分析词向量的这个特点， Mikolov 使用类比（analogy）的方式来评测。如已知 a 之于 b 犹如 c 之于 d。现在给出 a、b、c，看 $C(a)−C(b)+C(c)$最接近的词是否是 d。</p><p>在文章 Mikolov 对比了词法关系（名词单复数 good-better:rough-rougher、动词第三人称单数、形容词比较级最高级等）和语义关系（clothing-shirt:dish-bowl）。</p><p>在词法关系上，RNN 的效果最好，然后是 Turian 实现的 HLBL，最后是 Turian 的 C&amp;W。（RNN-80:19%；RNN-1600:39.6%；HLBL-100:18.7%；C&amp;W-100:5%；-100表示词向量为100维）</p><p>在语义关系上，表现最好的还是 RNN，然后是 Turian 的两个向量，差距没刚才的大。（RNN-80:0.211；C&amp;W-100:0.154；HLBL-100:0.146）</p><p>但是这个对比实验用的训练语料是不同的，也不能特别说明优劣。</p><p>这些实验结果中最容易理解的是：语料越大，词向量就越好。其它的实验由于缺乏严格控制条件进行对比，谈不上哪个更好哪个更差。不过这里的两个语言学分析都非常有意思，尤其是向量之间存在这种线性平移的关系，可能会是词向量发展的一个突破口。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Yoshua Bengio, Rejean Ducharme, Pascal Vincent, and Christian Jauvin. A neural probabilistic language model. Journal of Machine Learning Research (JMLR), 3:1137–1155, 2003. [PDF]</p><p>Ronan Collobert, Jason Weston, Léon Bottou, Michael Karlen, Koray Kavukcuoglu and Pavel Kuksa. Natural Language Processing (Almost) from Scratch. Journal of Machine Learning Research (JMLR), 12:2493-2537, 2011. [PDF]</p><p>Andriy Mnih &amp; Geoffrey Hinton. Three new graphical models for statistical language modelling. International Conference on Machine Learning (ICML). 2007. [PDF]<br>Andriy Mnih &amp; Geoffrey Hinton. A scalable hierarchical distributed language model. The Conference on Neural Information Processing Systems (NIPS) (pp. 1081–1088). 2008. [PDF]</p><p>Mikolov Tomáš. Statistical Language Models based on Neural Networks. PhD thesis, Brno University of Technology. 2012. [PDF]</p><p>Turian Joseph, Lev Ratinov, and Yoshua Bengio. Word representations: a simple and general method for semi-supervised learning. Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL). 2010. [PDF]</p><p>Eric Huang, Richard Socher, Christopher Manning and Andrew Ng. Improving word representations via global context and multiple word prototypes. Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers-Volume 1. 2012. [PDF]</p><p>Mikolov, Tomas, Wen-tau Yih, and Geoffrey Zweig. Linguistic regularities in continuous space word representations. Proceedings of NAACL-HLT. 2013. [PDF]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://licstar.net/archives/328#comment-1630&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LICSTAR的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是我看了半年的论文后，自己对Deep Learnimng在NLP领域中应用的理解和总结，在此分享。其中必然有局限性，欢迎各种交流，随便拍。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
      <category term="Skip-gram" scheme="http://yoursite.com/tags/Skip-gram/"/>
    
      <category term="CBOW" scheme="http://yoursite.com/tags/CBOW/"/>
    
  </entry>
  
  <entry>
    <title>日知录（2）：前景理论</title>
    <link href="http://yoursite.com/2017/12/10/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%882%EF%BC%89%EF%BC%9A%E5%89%8D%E6%99%AF%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2017/12/10/日知录（2）：前景理论/</id>
    <published>2017-12-10T15:14:45.000Z</published>
    <updated>2018-11-05T16:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓决策，就是在几个方案中选择一个方案，分为风险决策和非风险决策。在非风险决策中，各个方案的结果都是确定的。在风险决策中，有的方案有的结果是不确定的，即可能发生，也可能不发生。我们这里谈及的就是风险决策。</p><a id="more"></a><p>一般来说，风险决策研究有两个途径：</p><ul><li>一个是规范性途径，其基本问题是：人类的风险决策应该遵循怎样的规则？</li><li>一个是描述性途径，其基本问题是：人类的风险决策实际遵循怎样的规则？</li></ul><p>规范性途径往往被叫做决策逻辑学，描述性途径往往被叫做决策行为学或决策心理学。我们这里关注的是描述性途径。</p><p>关于风险决策的最早理论是期望效用理论，它最初只是规范性理论，但经济学家们逐渐把它当做描述性理论来使用——把它作为经济学中对人的决策行为的基本假定，即认为人的实际决策行为遵循期望效应理论，直到上世纪70年代处有的著名经济学家（如Arrow）仍然采取这种做法。</p><p>自1979年以来，Kahneman &amp; Tversky的一系列著作，对期望效用理论作为描述性理论的有效性提出了严峻的挑战，并提出前景理论作为合适的描述理论。由于前景理论能够精确解释、预言许多风险决策行为，它的影响越来越大；后来Kahneman把它应用于经济学领域，对经济学产生了深远的影响，为此，Kahneman于2002年获得了诺贝尔经济学奖。</p><p>这里首先介绍期望效用理论；然后介绍Kahneman等以实验事实对期望效用理论作为描述性理论的批评；最后介绍前景理论的主要内容。</p><h2 id="一、期望效用理论"><a href="#一、期望效用理论" class="headerlink" title="一、期望效用理论"></a>一、期望效用理论</h2><p>期望效用函数理论是20世纪50年代，冯·纽曼和摩根斯坦（von Neumann and Morgenstem）在公理化假设的基础上，运用逻辑和数学工具，建立了不确定条件下对理性人（rational actor）选择进行分析的框架。不过，该理论是将个体与群体合而为一的。后来，阿罗和德布鲁（Arrow and Debreu）将其吸收进瓦尔拉斯均衡的框架中，成为处理不确定决策问题的分析范式，进而构建起现代微观经济学并由此展开的包括宏观、金融、计量等在内的宏伟而又优美的理论大厦。</p><p>期望效用理论本来是作为规范性理论提出的，但后来在许多经济学著作中被应用为描述性理论，直到上个世纪70年代初仍然如此。</p><p>经济学上所使用的期望效用理论包括三方面的内容：Bayes框架；Savage公理；Bernoulli原则。它们分别由不同的人在不同的时期创建。以下分述之。</p><h3 id="1-1-Bayes框架"><a href="#1-1-Bayes框架" class="headerlink" title="1.1 Bayes框架"></a>1.1 Bayes框架</h3><p>早在1662年，Antoine Arnauld就写道：决定一个人必须做什么以获得好处或避免坏处，不仅必须考虑好处和坏处本身，而且必须考虑它发生或不发生的概率。</p><p>大约在100年之后出版的Bayes的遗著（1763）年把这个思想系统化、精确化，形成了所谓的风险决策的Bayes框架，其核心思想可以概括为两点：</p><ol><li>$ED(A_i)=\sum _jP_{ij}·D_{ij}$：即行动$A_i$的估计渴望度（estimated desirability，简称ED；后来改称期望效用，expected utility，EU）等于它的各个可能结果的渴望度$D_{ij}$乘以该可能结果出现的概率所得的积的和；或者说，行动$A_i$的估计渴望度等于它的各个结果的渴望度的加权和，权重为各个结果的概率。（注意，前提是各个可能结果互不相容。）</li><li>根据贝叶斯原则进行选择：选择有着最大估计渴望度的一个方案。</li></ol><p>请注意到Bayes决策框架所包含的两点假设：</p><ul><li>决策权重=概率本身</li><li>渴望度（效用）不依赖于参考点。Bayes决策框架并没有要求以一个参考点来衡量渴望度（效用）；实际上，在经济学中人们往往以财富的最终状态来计算效用。</li></ul><h3 id="1-2-Savage公理"><a href="#1-2-Savage公理" class="headerlink" title="1.2 Savage公理"></a>1.2 Savage公理</h3><p>Bayes决策框架一直沿用下来，并有进一步的发展。</p><p>Von Neumann &amp; Morgenstern（1944）发展出关于偏好（选择）的公理系统；而Ramsey（1931）和Savage（1954）继续发展了该公理系统，用主观概率代替客观概率，从而使概率理论和决策理论可以适用于更广泛的事情。Savage公理系统是这些公理系统中最为成熟的。其中的公理有：</p><ul><li>不变性公理（Invariance Axiom）：方案间的偏好顺序不依赖于方案的描述方式。</li><li>优势性公理（Dominance Axiom）：如果方案A在每个方面至少跟方案B一样好，而在至少一个方面比B更好，那么A应该比B更可取。</li><li>如果方案B由于方案A，那么它们与任一概率$p≠0$的结合所得的$(B,p)$一定优于$(A,p)$</li></ul><p>这些公理与直觉十分一致；也与Bayes决策框架完全一致。</p><h3 id="1-3-Bernoulli原则"><a href="#1-3-Bernoulli原则" class="headerlink" title="1.3 Bernoulli原则"></a>1.3 Bernoulli原则</h3><p>很早以前Bernoulli就指出人们通常是风险回避的。一个决策是风险回避的，是指：按照结果的表面值（如金额）计算，在确定的结果与有着相等或更高的期望值的不确定的结果之间，决策者选择了确定的结果，如，A. 确定得到80元；B.81%的可能得到100元，按结果的表面值计算，B的期望值高于A，按理应该选择B，但事实上大多数人们会选择A。</p><p>为了解释这个现象，Bernoulli提出：人们评价方案，不是用方案的金钱结果值，而是用这些金钱结果值的主观价值，而这个主观价值对于金钱值的函数曲线（效用曲线）是一条凹形的曲线，即$u’’(x)&lt;0$。通俗地说，随着x的不断增大，u的增长越来越慢。用这个原理能轻易解释上段提及的现象。假设80元的主观价值是72，由此可以推出100元的主观价值应该小于90（因为前面80元中每20元的主观价值是18，根据u增长越来越慢的原理，100元超出80元的那20元的主观价值应该小于18，因而100元的主观价值小于90），假设是85.于是，A方案的期望值是72，而B的期望值是$85*81%=68.85$。所以大多数人们选择了A方案。</p><p>于是，风险回避和$u’’(x)&lt;0$也成了一些经济学著作对人的决策行为的假定之一。</p><h3 id="1-4-小结与问题"><a href="#1-4-小结与问题" class="headerlink" title="1.4 小结与问题"></a>1.4 小结与问题</h3><p>经济学理论中常常把期望效用理论的上述Bayes框架，Savage公理和Bernoulli原则中的全部或部分作为对人的风险决策行为的基本假定，在此假定和其他假定的基础上构建经济学理论。</p><p>这种做法有明显的方法论问题：这些经验假定（经验命题）的真假并没有经过经验方法的系统判明。逻辑学家们提出Bayes框架，Savage公理的初衷是：高斯人们应该怎样决策，或者说怎样决策才是合乎理性的；他们并未考察人们的决策行为是否恰好符合这些规则。而Bernoulli原则知识根据某类风险决策事实归纳得出；并未建立在对各种类型的风险决策事实的全面考察上。人们的实际决策行为是否遵循上述规则，显然是个经验命题；而一个经验命题只有通过经验的方法才能判明它的真伪。而经济学家们，未经经验方法的判定，就把上述规则当做经验命题来使用，这种做法就存在方法论上的问题。</p><p>这种方法论上的问题使得采用期望效用理论作为描述性理论可能是错误的。而Kahneman &amp; Tversky的一系列实验表明：采用期望效用理论作为描述性理论确实是错误的。</p><h2 id="二、对期望效用理论的实验挑战"><a href="#二、对期望效用理论的实验挑战" class="headerlink" title="二、对期望效用理论的实验挑战"></a>二、对期望效用理论的实验挑战</h2><p>Kahneman &amp; Tversky的一系列实验对期望效用理论作为描述理论的有效性提出了挑战。下面是他们的部分实验。</p><h3 id="2-1-实验一"><a href="#2-1-实验一" class="headerlink" title="2.1 实验一"></a>2.1 实验一</h3><blockquote><p>期望效用理论的“决策权重=概率”成立吗？</p><p>问题一：<br>请选择：</p></blockquote><ul><li>A. 有80%的可能性得到4000元； 【20%】</li><li>B. 确定地得到3000元。【80%】</li></ul><p>方括号指的是该项被试的百分比，以下皆同。</p><blockquote><p>问题二：</p></blockquote><p>请选择：</p><ul><li>C. 有20%的可能性得到4000元；【65%】</li><li>D. 有25%的可能性得到3000元。【35%】</li></ul><blockquote><p>分析：</p></blockquote><p>如前1.1 所述，期望效用理论中，决策权重=概率。假设这点成立，那么有：</p><script type="math/tex; mode=display">U(A)=0.80*u(4000);</script><script type="math/tex; mode=display">U(B)=u(3000)</script><script type="math/tex; mode=display">U(C)=0.2*u(4000)</script><script type="math/tex; mode=display">U(D)=0.25*u(3000)</script><p>注意到$U(A),U(B)$分别乘以0.25就相应得到$U(C),U(D)$，所以有：<br>如果$U(A)<u(b)$，那么$u(c)<u(d)$；如果$u(a)>U(B)$，那么$U(C)&gt;U(D)$。即A、B之间的偏好顺序应该和C、D之间的偏好顺序相同。</u(b)$，那么$u(c)<u(d)$；如果$u(a)></p><p>但上述实验结果却是：虽然在A、B之间大部分偏好B；但在C、D之间大部分偏好C。即在集体水平上被试的偏好发生了逆转。另外，根据Kahneman &amp; Tversky的实验报告，在个体水平上，超过半数的被试的偏好也发生了逆转。</p><p>实验结果与假设推论相矛盾。可见，期望效用理论中的“决策权重=概率”这一假定并不符合人的真实的决策行为。</p><p>另外，由于C就是25%概率的A，D就是25% 的B，按照期望效用理论的替代性公理，A、B之间的偏好关系，与C、D之间的偏好关系相同，实验结果却是偏好发生了逆转。可见，期望效用理论的替代性公理在人们的实际行为中也不成立。</p><h3 id="2-2-实验二"><a href="#2-2-实验二" class="headerlink" title="2.2 实验二"></a>2.2 实验二</h3><blockquote><p>期望效用理论的不变性公理成立吗?</p></blockquote><p>下面是许多人都熟知的一个实验，但也许并非大家都知道其理论蕴涵。</p><blockquote><p>问题一：想象有一场流行病，预计将杀死600人。有两个预防方案，你希望哪个方案被征服采纳？</p></blockquote><ul><li>如果A方案被采纳，200人将被挽救； 【72%】</li><li>如果B方案被采纳，有 1/3 的可能性 600 人都被挽救，有 2/3 的可能性没有人能得到挽救。  【28%】</li></ul><blockquote><p>问题二：</p></blockquote><ul><li>如果方案 C 被采纳，400 人将死亡;  【22%】</li><li>如果方案 D 被采纳，有 1/3 的可能性没有人死亡并且有 2/3 的可能性 600 人都会死亡。  【78%】</li></ul><blockquote><p>分析</p></blockquote><p>期望效用理论的不变性公理认为:人们的选择不因描述方式不同而改变。 假设这点成立，那么，因为方案 A 等价于方案 C，而 B 等价于 D，所以 A,B 之间的偏好顺序与 C,D 之间的偏 好顺序应该是一样的。但事实上它们是相反的。假设有误。这说明人的决策行为并不遵循期望效用理论的不变性公理。</p><p>另外，上述偏好逆转发生的原因在于:在问题 1 中，被试被诱导把 600 人都会死作为参 考点，从而把问题表征为确定的 200 人被挽救与 1/3 可能的 600 人被挽救之比较;而在问题 2 中，被试被诱导把 0 人死亡作为参考点，从而把问题表征为确定的 400 人死亡与 2/3 可能 的 600 人死亡。问题表征上的这种不同进而导致了决策上的不同。由此我们看到:决策中， 人们并非以财富数值或生命个数的最终状态来计算主观价值，而是根据财富数值或生命个数 相对于参考点的值来计算主观价值。这也违反了期望效用理论。</p><h3 id="2-3-实验三"><a href="#2-3-实验三" class="headerlink" title="2.3 实验三"></a>2.3 实验三</h3><blockquote><p>期望效用理论的优势性公理成立吗?</p><p>问题一：<br>请选择</p></blockquote><ul><li>E.有25%的机会获得240元并有75%的机会失去760元； 【0%】</li><li>F. 有 25%的机会获得 250 元并有 75%的机会失去 750 元 。【100%】</li></ul><blockquote><p>问题二:</p></blockquote><p>假想你面临两组选择。请先仔细阅读两组选择，然后作出选择:</p><p>第一组选择：</p><ul><li>A. 固定得到 240 元【84%】</li><li>B. 25%的机会得到 1000 元，75%的机会得到 0 元。【16%】</li></ul><p>第二组选择：</p><ul><li>C.固定失去 750 元；【13%】</li><li>D.75%的机会失去 1000 元，25%的机会失去 0 元 【87%】</li></ul><blockquote><p>分析:</p></blockquote><p>期望效用理论的优势性公理认为:如果方案 A 在每个方面至少跟方案 B 一样好，而在至少一个方面比 B 更好，那么 A 应该比 B 更可取。假设这点成立，那么，由于 A 优于 B, D 优于 C，那么，A+D 应该优于 B+C;而注意到 A+D=E， B+C=F;所 以，E 应该优于 F。但事实相反，所有的被试都认为 F 优于 E。可见，人们的决策行为并不 遵循期望效用理论的优势性公理。</p><h3 id="2-4-实验四"><a href="#2-4-实验四" class="headerlink" title="2.4 实验四"></a>2.4 实验四</h3><blockquote><p>期望效用理论的“风险回避”原则总是成立吗?</p><p>问题一:</p></blockquote><p>请选择:</p><ul><li>A. 确定得到 1 元;</li><li>B. 1%的可能性得到 100 元，99%的可能性得到 0 元。 </li></ul><p>人们大多会选择 B.</p><blockquote><p>问题二：</p></blockquote><ul><li>C.确定失去 90 元;</li><li>D.有 90%的可能性失去 100 元，有 10%的可能性失去 0 元。</li></ul><p>人们大多会选择 D.</p><blockquote><p>分析</p></blockquote><p>经济学家所用的期望效用理论的“风险回避”原则认为:在按表面结果 值计算有着相等期望值的风险选项与确定选项之间，人们往往会选择确定项而回避风险项。但在上面这些决策问题上，大多数人们风险寻求，而非风险回避。可见期望效用理论的 “风险回避”原则在人们的实际决策行为中并不总是成立。</p><p>事实上，Kahneman 和 Tversky 的研究发现人们的风险态度有如下的模式:</p><div class="table-container"><table><thead><tr><th></th><th>中、大概率</th><th>小概率</th></tr></thead><tbody><tr><td>得</td><td>风险回避</td><td>风险寻求</td></tr><tr><td>失</td><td>风险寻求</td><td>风险回避</td></tr></tbody></table></div><h2 id="三、Kahneman和Tversky的前景理论"><a href="#三、Kahneman和Tversky的前景理论" class="headerlink" title="三、Kahneman和Tversky的前景理论"></a>三、Kahneman和Tversky的前景理论</h2><p>上述实验事实表明：人们的风险决策行为系统地偏离了期望效用理论。那么人们的风险决策行为究竟遵循怎样的规律呢？Kahneman和Tversky提出了前景理论（prospect theory）作为上述问题的答案。</p><p>前景理论的核心内容是：价值函数（曲线）与权重函数（曲线）。</p><h3 id="3-1-价值函数（曲线）"><a href="#3-1-价值函数（曲线）" class="headerlink" title="3.1 价值函数（曲线）"></a>3.1 价值函数（曲线）</h3><p>价值函数把表面价值如金额转化为决策价值，其具体形式是：</p><script type="math/tex; mode=display">v\left(x\right)=\left\{\begin{array}{l}    x^a \ (x>0)\\    -\lambda\left(-x\right)^{\beta}\ (x<0)\\end{array}\right.</script><p>其中x是表面价值如金额的得失，得为正，失为负；v为决策价值。在Kahneman &amp; Tversky的一个研究中，被试者们的中位参数$\alpha = \beta =0.88;\gamma = 2.25$；其他研究者也得到了相近的数值。</p><p>其曲线如下图所示：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3bytfa0j30c107l3yi.jpg" alt=""></p><p>它有如下特点：</p><ul><li>其定义域不是财富，而是财富的变化、得失，即财富相对于某个参考点的差距，这个参考点往往是当前的财富状态。</li><li>整个函数是个递增函数；$v(0) = 0$</li><li>在得（Gains）的区域呈凹形，在失（LOSSES）的区域呈凸形（即当$x&gt;0$时，$v’’(x)<0$;当$x<0$时，$v''(x)>0$）。用通俗的话来说就是，随着$|x|$的不断增大，$v$的变化越来越小。例如，从0元到10元所引起的价值上的变化，要大于从100元到110元所引起的价值上的变化。</0$;当$x<0$时，$v''(x)></li><li>在失的区域的曲线比在得的区域的曲线更加陡峭。通俗地说，失去100元所带来的痛苦的程度要大于100元所带来的快乐的程度。</li></ul><h3 id="3-2-权重函数（曲线）"><a href="#3-2-权重函数（曲线）" class="headerlink" title="3.2 权重函数（曲线）"></a>3.2 权重函数（曲线）</h3><p>权重函数把概率转化为决策权重。当风险前景为两个结果时，其具体的形式如下：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxnbwfo0aj30jd03idfp.jpg" alt=""></p><p>其中，p为概率，$w^+(p)$为得到时的决策权重，$w^-(p)$为失去时的决策权重。在Kahneman的一个实验中，求得被试们的中位参数$\lambda = 0.61,\delta =0.69$。其他研究者也得到相近的结果。</p><p>其曲线如下图所示：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxnc6prmdj30d20btgll.jpg" alt=""></p><ul><li>其中的$w^+$为得到时的权重，$w^-$为失去时的权重。当概率较小时，同等概率下，$w^+$大于$w^-$；当概率中等或较大时，同等概率下，$w^+$小于$w^-$</li></ul><p>无论$w^+$还是$w^-$都有以下特点：</p><ul><li>$w(0)=0$；$w(1)=1$；$w$是$p$的递增函数。</li><li>给予小概率以过高的权重（注意，并非高估小概率，因为被试清除地直到概率是多少；只是小概率所对应的权重高于高于概率本身）</li><li>给予中、高概率以较小的权重，即低于概率自身的权重。</li><li>次确定性：$w(p)+w(1-p)&lt;1$，其中$0&lt;p&lt;1$</li><li>次比例性：$\frac{w(pq)}{w(p)}≤\frac{w(pqr)}{w(pr)}$</li><li>次可加性，包括：<ul><li>下端次可加性：$w(p+q)≤w(p)+w(q)$，其中$p+q&lt;1$</li><li>上端次可加性：$w(1)-w(1-p)≥w(p+q)-w(q)$，其中$p≠0$</li></ul></li></ul><p>计算各个前景的价值，比较并作出选择。应用$v(x)$函数和$w(p)$函数，就能求出各个结果的$v$值和$w$值；把这些$v$值和$w$值代入$V$公式，就能求出各个前景的V值：</p><script type="math/tex; mode=display">V=\sum^n_{i=-m}w_iv(x_i)</script><p>其中V为一个前景的心理价值；$w_i$和$v(x_i)$分别是第i个结果的决策权重和决策价值；结果分得失即正负，所以结果的下标也分正负。然后比较各个前景的V值，选出最高V值的前景</p><p>以上就是前景理论所描述的人们的决策行为规律。</p><p>用上述规律，不仅能够轻易而一致地解释前面提到的各种违背期望效用理论的实验现象；还能很好地解释和预言大量的其他实验现象。Kahneman后来把这个理论应用于经济学领域，对经济学的微观基础产生了巨大的影响，为此，Kahneman获得了2002年的诺贝尔经济学奖。</p><h2 id="四、通俗解释"><a href="#四、通俗解释" class="headerlink" title="四、通俗解释"></a>四、通俗解释</h2><p>在《赌客信条》一书中，作者孙惟微将前景理论归纳为5句话：</p><ul><li>“二鸟在林，不如一鸟在手”，在确定的收益和“赌一把”之间，多数人会选择确定的好处。所谓“见好就收，落袋为安。称之为“确定效应”。</li><li>在确定的损失和“赌一把”之间，做一个抉择，多数人会选择“赌一把”。称之为“反射效应”。</li><li>白捡的100元所带来的快乐，难以抵消丢失100元所带来的痛苦。称之为“损失规避”。</li><li>很多人都买过彩票，虽然赢钱可能微乎其微，你的钱99.99%的可能支持福利事业和体育事业了，可还是有人心存侥幸搏小概率事件。称之为“迷恋小概率事件”。</li><li>多数人对得失的判断往往根据参照点决定，举例来说，在“其他人一年挣6万元你年收入7万元”和“其他人年收入为9万元你一年收入8万”的选择题中，大部分人会选择前者。称之为“参照依赖”。</li></ul><h3 id="4-1-确定效用"><a href="#4-1-确定效用" class="headerlink" title="4.1 确定效用"></a>4.1 确定效用</h3><p>所谓确定效应（certainty effect），就是在确定的好处（收益）和“赌一把”之间，做一个抉择，多数人会选择确定的好处。用一个词形容就是“见好就收”，用一句话打比方就是“二鸟在林，不如一鸟在手”，正所谓落袋为安。</p><p>让我们来做这样一个实验。</p><ul><li>A.你一定能赚30000元。</li><li>B.你有80%可能赚40000元，20%可能性什么也得不到。<br>你会选择哪一个呢？实验结果是，大部分人都选择A。</li></ul><p>传统经济学中的“理性人”这时会跳出来批判：选择A是错的，因为40000×80%=32000，期望值要大于30000。这个实验结果是对“原理1”的印证：大多数人处于收益状态时，往往小心翼翼、厌恶风险、喜欢见好就收，害怕失去已有的利润。卡尼曼和特韦斯基称为“确定效应”（certainty effect），即处于收益状态时，大部分人都是风险厌恶者。</p><p>“确定效应”表现在投资上就是投资者有强烈的获利了结倾向，喜欢将正在赚钱的股票卖出。投资时，多数人的表现是“赔则拖，赢必走”。在股市中，普遍有一种“卖出效应”，也就是投资者卖出获利的股票的意向，要远远大于卖出亏损股票的意向。这与“对则持，错即改”的投资核心理念背道而驰。</p><h3 id="4-2-反射效应"><a href="#4-2-反射效应" class="headerlink" title="4.2 反射效应"></a>4.2 反射效应</h3><p>面对两种损害，你是会选择躲避呢，还是勇往直前？当一个人在面对两种都损失的抉择时，会激起他的冒险精神。在确定的坏处（损失）和“赌一把”之间，做一个抉择，多数人会选择“赌一把”，这叫“反射效应”。用一句话概括就是“两害相权取其轻”。</p><p>让我们来做这样一个实验。</p><ul><li>A.你一定会赔30000元。</li><li>B.你有80%可能赔40000元，20%可能不赔钱。</li></ul><p>你会选择哪一个呢？投票结果是，只有少数人情愿“花钱消灾”选择A，大部分人愿意和命运抗一抗，选择B。</p><p>传统经济学中的“理性人”会跳出来说，两害相权取其轻，所以选B是错的，因为（-40000）×80%=-32000，风险要大于-30000元。现实是，多数人处于亏损状态时，会极不甘心，宁愿承受更大的风险来赌一把。也就是说，处于损失预期时，大多数人变得甘冒风险。卡尼曼和特韦斯基称为“反射效应”（reflectioneffect）。</p><p>“反射效应”是非理性的，表现在股市上就是喜欢将赔钱的股票继续持有下去。统计数据证实，投资者持有亏损股票的时间远长于持有获利股票。投资者长期持有的股票多数是不愿意“割肉”而留下的“套牢”股票。</p><h3 id="4-3-损失规避"><a href="#4-3-损失规避" class="headerlink" title="4.3 损失规避"></a>4.3 损失规避</h3><p>如何理解“损失规避”？用一句话打比方，就是“白捡的100元所带来的快乐，难以抵消丢失100元所带来的痛苦”。前景理论最重要也是最有用的发现之一是：当我们做有关收益和有关损失的决策时表现出的不对称性。对此，就连传统经济学的坚定捍卫者 保罗·萨缪尔森，也不得不承认：“增加100元收入所带来的效用，小于失去100元所带来的效用。”</p><p>这其实是前景理论的第3个原理，即“损失规避”（loss aversion）：大多数人对损失和获得的敏感程度不对称，面对损失的痛苦感要大大超过面对获得的快乐感。</p><p>行为经济学家通过一个赌局验证了这一论断。</p><p>假设有这样一个赌博游戏，投一枚均匀的硬币，正面为赢，反面为输。如果赢了可以获得50000元，输了失去50000元。请问你是否愿意赌一把？请做出你的选择。</p><ul><li>A.愿意</li><li>B.不愿意</li></ul><p>从整体上来说，这个赌局输赢的可能性相同，就是说这个游戏的结果期望值为零，是绝对公平的赌局。你会选择参与这个赌局吗？但大量类似实验的结果证明，多数人不愿意玩这个游戏。为什么人们会做出这样的选择呢？这个现象同样可以用损失规避效应解释，虽然出现正反面的概率是相同的，但是人们对“失”比对“得”敏感。想到可能会输掉50000元，这种不舒服的程度超过了想到有同样可能赢来50000元的快乐。由于人们对损失要比对相同数量的收益敏感得多，因此即使股票账户有涨有跌，人们也会更加频繁地为每日的损失而痛苦，最终将股票抛掉。一般人因为这种“损失规避”（loss aversion），会放弃本可以获利的投资。</p><h3 id="4-4-迷恋小概率事件"><a href="#4-4-迷恋小概率事件" class="headerlink" title="4.4 迷恋小概率事件"></a>4.4 迷恋小概率事件</h3><p>买彩票是赌自己会走运，买保险是赌自己会倒霉。这是两种很少发生的事件，但人们却十分热衷。前景理论还揭示了一个奇特现象，即人类具有强调小概率事件的倾向。</p><p>何谓小概率事件？就是几乎不可能发生的事件。如天上掉馅饼，这就是个小概率事件。掉的是馅饼固然好，但如果掉下来的不是馅饼而是陷阱呢？当然也属于小概率事件。</p><p>面对小概率的赢利，多数人是风险喜好者。面对小概率的损失，多数人是风险厌恶者。<br>事实上，很多人都买过彩票，虽然赢钱可能微乎其微，你的钱99.99%的可能支持福利事业和体育事业了，可还是有人心存侥幸搏小概率事件。</p><p>同时，很多人都买过保险，虽然倒霉的概率非常小，可还是想规避这个风险。人们的这种倾向，是保险公司经营下去的心理学基础。</p><p>在小概率事件面前人类对风险的态度是矛盾的，一个人可以是风险喜好者，同时又是风险厌恶者。传统经济学无法解释这个现象。</p><p>小概率事件的另一个名字叫运气。侥幸，就是企求好运，邀天之幸。孔子很反感这种事，他说：“小人行险以侥幸。”庄子认为孔子是个“灯下黑”，他借盗跖之口评价孔子：“妄作孝弟，而侥幸于封侯富贵者也。”对小概率事件的迷恋，连圣人也不能免俗。</p><p>前景理论指出，在风险和收益面前，人的“心是偏的”。在涉及收益时，我们是风险的厌恶者，但涉及损失时，我们却是风险喜好者。但涉及小概率事件时，风险偏好又会发生离奇的转变。所以，人们并不是风险厌恶者，他们在他们认为合适的情况下非常乐意赌一把。归根结底，人们真正憎恨的是损失，而不是风险。</p><p>这种损失厌恶而不是风险厌恶的情形，在股市中常常见到。比如，我们持有一只股票，在高点没有抛出，然后一路下跌，进入了彻彻底底的下降通道，这时的明智之举应是抛出该股票，而交易费用与预期的损失相比，是微不足道的。</p><p>扪心自问，如果现在持有现金，还会不会买这只股票？你很可能不会再买吧，那为什么不能卖掉它买别的更好的股票呢？也许，卖了它后损失就成了“事实”吧。</p><h3 id="4-5-参照依赖"><a href="#4-5-参照依赖" class="headerlink" title="4.5 参照依赖"></a>4.5 参照依赖</h3><p>假设你面对这样一个选择：在商品和服务价格相同的情况下，你有两种选择：</p><ul><li>A.其他同事一年挣6万元的情况下，你的年收入7万元。</li><li>B.其他同事年收入为9万元的情况下，你一年有8万元进账。</li></ul><p>卡尼曼的这调查结果出人意料：大部分人选择了前者。事实上，我们拼命赚钱的动力，多是来自同侪间的嫉妒和攀比。我们对得与失的判断，是来自比较。嫉妒总是来自自我与别人的比较，培根曾言：皇帝通常不会被人嫉妒，除非对方也是皇帝。对此，美国作家门肯早有妙论：“只要比你小姨子的丈夫（连襟）一年多赚1000块，你就算是有钱人了。”</p><p>传统经济学认为金钱的效用是绝对的，行为经济学则告诉我们，金钱的效用是相对的。这就是财富与幸福之间的悖论。到底什么是“得”，什么是“失”呢？你今年收入20万元，该高兴还是失落呢？假如你的奋斗目标是10万元，你也许会感到愉快；假如目标是100万元，你会不会有点失落呢？所谓的损失和获得，一定是相对于参照点而言的。卡尼曼称为“参照依赖”（Reference Dependence）。</p><p>老张最幸福的时候是他在20世纪80年代做“万元户”的时候，虽然现在自己的村镇已经改造成了城市，拆迁补贴也让自己成为了“百万元户”，但他感觉没有当年兴奋，因为邻里都是“百万元户”了。</p><p>讲这个故事的用意不难明白，我们就不再进行烦琐的论证了 得与失都是比较出来的结果。传统经济学的偏好理论（Preference theory）假设，人的选择与参照点无关。行为经济学则证实，人们的偏好会受到单独评判、联合评判、交替对比及语意效应等因素的影响。</p><p>参照依赖理论：多数人对得失的判断往往根据参照点决定。一般人对一个决策结果的评价，是通过计算该结果相对于某一参照点的变化而完成的。人们看的不是最终的结果，而是看最终结果与参照点之间的差额。一样东西可以说成是“得”，也可以说成是“失”，这取决于参照点的不同。非理性的得失感受会对我们的决策产生影响。</p><p>综上，前景理论引申出五个基本结论</p><ul><li>确定效应：处于收益状态时，多数人是风险厌恶者。</li><li>反射效应：处于损失状态时，多数人是风险喜好者。</li><li>迷恋小概率事件：面对小概率的赢利，多数人是风险喜好者；面对小概率的损失，多数人是风险厌恶者。</li><li>损失规避：多数人对损失比对收益敏感。</li><li>参照依赖：多数人对得失的判断往往由参照点决定。</li></ul><p>简言之，人在面临获利时，不愿冒风险；而在面临损失时，人人都成了冒险家。而损失和获利是相对于参照点而言的，改变评价事物时的参照点，就会改变对风险的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓决策，就是在几个方案中选择一个方案，分为风险决策和非风险决策。在非风险决策中，各个方案的结果都是确定的。在风险决策中，有的方案有的结果是不确定的，即可能发生，也可能不发生。我们这里谈及的就是风险决策。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="前景理论" scheme="http://yoursite.com/tags/%E5%89%8D%E6%99%AF%E7%90%86%E8%AE%BA/"/>
    
      <category term="卡尼曼" scheme="http://yoursite.com/tags/%E5%8D%A1%E5%B0%BC%E6%9B%BC/"/>
    
      <category term="行为经济学" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>日知录（1）：MacTips</title>
    <link href="http://yoursite.com/2017/12/05/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%881%EF%BC%89%EF%BC%9AMacTips%20/"/>
    <id>http://yoursite.com/2017/12/05/日知录（1）：MacTips /</id>
    <published>2017-12-05T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1.终端输入说英语</p></blockquote><p>说英语时我们当然希望有标准发音。在Mac中不需要字典，直接在终端里输入say yes，Mac就会说英语了。</p><a id="more"></a><blockquote><p>2.Spotlight快速打开程序</p></blockquote><p>很多刚开始使用Mac的用户，一般都知道Spotlight检索功能。事实上，用这个功能还可以快速打开程序。通过ctrl+space呼出，或者输入通讯或cont都可以找到通讯录这个程序，回车即可打开。</p><blockquote><p>3.Spotlight注释功能定位文件</p></blockquote><p>OS X的文件系统提供了Spotlight注释功能，可以帮助用户更有针对性地定位文件。选中一个文件或文件夹，command+i打开简介，在Spotlight注释功能中加入自己特定的关键词。关掉简介窗口，呼出Spotlight并输入刚才的关键词，可以准确定位到相关的文件或文件夹。</p><blockquote><p>4.使用sips命令批量处理图片</p></blockquote><p>如果你想批量修改一批图片（尺寸、旋转、反转等），但你不会或没有PS，可以使用sips命令高效完成这些功能，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">##把当前用户图片文件夹下的所有JPG图片宽度缩小为800px，高度按比例缩放</div><div class="line">sips -Z 800～/Pictures/.JPG</div><div class="line">##顺时针旋转90˚</div><div class="line">sips -r 90～/Pictures/.JPGwdhjf</div><div class="line">##垂直反转</div><div class="line">sips -f vertical ～/Pictures/.JPG</div></pre></td></tr></table></figure><p>更多命令可以用sips -h查看。</p><blockquote><p>5.把当前网页附加到待发送邮件中</p></blockquote><p>使用Safari浏览网页的时候，如果你想把当前页面通过邮件发送给自己或别人，使用command+i可以直接打开邮件并把当前网页附加到待发送的邮件中。</p><blockquote><p>6.快速删除文件和清空废纸篓</p></blockquote><p>在Finder中选中文件，使用command+delete删除文件。如果想彻底清除，使用shift+command+delete就会自动清空废纸篓。</p><blockquote><p>7.获悉目录空间</p></blockquote><p>在Mac下想知道某个目录下各个文件和子目录各占多少空间，不需要一个一个去查看。打开终端，在该目录下输入du-sh*，结果一目了然。</p><blockquote><p>8.英文自动完成</p></blockquote><p>当使用系统软件文本编辑、Pages和Keynote时，输入英文按esc键，系统会帮助你自动完成单词。比如你想输入“brilliance”，只需输入“brill”，按esc键，系统就会出现自动提示。如果某个应用，比如Safari的搜索框里esc是取消输入，那么使用fn+F5也可以达到这个效果。对于常写英文文档的人比较有帮助。</p><blockquote><p>9.文件操作</p></blockquote><p>在Finder中打开文件使用鼠标双击或按command+o键。和Windows不一样的是，选中文件回车是对文件重命名，而不是打开文件。</p><blockquote><p>10.显示隐藏文件</p></blockquote><p>在终端里输入ls-a，可以显示该目录下的隐藏文件。在Finder中按shift+command+.键可以显示隐藏文件，想恢复原来的设置，再按一遍shift+command+.即可。</p><blockquote><p>11.利用你的触发角</p></blockquote><p>OS X系统为用户提供了强大的Mission Control功能，今天为大家介绍其中的触发角。打开“系统偏好设置”→“Mission Control”→“触发角”，就可以对屏幕的四个角进行设置了。比如把左上角设置为将显示器置为睡眠状态，当我们暂时离开电脑时，顺手把鼠标移到左上角，屏幕就变黑了，非常方便。</p><blockquote><p>12.维护你的Mac</p></blockquote><p>Mac的OS X是一个使用起来非常简单的操作系统，一般情况下不需要装杀毒工具，大部分程序安装都非常简单，直接把后缀为app的程序拖进应用程序文件夹就可以了。但是，当你在使用系统时如果发现出现异常，那么就该进行日常维护了。<br>打开磁盘管理，选中你的系统盘，单击“修复磁盘权限”，对磁盘权限进行检查和修复。完成之后还可以手动执行维护脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo periodic daily</div><div class="line">sudo periodic weekly</div><div class="line">sudo periodic monthly</div></pre></td></tr></table></figure><p>也可以一次全部执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo periodic daily weekly monthly</div></pre></td></tr></table></figure><p>一般执行完这些操作后，你的Mac就会充满活力，可以继续上路了。这些操作可以定期执行。</p><blockquote><p>13.Mission Control</p></blockquote><p>设置中把“使窗口按应用程序成组”关掉，Mission Control的行为就会跟10.7以前的Exposé一样，不会把同一个程序的多个窗口叠在一起。对经常一个程序开很多窗口的程序员来说很有用。</p><blockquote><p>14.截图</p></blockquote><p>OS X提供了非常方便的截图工具，你可以随时随地截取屏幕画面。<br>shift+command+3：全屏幕截图；shift+command+4：通过鼠标选取截图。截取的图片默认存放在桌面上，以时间命名。系统默认截图格式是png，你可以通过如下命令修改截图文件类型，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture type -string JPEG</div></pre></td></tr></table></figure><blockquote><p>15.推荐几个有用的小工具</p></blockquote><p>◆TotalFinder：Finder的增强插件，Finder的插件，为Finder增加多标签（类似Chrome的多页签）、双面板、UI设置等功能。收费软件。<br>◆Breeze：窗口管理软件，option+1/2/3分别对应最大化窗口/左半屏幕窗口/右半屏幕窗口。收费软件。<br>◆Trillian：整合了MSN、GTalk、Twitter等，表现稳定，用户体验也不错。免费软件，可以从AppStore直接下载。<br>◆smcFancontrol：风扇控制软件，免费。OS X对风扇控制不敏感，CPU温度很高时才会增加风扇转速，那时机器表面已经比较热了。用这个软件可以自由控制风扇转速。夏天空调屋里一般3000～4000转就够了，冬天一般不需要开启。</p><blockquote><p>16.Mac的原生输入法</p></blockquote><p>我在Mac下曾经使用过很多输入法，包括百度、FIT、搜狗等，这是因为之前Mac的原生输入法太不给力了。不过现在的版本已经有了很大的改进，慢慢地也变成了常用输入法之一。今天就为大家介绍一些Mac输入法的操作技巧。<br>◆中英文混合输入：输入中文的时候，打开caps lock键，可以直接输入英文，关掉又切换回中文。<br>◆选词：通过-+号可以切换字或词，通过[]可以展开候选词列表并进行切换。<br>◆打开输入法偏好设置，可以设置自动校正模糊音。<br>◆用’可以进行手动分词，比如“fang’an（方案）”。<br>◆使用shift+6可以输入表情符号，比如“（☆_☆）”和“凸^-^凸”。<br>用习惯了，你会离不开这个输入法的。</p><blockquote><p>17.Safari的标签</p></blockquote><p>Safari是我在Mac上最常用的浏览器，Chrome也不错，但我更偏爱Safari。今天为大家介绍一下这个浏览器的标签使用。<br>当你想在新的标签页打开网页时，只需要按住command键，单击链接即可。使用Multi-Touch手势在标签页中切换。在触控板上，双指开合即可显示你打开的标签页。在标签视图中，双指轻扫可浏览不同标签页。<br>通过shift+command+左右方向键，可以快速在Safari中打开的标签中进行切换。</p><blockquote><p>18.监控Mac的运行状况</p></blockquote><p>◆top：打开终端输入top，可以显示目前系统的进程情况、CPU使用情况、内存使用情况、磁盘使用情况和进程的详细列表等信息，输入“?”会显示帮助信息，参考帮助你还可以自定义top显示的信息，输入“q”退出监控界面。<br>◆htop：htop是更聪明更高级的top，虽然不是Mac原生的，但安装非常方便。打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install htop</div></pre></td></tr></table></figure><p>命令结束就安装完成了。然后键入htop，你会看到一个更丰富的彩色的top，多个CPU、内存统计、uptime，以及更详细的进程信息。参考界面最底部的帮助信息还可以进行排序、展开和Kill。输入q退出监控界面。<br>◆系统的活动监视器：这个非常适合不喜欢终端的用户。从应用程序→实用工具可以找到活动监视器，打开后你会发现很类似Windows下的任务管理器，相信这个不需要给大家介绍了。</p><blockquote><p>19.批量复制文件</p></blockquote><p>例如你在一个目录下林林总总放了几百个文件，有图片、pdf、zip、doc等，你想把后缀为png、jpeg、gif的图片复制到另一个文件夹去，最简单的方式是什么？不是通过搜索把这些文件找出来，再全选复制到另一个文件夹下。而是进入该目录，执行这样一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp *.png *.jpeg *.gif /destpath</div></pre></td></tr></table></figure><p>如果想剪切，就把cp改为mv。</p><blockquote><p>20.程序切换</p></blockquote><p>在OS X中程序切换可以通过command+tab进行，command+tab进行顺序切换，command+shift+tab进行逆序切换，功能类似Win7的alt+tab。<br>OS X还提供了同组程序的切换，比如你打开了多个预览程序阅读pdf，你想在这些pdf之间切换阅读，这时候就可以使用command+`（esc下面的键）进行同组程序切换。</p><blockquote><p>21.远程复制</p></blockquote><p>OS X提供了基于SSH的远程复制命令scp，这个命令大部分Linux和Unix系统都会提供，使用该命令可以非常方便地在两台机器之间安全地复制文件，具体命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp ./testfile.txt  username@10.10.10.22:/tmp</div></pre></td></tr></table></figure><p>回车后会要求你输入username的密码，只会将当前目录下的testfile.txt复制到另一台机器的tmp目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp username@10.10.10.22:/tmp/testfile.txt  ./</div></pre></td></tr></table></figure><p>从远端复制到本地。</p><blockquote><p>22.OS X中的ftp</p></blockquote><p>这个问题有订阅者问过，总结一下，以下三种方式就够用了。<br>◆直接在命令行使用。打开终端输入ftp anonymous@ftp.mozilla.org，或者使用sftp通过SSH完成ftp的功能，例如sftp user@10.10.10.11。<br>◆使用第三方工具。比如FileZilla，用法和Windows类似。<br>◆利用OS X原生FTP工具。从Finder菜单栏中进入“前往”→“连接服务器…”，输入FTP服务器地址,如 ftp://ftp.mozilla.org , 单击地址栏右侧的“+”号按钮可以将当前地址加入“个人收藏服务器”，单击“连接”按钮，按照提示进行身份验证，成功后即可连接到FTP服务器。</p><blockquote><p>23.备份</p></blockquote><p>OS X提供了非常方便的备份工具TimeMachine（时间机器），我第一台Mac用的操作系统是Leopard，后来升级到Snow Leopard→Lion→MountainLion，再后来换新机器，但从未重装过系统。这对于Windows系统来说是不可想象的，这都得益于时间机器。我个人每周会备份一次，如果你觉得自己资料非常重要，可以每隔几小时备份一次。具体的用法我就不介绍了，可以参考官方介绍：<a href="http://support.apple.com/kb/HT1427?viewlocale=zh_CN。" target="_blank" rel="noopener">http://support.apple.com/kb/HT1427?viewlocale=zh_CN。</a></p><blockquote><p>24.inode和history</p></blockquote><p>◆inode：Mac的文件系统和Windows完全不同，文件所需信息都包含在这个inode（索引节点）里。每个文件都有inode，文件系统用inode来标识文件。简单来说就是inode包含了文件的元数据信息，文件名、文件内容，但不包含任何控制信息。inode是Unix/Linux系列文件系统设计的核心，有兴趣的同学可以上网查阅相关资料。对于普通用户用来，最直观的表现是，在Mac里，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用。<br>◆history：打开终端输入history，所有的历史命令都会显示出来，想找某一条执行过的命令，还可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history | grep apache</div></pre></td></tr></table></figure><p>找到左边的命令编号（例如1001），在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!1001</div></pre></td></tr></table></figure><p>就可以执行原来那条命令了。</p><blockquote><p>25.Go2Shell</p></blockquote><p>通过Finder浏览文件的时候，常常需要在浏览的文件目录中打开终端进行操作，Go2Shell能够自动做到这一点。从App Store下载这个免费软件 <a href="https://itunes.apple.com/us/app/go2shell/id445770608?mt=12" target="_blank" rel="noopener">https://itunes.apple.com/us/app/go2shell/id445770608?mt=12</a>  ,下载完成后从应用程序文件夹把Go2Shell拖到Finder工具栏上，然后随便进入一个目录，单击Go2Shell图标，即可打开终端进入该目录。<br>Go2Shell支持原生终端、iTerm2和xterm，在终端输入open-a Go2Shell—args config即可进入配置界面，选择你喜欢的终端。</p><blockquote><p>26.Safari的阅读器</p></blockquote><p>Safari的阅读器是浏览器创新之一，在Safari之前，没有其他浏览器提供过这样的功能。当Safari发现结构优良的网页文档时，就会在地址栏右侧显示“阅读器”，单击就可以进入简洁的阅读模式，通过shift+command+r也可以进入。</p><p>阅读器已经提供了良好的网页阅读体验，对于分页文档甚至能够自动翻页阅读，但是我们还可以更进一步。比如我就觉得阅读器太窄了，视野不够宽阔。有类似需求的同学就可以通过Safari的扩展插件CustomReader进行个性化定义。</p><p>从<a href="http://canisbos.com/customreader" target="_blank" rel="noopener">http://canisbos.com/customreader</a> 下载CustomReader ,双击即可安装。安装之后到任何一个支持阅读器的网页，按下shift+command+r激活阅读器，再用ctrl+r调出配置页面，就可以配置你自己独享的个性化阅读器了。</p><blockquote><p>27.Remote Desktop Connection for Mac</p></blockquote><p>很多读者询问如何在Mac中通过远程桌面连接到Windows，这次统一答复一下，微软提供了专门的Remote Desktop Connection for Mac，免费，下载链接：<a href="http://www.microsoft.com/mac/remote-desktop-client。" target="_blank" rel="noopener">http://www.microsoft.com/mac/remote-desktop-client。</a></p><blockquote><p>28.文档的版本控制</p></blockquote><p>经常使用Keynote、Pages、Numbers和原生文本编辑器的用户，可以尝试使用文档的版本控制功能。对于经常编写文档的人来说，这个功能非常有用。大家可能没有注意到，当你把鼠标移至文档标题的时候，会出现一个小箭头，下拉可以看到浏览所有版本的选项，单击进入该文档的时间线，界面与Time Machine一模一样，你可以非常方便地找到任何一时间点你编辑过的内容，也可以随意恢复到任何一个版本而不会影响其他版本。非常酷的功能，并且好用。</p><blockquote><p>29.如何快速发送带附件的邮件</p></blockquote><p>在Windows中，我们可以右键单击文件发送到邮箱即可发送带附件的邮件。OS X也有类似功能，只不过叫共享。右键单击要发送的文件→“共享”→“电子邮件”即可。</p><blockquote><p>30.如何快速创建便笺</p></blockquote><p>便笺是我们很常用的功能，可以把一些临时性的文字内容贴到桌面上，大家是如何做的呢？复制文字，打开便笺程序，新建便笺，粘贴文字！Too young too complicated，我们只需要选中文字，然后shift+command+y，就行了。</p><blockquote><p>31.Mac的通用快捷键</p></blockquote><p>这部分内容之前陆续介绍过，但还是有人希望有个汇总，基于二八原则，我把最常用的快捷键罗列一下，对于非开发者，应该够用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">command+tab                  任意情况下切换应用程序，向前循环</div><div class="line">shift+command+tab            切换应用程序，向后循环</div><div class="line">command delete               把选中的资源移到废纸篓</div><div class="line">shift+command+delete         清倒废纸篓（有确认）</div><div class="line">shift+option+command+delete   直接清倒废纸篓</div><div class="line">command+～                    同一应用程序多窗口间切换</div><div class="line">command+f                    呼出大部分应用程序的查询功能</div><div class="line">command+c/v/x                复制/粘贴/剪切</div><div class="line">command+n                    新建应用程序窗口</div><div class="line">command+q                    彻底退出当前应用程序</div><div class="line">command+l                    当前程序是浏览器时，可以直接定位到地址栏</div><div class="line">command+&quot;+/-&quot;                放大或缩小字体</div><div class="line">control+space                呼出Spotlight</div><div class="line">command+space                切换输入法</div></pre></td></tr></table></figure><p>对于最后两个快捷键，我个人比较习惯control+space切换输入法，所以做了自定义的配置。</p><blockquote><p>32.终端命令open</p></blockquote><p>我们之前介绍过如何在Finder中浏览文件时进入当前目录的shell界面，那个插件叫做Go2Shell。当然我们也会有在shell下打开当前目录的Finder的需求，运行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">open .</div><div class="line">#当然open也可以打开其他目录，比如</div><div class="line">open /Users</div><div class="line">#open还可以直接打开文件、打开程序、指定程序打开文件、打开网址等，例如</div><div class="line">open a.txt</div><div class="line">open -a Safari</div><div class="line">open -a TextMate a.txt</div><div class="line">open http://news.sina.com.cn</div></pre></td></tr></table></figure><blockquote><p>33.介绍小软件——CatchMouse</p></blockquote><p>可以自定义快捷键快速在多个显示器内切换鼠标，非常方便，链接附上：<a href="https://itunes.apple.com/cn/app/catchmouse/id439700005?mt=12。" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/catchmouse/id439700005?mt=12。</a></p><blockquote><p>34.激活窗口</p></blockquote><p>如果你在一个屏幕内打开了多个程序，除了当前激活的软件窗口，你还想看看其他窗口的内容，这时你直接单击其他窗口的话，原来的窗口就可能被遮挡或消失。如何保持原来的窗口一直处于最上层呢？非常简单，拖曳其他窗口的时候按住command键即可，原来的窗口会永远在最上面。</p><blockquote><p>35.文件检查器</p></blockquote><p>在Windows中大家经常选中多个文件，单击右键→“属性”可以查看这些文件的大小。在Mac里同样的操作（选中多个文件，单击右键→“显示简介”）弹出的是各个文件或文件夹的简介，这让很多人困惑不解。其实我们只要在单击右键的同时按住option键，“显示简介”就会变成“显示检查器”，单击“显示检查器”即可查看和操作批量文件。<br>另外，我还经常用这种方式浏览图片，比如选中多张图片，按住option键单击鼠标右键，选中“幻灯片显示xx项”，就可以全屏浏览图片了。</p><blockquote><p>36.屏幕放大镜</p></blockquote><p>有时我们需要放大屏幕做一些精细的操作，Ctrl+鼠标滚轮可以实现这一效果，如果你是键盘控，用option+command加上加减号也可以实现。</p><blockquote><p>37.语音识别</p></blockquote><p>Mountain Lion增加了语音识别的功能，具体的设置在“系统偏好设置”→“听写与语音”，可以设置听写语言、呼出窗口的快捷键等。我采用的是默认的快捷键，连续按fn键两次即可呼出语音识别窗口，这时候你就可以对Mac说话了。如果你想让Mac把你说的写下来，最好打开一个的文本编辑器并让光标处于可编辑状态。注意，该功能需要联网。</p><blockquote><p>38.time命令</p></blockquote><p>如果你想知道在终端执行的某个程序耗时多久，对CPU等的使用情况，可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">time python fib.py</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python fib.py  0.02s user 0.02s system 50% cpu 0.094 total</div></pre></td></tr></table></figure><blockquote><p>39.特殊字符输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">美元（$）              shift+4</div><div class="line">美分（¢）              option+4</div><div class="line">英镑（£）              option+3</div><div class="line">人民币（¥）            option+Y</div><div class="line">欧元（€）             shift+option+2</div><div class="line">连接号（–）           option+-</div><div class="line">破折号（—）           shift+option+-</div><div class="line">省略号（...）          option+;</div><div class="line">约等于（≈）           option+X</div><div class="line">度（°）                shift+option+8</div><div class="line">除号（÷）              option+/</div><div class="line">无穷大（∞）           option+5</div><div class="line">小于等于（≤）         option+,</div><div class="line">大于等于（≥）         option+.</div><div class="line">不等于（≠）           option+=</div><div class="line">圆周率（π）           option+P</div><div class="line">正负（±）              shift+option+=</div><div class="line">平方根（√）           option+V</div><div class="line">总和（∑）             option+W</div><div class="line">商标（™）             option+2</div><div class="line">注册（®）              option+R</div><div class="line">版权（©）              option+G</div></pre></td></tr></table></figure><blockquote><p>40.OS X三指轻拍查找功能</p></blockquote><p>OS X提供了三指轻拍查找的功能，什么意思呢？把光标移到一个单词上面，无需选中，三指轻拍，系统就会弹出词典显示相关单词的释义，非常方便。该功能可以在“系统偏好设置”→“触控板”里进行设置。</p><blockquote><p>41.F.lux调节屏幕色温</p></blockquote><p>推荐一款免费小软件F.lux。这个软件功能类似系统的亮度自动调节，不同的是它调节的是屏幕的色温。该软件能够根据时间来调节屏幕色温以达到保护眼睛的目的。有数据表明，4600～5000K的暖色有缓解眼部疲劳的作用。下载地址：<a href="http://stereopsis.com/flux/。" target="_blank" rel="noopener">http://stereopsis.com/flux/。</a><br>第一次打开应用，需要输入当前城市名称，搜索定位用户的当地时间。F.lux将根据日出及日落的时间来调节色温。在日出日落期间，屏幕色温和平时一样，对于RMBP来时就是6500K；日落之后，F.lux会逐渐地暖化你的屏幕。具体色温可以自定义。<br>我用了之后感觉还不错，大家可以试用下。</p><blockquote><p>42.让Mac不进入休眠状态</p></blockquote><p>如果你想离开电脑一段时间，又不想让电脑进入休眠状态，有个简单的命令可以帮助你做到这一点。在终端中输入：pmset noidle，即可。只要该命令一直运行，Mac就不会进入睡眠状态。关掉终端或ctrl+C可以取消该命令。pmset是OS X提供的命令行管理电源的工具，其功能远不止于此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pmset -g    #查看当前电源的使用方案</div><div class="line">sudo pmset -b displaysleep 5    #设置电池供电时，显示器5分钟内进睡眠</div><div class="line">sudo pmset schedule wake &quot;02/01/13 20:00:00&quot;    #设置电脑在2013年2月1日20点唤醒电脑    ……</div></pre></td></tr></table></figure><p>感兴趣的可以使用man pmset查看详细信息。</p><blockquote><p>43.网络共享</p></blockquote><p>Mac提供了非常简单易用的Internet共享功能，可以作为一个轻量级的家庭无线路由使用。只要你的Mac能够上网，那么Phone和Pad等设备就都可以通过Wi-Fi共享Mac的网络，实现无线上网。具体的设置非常简单，打开“系统偏好设置”→“共享”→“互联网共享”，选择共享源（网卡或AirPort），并设置Wi-Fi的名称、密码、安全级别等属性，最后勾选左侧列表的“互联网共享”，根据提示操作即可。<br>这是一个我曾经认为大部分用户都知道的功能，后来发现几乎很少人使用或会用。</p><blockquote><p>44.快速查看</p></blockquote><p>OS X提供了非常方便的预览文件内容的功能。在Finder或桌面上，选中一个文件并按空格键，系统就会弹出预览界面。对于很多文件我们仅仅使用快速查看功能就可以浏览文件内容了，比如iWorks的Keynote、Pages和Numbers的文档，微软Office的文档，pdf，图片，视频，各类文本文件等。除了在Finder和桌面快速查看文件，我们还可以快速浏览邮件的附件。打开邮件程序，找到一个带有附件的邮件，选中附件并按空格键，就可以快速浏览附件内容。<br>我们还可以在终端操作的时候使用这个功能，例如qlmanage-p文件名，系统就会弹出快速查看窗口。</p><blockquote><p>45.显示桌面</p></blockquote><p>我们下载文件或临时文件经常会放到桌面上，在Windows里通过alt+d或点击显示桌面的图标即可，在Mac里如何实现呢？<br>有两种方式，都很方便。第一种是四指划开，该功能可以在触控板里设置。还有一种方式是通过快捷键command+F3，即可实现移开程序显示桌面的功能。当我们想把桌面的文件放入某个程序（比如当做邮件附件）时，可以配合command+tab实现。用鼠标拖动桌面文件，command+tag切换程序，然后把文件拖入该程序即可。</p><blockquote><p>46.应用程序的安装和卸载</p></blockquote><p>OS X中的应用程序和OSGi中使用的Bundle类似，都是把配置文件和程序封装在一个包里。对于普通用户来说，你在Launchpad中看到的所有程序都像一个图标，但这个图标不是Windows中的快捷方式，而是封装好的Bundle，从程序角度而言这是一个文件夹，对普通用户来说，知道点这个图标运行程序就行了。这种设计方式使得OS X中95%以上的软件的安装变得十分简单。如果你是从Windows转过来的话，你会认为安装和卸载简单得令人发指。安装程序就是把XXX.app拖进/Applications（应用程序文件夹），卸载就是把程序从该目录删掉。好吧，你可以这么理解，OS X中95%以上的软件都是Windows中的“绿色软件”。</p><blockquote><p>47.磁盘映像</p></blockquote><p>磁盘映像类似Windows中的iso，不过文件后缀为dmg。磁盘映像可以直接挂接到OS X中，其表现形式就像是磁盘分区。双击文件可以直接打开，打开后在Finder左边栏的设备中可以找到挂接好的磁盘映像。dmg是Mac下最常用的文件组织方式，几乎所有的安装程序都是以dmg方式发布的。一般情况下安装程序就是打开相关程序的dmg文件，里面有一个app和应用程序文件夹，把app拖入应用程序即可。另外我们也可以使用磁盘工具把dmg里的文件恢复为真正的硬盘文件，也可以制作dmg文件。</p><blockquote><p>48.复制目录下文件名列表</p></blockquote><p>如何复制某个目录下所有文件的文件名列表呢？非常简单，command+a，command+c。然后打开一个文本编辑器（比如TextMate），command+v即可。</p><blockquote><p>49.多点触控手势</p></blockquote><p>当我们用Safari浏览网页时，经常想回到之前浏览过的历史页面。使用多点触控手势可以非常容易直观地实现该功能。打开Safari浏览多个页面，然后使用双指左右轻扫，可以来回切换浏览页面。</p><p>另外，如果你在浏览时不小心关掉了一个标签页，使用command+z可以恢复最后关闭的那个标签页。</p><blockquote><p>50.OS X的预览程序</p></blockquote><p>OS X的预览程序可以打开各类图片和pdf等类型的文件，当你想查看某个图片或pdf的细节时，没必要用command++/-来缩放整个文件，使用`键可以呼出放大镜，细节一览无遗。</p><blockquote><p>51.显示/隐藏桌面内容快捷键</p></blockquote><p>我们经常会在桌面上堆满文件夹和文件，有时候会很方便，有时候会觉得很乱。其实我们可以通过以下命令来决定什么时候显示，什么时候隐藏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chflags hidden ～/Desktop/*     //隐藏桌面内容</div><div class="line">chflags nohidden ～/Desktop/*   //显示桌面内容</div></pre></td></tr></table></figure><p>如果觉得输入麻烦，用TextExpander或Alfred设置成snippet即可。</p><blockquote><p>52.按住option的快捷键</p></blockquote><p>OS X设置了一些快捷键用来快速打开显示器、Mission Control、键盘、声音等系统设置，具体是什么呢？你只要按住option，轮番把键盘最上方的那排键试一下就知道了，一般人我不告诉他。</p><blockquote><p>53.Space（空间）</p></blockquote><p>使用OS X，我们可以充分利用系统提供的多个Space，把不同的程序放到不同的Space，让我们的系统更有扩展性。如何增加Space呢？四指上推，在桌面的最上方会出现当前的Space，把鼠标移到Space列表的右侧，会出现一个带+号的空间，单击加号，即可增加一个Space。<br>那么如何把某个程序固定在某个Space打开呢？在某个Space打开程序，在Dock中找到这个程序图标，鼠标长按会出现一个菜单，“选项”→“分配给”，选“这个桌面”，下次再打开这个程序，就会自动进入设定的Space。</p><p>Space的排列方式可以在Mission Control里设置，比如选择按照使用情况自动排列等。</p><blockquote><p>54.隐藏程序</p></blockquote><p>当我们不想在使用当前程序的时候看到其他程序的时候，可以使用快捷键option+command+h，这时除了你正在使用的程序，其他所有的程序都会被隐藏起来，有助于你专心工作。想切换到其他程序时，可以使用command+tab。</p><blockquote><p>55.文件颜色标签的使用</p></blockquote><p>OS X的Finder提供了颜色标签的功能，可以直接为文件和文件夹标记颜色。我在很长一段时间都没有注意到这个功能，一次偶然的机会开始使用颜色标记文件，感觉非常方便。<br>比如我会在Finder的主目录下用颜色标明最常访问的文件夹。如果是电子书，可以用颜色表示阅读状态，例如绿色表示正在阅读，灰色表示读完了，橙色表示待阅读，等等。大家可以根据自己的习惯使用颜色标签，提高效率。</p><blockquote><p>56.利用邮件中的日期创建日历事件</p></blockquote><p>工作中我们总是通过邮件来通知会议和活动，这时邮件中往往有日期信息。我们可以利用这个信息直接创建日历事件。打开邮件，把鼠标移动到有效的日期信息上，会出现下拉菜单的按钮，单击后可以为日历添加事件，事件标题默认为邮件标题。</p><blockquote><p>57.AppleScript小程序</p></blockquote><p>今天为大家介绍用AppleScript实现一个示例小功能：清空废纸篓。打开AppleScript编辑器，输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--操作对象是Finder</div><div class="line">tell application &quot;Finder&quot;</div><div class="line">--为isEmpty变量赋值</div><div class="line">set isEmpty to &quot;是否清空废纸篓！&quot;</div><div class="line">--显示确认对话框，单击“确认”程序继续执行，单击“取消”终止程序</div><div class="line">display dialog isEmpty</div><div class="line">--清空废纸篓</div><div class="line">empty the trash</div><div class="line">--通过语音说这事搞定了</div><div class="line">say &quot;It is done!&quot;</div><div class="line">end tell</div></pre></td></tr></table></figure><p>单击工具栏的“编译”按钮，检查没有错误后，单击“运行”即可，大家可以看看发生了什么。</p><blockquote><p>58.Homebrew</p></blockquote><p>Homebrew的功能和OS X自带的MacPorts很像，但是更为轻量级，由于大量利用了系统自带的库，安装方便，编译快速，实在是OS X系统开发中之必备工具。<br>安装方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby-e&quot;$（curl-fsSL https://raw.github.com/mxcl/homebrew/go）&quot;。</div></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install wget//安装wget工具。</div></pre></td></tr></table></figure><p>具体的使用请参考：<a href="https://github.com/mxcl/homebrew/wiki。" target="_blank" rel="noopener">https://github.com/mxcl/homebrew/wiki。</a></p><blockquote><p>59.根据文件名快速查找文件</p></blockquote><p>我们在OS X中查找文件或文件内容一般使用Spotlight或Alfred，这些功能在前面的Mac Tips中都介绍过，不过，如果你知道文件名的一部分，想更加快速地定位文件，那么就会用到命令行工具locate。</p><p>locate是Unix/Linux下的命令工具，基本原理就是通过定期更新系统的文件和文件名并把索引信息放入系统的数据库中，当通过locate查找文件时直接从数据库里取数据。而且locate可以查到Spotlight查不到的系统文件。基本的使用方法非常简单，比如你想找Nignx的配置文件在哪，只需输入：locate nginx.conf。</p><blockquote><p>60.设置用户登录选项</p></blockquote><p>OS X系统登录后会自动启动一些程序，比如Alfred、拼音输入法、风扇控制软件等等。有时我们会嫌多，有时又想增加一些启动项，在哪设置呢？打开“系统偏好设置”→“用户与群组”，选中“当前用户”，单击右边的“登录项”，你就会看到系统启动时加载的程序，可以随意删减，还能够设置启动后隐藏，非常方便。</p><blockquote><p>61.修改你的登录窗口</p></blockquote><p>我们默认登录OS X时，系统会显示登录用户列表，你需要用鼠标点一下要使用的用户，或者用光标键选择用户，出现登录框后输入密码登录。如果我们想不显示用户列表，直接输入用户名和密码登录怎么办呢？<br>打开“系统偏好设置”→“用户与群组”，单击左侧下方的“登录选项”（很奇怪很多人找不到这个），在右侧修改登录窗口为“名称和密码”。注销登录，这次大家就满意了。</p><blockquote><p>62.Mac的键盘</p></blockquote><p>很多人第一次用Mac的键盘时会发现，苹果也太抠门儿了，退格键没了，PageUP/PageDown/Home/End也没了。别担心，您不是还有delete键和上下左右方向键么？delete相对于退格键，fn+delete可以往前删，fn+上下左右方向键可以实现PageUP/PageDown/Home/End的功能，一个功能都不少。</p><blockquote><p>63.QuickTime</p></blockquote><p>很多人都会使用QuickTime Player看mp4或mov视频文件，但其功能远不止于此。option+command+n可以打开录像功能，ctrl+option+command+n可以打开录音功能，ctrl+command+n可以打开录制屏幕功能。最后一个功能非常适合做产品介绍或产品演示，大家可以试一试。遇到快捷键冲突的，在QuickTime的文件菜单中也可以找到这三项。</p><blockquote><p>64.Dropbox快速导入Mac</p></blockquote><p>有读者问如何把iPhone或iPad里的照片导入Mac，我自己用的办法是Dropbox，安装了Dropbox之后，每次用USB连接iPhone或iPad时，程序都会提示是否有新照片需要导入，导入后自动云端同步。不用Dropbox的同学，另外一个简单的方式是连接移动设备时，打开预览程序，单击文件，可以看到一个“从iPhone/iPad导入”的菜单，单击一下，后续你基本就知道该怎么做了。</p><p>当然还有其他方法，比如打开图像捕捉或iPhoto程序等。</p><blockquote><p>65.快速创建日历事件</p></blockquote><p>OS X提供了智能创建日历事件的功能。打开日历程序，单击左上角的“+”号，在弹出的输入框里输入：“明天上午9点到13点参加公司年会。”回车，看看效果如何？日历程序会准确地创建你想要的事件。大家可以试试其他写法。</p><blockquote><p>66.显卡监控软件gfxCardStatus</p></blockquote><p>现在大部分Mac都有两块显卡，集成显卡和独立显卡。OS X会根据不同的程序自动切换显卡，但有时候我们在电池供电的情况下会由于某些程序的原因一直使用独立显卡，会大大缩短待机时间，这时候就能用到这个软件了。gfxCardStatus能做的事情有两件。一件是手动切换显卡。另一件是监控现在系统在使用哪块显卡，如果是独立显卡的话，是因为哪个程序导致必须使用独显。下载地址：<a href="http://gfx.io。" target="_blank" rel="noopener">http://gfx.io。</a></p><blockquote><p>67.创建智能文件夹</p></blockquote><p>Finder提供了智能文件夹的功能，简单来说就是固化你的搜索条件，并形成文件夹存放在左侧边栏。</p><p>例如你想建一个文件大小大于1G的智能文件夹，使用快捷键option+command+n呼出新建智能文件夹界面，单击最右侧的加号，在条件选择第一栏选择“大小”，第二栏选择“大于”，第三栏输入“1G”，你就可以看到你的Mac上文件大于1G的列表，单击“存储”，命名后该文件夹就会出现在左侧边栏。随时单击随时动态监控自己的硬盘上有哪些超过1G的大文件。试试其他搜索条件吧！</p><blockquote><p>68.自动打开程序文稿</p></blockquote><p>OS X提供了自动恢复上次关闭程序时打开的文稿和窗口的功能。这就是说，如果你使用预览程序打开了5个PDF文件，用command+q关闭了预览程序，下次打开预览程序时，会自动恢复这5个PDF程序，包括文字选中的状态，阅读进度等信息。这个功能我非常喜欢，但有时候我们并不希望自动恢复，那么有两种方式可以关闭这个功能。</p><p>第一种：打开“系统偏好设置”→“通用”，选中“退出应用时关闭窗口”，这样所有的程序都不再具备恢复功能。</p><p>第二种：退出程序时使用option+command+q而不是command+q，相当于关闭所有文件并退出程序，下次打开时，这些文件就不会自动打开了.</p><blockquote><p>69.智能邮箱</p></blockquote><p>邮箱账户的创建相信一般的用户都可以正常操作，不知道你是否使用过OS X中Mail的智能邮箱功能呢？</p><p>打开邮件程序，单击“邮箱”→“新建智能邮箱”，在弹出的窗口中选择你的过滤条件。过滤条件非常灵活，可以定义与或关系，增加多个过滤条件，设置完成后保存即可。你会发现左侧栏多了一个智能邮箱，单击即可根据你设置的过滤条件找到那些符合条件的邮件。</p><blockquote><p>70.隐藏的VIP</p></blockquote><p>如果你的系统版本是10.8以上，那么你就会发现邮件程序中多了一个隐藏的VIP功能。随便找封邮件，把鼠标放在发件人或收件人的邮件地址上，会出现一个蓝色的选择框，单击其中的白色箭头，在下拉菜单中单击“添加到VIP”，你就会发现左边栏多了一个VIP分栏，单击加入的VIP用户，可以直接查看他们发送的邮件。</p><blockquote><p>71.在Finder中打开某个文件夹下所有子文件夹</p></blockquote><p>有时候我们希望在Finder中查看某个文件夹下的所有文件和子文件夹，怎么做到呢？把文件切换到列表视图（command+2），把排序方式设置为“不排序”，这时文件夹左侧会出现一个箭头。按住option键单击文件夹左侧的箭头，你就会发现所有的文件和文件夹都展现在眼前了。注意，如果该文件夹下文件太多，那么不建议使用，因为打开会需要很长时间。</p><blockquote><p>72.慢速动画</p></blockquote><p>所有具备动画效果的操作，按住shift键，会播放慢速动画。大家可以试试按住shift键的时候最小化窗口，效果非常酷。</p><blockquote><p>73.XtraFinder</p></blockquote><p>这个插件具备和TotalFinder类似的功能，支持tab、文件夹置顶、多窗口、剪切、全局热键等功能，重要的是这是一个完全免费的自由软件。<br>下载网址：<a href="http://www.trankynam.com/xtrafinder/。" target="_blank" rel="noopener">http://www.trankynam.com/xtrafinder/。</a></p><blockquote><p>74.MacBook待机仍可为iPhone供电</p></blockquote><p>我们平时会把iPhone接到MacBook上充电。事实上，把MacBook合上待机时，仍然可以为iPhone供电，大家可以试一下。如果你出游时会带上你的Mac，别忘了这也是一块大的移动电池。</p><blockquote><p>75.恢复截屏图片默认保存路径</p></blockquote><p>截屏图片存哪了？OS X自带截屏不好使了，截屏之后有“咔嚓”的程序运行声，但图片不知道去哪里了，如何修复？</p><p>OS X自带的截图文件是存储在桌面上的，你的可能是被修改过了，我们可以通过以下命令恢复默认路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults delete com.apple.screencapture location</div></pre></td></tr></table></figure><p>注销，重新登录，再次截屏看看文件是否保存在桌面上了。</p><blockquote><p>76.如何为OS X自带的字典增加中文字典</p></blockquote><p>目前OS X自带的字典程序是没有中文的，不过我们很容易为其扩展新字典。操作如下：</p><p>◆如果打开了字典程序，关闭。<br>◆到以下网址下载《朗道英汉字典》和《朗道汉英字典》，解压缩得到两个后缀为dictionary的文件：<a href="http://pan.baidu.com/share/link?shareid=249542&amp;uk=2617481269。" target="_blank" rel="noopener">http://pan.baidu.com/share/link?shareid=249542&amp;uk=2617481269。</a><br>◆把这两个文件复制到～/Library/Dictionaries下。<br>◆启动字典程序，你就会看到增加了《朗道英汉字典》和《朗道汉英字典》。</p><blockquote><p>77.文件共享</p></blockquote><p>在Mac之间进行文件共享有很多种方式，介绍两个最简单的，具备AirDrop功能的两台或多台Mac，在开着Wi-Fi的情况下打开AirDrop，就会找到同样打开AirDrop的Mac，把想传送的文件拖放到其他人的Mac头像上即可。</p><p>另一个就是利用系统的共享功能。打开“系统偏好设置”→“共享”，单击左侧栏的“文件共享”，在右侧区域配置即可。</p><blockquote><p>78.删除程序</p></blockquote><p>删除Mac上的程序有很多种方法，比如直接去应用程序文件夹下删除，用CleanApp删除，等等，今天介绍一个最好玩的。</p><p>打开Launchpad，按住option键，就会看到所有的程序图标都会像iOS图标那样晃动起来，单击图标左上角的叉，即可删除程序，和操作iOS一样。</p><blockquote><p>79.command+上下方向键</p></blockquote><p>这两个快捷键很多应用程序都支持，具体功能就是屏幕滚动到应用程序的顶部或底部，类似很多网站提供的“回到顶部/底部”功能。Safari、Chrome、Firefox、Pages、Evernote等默认都支持这样的功能。</p><p>在使用快捷键呼出Spotlight的时候，使用command+上下方向键还可以在搜索分组之间切换，非常方便。</p><blockquote><p>80.Mac上的阅读笔记类软件</p></blockquote><p>◆Kindle for Mac：支持视网膜屏，支持本地阅读和Amazon商店，支持中英文字典，电子阅读体验一流。遗憾的是不能整合中国和美国Amazon的账户，导致电子书商品也没法使用同一个账户阅读。免费。<br>◆Caffeinated：优秀的RSS阅读器，如果你还喜欢博客和传统阅读，那么推荐使用。<br>◆Pocket：免费。最好的稍后读App，支持标签分类、编辑等功能，支持afari、Chrome等插件，非常适合知识积累。收费。<br>◆Evernote：很好的笔记类App，5.0之后UI有了很大的改进，目前我所有的文章都是用Evernote管理。免费，有收费版本。<br>以上4个App在iPad、iPhone上也有相关应用，并且都支持云同步，合理使用对提高读写效率非常有帮助。</p><blockquote><p>81.查看电源状况</p></blockquote><p>按住option键，单击右上角的苹果图标，选择“系统信息”，在打开窗口的左侧栏中找到“电源”，单击即可查看电源的详细信息。主要的指标包括电池循环计数、状况等信息。如果您安装了Alfred，呼出后直接输“sys”，也可以找到系统信息。</p><p>如果想简单查看一下电池的使用状况，按住option键单击顶部工具栏上的电池图标，可以显示电池使用状况。如果出现“尽快更换”、“修理电池”等信息，那么有可能是电池出了问题，建议先重置系统管理控制器（SMC），如何重置可以去Apple的官方支持网站查一下。还没效果的话，可能就需要换电池了。</p><blockquote><p>82.Pixelmator</p></blockquote><p>这款图像处理软件号称是Mac上的精简版Photoshop，而且更为人性化，适合非专业人士使用，不是平面设计人员也可以作出非常专业的图像设计。MacTalk里很多配图我都使用这款软件加工过，很好用。收费软件，但值得拥有。推 荐 一 个Podcast视 频 教 程（RSS）：<a href="http://www.pixelmator.com/tutorials/itunes/。" target="_blank" rel="noopener">http://www.pixelmator.com/tutorials/itunes/。</a></p><blockquote><p>83.搜索命令mdfind</p></blockquote><p>mdfind是一个非常灵活的全局搜索命令，类似Spotlight的命令行模式，可以在任何目录对文件名、文件内容进行检索，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//搜索文件内容或文件名包含“苹果操作系统”的文件</div><div class="line">mdfind苹果操作系统</div><div class="line">//在桌面上搜索文件内容或文件名包含“苹果操作系统”的文件</div><div class="line">mdfind -onlyin ～/Desktop苹果操作系统</div><div class="line">//统计搜索到的结果</div><div class="line">mdfind -count -onlyin ～/Desktop苹果操作系统</div><div class="line">//搜索文件名包含“苹果操作系统”的文件</div><div class="line">mdfind -name苹果操作系统</div></pre></td></tr></table></figure><blockquote><p>84.元信息命令mdls</p></blockquote><p>mdls可以列出某个文件或文件夹的所有元数据信息，针对不同文件显示不同的元数据信息，例如文件创建时间、类型、大小等。如果是图片或音视频文件，则会显示更多元数据信息。使用方式非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mdls ～/Desktop/a.jpg</div></pre></td></tr></table></figure><p>如果想查看图片的ISO数据，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mdls ～/Desktop/a.jpg|grep ISO</div></pre></td></tr></table></figure><blockquote><p>85.功能键</p></blockquote><p>很多程序员在调试程序的时候总会用到F7、F8这些键，但在OS X里这些功能键默认分配了一些功能，想使用的话需要同时按fn+F8……</p><p>如果希望将F1～F12这些按键用作标准功能键而且不需要按fn，可以执行以下操作：打开“系统偏好设置”→“键盘”，选中“将F1、F2等键用作标准功能键”。启用此选项时，顶部一行按键将用作标准功能键（F1～F12），而不执行音量控制等特殊功能。启用此选项后，若要使用这些按键的特殊功能，请按fn，比如按fn+F8来播放音乐。</p><blockquote><p>86.查看文件信息的命令：file</p></blockquote><p>file可以查看相关文件的类型和属性，相对于mdls，这个更亲民一些，基本用法file xxx.png，大家感受一下。</p><blockquote><p>87.如何配置多种网络环境</p></blockquote><p>我自己无论在公司还是家里都是DHCP自动分配IP，所以不需要进行网络环境切换。但有些用户有时自动有时手动，需要多套网络配置方案，每次修改实在是太麻烦了。曾经有人问我Mac上是否有这样的第三方软件？我说没有，因为OS X的网络设置本身就提供了这样的功能。</p><p>打开“系统偏好设置”→“网络”，单击“位置”下拉菜单，找到“编辑位置”，打开后即可增删编辑多套网络设置，设置完成后保存。</p><p>这时单击屏幕左上角的苹果图标，在下拉菜单里增加了一个位置选项，里面就是你配置好的多种网络设置，单击切换即可。</p><blockquote><p>88.生成man page的PDF文档</p></blockquote><p>打开OS X的终端，通过man命令可以直接查看该命令的使用手册。但有时我们会觉得在命令行查看不太方便，如果可以提供一个PDF文档就完美了。这很容易做到，在终端输入如下命令，即可在预览程序打开grep的使用手册，另存为你需要的文件名即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man -t grep | open -f -a Preview</div></pre></td></tr></table></figure><blockquote><p>89.虚拟机</p></blockquote><p>2006年Mac的硬件进行了重大的架构调整，开始全面采用Intel系列的CPU，Power渐行渐远。架构的调整和Bootcamp的推出，使得在Mac上安装双系统变得触手可及。基于Mac的虚拟机应用也开始出现。我刚开始使用Mac时是双系统的支持者，后来Windows用得越来越少，就比较推荐使用虚拟机了。</p><p>在OS X上主要有三款虚拟机软件：Parallels Desktop、Vmware Fusion和VirtualBox。简单给大家介绍一下。</p><p>◆Parallels Desktop：Parallels是OS X上一款优秀的虚拟机软件，最新版本是8。它支持多种操作系统，并对Windows有完美的支持。通过融合模式，可以让Windows程序运行起来象Mac的应用。提供把Vmware Fusion虚拟机迁移到PD上的功能。收费。</p><p>◆Vmware Fusion：Vmware在Windows和Linux下大名鼎鼎，Fusion是Mac版本，功能同样强大。收费。</p><p>◆VirtualBox：Sun推出的一款开源虚拟机，现在归Oracle了，未来走势不明。免费。</p><p>我个人首推Parallels Desktop，功能、性能和价格都不错，专注于桌面版，属上乘之选。我自己虚拟了Win7、Redhat Linux和Ubuntu等环境，作软件测试和搭建多机开发环境。</p><blockquote><p>90.如何开启root用户</p></blockquote><p>用过Linux/Unix系统的都知道root用户，它具备读写文件系统所有区域的特权，是最高级别的用户。OS X一样有root用户，只不过默认情况是不开启的。我们想在命令行执行需要root权限的操作时，可以在命令之前增加sudo指令，比如执行每日维护指令：sudo periodic daily，系统会提示你输入用户密码，执行root权限。在GUI（图形界面）执行root级别的命令时也会提示输入用户密码。一般情况下我们是不需要开启root用户的。</p><p>用惯了Linux系统的用户有时很想启用root用户，其实也很简单，打开Finder，输入shift+command+g，在前往文件夹中输入：/System/Library/CoreServices，然后在目录中找到“目录实用工具”并打开，解开左下角的小锁，然后单击顶部菜单的“编辑”，你就会看到启用或停用root用户的选项了。然后我们在命令行下执行su-，就可以切换到root目录下，root的默认目录是/var/root。</p><p>root有风险，启用须谨慎！</p><blockquote><p>91.隐藏的空间切换功能</p></blockquote><p>以前介绍过OS X中Space的使用，我们可以定义多个Space，每个程序都可以在特定的Space中打开，多手势上推下滑选择程序，也可以通过ctrl+数字切换Space，很方便。今天再为大家介绍一个隐藏的功能，就是通过四指双击触控板，可以在你最近使用的两个Space之间切换，这个功能就类似电视频道中的返回功能，当你使用了Space1中的一些App，切换到了Space4之后，就可以通过四指双击在Space1和Space4之间切换了，对于协同工作非常有效。典型的应用场景：Space1里编码，在Space4里参考各类文档。</p><p>功能开启，打开终端程序，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.dock double-tap-jump-back -bool TRUE;  #功能开启</div><div class="line">killall Dock;     #重启Dock</div></pre></td></tr></table></figure><blockquote><p>92.免费的文本编辑器Imagine</p></blockquote><p>我个人觉得Imagine比OS X自带的TextEdit好，除了目前不支持iCloud外，基本涵盖了TE的功能，而且排版简约美观，可更换柔和的背景色，全屏写字非常舒服，对字体样式的支持很好，在富文本和纯文本间切换方便，我基本用Imagine替代了TextEdit。</p><p>下载地址：<a href="https://itunes.apple.com/cn/app/imagine/id566877440?mt=12。" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/imagine/id566877440?mt=12。</a></p><blockquote><p>93.去除右键菜单的重复项</p></blockquote><p>OS X系统有个问题，某个程序反复安装后，选中某种类型的文件，单击右键→“打开方式”，你会看到不少重复的选项，我们可以用以下命令的除重复项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain system -domain user</div></pre></td></tr></table></figure><blockquote><p>94.如何分别设置Mac的鼠标和触控板的滚动方向</p></blockquote><p>很多人习惯鼠标使用相反的滚动方向，而触控板类似iPad那样自然滚动，问如何设置，当时我的回答是不知道，因为目前OS X的系统设置里，鼠标和触控板的设置是统一的。今天发现了一个免费的软件Scroll Reverser，可以实现鼠标和触控板的分别设置。</p><p>下载地址：<a href="http://www.macupdate.com/app/mac/37872/scroll-reverser。" target="_blank" rel="noopener">http://www.macupdate.com/app/mac/37872/scroll-reverser。</a></p><p>启动后程序显示在顶部菜单栏，设置简单明了，有需要的用户体验一下吧。</p><blockquote><p>95.如何让不支持Retina的Mac软件变成Retina App</p></blockquote><p>前两天有读者求推荐Mac下的FTP软件，我推荐了FileZilla，但这个软件是不支持Retina屏的，Retina用户使用这个软件会感觉整个世界都模糊了，结果搜索之下，发现了一个小软件，叫做Retinizer，顾名思义，就是把非Retina的软件Retina化，我用了一下，完美支持FileZilla。<br>下载地址：<a href="http://retinizer.mikelpr.com/。" target="_blank" rel="noopener">http://retinizer.mikelpr.com/。</a></p><blockquote><p>96.文件比较</p></blockquote><p>◆对于单个文件的比较，一般使用diff或vimdiff就可以了，比如：vimdiff destfile.txt sourcefile.txt vim会非常清晰地显示出文件的不同，还有很多快捷方式帮助你查看和操作文件，这个命令比较适合命令行爱好者。</p><p>◆对于大批量文件的比较，还是图形化比较工具更合适一些。OS X自带了FileMerge比较工具，可以满足部分需求，但对于中文编码文件或大文件经常会崩溃，很奇怪Apple一直不解决这个问题。</p><p>◆推荐一款收费软件：VisualDiffer（25元），UI、功能和稳定性都非常不错，实在是居家旅行、代码比较、查找问题的必备利器。</p><blockquote><p>97.FTP工具Cyberduck</p></blockquote><p>之前介绍Retinizer（普通软件Retina化）的时候提到了FTP软件FileZilla，我个人一般使用命令行下的ftp/sftp/scp等实现FTP软件的功能，但普通用户还是用图形界面的更方便些。今天再给大家介绍一个可以实现远程同步文件的FTP工具：Cyberduck。<br>Cyberduck除了可以实现FTP的基本功能外，还能支持远程同步。所谓同步，就是把远程和本地的两个目录进行比较，然后自动找出修改的文件上传到服务器。</p><p>具体操作就是通过ftp或sftp的方式登入远端服务器，选中某个文件夹，右键菜单里选择“同步”，再选择本地文件夹，就可以进行同步比较上传了，上传之前你最好确认下，更稳妥。</p><p>同样，这个软件也可以用Retinizer实现高清显示效果。</p><blockquote><p>98.文件重命名</p></blockquote><p>文件重命名的问题以前说过，但最近又有些用户问起，就再说一下。<br>如果你没有装任何插件的话，在Finder中重命名文件或文件夹的快捷键就是回车。打开文件用command+O，返回上级目录用command+向上的方向键。如果你装了原来推荐过的XtraFinder，可以把回车改为打开文件（与Windows操作类似），把option+R设置为文件重命名。<br>如果你在命令行下重命名文件，命令是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv oldname newname</div></pre></td></tr></table></figure><blockquote><p>99.多个用户登录一个程序</p></blockquote><p>Mac下有很多程序默认是单进程的，比如你不能打开多个邮件程序，不能打开多个Evernote，但有时我们可能会有这样的需求，那么用如下命令可以实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open -n /Applications/XXX.app</div></pre></td></tr></table></figure><p>-n的含义是：Open a new instance of the application（s）even if one is already running.意思就是为正在运行的应用程序再开一个新实例。常用于多个账户登录一个程序，或软件比较等场景。</p><blockquote><p>100.强制关闭程序</p></blockquote><p>总有程序关闭不了，这时候我们就需要以下方法。</p><p>方法一：option+command+esc，调出强制退出应用程序的窗口，选择要退出的进程即可。</p><p>方法二：打开活动监视器，类似windows的任务管理器一样操作就好了。</p><p>方法三：命令行下的kill命令，比如想杀掉TextMate，首先用ps-ax|grep TextMate找到进程号，然后用kill-9进程号，即可。</p><p>至此，天下无杀不掉的进程。</p><blockquote><p>101.用AppleScript实现打开多实例程序</p></blockquote><p>之前介绍了通过open-n/Applications/XXX.app的方式打开多实例程序，有人在微博上问如何选中一个文件或程序，通过右键菜单打开新实例，而不是每次都去命令行操作。</p><p>我们可以通过Automator+AppleScript实现这个功能。<br>打开Automator，选择创建“服务”，在左侧选择“运行AppleScript”，双击打开程序窗口，在“（Yourscriptgoeshere）”处输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">   try</div><div class="line">        set filename to POSIX path of（selection as text）</div><div class="line">        set fileType to（do shell script &quot;file -b &quot; &amp; filename）</div><div class="line">        if（fileType does not end with &quot;directory&quot;）or（filename end with &quot;app&quot;）then</div><div class="line">        do shell script &quot;open -n &quot; &amp; filename</div><div class="line">        end if</div><div class="line">        end try</div><div class="line">end tell</div></pre></td></tr></table></figure><p>在程序上方的选择框设定“文件和文件夹”、“任何应用程序”，然后保存，起个你喜欢的名字，比如叫“以新实例运行”。退出Automator。<br>选中文件或程序，右键→“服务”→“以新实例运行”，即可实现类似open-n的方式。</p><blockquote><p>102.Automator</p></blockquote><p>Automator是苹果公司为其操作系统OS X开发的一款软件。通过单击拖曳鼠标等操作就可以将一系列动作组合成一个工作流，从而帮助你自动完成一些复杂的重复工作。Automator还能横跨很多不同种类的程序，包括：查找器、Safari网络浏览器、iCal、地址簿或者其他的一些程序。在Automator中可以运行AppleScript。</p><p>在上一个技巧中我们通过Automator创建了一个服务，当你在Finder或桌面上选中文件时，在右键的“服务”菜单里增加了一个选项“以新实例运行”，是通过AppleScript实现的。下面说明一下程序功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">--通知Finder</div><div class="line">tell application &quot;Finder&quot;</div><div class="line">--异常处理</div><div class="line">try</div><div class="line"> --获取选中文件的全路径</div><div class="line"> set filename to POSIX path of（selection as text）</div><div class="line"> --通过脚本file -b获取文件类型</div><div class="line"> set fileType to（do shell script &quot;file -b &quot; &amp; filename）</div><div class="line"> --如果不是文件夹或以app结尾，执行open -n脚本</div><div class="line"> if（fileType does not end with &quot;directory&quot;）or（filename ends with &quot;app&quot;）then</div><div class="line">        do shell script &quot;open -n &quot; &amp; filename</div><div class="line">        end if</div><div class="line">        end try</div><div class="line">end tell</div></pre></td></tr></table></figure><p>这里考虑到了选中程序直接打开，或选中文件以默认程序打开的情况。</p><blockquote><p>103.用Safari默认查询引擎查询应用软件里的文字</p></blockquote><p>如果你想通过Safari的默认查询引擎查询某个应用软件里的文字，那么选中文字，然后使用shift+command+L即可跳转到Safari的搜索页面，非常方便。大部分应用都支持这个快捷键。</p><blockquote><p>104.旋转屏幕</p></blockquote><p>打开“系统偏好设置”，已经打开了的，退出重新打开。按住option+command键，单击显示器，在原来的亮度选项下方会出现一个“旋转”的选项，这时候你就可以旋转你的屏幕了。</p><blockquote><p>105.最近尝试录制视频时在屏幕上显示键盘快捷键的操作，</p></blockquote><p>ScreenFlow固然可以实现这个功能，不过99美元的价格让人感觉得不偿失。搜索之下找到了KeyCastr，简单设置了一下发现可以实现我需要的功能，项目托管在GitHub上，网址：<a href="https://github.com/sdeken/keycastr" target="_blank" rel="noopener">https://github.com/sdeken/keycastr</a>, 可以直接下载DMG包。还有一种方案是使用OS X原生的键盘显示，打开“系统偏好设置”→“语言与文本”→“输入源”，选中左边栏的第一项“键盘与字符显示程序”。关闭偏好设置，这时单击顶部Menu Bar的“语言”，会多出两项功能，单击“显示键盘显示程序”，就会在屏幕上出现一个模拟键盘。</p><p>这个方案的缺点是没法区分快捷键和普通字符输入，而且显示速度太快，不够醒目。</p><blockquote><p>106.复制截屏图片到剪贴板</p></blockquote><p>以前介绍过如何通过苹果自带的快捷键截屏并存储图片文件，例如shift+command+3和shift+command+4。现在发现如果在以上两个截屏动作中加入ctrl键，可以实现直接把图片保存在剪贴板中，而不是实体文件中，这样就可以通过command+v直接把截取的图片内容复制到图像处理软件或Pages、Keynote等文件中了。</p><blockquote><p>107.CheatSheet</p></blockquote><p>一生要记住多少快捷键呢？我都不知道自己记住了多少快捷键，很多快捷键是到了那个环境下才能想起来。但是毋庸置疑，快捷键可以大大提高我们的工作效率，在Mac环境下使用快捷键和不使用，几乎是两种体验。如何记住这些快捷键呢，有人开发了一款软件叫做CheatSheet，安装并打开之后，当你记不住快捷键的时候，按住command键两秒钟，就会弹出一个当前应用软件快捷键列表，不全，但是对大部分用户都够用了。</p><p>下载地址：<a href="http://www.cheatsheetapp.com/CheatSheet/" target="_blank" rel="noopener">http://www.cheatsheetapp.com/CheatSheet/</a></p><blockquote><p>108.HTML5Player</p></blockquote><p>现在越来越多的人开始看在线视频，目前大部分视频网站的播放器都是基于Flash技术的，而苹果一直对Flash很抵触，支持得也不好，Flash播一会Mac机身就会变热。另外现在的视频网站广告太多，页面花里胡哨也不适合观看。于是有位无聊的程序员做了一个HTML5播放器，可以把在线视频的播放转化成HTML5方式，并且去除广告。使用起来非常简单，只要把{原文}里的HTML5Player链接拖曳到Safari的书签栏，播放视频时单击书签栏上的HTML5Player书签，播放器就会自动转换，效果自己看吧。目前支持优酷、土豆、搜狐视频、爱奇艺、乐视网、QQ、迅雷离线，以及56视频的单视频播放页面。</p><p>相关链接：<a href="http://zythum.sinaapp.com/youkuhtml5playerbookmark/" target="_blank" rel="noopener">http://zythum.sinaapp.com/youkuhtml5playerbookmark/</a></p><blockquote><p>109.重建Spotlight索引</p></blockquote><p>以前给大家介绍过，在OS X中几乎不需要进行文档和文件夹管理，因为有Spotlight机制，可以瞬间找到你想要的文件，只要你记得这个文件的一点蛛丝马迹。</p><p>但是Spotlight也有出问题的时候，就是它的索引文件出事了，比如查找速度变慢，某些文件明明在硬盘上就是检索不到，等等，这时候就需要重建索引了。</p><p>打开终端程序，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo mdutil -i off /</div><div class="line">#该命令用来关闭索引</div><div class="line">sudo mdutil -E /</div><div class="line">#该命令用来删除索引</div><div class="line">sudo mdutil -i on /</div><div class="line">#该命令用来重建索引</div></pre></td></tr></table></figure><p>然后用快捷键呼出Spotlight菜单，随便输入一个词，就能看到提示，正在进行索引，并且显示完成重建索引需要的时间。<br>完成之后，Spotlight又可以运转如飞了。</p><p>有时候人在某个阶段也需要重建索引，保持初心。什么是初心，空空如也！不要成天得瑟你知道的那点事，多琢磨那些你还不知道的事儿。</p><blockquote><p>110.用键盘操作Dock和Menu Bar的菜单</p></blockquote><p>当我们想操作Dock或顶部菜单栏的时候，往往需要鼠标去选中Dock或菜单栏，但是我们往往是不希望去碰鼠标的，这时候快捷键就又开始发挥作用了。使用control+F2可以选中Menu Bar的菜单，通过左右键选择功能，回车执行；使用control+F3可以选中并显示Dock，通过左右键选择功能，回车执行。</p><p>该功能在全屏操作时尤其有效。对于F1、F2等不是标准功能键的设置，增加fn键即可。</p><blockquote><p>111.定义自己的快捷键</p></blockquote><p>我认为OS X是一个把GUI、程序进程和脚本结合得最好的操作系统，当然这样说可能有些读者不是很明白，这么说吧，OS X是一个定制化非常强的系统，很多人说OS X封闭，事实上OS X为用户预留了非常多的入口和切面，让你能够通过简单、简洁的办法进入系统做你想做的事情。<br>举例来说，对于普通用户，你可以通过键盘的快捷键设置定义自己的常用操作。对于程序员，你可以自己通过AppleScript、Shell、Automator等创建自己的服务，也可通过类似Alfred2这样的优秀工具编写自己的workflow。</p><p>今天给大家说说第一种。打开“系统偏好设置”→“键盘”→“键盘快捷键”，左侧栏里列出了各种功能的快捷键，比如Launchpad、Dock、Mission Control、截屏、服务等，大家可以在这些选项中定义和修改自己常用的快捷键，增加右键菜单，等等。</p><blockquote><p>112.选择文本</p></blockquote><p>用command+鼠标，可以选中不同位置的文本内容。<br>用option+鼠标，可以对文本进行块选。</p><blockquote><p>113.Dock中的文件夹</p></blockquote><p>这个功能非常适合普通用户使用。一般安装了系统后Dock右边会有几个默认的文件夹，事实上你可以把任何常用的文件夹拖到这个位置，不想要的拖到废纸篓即可移除。<br>Dock文件夹的显示方式提供了扇状、网格和列表三种方式，我一般使用网格和列表。但是还有一个隐藏的列表功能，更为实用些，可以在命令行输入如下命令开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.dock use-new-list-stack -bool TRUE; killall Dock</div></pre></td></tr></table></figure><p>这时候你再启动列表模式，就会发现列表显示方式不一样了，变得更加容易操作了。<br>另外，在列表和网格模式下，还可以通过command+/-来放大和缩小图标，非常方便。</p><blockquote><p>114.Finder的宽度</p></blockquote><p>Finder是OS X的默认文件管理器，它提供了多种显示方式，包括图标、列表、分栏和Cover Flow。其中分栏最为常用，通过键盘的方向键浏览多层级的文件非常方便。不过每个分栏的宽度都是系统默认宽度，如何改变这个默认宽度呢？用鼠标拖动分栏线时同时按住option键，这个默认宽度就随之改变了。</p><blockquote><p>115.Dashboard</p></blockquote><p>顾名思义，Dashboard就是OS X系统中的仪表盘，它可以在桌面上显示各种小功能块，比如字典、便笺、系统状态、天气预报等。<br>使用快捷键F12或单击Dock中的Dashboard可以运行Dashboard，运行方式有两种，可以在一个新的Space里打开，也可以在当前的Space里打开，可以在“偏好设置”→“Mission Control”中设置。我一般使用在当前Space里打开。</p><p>单击左下角的“+”号，可以为Dashboard添加功能块，“-”号可以删除已经添加的功能块。把鼠标移动到某个功能块时按住option键，该功能块会出现一个删除图标，单击也可删除。</p><p>如果你想添加更多的功能块，在单击“+”号时，右侧会显示更多的Widget，单击可以到网络上下载你需要的功能。</p><p>Dashboard还有一个Web Clip的功能，如果你添加了这个功能块，浏览网页看到特别喜欢的词句或图片，可以单击右键→“在Dashboard打开”，把这部分内容放入Dashboard。</p><blockquote><p>116.Dock文件夹的使用小技巧</p></blockquote><p>前面介绍过Dock文件夹的使用问题，再说一个小技巧。当我们打开Dock文件夹后，先打开某个文件所在文件夹时，按住command，单击该文件，就会打开Finder文件夹，并选中你刚才单击的文件。</p><blockquote><p>117.几个简单的命令</p></blockquote><p>介绍几个简单的命令。打开终端程序，输入date会显示当前日期，输入cal会显示日历，输入uptime会显示系统从开机到现在所运行的时间。</p><blockquote><p>118.神奇的option键</p></blockquote><p>前面介绍过option相关的快捷键和功能，比如选中多个文件，然后按option+右键，可以显示检查器，按住option单击顶部菜单的电池图标会显示电池状况，单击Wi-Fi图标会显示网络状况，单击备份……可以自己试试。别忘了最左边的苹果按钮，option+单击，在下拉菜单击关机、重启都是不提示的。</p><p>option+拖曳文件可以复制，按住option输入“=”，输出是“≠”，按住option和shift输入“=”，输出是“±”。</p><p>还有好多，没事的时候多按按option键，你会有很多意外的发现。</p><blockquote><p>119.音乐处理软件XLD</p></blockquote><p>XLD全程是X Lossless Decoder，是Mac平台上无损音乐播放、编码和转换工具，不仅支持APE、FLAC等无损音频，还支持读取音频CD，将音轨抓取出来之后创建音乐文件。</p><p>免费软件，喜欢的可以捐赠。</p><p>官网地址：<a href="http://tmkk.undo.jp/xld/index_e.html。" target="_blank" rel="noopener">http://tmkk.undo.jp/xld/index_e.html。</a></p><blockquote><p>120.保护你的数据文件</p></blockquote><p>在Mac下对某些文件或数据进行加密操作有两种方式：</p><p>第一种：“系统偏好设置”→“安全性与隐私”→“FileVault”→“打开FileVault…”，即可。FileVault是全盘加密技术，可以对磁盘上的所有文件进行加密，后果是系统速度会稍微变慢一点点，一般不建议采用。</p><p>第二种：创建磁盘映像文件，对磁盘映像进行加密处理，然后把需要保护的数据和文件放到这个磁盘映像中即可。具体方式如下：<br>打开“应用程序”→“实用工具”→“磁盘工具”，单击“新建映像”，在“加密”选项处选择“256位AES加密（更安全但速度较慢）”，这种加密算法是极其安全的。创建映像时输入两次密码，即可创建加密的磁盘映像文件。在创建时最好不要选择“在我的钥匙串中记住密码”，这样可以每次打开这个磁盘映像文件时都需要输入密码，可以达到最佳保护数据的作用。</p><blockquote><p>121.如何禁用通知</p></blockquote><p>很多时候写作或写代码时，不希望被打扰，这时候就需要把OX S的通知关掉。双指从触控板右侧滑入，呼出“通知中心”，在最顶部有一个“显示提示和横幅”的开关，关掉就会禁止通知，不过第二天会自动恢复这个通知设置。</p><p>更简单的做法是按住option键单击屏幕右上角的“通知”图标。</p><blockquote><p>122.Finder的工具栏</p></blockquote><p>我们可以把文件和程序拖到Finder的工具栏上，以便随时打开。但是想移除时会发现单击鼠标拖动是没法把这些图标移除的，这时候只要在单击拖动时加上command，你就会发现这些图标被销毁了。</p><blockquote><p>123.Spotlight搜索时文件的定位</p></blockquote><p>用Spotlight搜索的时候，搜到文件时，我们有时候会需要打开该文件所在的文件夹，这时候按住command*键，单击文件即可打开Finder，并定位到该文件所在文件夹。</p><blockquote><p>124.重新启动Finder</p></blockquote><p>Finder是OS X系统中的常驻程序，一般不需要退出，如果想重新启动Finder，有一个简单的方式：按住option键，右键单击Dock上的Finder图标，底部菜单会出现“重新开启”的选项，单击即可。同样的操作对其他Dock上的程序是强制退出。</p><blockquote><p>125.屏幕画中画</p></blockquote><p>之前介绍过屏幕放大功能，也就是通过option+command++/-可以放大和缩小屏幕，使用control+滚轮也可以。</p><p>不过这只是放大屏幕方式的一种表现形式，我们还可以通过辅助设置改为画中画模式，打开“系统偏好设置”→“缩放”→“缩放样式”，把全屏幕改为画中画即可，效果大家自己看吧。</p><blockquote><p>126.粘贴纯文本</p></blockquote><p>我们在网页或其他文档上复制文字的时候，会把文字格式一并复制下来，command+v会把文字格式都粘贴过去，如果我们只想粘贴纯文本，可以使用shift+option+command+v，大部分软件都支持这种方式复制纯文本。</p><blockquote><p>127.终端命令lsof</p></blockquote><p>有用户问，在倾倒废纸篓的时候，经常会提示该文件还在使用，不能删除，但是又不知道哪个程序在用，怎么办？</p><p>Unix下有一个命令叫做lsof，名字是list open files的缩写，顾名思义，就是查看打开的文件，在终端里输入lsof文件名，就可以找到打开这个文件的程序。关掉程序，就可以正常删除文件。当然lsof还有很多丰富的指令，感兴趣的用户自行Google吧。</p><blockquote><p>128.AirDrop的有线传输</p></blockquote><p>AirDrop默认只能通过Wi-Fi来传文件，如果电脑已经连了网线，但是没开Wi-Fi就不能用AirDrop了，有一个办法可以打开AirDrop通过有线传文件的特征。打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.NetworkBrowser BrowseAllInterfaces 1</div></pre></td></tr></table></figure><p>然后选中Dock栏的Finder，按住option键，然后右键单击Finder图标，单击底部菜单项“重新开启”，Finder重启之后，即使你的电脑没开Wi-Fi，也可以用AirDrop给别人分享传文件了。</p><blockquote><p>129.切换程序时实现预览功能</p></blockquote><p>通过command+tab可以实现程序之间的切换，如果我们想在切换到某个程序的时候看看该程序组都在显示什么，可以按住command的同时按数字键1或上下方向键，系统会调出该程序的Exposé模式，这时你可以放开所有按键，用鼠标或方向键选择显示哪个程序窗口。</p><blockquote><p>130.Spotlight检索的高级技巧</p></blockquote><p>◆通过文件类型搜索文件，搜索格式是：<br>kind:文件类型——搜索关键字<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">kind:app——搜索应用程序</div><div class="line">kind:bookmark——搜索书签和历史记录</div><div class="line">kind:contact——搜索联系人</div><div class="line">kind:document——搜索各类文档</div><div class="line">kind:word——搜索word</div><div class="line">kind:pages——搜索pages</div><div class="line">kind:key——搜索keynote</div><div class="line">kind:email——搜索email</div><div class="line">kind:event——搜索日历事件</div><div class="line">kind:folder——搜索文件夹</div><div class="line">kind:movies——搜索视频</div><div class="line">kind:music——搜索音乐</div><div class="line">kind:pdf——搜索pdf文件</div><div class="line">kind:pic——搜索图片</div><div class="line">……</div></pre></td></tr></table></figure><p>◆通过标签颜色搜索。如果你喜欢使用各种颜色的标签标注不同的文件夹，那么这个功能就用得上了。“label:红”就可以找到红色标签的文件和文件夹。<br>◆通过日期搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">date:today——查看今天创建或修改的文件</div><div class="line">date:yesterday——查看昨天创建或修改的文件</div><div class="line">date:2013-05-01——查看2013年5月1日创建或修改的文件</div></pre></td></tr></table></figure><p>◆条件表达式。想搜索包含Mac不包含Windows的Keynote，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kind:key Mac -Windows</div></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kind:key Mac NOT Windows</div></pre></td></tr></table></figure><p> 我们可以使用+或-进行条件表达式求值，也可以通过NOT、AND和OR来检索，不过后者一定要大写，否则会被当做搜索内容处理。<br>有了以上4种搜索方式，天下再无搜不到的文档！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1.终端输入说英语&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说英语时我们当然希望有标准发音。在Mac中不需要字典，直接在终端里输入say yes，Mac就会说英语了。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="macbook" scheme="http://yoursite.com/tags/macbook/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述</title>
    <link href="http://yoursite.com/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8840%EF%BC%89%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/09/08/机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述/</id>
    <published>2017-09-08T15:14:45.000Z</published>
    <updated>2018-11-04T01:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。<br>本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。</p><a id="more"></a><h2 id="二、综述"><a href="#二、综述" class="headerlink" title="二、综述"></a>二、综述</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv380z2adj30hs0b5wff.jpg" alt=""><br>如上图所示是一个经典的机器学习问题框架图。数据清洗和特征挖掘的工作是在灰色框中框出的部分，即“数据清洗=&gt;特征，标注数据生成=&gt;模型学习=&gt;模型应用”中的前两个步骤。<br>灰色框中蓝色箭头对应的是离线处理部分。主要工作是</p><ul><li>从原始数据，如文本、图像或者应用数据中清洗出特征数据和标注数据。</li><li>对清洗出的特征和标注数据进行处理，例如样本采样，样本调权，异常点去除，特征归一化处理，特征变化，特征组合等过程。最终生成的数据主要是供模型训练使用。</li></ul><p>灰色框中绿色箭头对应的是在线处理的部分。所做的主要工作和离线处理的类似，主要的区别在于1.不需要清洗标注数据，只需要处理得到特征数据，在线模型使用特征数据预测出样本可能的标签。2.最终生成数据的用处，最终生成的数据主要用于模型的预测，而不是训练。<br>在离线的处理部分，可以进行较多的实验和迭代，尝试不同的样本采样、样本权重、特征处理方法、特征组合方法等，最终得到一个最优的方法，在离线评估得到好的结果后，最终将确定的方案在线上使用。<br>另外，由于在线和离线环境不同，存储数据、获取数据的方法存在较大的差异。例如离线数据获取可以将数据存储在Hadoop，批量地进行分析处理等操作，并且容忍一定的失败。而在线服务获取数据需要稳定、延时小等，可以将数据建入索引、存入KV存储系统等。后面在相应的部分会详细地介绍。</p><p>本文以点击下单率预测为例，结合实例来介绍如何进行数据清洗和特征处理。首先介绍下点击下单率预测任务，其业务目标是提高团购用户的用户体验，帮助用户更快更好地找到自己想买的单子。这个概念或者说目标看起来比较虚，我们需要将其转换成一个技术目标，便于度量和实现。最终确定的技术目标是点击下单率预估，去预测用户点击或者购买团购单的概率。我们将预测出来点击或者下单率高的单子排在前面，预测的越准确，用户在排序靠前的单子点击、下单的就越多，省去了用户反复翻页的开销，很快就能找到自己想要的单子。离线我们用常用的衡量排序结果的AUC指标，在线的我们通过ABTest来测试算法对下单率、用户转化率等指标的影响。</p><h2 id="三、特征使用方案"><a href="#三、特征使用方案" class="headerlink" title="三、特征使用方案"></a>三、特征使用方案</h2><p>在确定了目标之后，下一步，我们需要确定使用哪些数据来达到目标。需要事先梳理哪些特征数据可能与用户是否点击下单相关。我们可以借鉴一些业务经验，另外可以采用一些特征选择、特征分析等方法来辅助我们选择。具体的特征选择，特征分析等方法我们后面会详细介绍。从业务经验来判断，可能影响用户是否点击下单的因素有：</p><ul><li>距离，很显然这是一个很重要的特征。如果购买一个离用户距离较远的单子，用户去消费这个单子需要付出很多的代价。 当然，也并不是没有买很远单子的用户，但是这个比例会比较小。</li><li>用户历史行为，对于老用户，之前可能在美团有过购买、点击等行为。<br>用户实时兴趣。</li><li>单子质量，上面的特征都是比较好衡量的，单子质量可能是更复杂的一个特征。</li><li>是否热门，用户评价人数，购买数等等。</li></ul><p>在确定好要使用哪些数据之后，我们需要对使用数据的可用性进行评估，包括数据的获取难度，数据的规模，数据的准确率，数据的覆盖率等，</p><ul><li>数据获取难度：例如获取用户id不难，但是获取用户年龄和性别较困难，因为用户注册或者购买时，这些并不是必填项。即使填了也不完全准确。这些特征可能是通过额外的预测模型预测的，那就存在着模型精度的问题。</li><li>数据覆盖率：数据覆盖率也是一个重要的考量因素，例如距离特征，并不是所有用户的距离我们都能获取到。PC端的就没有距离，还有很多用户禁止使用它们的地理位置信息等。</li><li>用户历史行为，只有老用户才会有行为。</li><li>用户实时行为，如果用户刚打开app，还没有任何行为，同样面临着一个冷启动的问题。<br>数据的准确率</li><li>单子质量，用户性别等，都会有准确率的问题。</li></ul><h2 id="四、特征获取方案"><a href="#四、特征获取方案" class="headerlink" title="四、特征获取方案"></a>四、特征获取方案</h2><p>Ok，在选定好要用的特征之后，我们需要考虑一个问题。就是这些数据从哪可以获取？只有获取了这些数据我们才能用上。否则，提一个不可能获取到的特征，获取不到，提了也是白提。下面就介绍下特征获取方案。</p><ul><li>离线特征获取方案：离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等。</li><li>在线特征获取方案：在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了特征分层获取方案，如下图所示。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv381ekt7j308w03xdfu.jpg" alt="">出于性能考虑。在粗排阶段，使用更基础的特征，数据直接建入索引。精排阶段，再使用一些个性化特征等。</li></ul><h2 id="五、特征与标注数据清洗"><a href="#五、特征与标注数据清洗" class="headerlink" title="五、特征与标注数据清洗"></a>五、特征与标注数据清洗</h2><p>在了解特征数据放在哪儿、怎样获取之后。下一步就是考虑如何处理特征和标注数据了。下面3节都是主要讲的特征和标注处理方法</p><h3 id="5-1-标注数据清洗"><a href="#5-1-标注数据清洗" class="headerlink" title="5.1 标注数据清洗"></a>5.1 标注数据清洗</h3><p>首先介绍下如何清洗特征数据，清洗特征数据方法可以分为离线清洗和在线清洗两种方法。</p><ul><li>离线清洗数据：离线清洗优点是方便评估新特征效果，缺点是实时性差，与线上实时环境有一定误差。对于实时特征难以训练得到恰当的权重。</li><li>在线清洗数据：在线清洗优点是实时性强，完全记录的线上实际数据，缺点是新特征加入需要一段时间做数据积累。</li></ul><h3 id="5-2-样本采样与样本过滤"><a href="#5-2-样本采样与样本过滤" class="headerlink" title="5.2 样本采样与样本过滤"></a>5.2 样本采样与样本过滤</h3><p>特征数据只有在和标注数据合并之后，才能用来做为模型的训练。下面介绍下如何清洗标注数据。主要是数据采样和样本过滤。</p><p>数据采样，例如对于分类问题：选取正例，负例。对于回归问题，需要采集数据。对于采样得到的样本，根据需要，需要设定样本权重。当模型不能使用全部的数据来训练时，需要对数据进行采样，设定一定的采样率。采样的方法包括随机采样，固定比例采样等方法。</p><p>除了采样外，经常对样本还需要进行过滤，包括</p><ul><li>1.结合业务情况进行数据的过滤，例如去除crawler抓取，spam，作弊等数据。</li><li>2.异常点检测，采用异常点检测算法对样本进行分析，常用的异常点检测算法包括<br>偏差检测，例如聚类，最近邻等。<ul><li>基于统计的异常点检测算法</li><li>例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。</li><li>基于距离的异常点检测算法，主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。</li><li>基于密度的异常点检测算法，考察当前点周围密度，可以发现局部异常点，例如LOF算法</li></ul></li></ul><h2 id="六、特征分类"><a href="#六、特征分类" class="headerlink" title="六、特征分类"></a>六、特征分类</h2><p>在分析完特征和标注的清洗方法之后，下面来具体介绍下特征的处理方法，先对特征进行分类，对于不同的特征应该有不同的处理方法。</p><p>根据不同的分类方法，可以将特征分为(1)Low level特征和High level特征。(2)稳定特征与动态特征。(3)二值特征、连续特征、枚举特征。</p><p>Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。</p><p>稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。</p><p>二值特征主要是0/1特征，即特征只取两种值：0或者1，例如用户id特征：目前的id是否是某个特定的id，词向量特征：某个特定的词是否在文章中出现等等。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为N个二元特征，每个特征代表是否在这个区间内。</p><h3 id="6-1-特征归一化，离散化，缺省值处理"><a href="#6-1-特征归一化，离散化，缺省值处理" class="headerlink" title="6.1 特征归一化，离散化，缺省值处理"></a>6.1 特征归一化，离散化，缺省值处理</h3><p>主要用于单个特征的处理。</p><ul><li><p>归一化<br>不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。</p></li><li><p>离散化<br>在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。</p></li><li><p>缺省值处理<br>有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等。</p></li></ul><h3 id="6-2-特征降维"><a href="#6-2-特征降维" class="headerlink" title="6.2 特征降维"></a>6.2 特征降维</h3><p>在介绍特征降维之前，先介绍下特征升维。在机器学习中，有一个VC维理论。根据VC维理论，VC维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。可以想想，给你一堆物品，人脑是如何对这些物品进行分类，依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度：形状，来区分。这就是一个从“颜色”一维特征升维到二维特征的例子。</p><p>那问题来了，既然升维后模型能力能变强，那么是不是特征维度越高越好呢？为什么要进行特征降维&amp;特征选择？主要是出于如下考虑：1. 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。2. 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 3. 特征数量增加带来的训练、测试以及存储的开销都会增大。4.在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。5.可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100个平均分布的点能把一个单位区间以每个点距离不超过0.01采样；而当维度增加到10后，如果以相邻点距离不超过0.01小方格采样单位超一单位超正方体，则需要10^20 个采样点。</p><p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维和特征选择等工作。特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分</p><ul><li><p>PCA算法<br>通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。</p></li><li><p>LDA算法<br>考虑label，降维后的数据点尽可能地容易被区分</p></li></ul><h3 id="6-3-特征选择"><a href="#6-3-特征选择" class="headerlink" title="6.3 特征选择"></a>6.3 特征选择</h3><p>特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。</p><p>特征选择的一般过程如下图所示：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv382ft9fj30i90730sw.jpg" alt=""><br>主要分为产生过程，评估过程，停止条件和验证过程。</p><h4 id="6-3-1-特征选择-产生过程和生成特征子集方法"><a href="#6-3-1-特征选择-产生过程和生成特征子集方法" class="headerlink" title="6.3.1 特征选择-产生过程和生成特征子集方法"></a>6.3.1 特征选择-产生过程和生成特征子集方法</h4><blockquote><p>完全搜索(Complete)</p></blockquote><ul><li>广度优先搜索( Breadth First Search )：广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。</li><li>分支限界搜索( Branch and Bound )：穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。</li><li>其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等</li></ul><blockquote><p>启发式搜索(Heuristic)</p></blockquote><ul><li>序列前向选择( SFS ， Sequential Forward Selection )：从空集开始，每次加入一个选最优。</li><li>序列后向选择( SBS ， Sequential Backward Selection )：从全集开始，每次减少一个选最优。</li><li>增L去R选择算法 ( LRS ， Plus-L Minus-R Selection )：从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。</li></ul><p>其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等</p><blockquote><p>随机搜索(Random)</p></blockquote><ul><li>随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection)</li><li>随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。</li><li>模拟退火算法( SA， Simulated Annealing )：以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低</li><li>遗传算法( GA， Genetic Algorithms )：通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。</li></ul><p>随机算法共同缺点:依赖随机因素，有实验结果难重现。</p><h4 id="6-3-2-特征选择－有效性分析"><a href="#6-3-2-特征选择－有效性分析" class="headerlink" title="6.3.2 特征选择－有效性分析"></a>6.3.2 特征选择－有效性分析</h4><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为1.与模型相关特征权重，使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。2.与模型无关特征权重。主要分析特征与label的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括(1)交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL散度等</p><h2 id="七、特征监控"><a href="#七、特征监控" class="headerlink" title="七、特征监控"></a>七、特征监控</h2><p>在机器学习任务中，特征非常重要。</p><ul><li>个人经验，80%的效果由特征带来。下图是随着特征数的增加，最终模型预测值与实际值的相关系数变化。</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3839zwyj30hs09v3yt.jpg" alt=""></p><ul><li>对于重要的特征进行监控与有效性分析，了解模型所用的特征是否存在问题，当某个特别重要的特征出问题时，需要做好备案，防止灾难性结果。需要建立特征有效性的长效监控机制</li></ul><p>我们对关键特征进行了监控，下面特征监控界面的一个截图。通过监控我们发现有一个特征的覆盖率每天都在下降，与特征数据提供方联系之后，发现特征数据提供方的数据源存在着问题，在修复问题之后，该特征恢复正常并且覆盖率有了较大提升。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvsh6cy1qj31i00k4797.jpg" alt=""></p><p>在发现特征出现异常时，我们会及时采取措施，对服务进行降级处理，并联系特征数据的提供方尽快修复。对于特征数据生成过程中缺乏监控的情况也会督促做好监控，在源头解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。&lt;br&gt;本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征处理" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（39）：实例详解机器学习如何解决问题</title>
    <link href="http://yoursite.com/2017/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8839%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/07/机器学习算法系列（39）：实例详解机器学习如何解决问题/</id>
    <published>2017-09-07T15:14:45.000Z</published>
    <updated>2018-11-04T02:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。</p><a id="more"></a><p>下文分为</p><ul><li>1）机器学习的概述，</li><li>2）对问题建模，</li><li>3）准备训练数据，</li><li>4）抽取特征，</li><li>5）训练模型，</li><li>6）优化模型，</li><li>7）总结 </li></ul><p>共7个章节进行介绍。</p><h2 id="二、机器学习的概述："><a href="#二、机器学习的概述：" class="headerlink" title="二、机器学习的概述："></a>二、机器学习的概述：</h2><h3 id="2-1-什么是机器学习？"><a href="#2-1-什么是机器学习？" class="headerlink" title="2.1 什么是机器学习？"></a>2.1 什么是机器学习？</h3><p>随着机器学习在实际工业领域中不断获得应用，这个词已经被赋予了各种不同含义。在本文中的“机器学习”含义与wikipedia上的解释比较契合，如下：<br>Machine learning is a scientific discipline that deals with the construction and study of algorithms that can learn from data.</p><p>机器学习可以分为无监督学习（unsupervised learning）和有监督学习（supervised learning），在工业界中，有监督学习是更常见和更有价值的方式，下文中主要以这种方式展开介绍。如下图中所示，有监督的机器学习在解决实际问题时，有两个流程，一个是离线训练流程（蓝色箭头），包含数据筛选和清洗、特征抽取、模型训练和优化模型等环节；另一个流程则是应用流程（绿色箭头），对需要预估的数据，抽取特征，应用离线训练得到的模型进行预估，获得预估值作用在实际产品中。在这两个流程中，离线训练是最有技术挑战的工作（在线预估流程很多工作可以复用离线训练流程的工作），所以下文主要介绍离线训练流程。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3dwm7n5j30g009zzl3.jpg" alt=""></p><h3 id="2-2-什么是模型？"><a href="#2-2-什么是模型？" class="headerlink" title="2.2 什么是模型？"></a>2.2 什么是模型？</h3><p>模型，是机器学习中的一个重要概念，简单的讲，指特征空间到输出空间的映射；一般由模型的假设函数和参数w组成（下面公式就是Logistic Regression模型的一种表达，在训练模型的章节做稍详细的解释）；一个模型的假设空间（hypothesis space），指给定模型所有可能w对应的输出空间组成的集合。工业界常用的模型有Logistic Regression（简称LR）、Gradient Boosting Decision Tree（简称GBDT）、Support Vector Machine（简称SVM）、Deep Neural Network（简称DNN）等。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3dxj5fvj307m013dfn.jpg" alt=""></p><p>模型训练就是基于训练数据，获得一组参数w，使得特定目标最优，即获得了特征空间到输出空间的最优映射，具体怎么实现，见训练模型章节。</p><h3 id="2-3-为什么要用机器学习解决问题？"><a href="#2-3-为什么要用机器学习解决问题？" class="headerlink" title="2.3 为什么要用机器学习解决问题？"></a>2.3 为什么要用机器学习解决问题？</h3><ul><li>目前处于大数据时代，到处都有成T成P的数据，简单规则处理难以发挥这些数据的价值；</li><li>廉价的高性能计算，使得基于大规模数据的学习时间和代价降低；</li><li>廉价的大规模存储，使得能够更快地和代价更小地处理大规模数据；</li><li>存在大量高价值的问题，使得花大量精力用机器学习解决问题后，能获得丰厚收益。</li></ul><h3 id="2-4-机器学习应该用于解决什么问题？"><a href="#2-4-机器学习应该用于解决什么问题？" class="headerlink" title="2.4 机器学习应该用于解决什么问题？"></a>2.4 机器学习应该用于解决什么问题？</h3><ul><li>目标问题需要价值巨大，因为机器学习解决问题有一定的代价；</li><li>目标问题有大量数据可用，有大量数据才能使机器学习比较好地解决问题（相对于简单规则或人工）；</li><li>目标问题由多种因素（特征）决定，机器学习解决问题的优势才能体现（相对于简单规则或人工）；</li><li>目标问题需要持续优化，因为机器学习可以基于数据自我学习和迭代，持续地发挥价值。</li></ul><h2 id="三、对问题建模"><a href="#三、对问题建模" class="headerlink" title="三、对问题建模"></a>三、对问题建模</h2><p>本文以DEAL（团购单）交易额预估问题为例（就是预估一个给定DEAL一段时间内卖了多少钱），介绍使用机器学习如何解决问题。首先需要：</p><ul><li>收集问题的资料，理解问题，成为这个问题的专家；</li><li>拆解问题，简化问题，将问题转化机器可预估的问题。</li></ul><p>深入理解和分析DEAL交易额后，可以将它分解为如下图的几个问题：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3dy0751j30b207raae.jpg" alt=""></p><h3 id="3-1-单个模型？多个模型？如何来选择？"><a href="#3-1-单个模型？多个模型？如何来选择？" class="headerlink" title="3.1 单个模型？多个模型？如何来选择？"></a>3.1 单个模型？多个模型？如何来选择？</h3><p>按照上图进行拆解后，预估DEAL交易额就有2种可能模式，一种是直接预估交易额；另一种是预估各子问题，如建立一个用户数模型和建立一个访购率模型（访问这个DEAL的用户会购买的单子数），再基于这些子问题的预估值计算交易额。</p><p>不同方式有不同优缺点，具体如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvatrsetlj30ej04n74d.jpg" alt=""><br>选择哪种模式？</p><ul><li>1）问题可预估的难度，难度大，则考虑用多模型；</li><li>2）问题本身的重要性，问题很重要，则考虑用多模型；</li><li>3）多个模型的关系是否明确，关系明确，则可以用多模型。</li></ul><p>如果采用多模型，如何融合？</p><ul><li>可以根据问题的特点和要求进行线性融合，或进行复杂的融合。以本文问题为例，至少可以有如下两种：</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvt0kdaxyj315m0jy78g.jpg" alt=""></p><h3 id="3-2-模型选择"><a href="#3-2-模型选择" class="headerlink" title="3.2 模型选择"></a>3.2 模型选择</h3><p>对于DEAL交易额这个问题，我们认为直接预估难度很大，希望拆成子问题进行预估，即多模型模式。那样就需要建立用户数模型和访购率模型，因为机器学习解决问题的方式类似，下文只以访购率模型为例。要解决访购率问题，首先要选择模型，我们有如下的一些考虑：</p><blockquote><p>主要考虑</p></blockquote><ul><li>1）选择与业务目标一致的模型；</li><li>2）选择与训练数据和特征相符的模型。</li></ul><p>训练数据少，High Level特征多，则使用“复杂”的非线性模型（流行的GBDT、Random Forest等）；</p><p>训练数据很大量，Low Level特征多，则使用“简单”的线性模型（流行的LR、Linear-SVM等）。</p><blockquote><p>补充考虑</p></blockquote><p>1）当前模型是否被工业界广泛使用；<br>2）当前模型是否有比较成熟的开源工具包（公司内或公司外）；<br>3）当前工具包能够的处理数据量能否满足要求；<br>4）自己对当前模型理论是否了解，是否之前用过该模型解决问题。</p><p>为实际问题选择模型，需要转化问题的业务目标为模型评价目标，转化模型评价目标为模型优化目标；根据业务的不同目标，选择合适的模型，具体关系如下：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvt0qi99mj30ko07aq3c.jpg" alt=""></p><p>通常来讲，预估真实数值（回归）、大小顺序（排序）、目标所在的正确区间（分类）的难度从大到小，根据应用所需，尽可能选择难度小的目标进行。对于访购率预估的应用目标来说，我们至少需要知道大小顺序或真实数值，所以我们可以选择Area Under Curve（AUC）或Mean Absolute Error（MAE）作为评估目标，以Maximum likelihood为模型损失函数（即优化目标）。综上所述，我们选择spark版本 GBDT或LR，主要基于如下考虑：</p><p>1）可以解决排序或回归问题；<br>2）我们自己实现了算法，经常使用，效果很好；<br>3）支持海量数据；<br>4）工业界广泛使用。</p><h2 id="四、准备训练数据"><a href="#四、准备训练数据" class="headerlink" title="四、准备训练数据"></a>四、准备训练数据</h2><p>深入理解问题，针对问题选择了相应的模型后，接下来则需要准备数据；数据是机器学习解决问题的根本，数据选择不对，则问题不可能被解决，所以准备训练数据需要格外的小心和注意：</p><h3 id="4-1-注意点："><a href="#4-1-注意点：" class="headerlink" title="4.1 注意点："></a>4.1 注意点：</h3><p>待解决问题的数据本身的分布尽量一致；<br>训练集/测试集分布与线上预测环境的数据分布尽可能一致，这里的分布是指（x,y）的分布，不仅仅是y的分布；<br>y数据噪音尽可能小，尽量剔除y有噪音的数据；<br>非必要不做采样，采样常常可能使实际数据分布发生变化，但是如果数据太大无法训练或者正负比例严重失调（如超过100:1）,则需要采样解决。</p><h3 id="4-2-常见问题及解决办法"><a href="#4-2-常见问题及解决办法" class="headerlink" title="4.2 常见问题及解决办法"></a>4.2 常见问题及解决办法</h3><p>待解决问题的数据分布不一致：<br>1）访购率问题中DEAL数据可能差异很大，如美食DEAL和酒店DEAL的影响因素或表现很不一致，需要做特别处理；要么对数据提前归一化，要么将分布不一致因素作为特征，要么对各类别DEAL单独训练模型。<br>数据分布变化了：<br>1）用半年前的数据训练模型，用来预测当前数据，因为数据分布随着时间可能变化了，效果可能很差。尽量用近期的数据训练，来预测当前数据，历史的数据可以做降权用到模型，或做transfer learning。<br>y数据有噪音：<br>1）在建立CTR模型时，将用户没有看到的Item作为负例，这些Item是因为用户没有看到才没有被点击，不一定是用户不喜欢而没有被点击，所以这些Item是有噪音的。可以采用一些简单规则，剔除这些噪音负例，如采用skip-above思想，即用户点过的Item之上，没有点过的Item作为负例（假设用户是从上往下浏览Item）。<br>采样方法有偏，没有覆盖整个集合：<br>1）访购率问题中，如果只取只有一个门店的DEAL进行预估，则对于多门店的DEAL无法很好预估。应该保证一个门店的和多个门店的DEAL数据都有；<br>2）无客观数据的二分类问题，用规则来获得正/负例，规则对正/负例的覆盖不全面。应该随机抽样数据，进行人工标注，以确保抽样数据和实际数据分布一致。</p><h3 id="4-3-访购率问题的训练数据"><a href="#4-3-访购率问题的训练数据" class="headerlink" title="4.3 访购率问题的训练数据"></a>4.3 访购率问题的训练数据</h3><p>收集N个月的DEAL数据（x）及相应访购率（y）；<br>收集最近N个月，剔除节假日等非常规时间 （保持分布一致）；<br>只收集在线时长&gt;T 且 访问用户数 &gt; U的DEAL （减少y的噪音）；<br>考虑DEAL销量生命周期 （保持分布一致）；<br>考虑不同城市、不同商圈、不同品类的差别 （保持分布一致）。</p><h2 id="五、抽取特征"><a href="#五、抽取特征" class="headerlink" title="五、抽取特征"></a>五、抽取特征</h2><p>完成数据筛选和清洗后，就需要对数据抽取特征，就是完成输入空间到特征空间的转换（见下图）。针对线性模型或非线性模型需要进行不同特征抽取，线性模型需要更多特征抽取工作和技巧，而非线性模型对特征抽取要求相对较低。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3dyxs7oj30bk0ababn.jpg" alt=""></p><p>通常，特征可以分为High Level与Low Level，High Level指含义比较泛的特征，Low Level指含义比较特定的特征，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEAL A1属于POIA，人均50以下，访购率高；</div><div class="line">DEAL A2属于POIA，人均50以上，访购率高；</div><div class="line">DEAL B1属于POIB，人均50以下，访购率高；</div><div class="line">DEAL B2属于POIB，人均50以上，访购率底；</div></pre></td></tr></table></figure><p>基于上面的数据，可以抽到两种特征，POI（门店）或人均消费；POI特征则是Low Level特征，人均消费则是High Level特征；假设模型通过学习，获得如下预估：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果DEALx 属于POIA（Low Level feature），访购率高；</div><div class="line">如果DEALx 人均50以下（High Level feature），访购率高。</div></pre></td></tr></table></figure><p>所以，总体上，Low Level 比较有针对性，单个特征覆盖面小（含有这个特征的数据不多），特征数量（维度）很大。High Level比较泛化，单个特征覆盖面大（含有这个特征的数据很多），特征数量（维度）不大。长尾样本的预测值主要受High Level特征影响。高频样本的预测值主要受Low Level特征影响。</p><p>对于访购率问题，有大量的High Level或Low Level的特征，其中一些展示在下图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvt0w5zctj30f7086gls.jpg" alt=""></p><p>非线性模型的特征</p><ul><li>1）可以主要使用High Level特征，因为计算复杂度大，所以特征维度不宜太高；</li><li>2）通过High Level非线性映射可以比较好地拟合目标。</li></ul><p>线性模型的特征</p><ul><li>1）特征体系要尽可能全面，High Level和Low Level都要有；</li><li>2）可以将High Level转换Low Level，以提升模型的拟合能力。</li></ul><h3 id="5-1-特征归一化"><a href="#5-1-特征归一化" class="headerlink" title="5.1 特征归一化"></a>5.1 特征归一化</h3><p>特征抽取后，如果不同特征的取值范围相差很大，最好对特征进行归一化，以取得更好的效果，常见的归一化方式如下：</p><ul><li><p>Rescaling：<br>归一化到[0,1] 或 [-1，1]，用类似方式：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3dzdrjfj30500170sk.jpg" alt=""></p></li><li><p>Standardization：<br>设为x分布的均值，为x分布的标准差；<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3dzuuetj302d00xdfl.jpg" alt=""></p></li><li><p>Scaling to unit length：<br>归一化到单位长度向量<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3e0cd2zj301y012dfl.jpg" alt=""></p></li></ul><h3 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h3><p>特征抽取和归一化之后，如果发现特征太多，导致模型无法训练，或很容易导致模型过拟合，则需要对特征进行选择，挑选有价值的特征。</p><ul><li><p>Filter：<br>假设特征子集对模型预估的影响互相独立，选择一个特征子集，分析该子集和数据Label的关系，如果存在某种正相关，则认为该特征子集有效。衡量特征子集和数据Label关系的算法有很多，如Chi-square，Information Gain。</p></li><li><p>Wrapper：<br>选择一个特征子集加入原有特征集合，用模型进行训练，比较子集加入前后的效果，如果效果变好，则认为该特征子集有效，否则认为无效。</p></li><li><p>Embedded：<br>将特征选择和模型训练结合起来，如在损失函数中加入L1 Norm ，L2 Norm。</p></li></ul><h2 id="六、训练模型"><a href="#六、训练模型" class="headerlink" title="六、训练模型"></a>六、训练模型</h2><p>完成特征抽取和处理后，就可以开始模型训练了，下文以简单且常用的Logistic Regression模型（下称LR模型）为例，进行简单介绍。</p><p>设有m个（x,y）训练数据，其中x为特征向量，y为label，；w为模型中参数向量，即模型训练中需要学习的对象。<br>所谓训练模型，就是选定假说函数和损失函数，基于已有训练数据（x,y），不断调整w，使得损失函数最优，相应的w就是最终学习结果，也就得到相应的模型。</p><h3 id="6-1-模型函数"><a href="#6-1-模型函数" class="headerlink" title="6.1 模型函数"></a>6.1 模型函数</h3><p>假说函数，即假设x和y存在一种函数关系：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3e1aa1pj307m013dfn.jpg" alt=""></p><p>损失函数，基于上述假设函数，构建模型损失函数（优化目标），在LR中通常以（x,y）的最大似然估计为目标：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3e27k66j30bs01f3yf.jpg" alt=""></p><h3 id="6-2-优化算法"><a href="#6-2-优化算法" class="headerlink" title="6.2 优化算法"></a>6.2 优化算法</h3><ul><li>梯度下降（Gradient Descent）<br>即w沿着损失函数的负梯度方向进行调整，示意图见下图，的梯度即一阶导数（见下式），梯度下降有多种类型，如随机梯度下降或批量梯度下降。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3e2nh2bj306q01fglg.jpg" alt=""><br>随机梯度下降（Stochastic Gradient Descent），每一步随机选择一个样本，计算相应的梯度，并完成w的更新，如下式，<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3e34iizj309k00mjr8.jpg" alt=""></li></ul><p>批量梯度下降（Batch Gradient Descent）,每一步都计算训练数据中的所有样本对应的梯度，w沿着这个梯度方向迭代，即<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3e4jq1ij30ae01fa9y.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvt19ab7cj309q0agmxc.jpg" alt=""></p><ul><li>牛顿法（Newton’s Method）</li></ul><p>牛顿法的基本思想是在极小点附近通过对目标函数做二阶Taylor展开，进而找到L(w)的极小点的估计值。形象地讲，在wk处做切线，该切线与L(w)=0的交点即为下一个迭代点wk+1（示意图如下）。w的更新公式如下，其中目标函数的二阶偏导数，即为大名鼎鼎的Hessian矩阵。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvt1hyre4j307e01adfm.jpg" alt=""></p><p>拟牛顿法（Quasi-Newton Methods）：计算目标函数的二阶偏导数，难度较大，更为复杂的是目标函数的Hessian矩阵无法保持正定；不用二阶偏导数而构造出可以近似Hessian矩阵的逆的正定对称阵，从而在”拟牛顿”的条件下优化目标函数。</p><p>BFGS： 使用BFGS公式对H(w)进行近似，内存中需要放H(w),内存需要O(m2)级别；</p><p>L-BFGS：存储有限次数（如k次）的更新矩阵，用这些更新矩阵生成新的H(w),内存降至O(m)级别；</p><p>OWLQN: 如果在目标函数中引入L1正则化，需要引入虚梯度来解决目标函数不可导问题，OWLQN就是用来解决这个问题。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3e5m7ylj30dm0ay3z7.jpg" alt=""></p><ul><li>Coordinate Descent<br>对于w，每次迭代，固定其他维度不变，只对其一个维度进行搜索，确定最优下降方向（示意图如下），公式表达如下：</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3e6elnkj308r00mdfo.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3e6vsbgj30cg09cjru.jpg" alt=""></p><h2 id="七、优化模型"><a href="#七、优化模型" class="headerlink" title="七、优化模型"></a>七、优化模型</h2><p>经过上文提到的数据筛选和清洗、特征设计和选择、模型训练，就得到了一个模型，但是如果发现效果不好？怎么办？</p><p>【首先】<br>反思目标是否可预估，数据和特征是否存在bug。</p><p>【然后】<br>分析一下模型是Overfitting还是Underfitting，从数据、特征和模型等环节做针对性优化。</p><h3 id="7-1-Underfitting-amp-Overfitting"><a href="#7-1-Underfitting-amp-Overfitting" class="headerlink" title="7.1 Underfitting &amp; Overfitting"></a>7.1 Underfitting &amp; Overfitting</h3><p>所谓Underfitting，即模型没有学到数据内在关系，如下图左一所示，产生分类面不能很好的区分X和O两类数据；产生的深层原因，就是模型假设空间太小或者模型假设空间偏离。<br>所谓Overfitting，即模型过渡拟合了训练数据的内在关系，如下图右一所示，产生分类面过好地区分X和O两类数据，而真实分类面可能并不是这样，以至于在非训练数据上表现不好；产生的深层原因，是巨大的模型假设空间与稀疏的数据之间的矛盾。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwvt4i2rndj30jw05rgm3.jpg" alt=""></p><p>在实战中，可以基于模型在训练集和测试集上的表现来确定当前模型到底是Underfitting还是Overfitting，判断方式如下表：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvt4mo90qj309i0423yi.jpg" alt=""></p><h3 id="7-2-怎么解决Underfitting和Overfitting问题？"><a href="#7-2-怎么解决Underfitting和Overfitting问题？" class="headerlink" title="7.2 怎么解决Underfitting和Overfitting问题？"></a>7.2 怎么解决Underfitting和Overfitting问题？</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwvt4u2ca2j30j307tjrp.jpg" alt=""></p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>综上所述，机器学习解决问题涉及到问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节，有如下要点：</p><ul><li><p>理解业务，分解业务目标，规划模型可预估的路线图。</p></li><li><p>数据：y数据尽可能真实客观；训练集/测试集分布与线上应用环境的数据分布尽可能一致。</p></li><li><p>特征：利用Domain Knowledge进行特征抽取和选择；针对不同类型的模型设计不同的特征。</p></li><li><p>模型：针对不同业务目标、不同数据和特征，选择不同的模型；如果模型不符合预期，一定检查一下数据、特征、模型等处理环节是否有bug；考虑模型Underfitting和Qverfitting，针对性地优化。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（38）：外卖订单量预测异常报警模型实践</title>
    <link href="http://yoursite.com/2017/09/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8838%EF%BC%89%EF%BC%9A%E5%A4%96%E5%8D%96%E8%AE%A2%E5%8D%95%E9%87%8F%E9%A2%84%E6%B5%8B%E5%BC%82%E5%B8%B8%E6%8A%A5%E8%AD%A6%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/09/06/机器学习算法系列（38）：外卖订单量预测异常报警模型实践/</id>
    <published>2017-09-06T15:14:45.000Z</published>
    <updated>2018-11-03T11:21:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>外卖业务的快速发展对系统稳定性提出了更高的要求，每一次订单量大盘的异常波动，都需要做出及时的应对，以保证系统的整体稳定性。如何做出较为准确的波动预警，显得尤为重要。</p><a id="more"></a><p>从时间上看，外卖订单量时间序列有两个明显的特征（如下图所示）：</p><p>周期性。每天订单量的变化趋势都大致相同，午高峰和晚高峰订单量集中。<br>实时性。当天的订单量可能会受天气等因素影响，呈现整体的上涨或下降。<br>订单量波动预警，初期外卖订单中心使用的是当前时刻和前一时刻订单量比较，超过一定阈值就报警的方式，误报率和漏报率都比较大。后期将业务数据上传到美团点评的服务治理平台，使用该平台下的基线报警模型进行监控报警。基线数据模型考虑到了订单量时间序列的周期性特征，但是忽略了实时性特征，在实际使用中误报率依然很高，大量的误报漏报导致RD对于报警已经麻木，出现问题时不能及时响应，因此，急需一种新的异常检测模型，提高报警的准确率。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv39pcr1fj30me0d0t9k.jpg" alt=""></p><h2 id="二、异常检测的定义"><a href="#二、异常检测的定义" class="headerlink" title="二、异常检测的定义"></a>二、异常检测的定义</h2><p>异常，意为“异于正常”。异常检测，就是从一组数据中寻找那些和期望数据不同的数据。监控数据都是和时间相关的，每一个监控指标只有和时间组合一起才有其具体的含义。按照时间顺序，将监控指标组成一个序列，我们就得到了监控指标的时间序列。</p><p>基于预测的异常检测模型如下图所示，xt是真实数据，通过预测器得到预测数据，然后xt和pt分别作为比较器的输入，最终得到输出yt。yt是一个二元值，可以用+1（+1表示输入数据正常），-1（-1表示输入数据异常）表示。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv39ptq9aj31d00m2q3y.jpg" alt=""></p><p>异常检测主要有两种策略：</p><ul><li>异常驱动的异常检测（敏感性）：宁愿误报，也不能错过任何一个异常，这适用于非常重要的检测。简单概括，就是“宁可错杀一千，不能放过一个”。</li><li>预算驱动的异常检测（准确性）：这种策略的异常检测，从字面理解就是只有定量的一些预算去处理这些报警，那么只能当一定是某种问题时，才能将报警发送出来。</li></ul><p>这两种策略不可兼容的。对于检测模型的改善，可以从两个方面入手，一是预测器的优化，二是比较器的优化。我们从这两个方面描述模型的改善。</p><h2 id="三、预测器设计"><a href="#三、预测器设计" class="headerlink" title="三、预测器设计"></a>三、预测器设计</h2><p>预测器，就是用一批历史数据预测当前的数据。使用的历史数据集大小，以及使用的预测算法都会影响最终的预测效果。</p><p>外卖订单量具有明显的周期性，同时相邻时刻的订单量数据也有很强的相关性，我们的目标，就是使用上面说的相关数据预测出当前的订单量。下面，我们分析几种常用的预测器实现。</p><h3 id="3-1-同比环比预测器"><a href="#3-1-同比环比预测器" class="headerlink" title="3.1 同比环比预测器"></a>3.1 同比环比预测器</h3><p>同比环比是比较常用的异常检测方式，它是将当前时刻数据和前一时刻数据（环比）或者前一天同一时刻数据（同比）比较，超过一定阈值即认为该点异常。如果用图2.1模型来表示，那么预测器就可以表示为用当前时刻前一时刻或者前一天同一时刻数据作为当前时刻的预测数据。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv39qa4v6j30a207ut8s.jpg" alt=""></p><p>假如需要预测图中黄色数据，那么环比使用图中的蓝色数据作为预测黄点的源数据，同比使用图中红色数据作为预测黄点的源数据。</p><h3 id="3-2-基线预测器"><a href="#3-2-基线预测器" class="headerlink" title="3.2 基线预测器"></a>3.2 基线预测器</h3><p>同比环比使用历史上的单点数据来预测当前数据，误差比较大。t时刻的监控数据，与<br>$t-1,t-2,…$时刻的监控数据存在相关性。同时，与$t-k,t-2k,…$时刻的数据也存在相关性（k为周期），如果能利用上这些相关数据对t时刻进行预测，预测结果的误差将会更小。</p><p>比较常用的方式是对历史数据求平均，然后过滤噪声，可以得到一个平滑的曲线（基线），使用基线数据来预测当前时刻的数据。该方法预测t时刻数据（图中黄色数据）使用到的历史数据如下图所示（图中红色数据）：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv39qrp90j309s07e74g.jpg" alt=""></p><p>基线数据预测器广泛应用在业务大盘监控中，预测效果如图3.3所示。从图中可以看出，基线比较平滑，在低峰期预测效果比较好，但是在外卖的午高峰和晚高峰预测误差比较大。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv39ratt6j310z0rxtay.jpg" alt=""></p><h3 id="3-3-Holt-Winters预测器"><a href="#3-3-Holt-Winters预测器" class="headerlink" title="3.3 Holt-Winters预测器"></a>3.3 Holt-Winters预测器</h3><p>同比环比预测到基线数据预测，使用的相关数据变多，预测的效果也较好。但是基线数据预测器只使用了周期相关的历史数据，没有使用上同周期相邻时刻的历史数据，相邻时刻的历史数据对于当前时刻的预测影响是比较大的。如外卖订单量，某天天气不好，很多用户不愿意出门，那么当天的外卖的订单量就会呈现整体的上涨，这种整体上涨趋势只能从同一周期相邻时刻的历史数据中预测出来。如图3.4所示，预测图中黄色数据，如果使用上图中所有的红色数据，那么预测效果会更好。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv39s5ki0j309u07k3yo.jpg" alt=""></p><p>本文使用了Holt-Winters来实现这一目标。</p><p>Holt-Winters是三次指数滑动平均算法，它将时间序列数据分为三部分：残差数据a(t)，趋势性数据b(t)，季节性数据s(t)。使用Holt-Winters预测t时刻数据，需要t时刻前包含多个周期的历史数据。相关链接：Exponential smoothing、Holt-Winters seasonal method。</p><p>各部分的迭代计算公式（周期为k）：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv39t3fwkj30sc09adgx.jpg" alt=""></p><p>如图所示，(a)显示了某一段时间内外卖订单的原始提单监控数据（分钟统计量，周期为1天），图(b)显示了其Holt-Winters的分解图（四幅图分别对应原始数据、残差数据分量、趋势数据分量、周期数据分量）。将订单量时间序列分解为残差数据a(t)，趋势数据b(t)，周期数据s(t)后，就可以使用下面的公式预测未来不同时刻时刻的订单量，其中h表示未来时刻距离当前时刻的跨度。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv39uya5oj30rq02m0sx.jpg" alt=""></p><p>外卖订单量，是按分钟统计的离散时间序列，所以如果需要预测下一分钟的订单量，令h=1。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv39vibr9j31kw0wbtd8.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv39wgypsj31kw0t3djn.jpg" alt=""></p><h3 id="3-4-外卖报警模型中的预测器"><a href="#3-4-外卖报警模型中的预测器" class="headerlink" title="3.4 外卖报警模型中的预测器"></a>3.4 外卖报警模型中的预测器</h3><p>在外卖订单量异常检测中，使用Holt-Winters预测器实时预测下一分钟订单量，每次需要至少5天以上的订单量数据才能有较好的预测效果，数据量要求比较大。</p><p>在实际的异常检测模型中，我们对Holt-Winters预测器进行了简化。预测器的趋势数据表示的是时间序列的总体变化趋势，如果以天为周期看待外卖的订单量时间序列，是没有明显的趋势性的，图3.5(b)的分解图也证明了这一点。因此，我们可以去掉其中的趋势数据部分。</p><p>各部分的迭代公式简化为(3-1)：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv39wuk44j30lo046t90.jpg" alt=""></p><p>预测值：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv39z69mlj30ja02274j.jpg" alt=""></p><p>h越大，预测值Yhat[t+h] 的误差也就越大。实时的订单流监控，令h=1，每当有新的监控数据时，更新输入序列，然后预测下一分钟数据。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv39zncvrj30fc03cglk.jpg" alt=""></p><p>Holt-Winters每一次预测都需要大量的输入数据序列。从上面模型的简化公式可以看出，对残差数据a(t)的预测是对序列(a(t-m),a(t-m+1),…a(t-2),a(t-1))的一次指数滑动平均，对周期数据s(t)的预测是对序列（s(t-mk) ,s(t-(m-1)k),…s(t-k)）的一次滑动平均，大量的输入数据是用于周期数据s(t)的计算。</p><p>a(t)和s(t)是互相关联的迭代计算过程，如果从周期性角度看公式(3-1)，可以发现：计算当前周期内的a(t)时，使用的是上一周期计算出来的s(t-k)，当前周期计算出的s(t)是用于下一周期a(t+k)的计算。为了将算法应用到线上的实时预测，我们可以将Holt-Winters算法拆分为两个独立的计算过程：</p><ul><li>定时任务计算序列的周期数s(t)。</li><li>对残差序列做实时预测。</li></ul><p>下面就分别从这两个步骤介绍外卖报警模型中的预测器实现。</p><h4 id="3-4-1-计算序列的周期性数据"><a href="#3-4-1-计算序列的周期性数据" class="headerlink" title="3.4.1 计算序列的周期性数据"></a>3.4.1 计算序列的周期性数据</h4><p>时间序列的周期性数据不需要实时计算，按周期性更新即可，如外卖订单大盘监控，s(t)只需要每天更新一次即可。对于s(t)的计算，可以有多种方法，可以使用上面提到的Holt-Winters按公式(3-1)计算出时间序列的周期性数据（如图3.5b所示），或直接使用前一天的监控数据作为当天的周期数据（这两种方式都需要对输入序列进行预处理，保证算法的输入序列不含有异常数据）。也可以用上面3.2节提到的，将历史数据做平均求出基线作为序列的周期性数据。</p><p>目前外卖订单中心报警模型采用的是Holt-Winters计算周期数据的方式。在将该模型推广到外卖其他业务线监控时，使用了计算基线数据作为周期数据的方式，这里简单对比一下两种方式的优劣。</p><blockquote><p>使用Holt-Winters算法计算周期数据</p></blockquote><p>优点：如果序列中含有周期性的陡增陡降点，Holt-Winters计算出的周期数据中会保留这些陡增陡降趋势，因此可以准确的预测出这些趋势，不会产生误报。比如外卖订单的提单数据，在每天的某个时刻都有一个定期陡降，使用该方式可以正确的预测出下降的趋势。如图3.6所示，蓝色线是真实数据，棕色线是预测数据，在该时刻，棕色线准确的预测出了下降点。</p><p>缺点：需要对输入数据进行预处理，去除异常数据。如果输入序列中含有异常数据，使用Holt-Winters时可能会把这些异常数据计算到周期数据中，影响下一周期的预测从而产生误报（Holt-Winters理论上也只是滑动平均的过程，因此如果输入数据中含有比较大的异常数据时，存在这种可能性，实际应用中订单的报警模型也出现过这种误报）。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3a05f92j30vj0kcwfn.jpg" alt=""></p><blockquote><p>历史数据平均求基线</p></blockquote><p>优点：计算出的周期数据比较平滑，不需要对输入序列进行预处理，计算过程中可以自动屏蔽掉异常数据的影响，计算过程简单，如图3.3所示的基线数据。<br>缺点：周期数据比较平滑，不会出现陡增陡降点，因此对于周期性出现的陡增陡降不能很好的预测，出现误报。比如外卖活动的大盘（如图3.7所示，红线是真实数据，黑线是预测数据），提前下单优惠在每天某个时刻会出现周期性陡降，使用该方式会出现误报。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3a0llh6j314r0jzabz.jpg" alt=""></p><p>两种求周期数据的方式各有优劣，可以根据各自的监控数据特点选择合适的计算方式。如果监控数据中含有大量的周期性的陡增陡降点，那么推荐使用方式1，可以避免在这些时间点的误报。如果监控数据比较平滑，陡增陡降点很少，那么推荐方式2，计算简单的同时，也能避免因输入数据预处理不好而造成的意料之外的误报。</p><h4 id="3-4-2-残差数据实时预测"><a href="#3-4-2-残差数据实时预测" class="headerlink" title="3.4.2 残差数据实时预测"></a>3.4.2 残差数据实时预测</h4><p>计算出周期数据后，下一个目标就是对残差数据的预测。使用下面的公式，实际监控数据与周期数据相减得到残差数据，对残差数据做一次滑动平均，预测出下一刻的残差，将该时刻的残差、周期数据相加即可得到该时刻的预测数据。残差序列的长度设为60，即可以得到比较准确的预测效果。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3a1l32dj30kq02s3yj.jpg" alt=""></p><p>对于实时预测，使用的是当天的周期数据和前60分钟数据。最终的预测结果如图3.8(a)(b)所示，其中蓝色线是真实数据，红色线是预测数据。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3a2nbeyj31kw0urn6v.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3a5riadj31kb0wf48e.jpg" alt=""></p><h2 id="四、比较器设计"><a href="#四、比较器设计" class="headerlink" title="四、比较器设计"></a>四、比较器设计</h2><p>预测器预测出当前时刻订单量的预测值后，还需要与真实值比较来判断当前时刻订单量是否异常。一般的比较器都是通过阈值法，比如实际值超过预测值的一定比例就认为该点出现异常，进行报警。这种方式错误率比较大。在订单模型的报警检测中没有使用这种方式，而是使用了两个串联的Filter（如图4.1所示），只有当两个Fliter都认为该点异常时，才进行报警，下面简单介绍一下两个Filter的实现。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3a67zigj315k0jk3zr.jpg" alt=""></p><p>离散度Filter：根据预测误差曲线离散程度过滤出可能的异常点。一个序列的方差表示该序列离散的程度，方差越大，表明该序列波动越大。如果一个预测误差序列方差比较大，那么我们认为预测误差的报警阈值相对大一些才比较合理。离散度Filter利用了这一特性，取连续15分钟的预测误差序列，分为首尾两个序列（e1,e2），如果两个序列的均值差大于e1序列方差的某个倍数，我们就认为该点可能是异常点。</p><p>阈值Filter：根据误差绝对值是否超过某个阈值过滤出可能的异常点。利用离散度Filter进行过滤时，报警阈值随着误差序列波动程度变大而变大，但是在输入数据比较小时，误差序列方差比较小，报警阈值也很小，容易出现误报。所以设计了根据误差绝对值进行过滤的阈值Filter。阈值Filter设计了一个分段阈值函数y=f(x)，对于实际值x和预测值p，只有当|x-p|&gt;f(x)时报警。实际使用中，可以寻找一个对数函数替换分段阈值函数，更易于参数调优。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3a76evij30qg0gognw.jpg" alt=""></p><h2 id="五、报警模型最终效果"><a href="#五、报警模型最终效果" class="headerlink" title="五、报警模型最终效果"></a>五、报警模型最终效果</h2><p>最终的外卖订单异常报警模型结构图如图5.1所示，每天会有定时Job从ETL中统计出最近10天的历史订单量，经过预处理模块，去除异常数据，经过周期数据计算模块得到周期性数据。对当前时刻预测时，取60分钟的真实数据和周期性数据，经过实时预测模块，预测出当前订单量。将连续15分钟的预测值和真实值通过比较器，判断当前时刻是否异常。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3a7ot31j30yw0x8gpl.jpg" alt=""></p><p>新的报警模型上线后，外卖订单量的异常检测的漏报率和误报率都有显著的提升，上线半年以来，对于每一次的异常都能准确的检测出来，漏报率近乎为0。误报率在通常情况下限制在了每周0~3次误报。</p><p>报警模型目前应用在外卖订单量的异常检测中，同时推广到了外卖业务的其他各种大盘监控中，取得了不错的效果。在报警模型上线后，我们发现并解决了一些系统隐患点，如：</p><ul><li>点评侧外卖提单量在每天定时有一个下降尖刺，经过排查是因为客户端冷启动短时间内大量的请求，导致SLB性能达到瓶颈，从而导致接口成功率下降。</li><li>点评侧外卖订单取消量经常会有尖刺，经过排查发现是由于在支付时，需要进行跨机房的账号转换，专线网络抖动时造成接口超时。</li><li>外卖订单量在每天某些时刻都有陡降趋势，经过排查，是因为这些点大量商家开始休息导致的。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>将机器学习中的预测算法运用到外卖订单的异常检测中，极大的提高了异常检测的准确性和敏感性，提升了系统稳定运维的效率。该报警模型也有很广泛的应用场景，美团点评的各个业务线的监控数据，绝大多数都是含有明显周期性的时间序列，本文提出的模型都能运用到这些监控数据的异常检测中。</p><p>当然，模型还有进一步完善的空间，如：</p><ul><li>历史数据的预处理优化。在进行周期数据计算时，对于输入序列的预处理，如果能够排除绝大部分的异常数据，那么最终检测的误报率将会进一步的降低。</li><li>在不会产生持续误报的情况下替换有异常的实时数据。对于当前数据的预测，利用的都是前60分钟的真实数据，但是这些数据可能本身就存在异常数据，那么就存在一种情况，当出现异常时，真实数据开始下跌，预测数据紧接着也会下跌（如图3.8b所示）。这种情况有时候可能满足需求（比如只在异常开始的时候进行报警，异常持续时间内不再报警，防止报警太多造成的信息轰炸），有时候可能不满足需求（比如要求预测数据不跟随异常变化而变化，这种情况可以应用在故障期间的损失统计中）。如果需要预测值不随异常变化而变化，一种可能的方法是，当检测到当前数据是异常数据时，将预测数据替换当前的真实数据，作为下一时刻预测器的输入，这样可以防止异常数据对于下一时刻预测值的影响。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;外卖业务的快速发展对系统稳定性提出了更高的要求，每一次订单量大盘的异常波动，都需要做出及时的应对，以保证系统的整体稳定性。如何做出较为准确的波动预警，显得尤为重要。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="异常检测" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（37）：外卖O2O的用户画像实践</title>
    <link href="http://yoursite.com/2017/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8837%EF%BC%89%EF%BC%9A%E5%A4%96%E5%8D%96O2O%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/09/05/机器学习算法系列（37）：外卖O2O的用户画像实践/</id>
    <published>2017-09-05T15:14:45.000Z</published>
    <updated>2018-11-03T11:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>美团外卖经过3年的飞速发展，品类已经从单一的外卖扩展到了美食、夜宵、鲜花、商超等多个品类。用户群体也从早期的学生为主扩展到学生、白领、社区以及商旅，甚至包括在KTV等娱乐场所消费的人群。随着供给和消费人群的多样化，如何在供给和用户之间做一个对接，就是用户画像的一个基础工作。所谓千人千面，画像需要刻画不同人群的消费习惯和消费偏好。</p><a id="more"></a><p>外卖O2O和传统的电商存在一些差异。可以简单总结为如下几点：</p><p>1）新事物，快速发展：这意味很多用户对外卖的认知较少，对平台上的新品类缺乏了解，对自身的需求也没有充分意识。平台需要去发现用户的消费意愿，以便对用户的消费进行引导。</p><p>2）高频：外卖是个典型的高频O2O应用。一方面消费频次高，用户生命周期相对好判定；另一方面消费单价较低，用户决策时间短、随意性大。</p><p>3）场景驱动：场景是特定的时间、地点和人物的组合下的特定的消费意图。不同的时间、地点，不同类型的用户的消费意图会有差异。例如白领在写字楼中午的订单一般是工作餐，通常在营养、品质上有一定的要求，且单价不能太高；而到了周末晚上的订单大多是夜宵，追求口味且价格弹性较大。场景辨识越细致，越能了解用户的消费意图，运营效果就越好。</p><p>4）用户消费的地理位置相对固定，结合地理位置判断用户的消费意图是外卖的一个特点。</p><h2 id="一、外卖产品运营对画像技术的要求"><a href="#一、外卖产品运营对画像技术的要求" class="headerlink" title="一、外卖产品运营对画像技术的要求"></a>一、外卖产品运营对画像技术的要求</h2><p>如下图所示，我们大致可以把一个产品的运营分为用户获取和用户拓展两个阶段。在用户获取阶段，用户因为自然原因或一些营销事件（例如广告、社交媒体传播）产生对外卖的注意，进而产生了兴趣，并在合适的时机下完成首购，从而成为外卖新客。在这一阶段，运营的重点是提高效率，通过一些个性化的营销和广告手段，吸引到真正有潜在需求的用户，并刺激其转化。在用户完成转化后，接下来的运营重点是拓展用户价值。这里有两个问题：第一是提升用户价值，具体而言就是提升用户的单均价和消费频次，从而提升用户的LTV（life-time value)。基本手段包括交叉销售（新品类的推荐）、向上销售（优质高价供给的推荐）以及重复购买（优惠、红包刺激重复下单以及优质供给的推荐带来下单频次的提升）；第二个问题是用户的留存，通过提升用户总体体验以及在用户有流失倾向时通过促销和优惠将用户留在外卖平台。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2eoqvbrj312y0j4te7.jpg" alt=""></p><p>所以用户所处的体验阶段不同，运营的侧重点也需要有所不同。而用户画像作为运营的支撑技术，需要提供相应的用户刻画以满足运营需求。根据上图的营销链条，从支撑运营的角度，除去提供常规的用户基础属性（例如年龄、性别、职业、婚育状况等）以及用户偏好之外，还需要考虑这么几个问题：1）什么样的用户会成为外卖平台的顾客（新客识别）；2）用户所处生命周期的判断，用户是否可能从平台流失（流失预警）；3）用户处于什么样的消费场景（场景识别）。后面“外卖O2O的用户画像实践”一节中，我们会介绍针对这三个问题的一些实践。</p><h2 id="二、外卖画像系统架构"><a href="#二、外卖画像系统架构" class="headerlink" title="二、外卖画像系统架构"></a>二、外卖画像系统架构</h2><p>下图是我们画像服务的架构：数据源包括基础日志、商家数据和订单数据。数据完成处理后存放在一系列主题表中，再导入kv存储，给下游业务端提供在线服务。同时我们会对整个业务流程实施监控。主要分为两部分，第一部分是对数据处理流程的监控，利用用内部自研的数据治理平台，监控每天各主题表产生的时间、数据量以及数据分布是否有异常。第二部分是对服务的监控。目前画像系统支持的下游服务包括：广告、排序、运营等系统。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2eq5i6zj31a60nmafu.jpg" alt=""></p><h2 id="三、外卖O2O的用户画像实践"><a href="#三、外卖O2O的用户画像实践" class="headerlink" title="三、外卖O2O的用户画像实践"></a>三、外卖O2O的用户画像实践</h2><h3 id="3-1-新客运营"><a href="#3-1-新客运营" class="headerlink" title="3.1 新客运营"></a>3.1 新客运营</h3><p>新客运营主要需要回答下列三个问题：</p><p>1）新客在哪里？</p><p>2）新客的偏好如何？</p><p>3）新客的消费力如何？</p><p>回答这三个问题是比较困难的，因为相对于老客而言，新客的行为记录非常少或者几乎没有。这就需要我们通过一些技术手段作出推断。例如：新客的潜在转化概率，受到新客的人口属性（职业、年龄等）、所处地域（需求的因素）、周围人群（同样反映需求）以及是否有充足供给等因素的影响；而对于新客的偏好和消费力，从新客在到店场景下的消费行为可以做出推测。另外用户的工作和居住地点也能反映他的消费能力。<br>对新客的预测大量依赖他在到店场景下的行为，而用户的到店行为对于外卖是比较稀疏的，大多数的用户是在少数几个类别上有过一些消费行为。这就意味着我们需要考虑选择什么样的统计量描述：是消费单价，总消费价格，消费品类等等。然后通过大量的试验来验证特征的显著性。另外由于数据比较稀疏，需要考虑合适的平滑处理。</p><p>我们在做高潜新客挖掘时，融入了多方特征，通过特征的组合最终作出一个效果比较好的预测模型。我们能够找到一些高转化率的用户，其转化率比普通用户高若干倍。通过对高潜用户有针对性的营销，可以极大提高营销效率。</p><h3 id="3-2-流失预测"><a href="#3-2-流失预测" class="headerlink" title="3.2 流失预测"></a>3.2 流失预测</h3><p>新客来了之后，接下来需要把他留在这个平台上，尽量延长生命周期。营销领域关于用户留存的两个基本观点是（引自菲利普.科特勒 《营销管理》）：</p><p>获取一个新顾客的成本是维系现有顾客成本的5倍！</p><p>如果将顾客流失率降低5%，公司利润将增加25%~85%</p><p>用户流失的原因通常包括：竞对的吸引；体验问题；需求变化。我们借助机器学习的方法，构建用户的描述特征，并借助这些特征来预测用户未来流失的概率。这里有两种做法: 第一种是预测用户未来若干天是否会下单这一事件发生的概率。这是典型的概率回归问题，可以选择逻辑回归、决策树等算法拟合给定观测下事件发生的概率；第二种是借助于生存模型，例如COX-PH模型，做流失的风险预测。下图左边是概率回归的模型，用户未来T天内是否有下单做为类别标记y，然后估计在观察到特征X的情况下y的后验概率P(y|X)。右边是用COX模型的例子，我们会根据用户在未来T天是否下单给样本一个类别，即观测时长记为T。假设用户的下单的距今时长t&lt;T，将t作为生存时长t’；否则将生存时长t’记为T。这样一个样本由三部分构成：样本的类别(flag)，生存时长(t’)以及特征列表。通过生存模型虽然无法显式得到P(t’|X)的概率，但其协变量部分实际反映了用户流失的风险大小。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2euve1lj31ja0isjxg.jpg" alt=""></p><p>生存模型中，βTx反映了用户流失的风险，同时也和用户下次订单的时间间隔成正相关。下面的箱线图中，横轴为βTx，纵轴为用户下单时间的间隔。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2evq1ddj30pq0ncadm.jpg" alt=""></p><p>我们做了COX模型和概率回归模型的对比。在预测用户XX天内是否会下单上面，两者有相近的性能。</p><p>美团外卖通过使用了用户流失预警模型，显著降低了用户留存的运营成本。</p><h3 id="3-3-场景运营"><a href="#3-3-场景运营" class="headerlink" title="3.3 场景运营"></a>3.3 场景运营</h3><p>拓展用户的体验，最重要的一点是要理解用户下单的场景。了解用户的订餐场景有助于基于场景的用户运营。对于场景运营而言，通常需要经过如下三个步骤：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2ewnwy5j30v60m40x0.jpg" alt=""><br>场景可以从时间、地点、订单三个维度描述。比如说工作日的下午茶，周末的家庭聚餐，夜里在家点夜宵等等。其中重要的一点是用户订单地址的分析。通过区分用户的订单地址是写字楼、学校或是社区，再结合订单时间、订单内容，可以对用户的下单场景做到大致的了解。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2ex3w1pj30jg0hwwh6.jpg" alt=""></p><p>上图是我们订单地址分析的流程。根据订单系统中的用户订单地址文本，基于自然语言处理技术对地址文本分析，可以得到地址的主干名称（指去掉了楼宇、门牌号的地址主干部分）和地址的类型（写字楼、住宅小区等）。在此基础上通过一些地图数据辅助从而判断出最终的地址类型。<br>另外我们还做了合并订单的识别，即识别一个订单是一个人下单还是拼单。把拼单信息、地址分析以及时间结合在一起，我们可以预测用户的消费场景，进而基于场景做交叉销售和向上销售。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>外卖的营销特征，跟其他行业的主要区别在于：</p><p>外卖是一个高频的业务。由于用户的消费频次高，用户生命周期的特征体现较显著。运营可以基于用户所处生命周期的阶段制定营销目标，例如用户完成首购后的频次提升、成熟用户的价值提升、衰退用户的挽留以及流失用户的召回等。因此用户的生命周期是一个基础画像，配合用户基本属性、偏好、消费能力、流失预测等其他画像，通过精准的产品推荐或者价格策略实现运营目标。</p><p>用户的消费受到时间、地点等场景因素驱动。因此需要对用户在不同的时间、地点下消费行为的差异做深入了解，归纳不同场景下用户需求的差异，针对场景制定相应的营销策略，提升用户活跃度。</p><p>另外由于外卖是一个新鲜的事物，在用户对一些新品类和新产品缺乏认知的情况下，需要通过技术手段识别用户的潜在需求，进行精准营销。例如哪些用户可能会对小龙虾、鲜花、蛋糕这样的相对低频、高价值的产品产生购买。可以采用的技术手段包括用户分群、对已产生消费的用户做look-alike扩展、迁移学习等。</p><p>同时我们在制作外卖的用户画像时还面临如下挑战：</p><p>1）数据多样性，存在大量非结构化数据例如用户地址、菜品名称等。需要用到自然语言处理技术，同时结合其他数据进行分析。</p><p>2）相对于综合电商而言，外卖是个相对单一的品类，用户在外卖上的行为不足以全方位地描述用户的基本属性。因此需要和用户在其他场合的消费行为做融合。</p><p>3）外卖单价相对较低，用户消费的决策时间短、随意性强。不像传统电商用户在决策前有大量的浏览行为可以用于捕捉用户单次的需求。因此更需要结合用户画像分析用户的历史兴趣、以及用户的消费场景，在消费前对用户做适当的引导、推荐。</p><p>面临这些挑战，需要用户画像团队更细致的数据处理、融合多方数据源，同时发展出新的方法论，才能更好地支持外卖业务发展的需要。而外卖的上述挑战，又分别和一些垂直领域电商类似，经验上存在可以相互借鉴之处。因此，外卖的用户画像的实践和经验累积，必将对整个电商领域的大数据应用作出新的贡献！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团外卖经过3年的飞速发展，品类已经从单一的外卖扩展到了美食、夜宵、鲜花、商超等多个品类。用户群体也从早期的学生为主扩展到学生、白领、社区以及商旅，甚至包括在KTV等娱乐场所消费的人群。随着供给和消费人群的多样化，如何在供给和用户之间做一个对接，就是用户画像的一个基础工作。所谓千人千面，画像需要刻画不同人群的消费习惯和消费偏好。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="用户画像" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（36）：GBDT算法原理深入解析</title>
    <link href="http://yoursite.com/2017/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8836%EF%BC%89%EF%BC%9AGBDT%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/09/04/机器学习算法系列（36）：GBDT算法原理深入解析/</id>
    <published>2017-09-04T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>梯度提升（Gradient boosting）是一种用于回归、分类和排序任务的机器学习技术[1]，属于Boosting算法族的一部分。Boosting是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是“三个臭皮匠顶个诸葛亮”的道理。梯度提升同其他boosting方法一样，通过集成（ensemble）多个弱学习器，通常是决策树，来构建最终的预测模型。</p><a id="more"></a><p>Boosting、bagging和stacking是集成学习的三种主要方法。不同于bagging方法，boosting方法通过分步迭代（stage-wise）的方式来构建模型，在迭代的每一步构建的弱学习器都是为了弥补已有模型的不足。Boosting族算法的著名代表是AdaBoost，AdaBoost算法通过给已有模型预测错误的样本更高的权重，使得先前的学习器做错的训练样本在后续受到更多的关注的方式来弥补已有模型的不足。与AdaBoost算法不同，梯度提升方法在迭代的每一步构建一个能够沿着梯度最陡的方向降低损失（steepest-descent）的学习器来弥补已有模型的不足。经典的AdaBoost算法只能处理采用指数损失函数的二分类学习任务[2]，而梯度提升方法通过设置不同的可微损失函数可以处理各类学习任务（多分类、回归、Ranking等），应用范围大大扩展。另一方面，AdaBoost算法对异常点（outlier）比较敏感，而梯度提升算法通过引入bagging思想、加入正则项等方法能够有效地抵御训练数据中的噪音，具有更好的健壮性。这也是为什么梯度提升算法（尤其是采用决策树作为弱学习器的GBDT算法）如此流行的原因，有种观点认为GBDT是性能最好的机器学习算法，这当然有点过于激进又固步自封的味道，但通常各类机器学习算法比赛的赢家们都非常青睐GBDT算法，由此可见该算法的实力不可小觑。</p><p>基于梯度提升算法的学习器叫做GBM(Gradient Boosting Machine)。理论上，GBM可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是CART树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是if-then规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收bagging的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。现在主流的GBDT算法实现中这些方法基本上都有实现，因此GBDT算法的超参数还是比较多的，应用过程中需要精心调参，并用交叉验证的方法选择最佳参数。</p><p>本文对GBDT算法原理进行介绍，从机器学习的关键元素出发，一步一步推导出GBDT算法背后的理论基础，读者可以从这个过程中了解到GBDT算法的来龙去脉。对于该算法的工程实现，本文也有较好的指导意义，实际上对机器学习关键概念元素的区分对应了软件工程中的“开放封闭原则”的思想，基于此思想的实现将会具有很好的模块独立性和扩展性。</p><h2 id="一、机器学习的关键元素"><a href="#一、机器学习的关键元素" class="headerlink" title="一、机器学习的关键元素"></a>一、机器学习的关键元素</h2><p>先复习下监督学习的关键概念：模型（model）、参数（parameters）、目标函数（objective function）</p><p>模型就是所要学习的条件概率分布或者决策函数，它决定了在给定特征向量x时如何预测出目标y。定义$x_i\in R^d$为训练集中的第$i$个训练样本，则线性模型（linear model）可以表示为：$\hat{y}=\sum_jw_jx_{ij }$。模型预测的分数$\hat{y_i}$在不同的任务中有不同的解释。例如在逻辑回归任务中，$1/(1+exp(-\hat{y}_i))$表示模型预测为正例的概率；而在排序学习任务中，$\hat{y_i}$表示排序分。</p><p>参数就是我们要从数据中学习得到的内容。模型通常是由一个参数向量决定的函数。例如，线性模型的参数可以表示为：$\Theta=\{w_j|j=1,\cdots,d\}$</p><p>目标函数通常定义为如下形式：</p><script type="math/tex; mode=display">Obj(\Theta)=L(\Theta)+\Omega(\Theta)</script><p>其中，$L(\Theta)$是损失函数，用来衡量模型拟合训练数据的好坏程度；$\Omega(\Theta)$称之为正则项，用来衡量学习到的模型的复杂度。训练集上的损失（Loss）定义为：$L=\sum_{i=1}^n l(y_i, \hat{y}_i)$。常用的损失函数有平方损失（square loss）：$l(y_i, \hat{y}_i)=(y_i - \hat{y}_i)^2$；Logistic损失： $l(y_i, \hat{y}_i)=y_i ln(1+e^{y_i}) + (1-y_i)ln(1+e^{\hat{y}_i})$。常用的正则项有L1范数$\Omega(w)=\lambda \Vert w \Vert_1$和L2范数$\Omega(w)=\lambda \Vert w \Vert_2$。Ridge regression就是指使用平方损失和L2范数正则项的线性回归模型；Lasso regression就是指使用平方损失和L1范数正则项的线性回归模型；逻辑回归（Logistic regression）指使用logistic损失和L2范数或L1范数正则项的线性模型。</p><p>目标函数之所以定义为损失函数和正则项两部分，是为了尽可能平衡模型的偏差和方差（Bias Variance Trade-off）。最小化目标函数意味着同时最小化损失函数和正则项，损失函数最小化表明模型能够较好的拟合训练数据，一般也预示着模型能够较好地拟合真实数据（groud true）；另一方面，对正则项的优化鼓励算法学习到较简单的模型，简单模型一般在测试样本上的预测结果比较稳定、方差较小（奥坎姆剃刀原则）。也就是说，优化损失函数尽量使模型走出欠拟合的状态，优化正则项尽量使模型避免过拟合。</p><p>从概念上区分模型、参数和目标函数给学习算法的工程实现带来了益处，使得机器学习的各个组成部分之间耦合尽量松散。</p><h2 id="二、加法模型"><a href="#二、加法模型" class="headerlink" title="二、加法模型"></a>二、加法模型</h2><p>GBDT算法可以看成是由K棵树组成的加法模型：</p><script type="math/tex; mode=display">\hat{y}_i=\sum_{k=1}^K f_k(x_i), f_k \in F \tag 0</script><p>其中$F$为所有树组成的函数空间，以回归任务为例，回归树可以看作为一个把特征向量映射为某个score的函数。该模型的参数为：$\Theta=\{f_1,f_2, \cdots, f_K \}$。于一般的机器学习算法不同的是，加法模型不是学习d维空间中的权重，而是直接学习函数（决策树）集合。</p><p>上述加法模型的目标函数定义为：$Obj=\sum_{i=1}^n l(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k)$，其中表示决策树的复杂度，那么该如何定义树的复杂度呢？比如，可以考虑树的节点数量、树的深度或者叶子节点所对应的分数的L2范数等等。</p><p>如何来学习加法模型呢？</p><p>解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下： </p><script type="math/tex; mode=display">\begin{split}\hat{y}_i^0 &= 0 \\\hat{y}_i^1 &= f_1(x_i) = \hat{y}_i^0 + f_1(x_i) \\\hat{y}_i^2 &= f_1(x_i) + f_2(x_i) = \hat{y}_i^1 + f_2(x_i) \\& \cdots \\\hat{y}_i^t &= \sum_{k=1}^t f_k(x_i) = \hat{y}_i^{t-1} + f_t(x_i) \\\end{split}</script><p>那么，在每一步如何决定哪一个函数$f$被加入呢？指导原则还是最小化目标函数。<br>在第$t$步，模型对$x_i$的预测为：$\hat{y}_i^t= \hat{y}_i^{t-1} + f_t(x_i)$，其中$f_t(x_i)$为这一轮我们要学习的函数（决策树）。这个时候目标函数可以写为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^nl(y_i, \hat{y}_i^t) + \sum_{i=i}^t \Omega(f_i) \\&=  \sum_{i=1}^n l\left(y_i, \hat{y}_i^{t-1} + f_t(x_i) \right) + \Omega(f_t) + constant\end{split}\tag{1}</script><p>举例说明，假设损失函数为平方损失（square loss），则目标函数为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^n \left(y_i - (\hat{y}_i^{t-1} + f_t(x_i)) \right)^2 + \Omega(f_t) + constant \\&= \sum_{i=1}^n \left[2(\hat{y}_i^{t-1} - y_i)f_t(x_i) + f_t(x_i)^2 \right] + \Omega(f_t) + constant\end{split}\tag{2}</script><p>其中$(\hat{y}_i^{t-1} - y_i)$，称之为残差（residual）。因此，使用平方损失函数时，GBDT算法的每一步在生成决策树时只需要拟合前面的模型的残差。</p><blockquote><p>泰勒公式：设$n$是一个正整数，如果定义在一个包含$a$的区间上的函数$f$在$a$点处$n+1$次可导，那么对于这个区间上的任意$x$都有：</p><script type="math/tex; mode=display">\displaystyle f(x)=\sum _{n=0}^{N}\frac{f^{(n)}(a)}{n!}(x-a)^ n+R_ n(x)</script><p>，其中的多项式称为函数在$a$处的泰勒展开式，$R_n(x)$是泰勒公式的余项且是$(x-a)^n$的高阶无穷小。——维基百科</p></blockquote><p>根据泰勒公式把函数$f(x+\Delta x)$在点处二阶展开，可得到如下等式： </p><script type="math/tex; mode=display">f(x+\Delta x) \approx f(x) + f'(x)\Delta x + \frac12 f''(x)\Delta x^2 \tag 3</script><p>由等式(1)可知，目标函数是关于变量$\hat{y}_i^{t-1} + f_t(x_i)$若把变量$\hat{y}_i^{t-1}$看成是等式(3)中的$x$，把变量$f_t(x_i)$看成是等式(3)中的$\Delta x$，则等式(1)可转化为： </p><script type="math/tex; mode=display">Obj^{(t)} = \sum_{i=1}^n \left[ l(y_i, \hat{y}_i^{t-1}) + g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) + constant \tag 4</script><p>其中，$g_i$定义为损失函数的一阶导数，即$g_i=\partial_{\hat{y}^{t-1}}l(y_i,\hat{y}^{t-1})$；$h_i$定义为损失函数的二阶导数，即$h_i=\partial_{\hat{y}^{t-1}}^2l(y_i,\hat{y}^{t-1})$。 假设损失函数为平方损失函数，则$g_i=\partial_{\hat{y}^{t-1}}(\hat{y}^{t-1} - y_i)^2 = 2(\hat{y}^{t-1} - y_i)$，$h_i=\partial_{\hat{y}^{t-1}}^2(\hat{y}^{t-1} - y_i)^2 = 2$，把$g_i$和$h_i$代入等式(4)即得等式(2)。由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4)中移除掉常量项，得： </p><script type="math/tex; mode=display">Obj^{(t)} \approx \sum_{i=1}^n \left[ g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) \tag 5</script><p>由于要学习的函数仅仅依赖于目标函数，从等式(5)可以看出只需为学习任务定义好损失函数，并为每个训练样本计算出损失函数的一阶导数和二阶导数，通过在训练样本集上最小化等式(5)即可求得每步要学习的函数$f(x)$，从而根据加法模型等式(0)可得最终要学习的模型。</p><h2 id="二、GBDT算法"><a href="#二、GBDT算法" class="headerlink" title="二、GBDT算法"></a>二、GBDT算法</h2><p>一颗生成好的决策树，假设其叶子节点个数为$T$，该决策树是由所有叶子节点对应的值组成的向量$w \in R^T$，以及一个把特征向量映射到叶子节点索引（Index）的函数$q:R^d \to \{1,2,\cdots,T\}$组成的。因此，决策树可以定义为$f_t(x)=w_{q(x)}$。</p><p>决策树的复杂度可以由正则项$\Omega(f_t)=\gamma T + \frac12 \lambda \sum_{j=1}^T w_j^2$来定义，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的L2范数决定。</p><p>定义集合$I_j=\{ i \vert q(x_i)=j \}$为所有被划分到叶子节点的训练样本的集合。等式(5)可以根据树的叶子节点重新组织为T个独立的二次函数的和： </p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &\approx \sum_{i=1}^n \left[ g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) \\&= \sum_{i=1}^n \left[ g_iw_{q(x_i)} + \frac12h_iw_{q(x_i)}^2 \right] + \gamma T + \frac12 \lambda \sum_{j=1}^T w_j^2 \\&= \sum_{j=1}^T \left[(\sum_{i \in I_j}g_i)w_j + \frac12(\sum_{i \in I_j}h_i + \lambda)w_j^2 \right] + \gamma T\end{split}\tag 6</script><p>定义$G_j=\sum_{i \in I_j}g_i$，$H_j=\sum_{i \in I_j}h_i$，则等式(6)可写为：</p><script type="math/tex; mode=display">Obj^{(t)} = \sum_{j=1}^T \left[G_iw_j + \frac12(H_i + \lambda)w_j^2 \right] + \gamma T</script><p>假设树的结构是固定的，即函数$q(x)$确定，令函数$Obj^{(t)}$的一阶导数等于0，即可求得叶子节点对应的值为：$w_j^*=-\frac{G_j}{H_j+\lambda} \tag 7$此时，目标函数的值为</p><script type="math/tex; mode=display">Obj = -\frac12 \sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} + \gamma T \tag 8</script><p>综上，为了便于理解，单颗决策树的学习过程可以大致描述为： </p><ol><li>枚举所有可能的树结构$q$ </li><li>用等式(8)为每个$q$计算其对应的分数$Obj$，分数越小说明对应的树结构越好。</li><li>根据上一步的结果，找到最佳的树结构，用等式(7)为树的每个叶子节点计算预测值</li></ol><p>然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。 </p><ol><li>从深度为0的树开始，对每个叶节点枚举所有的可用特征 </li><li>针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益（采用最佳分裂点时的收益） </li><li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集 </li><li>回到第1步，递归执行到满足特定条件为止</li></ol><p>在上述算法的第二步，样本排序的时间复杂度为$O(nlogn)$，假设共用K个特征，那么生成一颗深度为K的树的时间复杂度为$O(dKnlogn)$。具体实现可以进一步优化计算复杂度，比如可以缓存每个特征的排序结果等。</p><p>如何计算每次分裂的收益呢？假设当前节点记为,分裂之后左孩子节点记为，右孩子节点记为，则该分裂获得的收益定义为当前节点的目标函数值减去左右两个孩子节点的目标函数值之和：$Gain=Obj_C-Obj_L-Obj_R$，具体地，根据等式(8)可得：</p><script type="math/tex; mode=display">Gain=\frac12 \left[ \frac{G_L^2}{H_L+\lambda} + \frac{G_R^2}{H_R+\lambda} - \frac{(G_L+G_R)^2}{H_L+H_R+\lambda}\right] - \gamma \tag 9</script><p>其中，$-\gamma$项表示因为增加了树的复杂性（该分裂增加了一个叶子节点）带来的惩罚。等式(9)还可以用来计算输入特征的相对重要程度，具体见下一节</p><p>最后，总结一下GBDT的学习算法： </p><ol><li>算法每次迭代生成一颗新的决策树 </li><li>在每次迭代开始之前，计算损失函数在每个训练样本点的一阶导数$g_i$和二阶导数$h_i$</li><li>通过贪心策略生成新的决策树，通过等式(7)计算每个叶节点对应的预测值 </li><li>把新生成的决策树$f_t(x)$添加到模型中：$\hat{y}_i^t = \hat{y}_i^{t-1} + f_t(x_i)$</li></ol><p>通常在第四步，我们把模型更新公式替换为：$\hat{y}_i^t = \hat{y}_i^{t-1} + \epsilon f_t(x_i)$，其中$\epsilon$称之为步长或者学习率。增加因子的目的是为了避免模型过拟合。</p><h2 id="三、特征重要度"><a href="#三、特征重要度" class="headerlink" title="三、特征重要度"></a>三、特征重要度</h2><p>集成学习因具有预测精度高的优势而受到广泛关注，尤其是使用决策树作为基学习器的集成学习算法。树的集成算法的著名代码有随机森林和GBDT。随机森林具有很好的抵抗过拟合的特性，并且参数（决策树的个数）对预测性能的影响较小，调参比较容易，一般设置一个比较大的数。GBDT具有很优美的理论基础，一般而言性能更有优势。</p><p>基于树的集成算法还有一个很好的特性，就是模型训练结束后可以输出模型所使用的特征的相对重要度，便于我们选择特征，理解哪些因素是对预测有关键影响，这在某些领域（如生物信息学、神经系统科学等）特别重要。本文主要介绍基于树的集成算法如何计算各特征的相对重要度。</p><h3 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h3><ul><li>使用不同类型的数据时，不需要做特征标准化/归一化</li><li>可以很容易平衡运行时效率和精度；比如，使用boosted tree作为在线预测的模型可以在机器资源紧张的时候截断参与预测的树的数量从而提高预测效率</li><li>学习模型可以输出特征的相对重要程度，可以作为一种特征选择的方法</li><li>模型可解释性好</li><li>对数据字段缺失不敏感</li><li>能够自动做多组特征间的interaction，具有很好的非性线性</li></ul><h3 id="3-2-特征重要度的计算"><a href="#3-2-特征重要度的计算" class="headerlink" title="3.2 特征重要度的计算"></a>3.2 特征重要度的计算</h3><p>Friedman在GBM的论文中提出的方法：</p><p>特征$j$的全局重要度通过特征$j$在单颗树中的重要度的平均值来衡量：</p><script type="math/tex; mode=display">\hat{J_{j}^2}=\frac1M \sum_{m=1}^M\hat{J_{j}^2}(T_m)</script><p>其中，M是树的数量。特征$j$在单颗树中的重要度的如下：</p><script type="math/tex; mode=display">\hat{J_{j}^2}(T)=\sum\limits_{t=1}^{L-1} \hat{i_{t}^2} 1(v_{t}=j)</script><p>其中，$L$为树的叶子节点数量，$L-1$即为树的非叶子节点数量（构建的树都是具有左右孩子的二叉树），是和节点$t$相关联的特征，$\hat{i_t^2}$是节点分裂之后平方损失的减少值。</p><h3 id="3-3-实现代码"><a href="#3-3-实现代码" class="headerlink" title="3.3 实现代码"></a>3.3 实现代码</h3><p>为了更好的理解特征重要度的计算方法，下面给出scikit-learn工具包中的实现，代码移除了一些不相关的部分。</p><p>下面的代码来自于GradientBoostingClassifier对象的feature_importances属性的计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_importances_</span><span class="params">(self)</span>:</span></div><div class="line">    total_sum = np.zeros((self.n_features, ), dtype=np.float64)</div><div class="line">    <span class="keyword">for</span> tree <span class="keyword">in</span> self.estimators_:</div><div class="line">        total_sum += tree.feature_importances_ </div><div class="line">    importances = total_sum / len(self.estimators_)</div><div class="line">    <span class="keyword">return</span> importances</div></pre></td></tr></table></figure><p>其中，self.estimators_是算法构建出的决策树的数量，tree.feature_importances_ 是单棵树的特征重要度向量，其计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cpdef compute_feature_importances(self, normalize=True):</div><div class="line">    &quot;&quot;&quot;Computes the importance of each feature (aka variable).&quot;&quot;&quot;</div><div class="line">    while node != end_node:</div><div class="line">        if node.left_child != _TREE_LEAF:</div><div class="line">            # ... and node.right_child != _TREE_LEAF:</div><div class="line">            left = &amp;nodes[node.left_child]</div><div class="line">            right = &amp;nodes[node.right_child]</div><div class="line">            importance_data[node.feature] += (</div><div class="line">                node.weighted_n_node_samples * node.impurity -</div><div class="line">                left.weighted_n_node_samples * left.impurity -</div><div class="line">                right.weighted_n_node_samples * right.impurity)</div><div class="line">        node += 1</div><div class="line">    importances /= nodes[0].weighted_n_node_samples</div><div class="line">    return importances</div></pre></td></tr></table></figure><p>上面的代码关键点是两个：</p><p>第一点：weighted_n_node_samples : array of int, shape [node_count]<br>        weighted_n_node_samples[i] holds the weighted number of training samples reaching node i.</p><p>第二点：impurity : array of double, shape [node_count]<br>        impurity[i] holds the impurity (i.e., the value of the splitting criterion) at node i.</p><p>当然上面的代码经过了简化，保留了核心思想。计算所有的非叶子节点在分裂时加权不纯度的减少，减少得越多说明特征越重要</p><p>不纯度的减少实际上就是该节点此次分裂的收益，因此我们也可以这样理解，节点分裂时收益越大，该节点对应的特征的重要度越高。关于收益的定义就是上一节中等式(9)的定义。</p><p>参考资料<br>[1] <a href="https://www.wikiwand.com/en/Gradient_boosting" target="_blank" rel="noopener">Gradient Boosting</a> 的更多内容<br>[2] <a href="http://xgboost.readthedocs.io/en/latest/" target="_blank" rel="noopener">XGBoost</a>是一个优秀的GBDT开源软件库，有多种语言接口<br>[3] <a href="https://github.com/cheng-li/pyramid" target="_blank" rel="noopener">Pyramid</a>是一个基于Java语言的机器学习库，里面也有GBDT算法的介绍和实现<br>[4] Friedman的论文<a href="http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noopener">《Greedy function approximation: a gradient boosting machine》</a>是比较早的GBDT算法文献，但是比较晦涩难懂，不适合初学者，高阶选手可以进一步学习<br>[5] <a href="http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noopener">“A Gentle Introduction to Gradient Boosting”</a>是关于Gradient Boosting的一个通俗易懂的解释，比较适合初学者或者是已经对GBDT算法原理印象不深的从业者<br>[6] 关于GBDT算法调参的经验和技巧可以参考这两篇博文：<a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">《GBM调参指南》</a>、<br><a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">《XGBoost调参指南》</a>，作者使用的算法实现工具来自于著名的Python机器学习工具scikit-learn<br>[7] GBDT算法在搜索引擎排序中的应用可以查看这篇论文<a href="http://proceedings.mlr.press/v14/mohan11a/mohan11a.pdf" target="_blank" rel="noopener">《Web-Search Ranking with Initialized Gradient Boosted Regression Trees 》</a>，这篇论文提出了一个非常有意思的方法，用一个已经训练好的随机森林模型作为GBDT算法的初始化，再用GBDT算法优化最终的模型，取得了很好的效果</p><p>[1] <a href="https://pdfs.semanticscholar.org/156e/3c979e7bc25381fdd0614d1bab60b7aa5dfd.pdf" target="_blank" rel="noopener">Feature Selection for Ranking using Boosted Trees </a><br>[2] <a href="http://alicezheng.org/papers/gbfs.pdf" target="_blank" rel="noopener">Gradient Boosted Feature Selection</a><br>[3] <a href="http://www.jmlr.org/papers/volume10/tuv09a/tuv09a.pdf" target="_blank" rel="noopener">Feature Selection with Ensembles, Artificial Variables, and Redundancy Elimination</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梯度提升（Gradient boosting）是一种用于回归、分类和排序任务的机器学习技术[1]，属于Boosting算法族的一部分。Boosting是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是“三个臭皮匠顶个诸葛亮”的道理。梯度提升同其他boosting方法一样，通过集成（ensemble）多个弱学习器，通常是决策树，来构建最终的预测模型。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GBDT" scheme="http://yoursite.com/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（35）：使用Sklearn进行集成学习（实践）</title>
    <link href="http://yoursite.com/2017/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8835%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Sklearn%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%AE%9E%E8%B7%B5%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/03/机器学习算法系列（35）：使用Sklearn进行集成学习（实践）/</id>
    <published>2017-09-03T15:14:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>jjj<br><a id="more"></a><br>hhh</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jjj&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（34）：使用Sklearn进行集成学习（理论）</title>
    <link href="http://yoursite.com/2017/09/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8834%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Sklearn%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%90%86%E8%AE%BA%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/02/机器学习算法系列（34）：使用Sklearn进行集成学习（理论）/</id>
    <published>2017-09-02T15:14:45.000Z</published>
    <updated>2018-11-03T11:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>很多人在竞赛（Kaggle，天池等）或工程实践中使用了集成学习（例如，RF、GTB等），确实也取得了不错的效果，在保证准确度的同时也提升了模型防止过拟合的能力。但是，我们真的用对了集成学习吗？</p><a id="more"></a><p>sklearn提供了sklearn.ensemble库，支持众多集成学习算法和模型。恐怕大多数人使用这些工具时，要么使用默认参数，要么根据模型在测试集上的性能试探性地进行调参（当然，完全不懂的参数还是不动算了），要么将调参的工作丢给调参算法（网格搜索等）。这样并不能真正地称为“会”用sklearn进行集成学习。</p><p>我认为，学会调参是进行集成学习工作的前提。然而，第一次遇到这些算法和模型时，肯定会被其丰富的参数所吓到，要知道，教材上教的伪代码可没这么多参数啊！！！没关系，暂时，我们只要记住一句话：参数可分为两种，一种是影响模型在训练集上的准确度或影响防止过拟合能力的参数；另一种不影响这两者的其他参数。模型在样本总体上的准确度（后简称准确度）由其在训练集上的准确度及其防止过拟合的能力所共同决定，所以在调参时，我们主要对第一种参数进行调整，最终达到的效果是：模型在训练集上的准确度和防止过拟合能力的大和谐！</p><p>本篇博文将详细阐述模型参数背后的理论知识，在下篇博文中，我们将对最热门的两个模型Random Forrest和Gradient Tree Boosting（含分类和回归，所以共4个模型）进行具体的参数讲解。如果你实在无法静下心来学习理论，你也可以在下篇博文中找到最直接的调参指导，虽然我不赞同这么做。</p><h2 id="二、集成学习是什么？"><a href="#二、集成学习是什么？" class="headerlink" title="二、集成学习是什么？"></a>二、集成学习是什么？</h2><p>我们还是花一点时间来说明一下集成学习是什么，如果对此有一定基础的同学可以跳过本节。简单来说，集成学习是一种技术框架，其按照不同的思路来组合基础模型，从而达到其利断金的目的。</p><p>目前，有三种常见的集成学习框架：bagging，boosting和stacking。国内，南京大学的周志华教授对集成学习有很深入的研究，其在09年发表的一篇概述性论文《Ensemble Learning》对这三种集成学习框架有了明确的定义，概括如下：</p><ul><li>bagging：从训练集从进行子抽样组成每个基模型所需要的子训练集，对所有基模型预测的结果进行综合产生最终的预测结果：</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2eb4fo4j30ys0ckabw.jpg" alt=""></p><ul><li>boosting：训练过程为阶梯状，基模型按次序一一进行训练（实现上可以做到并行），基模型的训练集按照某种策略每次都进行一定的转化。对所有基模型预测的结果进行线性综合产生最终的预测结果：</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2ec1l4dj317r0sh0v2.jpg" alt=""></p><ul><li>stacking：将训练好的所有基模型对训练基进行预测，第j个基模型对第i个训练样本的预测值将作为新的训练集中第i个样本的第j个特征值，最后基于新的训练集进行训练。同理，预测的过程也要先经过所有基模型的预测形成新的测试集，最后再对测试集进行预测：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15043256303505.jpg" alt=""><br>有了这些基本概念之后，直觉将告诉我们，由于不再是单一的模型进行预测，所以模型有了“集思广益”的能力，也就不容易产生过拟合现象。但是，直觉是不可靠的，接下来我们将从模型的偏差和方差入手，彻底搞清楚这一问题。</p><h2 id="三、偏差和方差"><a href="#三、偏差和方差" class="headerlink" title="三、偏差和方差"></a>三、偏差和方差</h2><p>广义的偏差（bias）描述的是预测值和真实值之间的差异，方差（variance）描述距的是预测值作为随机变量的离散程度。《Understanding the Bias-Variance Tradeoff》当中有一副图形象地向我们展示了偏差和方差的关系：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2ed3zbnj30go0frdhz.jpg" alt=""></p><h3 id="3-1-模型的偏差和方差"><a href="#3-1-模型的偏差和方差" class="headerlink" title="3.1 模型的偏差和方差"></a>3.1 模型的偏差和方差</h3><p>模型的偏差是一个相对来说简单的概念：训练出来的模型在训练集上的准确度。</p><p>定义随机变量的值的差异是计算方差的前提条件，通常来说，我们遇到的都是数值型的随机变量，数值之间的差异再明显不过（减法运算）。但是，模型的差异性呢？我们可以理解模型的差异性为模型的结构差异，例如：线性模型中权值向量的差异，树模型中树的结构差异等。在研究模型方差的问题上，我们并不需要对方差进行定量计算，只需要知道其概念即可。</p><p>研究模型的方差有什么现实的意义呢？我们认为方差越大的模型越容易过拟合：假设有两个训练集A和B，经过A训练的模型Fa与经过B训练的模型Fb差异很大，这意味着Fa在类A的样本集合上有更好的性能，而Fb反之，这便是我们所说的过拟合现象。</p><p>我们常说集成学习框架中的基模型是弱模型，通常来说弱模型是偏差高（在训练集上准确度低）方差小（防止过拟合能力强）的模型。但是，并不是所有集成学习框架中的基模型都是弱模型。bagging和stacking中的基模型为强模型（偏差低方差高），boosting中的基模型为弱模型。</p><p>在bagging和boosting框架中，通过计算基模型的期望和方差，我们可以得到模型整体的期望和方差。为了简化模型，我们假设基模型的权重、方差及两两间的相关系数相等。由于bagging和boosting的基模型都是线性组成的，那么有：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2edv455j30b20b03yx.jpg" alt=""></p><h3 id="3-2-bagging的偏差和方差"><a href="#3-2-bagging的偏差和方差" class="headerlink" title="3.2 bagging的偏差和方差"></a>3.2 bagging的偏差和方差</h3><p>对于bagging来说，每个基模型的权重等于1/m且期望近似相等（子训练集都是从原训练集中进行子抽样），故我们可以进一步化简得到：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2eec0rjj308i06cwel.jpg" alt=""></p><p>根据上式我们可以看到，整体模型的期望近似于基模型的期望，这也就意味着整体模型的偏差和基模型的偏差近似。同时，整体模型的方差小于等于基模型的方差（当相关性为1时取等号），随着基模型数（m）的增多，整体模型的方差减少，从而防止过拟合的能力增强，模型的准确度得到提高。但是，模型的准确度一定会无限逼近于1吗？并不一定，当基模型数增加到一定程度时，方差公式第二项的改变对整体方差的作用很小，防止过拟合的能力达到极限，这便是准确度的极限了。另外，在此我们还知道了为什么bagging中的基模型一定要为强模型，否则就会导致整体模型的偏差度低，即准确度低。</p><p>Random Forest是典型的基于bagging框架的模型，其在bagging的基础上，进一步降低了模型的方差。Random Fores中基模型是树模型，在树的内部节点分裂过程中，不再是将所有特征，而是随机抽样一部分特征纳入分裂的候选项。这样一来，基模型之间的相关性降低，从而在方差公式中，第一项显著减少，第二项稍微增加，整体方差仍是减少。</p><h3 id="3-3-boosting的偏差和方差"><a href="#3-3-boosting的偏差和方差" class="headerlink" title="3.3 boosting的偏差和方差"></a>3.3 boosting的偏差和方差</h3><p>对于boosting来说，基模型的训练集抽样是强相关的，那么模型的相关系数近似等于1，故我们也可以针对boosting化简公式为：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2efa3szj308j039jre.jpg" alt=""></p><p>通过观察整体方差的表达式，我们容易发现，若基模型不是弱模型，其方差相对较大，这将导致整体模型的方差很大，即无法达到防止过拟合的效果。因此，boosting框架中的基模型必须为弱模型。</p><p>因为基模型为弱模型，导致了每个基模型的准确度都不是很高（因为其在训练集上的准确度不高）。随着基模型数的增多，整体模型的期望值增加，更接近真实值，因此，整体模型的准确度提高。但是准确度一定会无限逼近于1吗？仍然并不一定，因为训练过程中准确度的提高的主要功臣是整体模型在训练集上的准确度提高，而随着训练的进行，整体模型的方差变大，导致防止过拟合的能力变弱，最终导致了准确度反而有所下降。</p><p>基于boosting框架的Gradient Tree Boosting模型中基模型也为树模型，同Random Forrest，我们也可以对特征进行随机抽样来使基模型间的相关性降低，从而达到减少方差的效果。</p><h3 id="3-4-模型的独立性"><a href="#3-4-模型的独立性" class="headerlink" title="3.4 模型的独立性"></a>3.4 模型的独立性</h3><p>聪明的读者这时肯定要问了，如何衡量基模型的独立性？我们说过，抽样的随机性决定了模型的随机性，如果两个模型的训练集抽样过程不独立，则两个模型则不独立。这时便有一个天大的陷阱在等着我们：bagging中基模型的训练样本都是独立的随机抽样，但是基模型却不独立呢？</p><p>我们讨论模型的随机性时，抽样是针对于样本的整体。而bagging中的抽样是针对于训练集（整体的子集），所以并不能称其为对整体的独立随机抽样。那么到底bagging中基模型的相关性体现在哪呢？在知乎问答《为什么说bagging是减少variance，而boosting是减少bias?》中请教用户“过拟合”后，我总结bagging的抽样为两个过程：</p><ul><li>样本抽样：整体模型F(X1, X2, …, Xn)中各输入随机变量（X1, X2, …, Xn）对样本的抽样</li><li>子抽样：从整体模型F(X1, X2, …, Xn)中随机抽取若干输入随机变量成为基模型的输入随机变量</li></ul><p>假若在子抽样的过程中，两个基模型抽取的输入随机变量有一定的重合，那么这两个基模型对整体样本的抽样将不再独立，这时基模型之间便具有了相关性。</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>还记得调参的目标吗：模型在训练集上的准确度和防止过拟合能力的大和谐！为此，我们目前做了一些什么工作呢？</p><ul><li>使用模型的偏差和方差来描述其在训练集上的准确度和防止过拟合的能力</li><li>对于bagging来说，整体模型的偏差和基模型近似，随着训练的进行，整体模型的方差降低</li><li>对于boosting来说，整体模型的初始偏差较高，方差较低，随着训练的进行，整体模型的偏差降低（虽然也不幸地伴随着方差增高），当训练过度时，因方差增高，整体模型的准确度反而降低</li><li>整体模型的偏差和方差与基模型的偏差和方差息息相关</li></ul><p>这下总算有点开朗了，那些让我们抓狂的参数，现在可以粗略地分为两类了：控制整体训练过程的参数和基模型的参数，这两类参数都在影响着模型在训练集上的准确度以及防止过拟合的能力。</p><h2 id="四、Gradient-Boosting"><a href="#四、Gradient-Boosting" class="headerlink" title="四、Gradient Boosting"></a>四、Gradient Boosting</h2><p>对基于Gradient Boosting框架的模型的进行调试时，我们会遇到一个重要的概念：损失函数。在本节中，我们将把损失函数的“今生来世”讲个清楚！</p><p>基于boosting框架的整体模型可以用线性组成式来描述，其中$h<a href="x">i</a>$为基模型与其权值的乘积：<img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2eg7mp1j303201d3ya.jpg" alt=""></p><p>根据上式，整体模型的训练目标是使预测值F(x)逼近真实值y，也就是说要让每一个基模型的预测值逼近各自要预测的部分真实值。由于要同时考虑所有基模型，导致了整体模型的训练变成了一个非常复杂的问题。所以，研究者们想到了一个贪心的解决手段：每次只训练一个基模型。那么，现在改写整体模型为迭代式：<img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2ego3pkj304m00smwy.jpg" alt=""></p><p>这样一来，每一轮迭代中，只要集中解决一个基模型的训练问题：使$F<a href="x">i</a>$逼近真实值y。</p><h3 id="4-1-拟合残差"><a href="#4-1-拟合残差" class="headerlink" title="4.1 拟合残差"></a>4.1 拟合残差</h3><p>使F<a href="x">i</a>逼近真实值，其实就是使h<a href="x">i</a>逼近真实值和上一轮迭代的预测值F<a href="x">i-1</a>之差，即残差（y-F<a href="x">i-1</a>）。最直接的做法是构建基模型来拟合残差，在博文《GBDT（MART） 迭代决策树入门教程 | 简介》中，作者举了一个生动的例子来说明通过基模型拟合残差，最终达到整体模型F(x)逼近真实值。</p><p>研究者发现，残差其实是最小均方损失函数的关于预测值的反向梯度：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2eh9uwbj306t01t0sl.jpg" alt=""></p><p>也就是说，若$F<a href="x">i-1</a>$加上拟合了反向梯度的$h<a href="x">i</a>$得到$F<a href="x">i</a>$，该值可能将导致平方差损失函数降低，预测的准确度提高！这显然不是巧合，但是研究者们野心更大，希望能够创造出一种对任意损失函数都可行的训练方法，那么仅仅拟合残差是不恰当的了。</p><h3 id="4-2-拟合反向梯度"><a href="#4-2-拟合反向梯度" class="headerlink" title="4.2 拟合反向梯度"></a>4.2 拟合反向梯度</h3><h4 id="4-2-1-契机：引入任意损失函数"><a href="#4-2-1-契机：引入任意损失函数" class="headerlink" title="4.2.1 契机：引入任意损失函数"></a>4.2.1 契机：引入任意损失函数</h4><p>引入任意损失函数后，我们可以定义整体模型的迭代式如下：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2ehlszqj309o01kt8l.jpg" alt=""></p><p>在这里，损失函数被定义为泛函。</p><h4 id="4-2-2-难题一：任意损失函数的最优化"><a href="#4-2-2-难题一：任意损失函数的最优化" class="headerlink" title="4.2.2 难题一：任意损失函数的最优化"></a>4.2.2 难题一：任意损失函数的最优化</h4><p>对任意损失函数（且是泛函）的最优化是困难的。我们需要打破思维的枷锁，将整体损失函数L’定义为n元普通函数（n为样本容量），损失函数L定义为2元普通函数（记住！！！这里的损失函数不再是泛函！！！）：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2ei2e7jj309w01at8l.jpg" alt=""></p><p>我们不妨使用梯度最速下降法来解决整体损失函数L’最小化的问题，先求整体损失函数的反向梯度：<br><img src="http://omu7tit09.bkt.clouddn.com/15049167506559.png" alt=""></p><p>假设已知样本x的当前预测值为$F<a href="x">i-1</a>$，下一步将预测值按照反向梯度，依照步长为$r[i]$，进行更新：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2eijjcpj306k01hmx0.jpg" alt=""></p><p>步长r[i]不是固定值，而是设计为：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2ej0u0kj309o022dfr.jpg" alt=""></p><h4 id="4-2-3-难题二：无法对测试样本计算反向梯度"><a href="#4-2-3-难题二：无法对测试样本计算反向梯度" class="headerlink" title="4.2.3 难题二：无法对测试样本计算反向梯度"></a>4.2.3 难题二：无法对测试样本计算反向梯度</h4><p>问题又来了，由于测试样本中y是未知的，所以无法求反向梯度。这正是Gradient Boosting框架中的基模型闪亮登场的时刻！在第i轮迭代中，我们创建训练集如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2ejy99pj304w0223yd.jpg" alt=""></p><p>也就是说，让基模型拟合反向梯度函数，这样我们就可以做到只输入x这一个参数，就可求出其对应的反向梯度了（当然，通过基模型预测出来的反向梯度并不是准确的，这也提供了泛化整体模型的机会）。</p><p>综上，假设第i轮迭代中，根据新训练集训练出来的基模型为$f<a href="x">i</a>$，那么最终的迭代公式为：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2ekw4jxj307b02dq2u.jpg" alt=""></p><h3 id="4-3-常见的损失函数"><a href="#4-3-常见的损失函数" class="headerlink" title="4.3 常见的损失函数"></a>4.3 常见的损失函数</h3><p>ls：最小均方回归中用到的损失函数。在之前我们已经谈到，从拟合残差的角度来说，残差即是该损失函数的反向梯度值（所以又称反向梯度为伪残差）。不同的是，从拟合残差的角度来说，步长是无意义的。该损失函数是sklearn中Gradient Tree Boosting回归模型默认的损失函数。</p><p>deviance：逻辑回归中用到的损失函数。熟悉逻辑回归的读者肯定还记得，逻辑回归本质是求极大似然解，其认为样本服从几何分布，样本属于某类别的概率可以logistic函数表达。所以，如果该损失函数可用在多类别的分类问题上，故其是sklearn中Gradient Tree Boosting分类模型默认的损失函数。</p><p>exponential：指数损失函数，表达式为：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169121290.png" alt=""></p><p>对该损失函数求反向梯度得：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2elced7j306s01swec.jpg" alt=""></p><p>这时，在第i轮迭代中，新训练集如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169392577.png" alt=""><br>脑袋里有什么东西浮出水面了吧？让我们看看Adaboost算法中，第i轮迭代中第j个样本权值的更新公式：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2eltsqhj304601pt8j.jpg" alt=""><br>样本的权值什么时候会用到呢？计算第i轮损失函数的时候会用到：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2ems8k0j307o01pt8l.jpg" alt=""><br>让我们再回过头来，看看使用指数损失函数的Gradient Boosting计算第i轮损失函数：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2en8g0wj307501c3yc.jpg" alt=""></p><p>天呐，两个公式就差了一个对权值的归一项。这并不是巧合，当损失函数是指数损失时，Gradient Boosting相当于二分类的Adaboost算法。是的，指数损失仅能用于二分类的情况。</p><h3 id="4-4-步子太大容易扯着蛋：缩减"><a href="#4-4-步子太大容易扯着蛋：缩减" class="headerlink" title="4.4 步子太大容易扯着蛋：缩减"></a>4.4 步子太大容易扯着蛋：缩减</h3><p>缩减也是一个相对显见的概念，也就是说使用Gradient Boosting时，每次学习的步长缩减一点。这有什么好处呢？缩减思想认为每次走一小步，多走几次，更容易逼近真实值。如果步子迈大了，使用最速下降法时，容易迈过最优点。将缩减代入迭代公式：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2enoxmuj307b00pweb.jpg" alt=""></p><p>缩减需要配合基模型数一起使用，当缩减率v降低时，基模型数要配合增大，这样才能提高模型的准确度。</p><h3 id="4-5-初始模型"><a href="#4-5-初始模型" class="headerlink" title="4.5 初始模型"></a>4.5 初始模型</h3><p>还有一个不那么起眼的问题，初始模型$F<a href="x">0</a>$是什么呢？如果没有定义初始模型，整体模型的迭代式一刻都无法进行！所以，我们定义初始模型为：<br><img src="http://omu7tit09.bkt.clouddn.com/15049170394638.png" alt=""></p><p>根据上式可知，对于不同的损失函数来说，初始模型也是不一样的。对所有的样本来说，根据初始模型预测出来的值都一样。</p><h3 id="4-5-Gradient-Tree-Boosting"><a href="#4-5-Gradient-Tree-Boosting" class="headerlink" title="4.5 Gradient Tree Boosting"></a>4.5 Gradient Tree Boosting</h3><p>终于到了备受欢迎的Gradient Tree Boosting模型了！但是，可讲的却已经不多了。我们已经知道了该模型的基模型是树模型，并且可以通过对特征的随机抽样进一步减少整体模型的方差。我们可以在维基百科的Gradient Boosting词条中找到其伪代码实现。</p><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><p>到此，读者应当很清楚Gradient Boosting中的损失函数有什么意义了。要说偏差描述了模型在训练集准确度，则损失函数则是描述该准确度的间接量纲。也就是说，模型采用不同的损失函数，其训练过程会朝着不同的方向进行！</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>　　磨刀不误砍柴功，我们花了这么多时间来学习必要的理论，我强调一次：必要的理论！集成学习模型的调参工作的核心就是找到合适的参数，能够使整体模型在训练集上的准确度和防止过拟合的能力达到协调，从而达到在样本总体上的最佳准确度。有了本文的理论知识铺垫，在下篇中，我们将对Random Forest和Gradient Tree Boosting中的每个参数进行详细阐述，同时也有一些小试验证明我们的结论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;很多人在竞赛（Kaggle，天池等）或工程实践中使用了集成学习（例如，RF、GTB等），确实也取得了不错的效果，在保证准确度的同时也提升了模型防止过拟合的能力。但是，我们真的用对了集成学习吗？&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Scikit-Learn" scheme="http://yoursite.com/tags/Scikit-Learn/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（33）：特征处理（Feature Processing）</title>
    <link href="http://yoursite.com/2017/08/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8833%EF%BC%89%EF%BC%9A%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%EF%BC%88Feature%20Processing%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/31/机器学习算法系列（33）：特征处理（Feature Processing）/</id>
    <published>2017-08-31T15:14:45.000Z</published>
    <updated>2018-11-04T00:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。</p><a id="more"></a><p>单个原始特征（或称为变量）通常属于以下几类之一：</p><ul><li>连续（continuous）特征；</li><li>无序类别（categorical）特征；</li><li>有序类别（ordinal）特征。</li></ul><p>本文中我主要介绍针对单个特征的处理方法，虽然也会附带介绍基础的特征组合方法。同时处理多个特征，以及更复杂的特征处理方法介绍，以后我再另外细说。下面我由浅入深地逐渐说明针对这三类特征的常用处理方法。</p><h2 id="一、初级篇"><a href="#一、初级篇" class="headerlink" title="一、初级篇"></a>一、初级篇</h2><p>这节要讲的处理技术，应该刚接触机器学习不久的同学都会知道。</p><h3 id="1-1-连续特征"><a href="#1-1-连续特征" class="headerlink" title="1.1 连续特征"></a>1.1 连续特征</h3><h3 id="1-2-无序特征"><a href="#1-2-无序特征" class="headerlink" title="1.2 无序特征"></a>1.2 无序特征</h3><p>可以使用One-hot（也叫One-of-k）的方法把每个无序特征转化为一个数值向量。比如一个无序特征color有三种取值：red，green，blue。那么可以用一个长度为3的向量来表示它，向量中的各个值分别对应于red，green，blue。如：</p><div class="table-container"><table><thead><tr><th>color取值</th><th>向量表示</th></tr></thead><tbody><tr><td>red</td><td>(1, 0, 0)</td><td></td></tr><tr><td>green</td><td>(0, 1, 0)</td></tr><tr><td>blue</td><td>(0, 0, 1)</td></tr></tbody></table></div><p>这种方法在NLP里用的很多，就是所谓的词向量模型。变换后的向量长度对于词典长度，每个词对应于向量中的一个元素。</p><p>机器学习书籍里在讲这个的时候介绍的处理方法可能跟我上面说的有点差别。上面说的表达方式里有一个维度是可以省略的。</p><p>既然我们知道color一定是取3个值中的一个，那么我们知道向量的前两个元素值，就能推断第3个值是多少。所以，其实用下面的方式就可以表达到底是哪种颜色：</p><div class="table-container"><table><thead><tr><th>color取值</th><th>向量表示</th></tr></thead><tbody><tr><td>red</td><td>(1, 0)</td><td></td></tr><tr><td>green</td><td>(0, 1)</td></tr><tr><td>blue</td><td>(0, 0)</td></tr></tbody></table></div><p>这样表达的好处是少用了一个维度，降低了转化后特征之间的相关性。但在实际问题中特征基本都或多或少会有些缺失。使用第一种表达方式就可以用全0的向量来表示值缺失，而第二种表达方式是没法表达缺失的。</p><h3 id="1-3-有序特征"><a href="#1-3-有序特征" class="headerlink" title="1.3 有序特征"></a>1.3 有序特征</h3><p>有些特征虽然也像无序特征那样只取限定的几个值，但是这些值之间有顺序的含义。例如一个人的状态status有三种取值：bad, normal, good，显然bad &lt; normal &lt; good。</p><p>当然，对有序特征最简单的处理方式是忽略其中的顺序关系，把它看成无序的，这样我们就可以使用处理无序特征的方式来处理它。在实际问题中，这种处理方式其实用的很多。</p><p>当然有些问题里有序可能会很重要，这时候就不应该把其中的顺序关系丢掉。一般的表达方式如下：</p><div class="table-container"><table><thead><tr><th>status取值</th><th>向量表示</th></tr></thead><tbody><tr><td>bad</td><td>(1, 0, 0)</td><td></td></tr><tr><td>normal</td><td>(1, 1, 0)</td></tr><tr><td>good</td><td>(1, 1, 1)</td></tr></tbody></table></div><p>上面这种表达方式很巧妙地利用递进表达了值之间的顺序关系。</p><h2 id="二、中级篇"><a href="#二、中级篇" class="headerlink" title="二、中级篇"></a>二、中级篇</h2><p>最容易让人掉以轻心的，往往就是大家觉得最简单的事。在特征处理中，最容易让刚入门同学忽略的，是对连续特征的处理方式。</p><p>以线性分类器Linear Regression (LinearReg)为例，它是通过特征的线性加权来预测因变量y：</p><script type="math/tex; mode=display">y=w^Tx</script><p>但大部分实际情况下，yy与xx都不会是这么简单的线性关系，甚至连单调关系都不会有。举个只有一个特征的例子，如果yy与xx的实际关系如下图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3bah2dhj30a70bxq3a.jpg" alt=""></p><p>那么直接把xx扔进LinearReg模型是怎么也得不到好结果的。很多人会想着既然线性分类器搞不定，那就直接找个非线性的好了，比如高斯核的SVM。我们确实可以通过这种简单换算法的方式解决这个简单的问题。但对于很多实际问题（如广告点击率预测），往往特征非常多，这时候时间约束通常不允许我们使用很复杂的非线性分类器。这也是为什么算法发展这么多年，广告点击率预测最常用的方法还是Logistic Regression (LogisticReg)。</p><p>对于上面这个问题，有没有什么办法使得LinearReg也能处理得不错？当然是有，就是对原始特征x做转化，把原来的非线性关系转化为线性关系。</p><h3 id="2-1-方法一：离散化"><a href="#2-1-方法一：离散化" class="headerlink" title="2.1 方法一：离散化"></a>2.1 方法一：离散化</h3><p>最常用的转化方式是对xx做离散化(discretization)，也就是把原来的值分段，转化成一个取值为0或1的向量。原始值落在某个段里，向量中此段对应的元素就为1，否则为0。</p><p>离散化的目标是y与转化后向量里的每个元素都保持比较好的线性关系。</p><p>比如取离散点{0.5,1.5,2.5}，通过判断xx属于(−∞,0.5)，[0.5,1.5)，[1.5,2.5)，[2.5,+∞)中哪段来把它离散化为4维的向量。下面是一些例子的离散结果：</p><div class="table-container"><table><thead><tr><th>原始值xx</th><th>离散化后的值</th></tr></thead><tbody><tr><td>0.1</td><td>(1, 0, 0, 0)</td></tr><tr><td>1.3</td><td>(0, 1, 0, 0)</td></tr><tr><td>3.2</td><td>(0, 0, 0, 1)</td></tr><tr><td>5.8</td><td>(0, 0, 0, 1)</td></tr></tbody></table></div><p>离散化方法的关键是怎么确定分段中的离散点。下面是常用的选取离散点的方法：</p><blockquote><p>等距离离散：</p></blockquote><p>顾名思义，就是离散点选取等距点。我们上面对xx取离散点{0.5,1.5,2.5}就是一种等距离散，见下图。图中垂直的灰线代表离散点。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3bazbvfj30a70bx74o.jpg" alt=""></p><blockquote><p>等样本点离散</p></blockquote><p>选取的离散点保证落在每段里的样本点数量大致相同，见下图。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvqukin0nj30iu0km0sz.jpg" alt=""></p><blockquote><p>画图观察趋势</p></blockquote><p>以xx为横坐标，yy为纵坐标，画图，看曲线的趋势和拐点。通过观察下面的图我们发现可以利用3条直线（红色直线）来逐段近似原来的曲线。把离散点设为两条直线相交的各个点，我们就可以把xx离散化为长度为3的向量。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3bbx377j30a70bx3z0.jpg" alt=""></p><p>上面介绍的这种离散化为0/1向量的方法有个问题，它在离散时不会考虑到具体的xx到离散边界的距离。比如等距离散中取离散点为{0.5,1.5,2.5}{0.5,1.5,2.5}，那么1.499，1.501和2.49分别会离散为(0, 1, 0, 0)，(0, 0, 1, 0)和(0, 0, 1, 0)。1.499和1.501很接近，可是就因为这种强制分段的离散导致它们离散的结果差距很大。</p><p>针对上面这种硬离散的一种改进就是使用软离散，也就是在离散时考虑到xx与附近离散点的距离，离散出来的向量元素值可以是0/1之外的其他值。有兴趣的同学可以去ESL1这本书中找点感觉。</p><h3 id="2-2-函数变换"><a href="#2-2-函数变换" class="headerlink" title="2.2 函数变换"></a>2.2 函数变换</h3><p>函数变换直接把原来的特征通过非线性函数做变换，然后把原来的特征，以及变换后的特征一起加入模型进行训练。常用的变换函数见下表，不过其实你可以尝试任何函数。</p><div class="table-container"><table><thead><tr><th>常用非线性函数f(x)</th><th>x的取值范围</th></tr></thead><tbody><tr><td>$x^α; α∈(−∞,+∞)$</td><td>$(−∞,+∞)$</td></tr><tr><td>$log(x)$</td><td>$(0,+∞)$</td></tr><tr><td>$log(\frac{x}{1−x})$</td><td>$(0,1)$</td></tr></tbody></table></div><p>这个方法操作起来很简单，但记得对新加入的特征做归一化。</p><p>对于我们前面的问题，只要把$x^2$，$x^3$也作为特征加入即可，因为实际上y就是x的一个三次多项式。</p><h2 id="三、高级篇"><a href="#三、高级篇" class="headerlink" title="三、高级篇"></a>三、高级篇</h2><h3 id="3-1-笛卡尔乘积"><a href="#3-1-笛卡尔乘积" class="headerlink" title="3.1 笛卡尔乘积"></a>3.1 笛卡尔乘积</h3><p>我们可以使用笛卡尔乘积的方式来组合2个或更多个特征。比如有两个类别特征color和light，它们分别可以取值为red，green，blue和on, off。这两个特征各自可以离散化为3维和2维的向量。对它们做笛卡尔乘积转化，就可以组合出长度为6的特征，它们分别对应着原始值对(red, on)，(red, off)，(green, on)，(green, off)，(blue, on)，(blue, off)。下面的矩阵表达方式更清楚地说明了这种组合。</p><div class="table-container"><table><thead><tr><th>X</th><th>on</th><th>off</th></tr></thead><tbody><tr><td>red</td><td></td></tr><tr><td>green</td><td></td></tr><tr><td>blue</td></tr></tbody></table></div><p>对于3个特征的笛卡尔乘积组合，可以表达为立方的形式。更多特征的组合依次类推。这个方法也可以直接用于连续特征与类别特征之间的组合，只要把连续特征看成是1维的类别特征就好了，这时候组合后特征对应的值就不是0/1了，而是连续特征的取值。</p><h3 id="3-2-离散化续篇"><a href="#3-2-离散化续篇" class="headerlink" title="3.2 离散化续篇"></a>3.2 离散化续篇</h3><p>在上节中我已经介绍了一些常用的离散化单个连续特征的方法，其中一个是画图观察趋势。画图观察趋势的好处是直观、可解释性强，坏处是很麻烦。当要离散化的特征很多时，这种方法可操作性较差。</p><p>机器学习中有个很好解释，速度也不错的模型——决策树模型。大白话说决策树模型就是一大堆的if else。它天生就可以对连续特征分段，所以把它用于离散化连续特征合情合理。我称这种方法为决策树离散化方法。例如Gmail在对信件做重要性排序时就使用了决策树离散化方法</p><p>决策树离散化方法通常也是每次离散化一个连续特征，做法如下：</p><p>单独用此特征和目标值yy训练一个决策树模型，然后把训练获得的模型内的特征分割点作为离散化的离散点。</p><p>这种方法当然也可以同时离散化多个连续特征，但是操作起来就更复杂了，实际用的不多。</p><h3 id="3-3-核方法"><a href="#3-3-核方法" class="headerlink" title="3.3 核方法"></a>3.3 核方法</h3><p>核方法经常作为线性模型的一种推广出现。以线性回归模型为例，它对应的核方法如下：</p><script type="math/tex; mode=display">f_\theta (x)=\sum_{i=1}^n\theta _iK(x,x_i)</script><p>其中$\{x_i\}^n_{i=1}$为训练样本点，$K(x_i，x_j)$为核函数，比如常用的高斯核函数为：</p><script type="math/tex; mode=display">K(x_i，x_j)=exp(-\frac{||x_i-x_j||_2^2}{2h^2})</script><p>如果我们把上面模型里的${K(x,x_i)}^n_{i=1}$看成特征，而$θ$看成模型参数的话，上面的模型仍旧是个线性模型。所以可以认为核方法只是特征函数变换的一种方式。</p><p>当然，如果把核函数$K(x_i,x_j)$看成一种相似度的话，那上面的模型就是kNN模型了，或者叫做加权平均模型也可以。</p><p>因为核方法在预测时也要用到训练样本点，耗内存且计算量大，所以在数据量较大的实际问题中用的并不多。</p><p>到此，我已经介绍了不少针对单个特征的处理方法。这些处理方法很难说哪个好哪个不好。有些问题这个好，有些问题那个好，也没什么绝招能直接判断出哪种方法能适合哪些问题。唯一的招就是：Experiment a lot!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Trevor Hastie et al. The Elements of Statistical Learning, 2001. ↩</li><li>Douglas Aberdeen et al. The Learning Behind Gmail Priority Inbox, 2010. ↩</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（12）：单例模式</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（12）：单例模式/</id>
    <published>2017-08-30T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><a id="more"></a><p>面向对象最基本的设计原则有5条，分别是：单一职责原则、开放封闭原则、依赖倒置原则、接口隔离原则和Liskov替换原则。</p><p>设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p><p>设计模式分为三种类型，共23类。</p><ul><li>创建型模式：</li></ul><p>是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p><p>创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p><p>创建型模式包括：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p><ul><li>结构型模式：</li></ul><p>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p><ul><li>行为型模式：</li></ul><p>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>单例模式是较为常用的模式之一，且经常作为考题进行考察。<br>单例模式的意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式的结构图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0obyrvsj30ck03dq3c.jpg" alt=""></p><p>使用单例的优点：</p><ul><li>单例类只有一个实例</li><li>共享资源，全局使用</li><li>节省创建时间，提高性能</li></ul><p>单例模式有多种写法各有利弊，现在我们来看看各种模式写法。</p><h3 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">     private static Singleton instance = new Singleton();  </div><div class="line">     private Singleton ()&#123;</div><div class="line">     &#125;</div><div class="line">     public static Singleton getInstance() &#123;  </div><div class="line">     return instance;  </div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>这种方式和名字很贴切，饥不择食，在类装载的时候就创建，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。</p><p>Java Runtime就是使用这种方式，它的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the runtime object associated with the current Java application.</div><div class="line">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</div><div class="line">     * methods and must be invoked with respect to the current runtime object.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</div><div class="line">     *          Java application.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentRuntime;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Don't let anyone else instantiate this class */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="comment">//以下代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结：「饿汉式」是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。</p><p>但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用「饿汉式」的单例模式就是不合适的，这时候就需要用到「懒汉式」的方式去按需延迟加载单例。</p><h3 id="2-2-懒汉式（非线程安全）"><a href="#2-2-懒汉式（非线程安全）" class="headerlink" title="2.2 懒汉式（非线程安全）"></a>2.2 懒汉式（非线程安全）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">      &#125;   </div><div class="line">      public static Singleton getInstance() &#123;  </div><div class="line">      if (instance == null) &#123;  </div><div class="line">          instance = new Singleton();  </div><div class="line">      &#125;  </div><div class="line">      return instance;  </div><div class="line">      &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。在多线程访问的时候，很可能会造成多次实例化，就不再是单例了。</p><p>「懒汉式」与「饿汉式」的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用「懒汉式」就是非常不错的选择。</p><h3 id="2-3-懒汉式（线程安全）"><a href="#2-3-懒汉式（线程安全）" class="headerlink" title="2.3 懒汉式（线程安全）"></a>2.3 懒汉式（线程安全）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">      &#125;</div><div class="line">      public static synchronized Singleton getInstance() &#123;  </div><div class="line">      if (instance == null) &#123;  </div><div class="line">          instance = new Singleton();  </div><div class="line">      &#125;  </div><div class="line">      return instance;  </div><div class="line">      &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>这两种「懒汉式」单例，名字起的也很贴切，一直等到对象实例化的时候才会创建，确实够懒，不用鞭子抽就不知道走了，典型的时间换空间，每次获取实例的时候才会判断，看是否需要创建，浪费判断时间，如果一直没有被使用，就不会被创建，节省空间。</p><p>因为这种方式在getInstance()方法上加了同步锁，所以在多线程情况下会造成线程阻塞，把大量的线程锁在外面，只有一个线程执行完毕才会执行下一个线程。</p><p>Android中的 InputMethodManager 使用了这种方式，我们看看它的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class InputMethodManager &#123;</div><div class="line">    static InputMethodManager sInstance;</div><div class="line">    </div><div class="line">     /**</div><div class="line">     * Retrieve the global InputMethodManager instance, creating it if it</div><div class="line">     * doesn&apos;t already exist.</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public static InputMethodManager getInstance() &#123;</div><div class="line">        synchronized (InputMethodManager.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">                sInstance = new InputMethodManager(service, Looper.getMainLooper());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-双重校验锁（DCL）"><a href="#2-4-双重校验锁（DCL）" class="headerlink" title="2.4 双重校验锁（DCL）"></a>2.4 双重校验锁（DCL）</h3><p>上面的方法「懒汉式（线程安全）」毫无疑问存在性能的问题 — 如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！</p><p>让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码，就成了下面的双重校验锁（Double Check Lock）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">/**</div><div class="line">     * 注意此处使用的关键字 volatile，</div><div class="line">     * 被volatile修饰的变量的值，将不会被本地线程缓存，</div><div class="line">     * 所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</div><div class="line">     */</div><div class="line">    private volatile static Singleton singleton;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            synchronized(Singleton.class) &#123;</div><div class="line">                if (instance == null) &#123;</div><div class="line">                    instance = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种写法在getSingleton()方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看 Java多线程（三）volatile域 和 java中volatile关键字的含义 两篇文章，可以看到双重检查模式是正确使用volatile关键字的场景之一。</p><p>「双重校验锁」：既可以达到线程安全，也可以使性能不受很大的影响，换句话说在保证线程安全的前提下，既节省空间也节省了时间，集合了「饿汉式」和两种「懒汉式」的优点，取其精华，去其槽粕。</p><p>对于volatile关键字，还是存在很多争议的。由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。</p><p>还有就是在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java1.5及以上的版本。</p><h3 id="2-5-静态内部类"><a href="#2-5-静态内部类" class="headerlink" title="2.5 静态内部类"></a>2.5 静态内部类</h3><p>另外，在很多情况下JVM已经为我们提供了同步控制，比如：</p><ul><li>在static {…}区块中初始化的数据</li><li>访问final字段时</li></ul><p>因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现「懒汉式」的延迟加载和线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private Singleton()&#123;</div><div class="line">    &#125;</div><div class="line">      public static Singleton getInstance()&#123;  </div><div class="line">        return SingletonHolder.sInstance;  </div><div class="line">    &#125;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">        private static final Singleton sInstance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p><p>然而这还不是最简单的方式，《Effective Java》中作者推荐了一种更简洁方便的使用方式，就是使用「枚举」。</p><h3 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h3><p>《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;</div><div class="line"> //定义一个枚举的元素，它就是 Singleton 的一个实例</div><div class="line">     INSTANCE;  </div><div class="line">     </div><div class="line">     public void doSomeThing() &#123;  </div><div class="line">     // do something...</div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[]) &#123;</div><div class="line">Singleton singleton = Singleton.instance;</div><div class="line">singleton.doSomeThing();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><h3 id="2-7-使用容器"><a href="#2-7-使用容器" class="headerlink" title="2.7 使用容器"></a>2.7 使用容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class SingletonManager &#123; </div><div class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</div><div class="line">　　private Singleton() &#123; </div><div class="line">　　&#125;</div><div class="line">　　public static void registerService(String key, Objectinstance) &#123;</div><div class="line">　　　　if (!objMap.containsKey(key) ) &#123;</div><div class="line">　　　　　　objMap.put(key, instance) ;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　public static ObjectgetService(String key) &#123;</div><div class="line">　　　　return objMap.get(key) ;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种是用SingletonManager 将多种单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><ul><li>总结</li></ul><p>对于以上七种单例，分别是「饿汉式」、「懒汉式(非线程安全)」、「懒汉式(线程安全)」、「双重校验锁」、「静态内部类」、「枚举」和「容器类管理」。很多时候取决人个人的喜好，虽然双重检查有一定的弊端和问题，但我就是钟爱双重检查，觉得这种方式可读性高、安全、优雅（个人观点）。所以代码里常常默写这样的单例，写的时候感觉自己是个伟大的建筑师。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、设计模式&quot;&gt;&lt;a href=&quot;#一、设计模式&quot; class=&quot;headerlink&quot; title=&quot;一、设计模式&quot;&gt;&lt;/a&gt;一、设计模式&lt;/h2&gt;&lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（11）：进程与线程</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（11）：进程与线程/</id>
    <published>2017-08-30T13:20:45.000Z</published>
    <updated>2018-11-05T16:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><a id="more"></a><p>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p><h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>狭义定义：进程是计算机中正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>程序本身只是指令的集合，进程才是程序（那些指令）的真正运行。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，比如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。</p><h3 id="1-2-基本状态"><a href="#1-2-基本状态" class="headerlink" title="1.2 基本状态"></a>1.2 基本状态</h3><p>通常进程有如下5种状态，其中前三种是进程的基本状态。</p><ul><li>1）运行状态（执行窗台）：进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。</li><li>2）就绪状态：进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。</li><li>3）阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。</li><li>4）创建状态：进程正在被创建，尚未转到就绪状态。</li><li>5）结束状态：进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxn8exmx1g306203c0mn.gif" alt=""><br>进程的三个基本状态之间只可以相互转换的，如图所示。具体的说：</p><ul><li>当一个就绪状态获得处理机时，其状态由就绪变为执行；</li><li>当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪；</li><li>当一个运行进程因某事件受阻时，如所申请资源被占用、启动I/O传输未完成，其状态由执行变为阻塞；</li><li>当所等待事件发生时，如得到申请资源、I/O传输完成，其状态由阻塞变为就绪</li></ul><h3 id="1-3-进程与程序的区别"><a href="#1-3-进程与程序的区别" class="headerlink" title="1.3 进程与程序的区别"></a>1.3 进程与程序的区别</h3><ul><li>进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。而程序时一组有序的指令集合，是一种静态的概念。</li><li>进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。</li><li>一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。</li></ul><h2 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈（stack）组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源。</p><p>线程共享的进程环境包括：进程代码段、进程的共有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p><p>线程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能够实现并发性。这些个性包括：</p><ul><li>线程ID：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程；</li><li>寄存器的值：由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。</li><li>线程的堆栈（Stack）：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。在一个进程的线程共享堆区（heap）。</li><li>错误返回码</li><li>线程的信号屏蔽码</li><li>线程的优先级</li></ul><p>一个线程可以创建和撤销另一个线程，同一进程的多个线程之间可以并发执行。由于县城之间的相互制约，致使线程在运行中呈现间断性。</p><p>线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p><p>线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p><p>引入线程后，进程的内涵发生了变化，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p><h3 id="1-2-进程与线程的区别"><a href="#1-2-进程与线程的区别" class="headerlink" title="1.2 进程与线程的区别"></a>1.2 进程与线程的区别</h3><ul><li>调度：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。</li><li>拥有资源：不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的系统资源。</li><li>并发性：在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有具有更好的并发性，大大提高了系统的吞吐量。</li><li>系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无需操作系统的干预。</li><li>地址空间和其他资源（如打开的文件）：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</li><li>通信方面：进程间通信需要借助操作系统，而线程间可以直接读、写进程数据段（如全局变量）来进行通信。</li></ul><h2 id="三、进程通信与进程同步"><a href="#三、进程通信与进程同步" class="headerlink" title="三、进程通信与进程同步"></a>三、进程通信与进程同步</h2><p>多个进程可以共享系统中的各种资源，但其中许多资源一次为能为一个进程使用，我们把一次仅允许一个进程使用的资源成为临界资源。许多物理设备都属于临界资源，如打印机等。</p><p>对临界资源的访问，必须互斥的进行，在每个进程中，访问临界资源的那段代码成为临界区（Critical Section）。</p><p>进程通信与同步有如下一些目的。</p><ul><li>数据传输</li><li>共享数据</li><li>通知数据</li><li>资源共享</li><li>进程控制</li></ul><p>Linux进程间通信的几种主要手段简介：</p><ul><li>管道（Pipe）及有名管道（named Pipe）</li><li>信号（Signal）</li><li>Message（消息队列）</li><li>共享内存（Shared Memory）</li><li>信号量</li><li>套接口</li></ul><p>Linux线程间通信：互斥体（互斥量）、信号量、条件变量<br>Windows进程间通信：管道、共享内存、消息队列、信号量、socket<br>windows线程间通信：临界区（Critical Section）、互斥量（Mutex）、信号量（信号灯）（Semaphore）、事件（Event）。</p><h2 id="四、调度算法"><a href="#四、调度算法" class="headerlink" title="四、调度算法"></a>四、调度算法</h2><p>调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。</p><ul><li>系统吞吐量：表示单位时间内CPU完成作业的数量</li><li>周转时间：作业完成时刻减去作业到达的时刻</li><li>等待时间：进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。</li><li>响应时间：从用户提交请求到系统首次产生响应所用的时间。</li></ul><p>典型的调度算法包括：</p><p>实时系统中：FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</p><p>交互式系统中：RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</p><p>多级反馈队列调度算法。其中SJF的平均等待时间、平均周转时间最少。</p><h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h2><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。现实生活中简单的例子：交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。</p><p>死锁产生的原因：系统资源的竞争、进程推进顺序非法</p><p>死锁产生的必要条件：产生死锁必须同时满足以下四个条件，只要其中任一条件不满足，死锁就不会发生。</p><ul><li>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待；</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他资源强行夺走，即只能由获得该资源的进程自己来释放。</li><li>请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合$\{P_1,P_2,….P_n\}$其中$P_i$等待的资源被$P_{i+1}(i=0,1,2,…n-1)$占有，$P_n$等待资源被$P_0$占有。</li></ul><p>死锁处理策略</p><ul><li>预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个</li><li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。</li><li>死锁的检测及解除：无需采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。死锁可利用资源分配图来描述。死锁的解除主要方法：资源剥夺法、撤销进程法、进程回退法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="操作系统基础" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（10）：QA</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9AQA/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（10）：QA/</id>
    <published>2017-08-30T12:20:45.000Z</published>
    <updated>2018-11-05T16:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p><a id="more"></a><h2 id="二、JDK和JRE的区别是什么？"><a href="#二、JDK和JRE的区别是什么？" class="headerlink" title="二、JDK和JRE的区别是什么？"></a>二、JDK和JRE的区别是什么？</h2><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p><h2 id="三、static关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#三、static关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="三、static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>三、static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h2><p>第一小问：<br>static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。</p><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存。实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响，改变 a 对象的实例变量不会影响 b 对象。</p><p>static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p><p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</div><div class="line">        obj1.i = <span class="number">10</span>;</div><div class="line">        obj1.j = <span class="number">20</span>;</div><div class="line">       </div><div class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</div><div class="line">       </div><div class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</div><div class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1.i=10, obj1.j=20</div><div class="line">obj2.i=10, obj2.j=0</div></pre></td></tr></table></figure><p>第二小问：<br>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><h2 id="四、是否可以在static环境中访问非static变量？"><a href="#四、是否可以在static环境中访问非static变量？" class="headerlink" title="四、是否可以在static环境中访问非static变量？"></a>四、是否可以在static环境中访问非static变量？</h2><p>非静态的既可以访问静态的，也可以访问非静态的，而静态的只能访问静态的。</p><p>不可以在静态环境中访问非静态。因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态！</p><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h2 id="五、Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#五、Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="五、Java支持的数据类型有哪些？什么是自动拆装箱？"></a>五、Java支持的数据类型有哪些？什么是自动拆装箱？</h2><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><p>虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p><p>基本类型和对应的包装类可以相互装换：</p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><p>八个包装类的使用比较相似，下面是常见的应用场景。</p><ul><li>1）实现 int 和 Integer 的相互转换</li></ul><p>可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        Integer obj = new Integer(m);  // 手动装箱</div><div class="line">        int n = obj.intValue();  // 手动拆箱</div><div class="line">        System.out.println(&quot;n = &quot; + n);</div><div class="line">       </div><div class="line">        Integer obj1 = new Integer(500);</div><div class="line">        System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><ul><li>2）将字符串转换为整数</li></ul><p>Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(String s, int radix);</div></pre></td></tr></table></figure><p>s 为要转换的字符串，radix 为进制，可选，默认为十进制。</p><p>下面的代码将会告诉你什么样的字符串可以转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String str[] = &#123;&quot;123&quot;, &quot;123abc&quot;, &quot;abc123&quot;, &quot;abcxyz&quot;&#125;;</div><div class="line">       </div><div class="line">        for(String str1 : str)&#123;</div><div class="line">            try&#123;</div><div class="line">                int m = Integer.parseInt(str1, 10);</div><div class="line">                System.out.println(str1 + &quot; 可以转换为整数 &quot; + m);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                System.out.println(str1 + &quot; 无法转换为整数&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">123 可以转换为整数 123</div><div class="line">123abc 无法转换为整数</div><div class="line">abc123 无法转换为整数</div><div class="line">abcxyz 无法转换为整数</div></pre></td></tr></table></figure><ul><li>3）将整数转换为字符串</li></ul><p>Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        String s = Integer.toString(m);</div><div class="line">        System.out.println(&quot;s = &quot; + s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = 500</div></pre></td></tr></table></figure><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p><p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</div><div class="line">        Integer obj = m;  <span class="comment">// 自动装箱</span></div><div class="line">        <span class="keyword">int</span> n = obj;  <span class="comment">// 自动拆箱</span></div><div class="line">        System.out.println(<span class="string">"n = "</span> + n);</div><div class="line">      </div><div class="line">        Integer obj1 = <span class="number">500</span>;</div><div class="line">        System.out.println(<span class="string">"obj 等价于 obj1？"</span> + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><p>自动拆箱装箱是常用的一个功能，需要重点掌握。</p><h2 id="六、Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#六、Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="六、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>六、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h2><p>1、方法覆盖（Overriding）：</p><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p><p>注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>);</div><div class="line">        myDog.say();  <span class="comment">// 子类的实例调用子类中的方法</span></div><div class="line">       </div><div class="line">        Animal myAnmial = <span class="keyword">new</span> Animal(<span class="string">"贝贝"</span>);</div><div class="line">        myAnmial.say();  <span class="comment">// 父类的实例调用父类中的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小动物，我的名字叫"</span> + name + <span class="string">"，我会发出叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="comment">// 构造方法不能被继承，通过super()调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 覆盖say() 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我的名字叫"</span> + name + <span class="string">"，我会发出汪汪的叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是一只小狗，我的名字叫花花，我会发出汪汪的叫声</div><div class="line">我是一只小动物，我的名字叫贝贝，我会发出叫声</div></pre></td></tr></table></figure><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><p>2、方法重载(Overloading)<br>在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><p>下面看一个详细的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // 一个普通的方法，不带参数</div><div class="line">    void test()&#123;</div><div class="line">        System.out.println(&quot;No parameters&quot;);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个整型参数</div><div class="line">    void test(int a)&#123;</div><div class="line">        System.out.println(&quot;a: &quot; + a);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了两个参数</div><div class="line">    void test(int a,int b)&#123;</div><div class="line">        System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个双精度参数</div><div class="line">    double test(double a)&#123;</div><div class="line">        System.out.println(&quot;double a: &quot; + a);</div><div class="line">        return a*a;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Demo obj= new Demo();</div><div class="line">        obj.test();</div><div class="line">        obj.test(2);</div><div class="line">        obj.test(2,3);</div><div class="line">        obj.test(2.0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">No parameters</div><div class="line">a: 2</div><div class="line">a and b: 2 3</div><div class="line">double a: 2.0</div></pre></td></tr></table></figure><p>通过上面的实例，读者可以看出，重载就是在一个类中，有相同的函数名称，但形参不同的函数。重载的结果，可以让一个程序段尽量减少代码和方法的种类。<br>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><p>方法的重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>方法重载的实现：</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。</li></ul><p>3、覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li></ul><h2 id="七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h2><p>1、Java中，什么是构造方法？</p><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>构造方法的名称必须与类的名称相同，并且没有返回值。</p><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p><p>下面是一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="comment">// 构造方法，没有返回值</span></div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="comment">// 普通方法，必须有返回值</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建对象时传递的参数要与构造方法参数列表对应</span></div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div></pre></td></tr></table></figure><p>说明：</p><ul><li>构造方法不能被显示调用。</li><li>构造方法不能有返回值，因为没有变量来接收返回值。</li></ul><p>2、什么是构造方法重载？</p><p>跟成员方法一样，构造方法也可以重载。Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p><p>3、什么是复制构造方法？<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数.</p><h2 id="八、Java支持多继承么？"><a href="#八、Java支持多继承么？" class="headerlink" title="八、Java支持多继承么？"></a>八、Java支持多继承么？</h2><p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。</p><p>但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h2 id="九、接口和抽象类的区别是什么？"><a href="#九、接口和抽象类的区别是什么？" class="headerlink" title="九、接口和抽象类的区别是什么？"></a>九、接口和抽象类的区别是什么？</h2><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><ul><li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li><li>类可以实现很多个接口，但是只能继承一个抽象类</li><li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>抽象类可以在不提供接口方法实现的情况下实现接口。</li><li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li><li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li><li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</li><li>也可以参考JDK8中抽象类和接口的区别</li></ul><h2 id="十、什么是值传递和引用传递"><a href="#十、什么是值传递和引用传递" class="headerlink" title="十、什么是值传递和引用传递?"></a>十、什么是值传递和引用传递?</h2><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</p><p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</p><p>一般认为,java内的传递都是值传递.</p><h2 id="十一、进程与线程的区别"><a href="#十一、进程与线程的区别" class="headerlink" title="十一、进程与线程的区别"></a>十一、进程与线程的区别</h2><p>概述:</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><p>区别:<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。</p><ul><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><p>优缺点:</p><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p><h2 id="十二、为什么集合类没有实现Cloneable和Serializable接口？"><a href="#十二、为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="十二、为什么集合类没有实现Cloneable和Serializable接口？"></a>十二、为什么集合类没有实现Cloneable和Serializable接口？</h2><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化</p><p>实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。</p><p>实现Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。</p><h2 id="十三、什么是迭代器-Iterator-？"><a href="#十三、什么是迭代器-Iterator-？" class="headerlink" title="十三、什么是迭代器(Iterator)？"></a>十三、什么是迭代器(Iterator)？</h2><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的<br>迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的<br>remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p><h2 id="十四、-Iterator和ListIterator的区别是什么？"><a href="#十四、-Iterator和ListIterator的区别是什么？" class="headerlink" title="十四、 Iterator和ListIterator的区别是什么？"></a>十四、 Iterator和ListIterator的区别是什么？</h2><p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。</p><p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p><p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="十五、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#十五、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="十五、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>十五、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h2><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h2 id="十六、final的作用"><a href="#十六、final的作用" class="headerlink" title="十六、final的作用"></a>十六、final的作用</h2><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被子类重写。</li><li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li><li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li><li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li></ul><p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p><p>事实上，为确保终态性，提供了上述方法和常量的 java.lang.Math 类也已被定义为final 的。</p><p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p><p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。下面是一个正确定义 final 变量的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final int MAX_ARRAY_SIZE = 25;  // 常量名一般大写</div></pre></td></tr></table></figure><p>常量因为有 final 修饰，所以不能被继承。<br>请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static final int TOTAL_NUMBER = 5;</div><div class="line">    public int id;</div><div class="line">    public Demo() &#123;</div><div class="line">        // 非法，对final变量TOTAL_NUMBER进行二次赋值了</div><div class="line">        // 因为++TOTAL_NUMBER相当于 TOTAL_NUMBER=TOTAL_NUMBER+1</div><div class="line">        id = ++TOTAL_NUMBER;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Demo t = new Demo();</div><div class="line">        final int i = 10;</div><div class="line">        final int j;</div><div class="line">        j = 20;</div><div class="line">        j = 30;  // 非法，对final变量进行二次赋值</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类，例如 Java.lang.String 就是一个 final 类。这样做是出于安全原因，因为要保证一旦有字符串的引用，就必须是类 String 的字符串，而不是某个其它类的字符串（String 类可能被恶意继承并篡改）。</p><p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖；变量也可以被 final 修饰，被 final 修饰的变量在创建对象以后就不允许改变它们的值了。一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。</p><p>被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。在Java中，被 static 或 private 修饰的方法会被隐式的声明为 final，因为动态绑定没有意义。</p><p>由于动态绑定会消耗资源并且很多时候没有必要，所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。</p><p>这样的认识未免有些偏激，因为 JVM 中的即时编译器能够实时监控程序的运行信息，可以准确的知道类之间的继承关系。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 变量。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName() 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p><h2 id="十七、String-与StringBuffer的区别，有什么好处？"><a href="#十七、String-与StringBuffer的区别，有什么好处？" class="headerlink" title="十七、String 与StringBuffer的区别，有什么好处？"></a>十七、String 与StringBuffer的区别，有什么好处？</h2><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p><p>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</p><p>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。</p><p>StringBuffer不像String，只能通过 new 来创建对象，不支持简写方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuffer str1 = new StringBuffer();  // 分配16个字节长度的缓冲区</div><div class="line">StringBuffer str2 = =new StringBuffer(512);  // 分配512个字节长度的缓冲区</div><div class="line">// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区</div><div class="line">StringBuffer str3 = new StringBuffer(&quot;www.baidu.com&quot;);</div></pre></td></tr></table></figure><h3 id="17-1-StringBuffer类的主要方法"><a href="#17-1-StringBuffer类的主要方法" class="headerlink" title="17.1 StringBuffer类的主要方法"></a>17.1 StringBuffer类的主要方法</h3><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p><ul><li>1) append() 方法</li></ul><p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(“biancheng100”);</div><div class="line">str.append(true);</div></pre></td></tr></table></figure><p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p><p>字符串的”+“操作实际上也是先创建一个StringBuffer对象，然后调用append()方法将字符串片段拼接起来，最后调用toString()方法转换为字符串。</p><p>这样看来，String的连接操作就比StringBuffer多出了一些附加操作，效率上必然会打折扣。</p><p>但是，对于长度较小的字符串，”+“操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率。</p><ul><li>2) deleteCharAt()</li></ul><p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str. deleteCharAt(3);</div></pre></td></tr></table></figure><p>该代码将会删除索引值为3的字符，即”d“字符。</p><p>你也可以通过delete()方法一次性删除多个字符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StingBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.delete(1, 4);</div></pre></td></tr></table></figure><p>该代码会删除索引值为1~4之间的字符，包括索引值1，但不包括4。</p><ul><li>3) insert()方法</li></ul><p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.insert(3, &quot;xyz&quot;);</div></pre></td></tr></table></figure><p>最后str所指向的字符串为 abcdxyzef。</p><ul><li>4) setCharAt() 方法</li></ul><p>setCharAt() 方法用来修改指定位置的字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.setCharAt(3, &apos;z&apos;);</div></pre></td></tr></table></figure><p>该代码将把索引值为3的字符修改为 z，最后str所指向的字符串为 abczef。</p><p>以上仅仅是部分常用方法的简单说明，更多方法和解释请查阅API文档。</p><h3 id="17-2-String和StringBuffer的效率对比"><a href="#17-2-String和StringBuffer的效率对比" class="headerlink" title="17.2 String和StringBuffer的效率对比"></a>17.2 String和StringBuffer的效率对比</h3><p>为了更加明显地看出它们的执行效率，下面的代码，将26个英文字母加了10000次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String fragment = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">10000</span>;</div><div class="line">       </div><div class="line">        <span class="comment">// 通过String对象</span></div><div class="line">        <span class="keyword">long</span> timeStart1 = System.currentTimeMillis();</div><div class="line">        String str1 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str1 += fragment;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd1 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"String: "</span> + (timeEnd1 - timeStart1) + <span class="string">"ms"</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 通过StringBuffer</span></div><div class="line">        <span class="keyword">long</span> timeStart2 = System.currentTimeMillis();</div><div class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str2.append(fragment);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (timeEnd2 - timeStart2) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 5287ms</div><div class="line">StringBuffer: 3ms</div></pre></td></tr></table></figure><p>结论很明显，StringBuffer的执行效率比String快上千倍，这个差异随着叠加次数的增加越来越明显，当叠加次数达到30000次的时候，运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 35923ms</div><div class="line">StringBuffer: 8ms</div></pre></td></tr></table></figure><p>所以，强烈建议在涉及大量字符串操作时使用StringBuffer。</p><h3 id="17-3-StringBuilder类"><a href="#17-3-StringBuilder类" class="headerlink" title="17.3 StringBuilder类"></a>17.3 StringBuilder类</h3><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p><p>StringBuffer、StringBuilder、String中都实现了CharSequence接口。CharSequence是一个定义字符串操作的接口，它只包括length()、charAt(int index)、subSequence(int start, int end) 这几个API。</p><p>StringBuffer、StringBuilder、String对CharSequence接口的实现过程不一样，如下图所示：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxn9nl5h3j30b805x744.jpg" alt=""></p><p>可见，String直接实现了CharSequence接口；StringBuilder 和 StringBuffer都是可变的字符序列，它们都继承于AbstractStringBuilder，实现了CharSequence接口。</p><p>总结一下：</p><ul><li>线程安全：<ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul></li><li><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul></li><li><p>使用环境：</p><ul><li>操作少量的数据使用 String；</li><li>单线程操作大量数据使用 StringBuilder；</li><li>多线程操作大量数据使用 StringBuffer。</li></ul></li></ul><h2 id="十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。"><a href="#十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。" class="headerlink" title="十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。"></a>十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。</h2><h2 id="二十、-synchronized和lock的区别"><a href="#二十、-synchronized和lock的区别" class="headerlink" title="二十、 synchronized和lock的区别"></a>二十、 synchronized和lock的区别</h2><ul><li><p>动态绑定与静态绑定：</p></li><li><p>volatile是什么，threadlocal是什么 </p></li><li><p>volatile和synchronized的区别 </p></li></ul><p>垃圾回收机制</p><p>1.进程与线程的区别，线程的同步问题，两个线程访问一个临界资源该怎么做？线程什么时候终止？（还问到一个daemon函数，我当时完全不知道这是什么）</p><p>1.什么是面向对象？JAVA与C相比有什么区别？JAVA的对象与c的结构体有什么区别？</p><p>2.JAVA的IO有哪些类？接口？关系是啥？（谁继承谁之类的）</p><p>3.你用过哪些JAVA的库？（java.io, java.util, 等等）你什么时候开始用JAVA的？（这个问题是最开始问的，我说14年开始的。。后面又问了一遍。。）</p><p>然后问了高并发问题，讲讲CurrentHashMap原理，可是我并不了解，就大概说了下自己想法</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;a href=&quot;#一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;/a&gt;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&lt;/h2&gt;&lt;p&gt;Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="QA" scheme="http://yoursite.com/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（9）：内部类、抽象类、接口</title>
    <link href="http://yoursite.com/2017/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2017/08/28/Java学习笔记（9）：内部类、抽象类、接口/</id>
    <published>2017-08-28T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java内部类及其实例化"><a href="#一、Java内部类及其实例化" class="headerlink" title="一、Java内部类及其实例化"></a>一、Java内部类及其实例化</h1><p>在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。</p><a id="more"></a><p>内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。</p><p>使用内部类的主要原因有：</p><ul><li>内部类可以访问外部类中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous)内部类比较便捷。</li><li>减少类的命名冲突。</li></ul><p>请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">10</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</div><div class="line">            size++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Demo outer = <span class="keyword">new</span> Demo();</div><div class="line">        Inner inner = outer.new Inner();</div><div class="line">        inner.doStuff();</div><div class="line">        System.out.println(outer.size);</div><div class="line">        System.out.println(inner.counter);</div><div class="line">        <span class="comment">// 编译错误，外部类不能访问内部类的变量</span></div><div class="line"><span class="comment">//        System.out.println(counter);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码定义了一个外部类 Outer，它包含了一个内部类 Inner。将错误语句注释掉，编译，会生成两个 .class 文件：Outer.class 和 Outer<script type="math/tex">`Inner.class。也就是说，内部类会被编译成独立的字节码文件。内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用`</script> 符号分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。<br>注意：必须先有外部类的对象才能生成内部类的对象，因为内部类需要访问外部类中的成员变量，成员变量必须实例化才有意义。</p><p>内部类是 Java 1.1 的新增特性，有些程序员认为这是一个值得称赞的进步，但是内部类的语法很复杂，严重破坏了良好的代码结构， 违背了Java要比C++更加简单的设计理念。</p><p>内部类看似增加了—些优美有趣，实属没必要的特性，这是不是也让Java开始走上了许多语言饱受折磨的毁灭性道路呢？本教程并不打算就这个问题给予一个肯定的答案。</p><h1 id="二、内部类的分类"><a href="#二、内部类的分类" class="headerlink" title="二、内部类的分类"></a>二、内部类的分类</h1><p>内部类可以是静态(static)的，可以使用 public、protected 和 private 访问控制符，而外部类只能使用 public，或者默认。</p><h2 id="2-1-成员式内部类"><a href="#2-1-成员式内部类" class="headerlink" title="2.1 成员式内部类"></a>2.1 成员式内部类</h2><p>在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员式内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。</p><p>请看下面的代码：</p><h1 id="三、抽象类的概念和使用"><a href="#三、抽象类的概念和使用" class="headerlink" title="三、抽象类的概念和使用"></a>三、抽象类的概念和使用</h1><p>在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。</p><p>这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p><p>使用 abstract 修饰符来表示抽象方法和抽象类。</p><p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。</p><p>抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line"></div><div class="line">public  class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Teacher t = new Teacher();</div><div class="line">        t.setName(&quot;王明&quot;);</div><div class="line">        t.work();</div><div class="line">       </div><div class="line">        Driver d = new Driver();</div><div class="line">        d.setName(&quot;小陈&quot;);</div><div class="line">        d.work();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义一个抽象类</div><div class="line">abstract class People&#123;</div><div class="line">    private String name;  // 实例变量</div><div class="line">   </div><div class="line">    // 共有的 setter 和 getter 方法</div><div class="line">    public void setName(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public String getName()&#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    // 抽象方法</div><div class="line">    public abstract void work();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Teacher extends People&#123;</div><div class="line">    // 必须实现该方法</div><div class="line">    public void work()&#123;</div><div class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在讲课，请大家不要东张西望...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Driver extends People&#123;</div><div class="line">    // 必须实现该方法</div><div class="line">    public void work()&#123;</div><div class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在开车，不能接听电话...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br>我的名字叫王明，我正在讲课，请大家不要东张西望…<br>我的名字叫小陈，我正在开车，不能接听电话…</p><p>关于抽象类的几点说明：</p><ul><li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li><li>不能有抽象构造方法或抽象静态方法。</li></ul><p>在下列情况下，一个类将成为抽象类：</p><ul><li>当一个类的一个或多个方法是抽象方法时；</li><li>当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li><li>当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时；注意：</li></ul><p>这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。一个典型的错误：抽象类一定包含抽象方法。 但是反过来说“包含抽象方法的类一定是抽象类”就是正确的。事实上，抽象类可以是一个完全正常实现的类</p><h1 id="四、接口的概念和使用"><a href="#四、接口的概念和使用" class="headerlink" title="四、接口的概念和使用"></a>四、接口的概念和使用</h1><h2 id="4-1-接口的概念"><a href="#4-1-接口的概念" class="headerlink" title="4.1 接口的概念"></a>4.1 接口的概念</h2><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p><p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p><p>现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。</p><p>希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。</p><p>下面的代码可以模拟Serial ATA委员会定义以下串口硬盘接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface Demo&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public static final int CONNECT_LINE=4;</div><div class="line">    //写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    //读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。</p><p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。</p><p>但接口有其自身的一些特性，归纳如下。</p><ul><li>1) 接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface SataHdd&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public int connectLine; //编译出错，connectLine被看做静态常量，必须显式初始化</div><div class="line">    //写数据</div><div class="line">    protected void writeData(String data); //编译出错，必须是public类型</div><div class="line">    //读数据</div><div class="line">    public static String readData()&#123; //编译出错，接口中不能包含静态方法</div><div class="line">        return &quot;数据&quot;; //编译出错，接口中只能包含抽象方法，</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>2) 接口中没有构造方法，不能被实例化。</p></li><li><p>3) 一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//串行硬盘接口</div><div class="line">public interface SataHdd extends A,B&#123;</div><div class="line">    // 连接线的数量</div><div class="line">    public static final int CONNECT_LINE = 4;</div><div class="line">    // 写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    // 读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div><div class="line">interface A&#123;</div><div class="line">    public void a();</div><div class="line">&#125;</div><div class="line">interface B&#123;</div><div class="line">    public void b();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-为什么使用接口"><a href="#4-2-为什么使用接口" class="headerlink" title="4.2 为什么使用接口"></a>4.2 为什么使用接口</h2><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p><p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。</p><p>我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。</p><p>接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。</p><p>接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。</p><h2 id="4-3-接口的使用"><a href="#4-3-接口的使用" class="headerlink" title="4.3 接口的使用"></a>4.3 接口的使用</h2><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p><p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p><p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p><p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p><p>一个类只能继承一个父类，但却可以实现多个接口。</p><p>实现接口的格式如下：<br>修饰符 class 类名 extends 父类 implements 多个接口 {<br>实现方法<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line"></div><div class="line">public class Demo&#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">      SataHdd sh1=new SeagateHdd(); //初始化希捷硬盘</div><div class="line">      SataHdd sh2=new SamsungHdd(); //初始化三星硬盘</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//串行硬盘接口</div><div class="line">interface SataHdd&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public static final int CONNECT_LINE=4;</div><div class="line">    //写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    //读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 维修硬盘接口</div><div class="line">interface fixHdd&#123;</div><div class="line">    // 维修地址</div><div class="line">    String address = &quot;北京市海淀区&quot;;</div><div class="line">    // 开始维修</div><div class="line">    boolean doFix();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//捷硬盘</div><div class="line">class SeagateHdd implements SataHdd, fixHdd&#123;</div><div class="line">    //希捷硬盘读取数据</div><div class="line">    public String readData()&#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">    //希捷硬盘写入数据</div><div class="line">    public void writeData(String data) &#123;</div><div class="line">        out.println(&quot;写入成功&quot;);</div><div class="line">    &#125;</div><div class="line">    // 维修希捷硬盘</div><div class="line">    public boolean doFix()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//三星硬盘</div><div class="line">class SamsungHdd implements SataHdd&#123;</div><div class="line">    //三星硬盘读取数据</div><div class="line">    public String readData()&#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">    //三星硬盘写入数据</div><div class="line">    public void writeData(String data)&#123;</div><div class="line">        out.println(&quot;写入成功&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//某劣质硬盘，不能写数据</div><div class="line">abstract class XXHdd implements SataHdd&#123;</div><div class="line">    //硬盘读取数据</div><div class="line">    public String readData() &#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-4-接口作为类型使用"><a href="#4-4-接口作为类型使用" class="headerlink" title="4.4 接口作为类型使用"></a>4.4 接口作为类型使用</h2><p>接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        a.doSth();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        A a = <span class="keyword">new</span> B();</div><div class="line">        d.test1(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSth</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"now in B"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">123</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br>now in B</p><p>大家看到接口可以作为一个类型来使用，把接口作为方法的参数和返回类型。</p><h1 id="五、接口和抽象类的区别"><a href="#五、接口和抽象类的区别" class="headerlink" title="五、接口和抽象类的区别"></a>五、接口和抽象类的区别</h1><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p><p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。我们首先分析它们具有的相同点。</p><ul><li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li><li>都不能被实例化。</li><li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li></ul><p>下面说一下抽象类和接口的主要区别。</p><ul><li>1) 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class A&#123;</div><div class="line">    public abstract void method1();</div><div class="line">    public void method2()&#123;</div><div class="line">        //A method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class B extends A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //B method1</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class C extends A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p><p>再换成接口看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public interface A&#123;</div><div class="line">    public void method1();</div><div class="line">    public void method2();</div><div class="line">&#125;</div><div class="line">public class B implements A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //B method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //B method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class C implements A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p><ul><li>2) 一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">interface A&#123;</div><div class="line">    public void method2();</div><div class="line">&#125;</div><div class="line">interface B&#123;</div><div class="line">    public void method1();</div><div class="line">&#125;</div><div class="line">class C implements A,B&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</div><div class="line">A a=new C();</div><div class="line">B b=new C();</div><div class="line">abstract class A&#123;</div><div class="line">    public abstract void method1();</div><div class="line">&#125;</div><div class="line">abstract class B extends A&#123;</div><div class="line">    public abstract void method2();</div><div class="line">&#125;</div><div class="line">class C extends B&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于C类，将没有机会继承其他父类了。</p><p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Java内部类及其实例化&quot;&gt;&lt;a href=&quot;#一、Java内部类及其实例化&quot; class=&quot;headerlink&quot; title=&quot;一、Java内部类及其实例化&quot;&gt;&lt;/a&gt;一、Java内部类及其实例化&lt;/h1&gt;&lt;p&gt;在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="内部类" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="抽象类" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（8）：常用库类、向量与哈希</title>
    <link href="http://yoursite.com/2017/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%BA%93%E7%B1%BB%E3%80%81%E5%90%91%E9%87%8F%E4%B8%8E%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2017/08/27/Java学习笔记（8）：常用库类、向量与哈希/</id>
    <published>2017-08-27T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java基础类库"><a href="#一、Java基础类库" class="headerlink" title="一、Java基础类库"></a>一、Java基础类库</h1><p>Java 的类库是 Java 语言提供的已经实现的标准类的集合，是 Java 编程的 API（Application Program Interface），它可以帮助开发者方便、快捷地开发 Java 程序。这些类根据实现的功能不同，可以划分为不同的集合，每个集合组成一个包，称为类库。Java 类库中大部分都是由Sun 公司提供的，这些类库称为基础类库。</p><a id="more"></a><p>Java 语言中提供了大量的类库共程序开发者来使用，了解类库的结构可以帮助开发者节省大量的编程时间，而且能够使编写的程序更简单更实用。Java 中丰富的类库资源也是 Java 语言的一大特色，是 Java 程序设计的基础。</p><p>Java 常用包的简单介绍如下：</p><ul><li>java.lang 包：主要含有与语言相关的类。java.lang 包由解释程序自动加载，不需要显示说明。</li><li>java.io 包：主要含有与输入/输出相关的类，这些类提供了对不同的输入和输出设备读写数据的支持，这些输入和输出设备包括键盘、显示器、打印机、磁盘文件等。</li><li>java.util 包：包括许多具有特定功能的类，有日期、向量、哈希表、堆栈等，其中 Date类支持与时间有关的操作。</li><li>java.swing 包和 java.awt 包：提供了创建图形用户界面元素的类。通过这些元素，编程者可以控制所写的 Applet 或 Application 的外观界面。包中包含了窗口、对话框、菜单等类。</li><li>java.net 包：含有与网络操作相关的类，如 TCP Scokets、URL 等工具。</li><li>java.applet 包：含有控制 HTML 文档格式、应用程序中的声音等资源的类，其中 Applet类是用来创建包含于 HTML 的 Applet 必不可少的类。</li><li>java.beans 包：定义了应用程序编程接口（API），Java Beans 是 Java 应用程序环境的中性平台组件结构。</li></ul><h1 id="二、Java语言包-java-lang-简介"><a href="#二、Java语言包-java-lang-简介" class="headerlink" title="二、Java语言包(java.lang)简介"></a>二、Java语言包(java.lang)简介</h1><p>Java语言包（java.lang）定义了Java中的大多数基本类，由Java语言自动调用，不需要显示声明。该包中包含了Object类，Object类是整个类层次结构的根结点，同时还定义了基本数据类型的类，如：String、Boolean、Byter、Short等。这些类支持数字类型的转换和字符串的操作等，下面将进行简单介绍。</p><p>Math类提供了常用的数学运算方法以及Math.PI和Math.E两个数学常量。该类是final的，不能被继承，类中的方法和属性全部是静态，不允许在类的外部创建Math类的对象。因此，只能使用Math类的方法而不能对其作任何更改。表8-1列出了Math类的主要方法。</p><h2 id="2-1-Math类"><a href="#2-1-Math类" class="headerlink" title="2.1 Math类"></a>2.1 Math类</h2><blockquote><p>Math类的主要方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>int abs(int i)</td><td>求整数的绝对值（另有针对long、float、double的方法）</td></tr><tr><td>double ceil(double d)</td><td>不小于d的最小整数（返回值为double型）</td></tr><tr><td>double floor(double d)</td><td>不大于d的最大整数（返回值为double型）</td></tr><tr><td>int max(int i1,int i2)</td><td>求两个整数中最大数（另有针对long、float、double的方法）</td></tr><tr><td>int min(int i1,int i2)</td><td>求两个整数中最小数（另有针对long、float、double的方法）</td></tr><tr><td>double random()</td><td>产生0~1之间的随机数</td></tr><tr><td>int round(float f)</td><td>求最靠近f的整数</td></tr><tr><td>long round(double d)</td><td>求最靠近d的长整数</td></tr><tr><td>double sqrt(double a)</td><td>求平方根</td></tr><tr><td>double sin(double d)</td><td>求d的sin值（另有求其他三角函数的方法如cos，tan，atan）</td></tr><tr><td>double log(double x)</td><td>求自然对数</td></tr><tr><td>double exp(double x)</td><td>求e的x次幂（ex）</td></tr><tr><td>double pow(double a, double b)</td><td>求a的b次幂</td></tr></tbody></table></div><p>例如：产生10个10~100之间的随机整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//********** ep8_2.java **********</div><div class="line">class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        int a;</div><div class="line">        System.out.print(&quot;随机数为：&quot;);</div><div class="line">        for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">            a=(int)((100-10+1)*Math.random()+10);</div><div class="line">            System.out.print(&quot; &quot;+a);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-字符串类"><a href="#2-2-字符串类" class="headerlink" title="2.2 字符串类"></a>2.2 字符串类</h2><p>字符串是字符的序列。在 Java 中，字符串无论是常量还是变量都是用类的对象来实现的。java.lang 提供了两种字符串类：String 类和 StringBuffer 类。</p><blockquote><p>1.String 类</p></blockquote><p>按照 Java 语言的规定，String 类是 immutable 的 Unicode 字符序列，其作用是实现一种不能改变的静态字符串。例如，把两个字符串连接起来的结果是生成一个新的字符串，而不会使原来的字符串改变。实际上，所有改变字符串的结果都是生成新的字符串，而不是改变原来字符串。</p><p>字符串与数组的实现很相似，也是通过 index 编号来指出字符在字符串中的位置的，编号从0 开始，第 2 个字符的编号为 1，以此类推。如果要访问的编号不在合法的范围内，系统会产生 StringIndexOutOfBoundsExecption 异常。如果 index 的值不是整数，则会产生编译错误。</p><p>String 类提供了如下表所示的几种字符串创建方法。</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>String s=”Hello!”</td><td>用字符串常量自动创建 String 实例。</td></tr><tr><td>String s=new String(String s)</td><td>通过 String 对象或字符串常量传递给构造方法。</td></tr><tr><td>public String(char value[])</td><td>将整个字符数组赋给 String 构造方法。</td></tr><tr><td>public String(char value[], int offset, int count)</td><td>将字符数组的一部分赋给 String 构造方法，offset 为起始下标，count为子数组长度。</td></tr></tbody></table></div><blockquote><p>2.StringBuffer 类</p></blockquote><p>String 类不能改变字符串对象中的内容，只能通过建立一个新串来实现字符串的变化。如果字符串需要动态改变，就需要用 StringBuffer 类。StringBuffer 类主要用来实现字符串内容的添加、修改、删除，也就是说该类对象实体的内存空间可以自动改变大小，以便于存放一个可变的字符序列。</p><p>StringBuffer 类提供的三种构造方法：</p><div class="table-container"><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer()</td><td>使用该无参数的构造方法创建的 StringBuffer 对象，初始容量为 16 个字符，当对象存放的字符序列大于 16 个字符时，对象的容量自动增加。该对象可以通过 length()方法获取实体中存放的字符序列的长度，通过 capacity()方法获取当前对象的实际容量。</td></tr><tr><td>StringBuffer(int length)</td><td>使用该构造方法创建的 StringBuffer 对象，其初始容量为参数 length 指定的字符个数，当对象存放的字符序列的长度大于 length 时，对象的容量自动增加，以便存放所增加的字符。</td></tr><tr><td>StringBuffer(Strin str)</td><td>使用该构造方法创建的 StringBuffer 对象，其初始容量为参数字符串 str 的长度再加上 16 个字符。</td></tr></tbody></table></div><blockquote><p>几种 StringBuffer 类常用的方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>append()</td><td>使用 append() 方法可以将其他 Java 类型数据转化为字符串后再追加到 StringBuffer 的对象中。</td></tr><tr><td>insert(int index, String str)</td><td>insert() 方法将一个字符串插入对象的字符序列中的某个位置。</td></tr><tr><td>setCharAt(int n, char ch)</td><td>将当前 StringBuffer 对象中的字符序列 n 处的字符用参数 ch 指定的字符替换，n 的值必须是非负的，并且小于当前对象中字符串序列的长度。</td></tr><tr><td>reverse()</td><td>使用 reverse()方法可以将对象中的字符序列翻转。</td></tr><tr><td>delete(int n, int m)</td><td>从当前 StringBuffer 对象中的字符序列删除一个子字符序列。这里的 n 指定了需要删除的第一个字符的下标，m 指定了需要删除的最后一个字符的下一个字符的下标，因此删除的子字符串从 n~m-1。</td></tr><tr><td>replace(int n, int m, String str)</td><td>用 str 替换对象中的字符序列，被替换的子字符序列由下标 n 和 m 指定。</td></tr></tbody></table></div><h1 id="三、日期和时间类"><a href="#三、日期和时间类" class="headerlink" title="三、日期和时间类"></a>三、日期和时间类</h1><p>Java 的日期和时间类位于 java.util 包中。利用日期时间类提供的方法，可以获取当前的日期和时间，创建日期和时间参数，计算和比较时间。</p><h2 id="3-1-Date-类"><a href="#3-1-Date-类" class="headerlink" title="3.1 Date 类"></a>3.1 Date 类</h2><p>Date 类是 Java 中的日期时间类，其构造方法比较多，下面是常用的两个：</p><ul><li>Date()：使用当前的日期和时间初始化一个对象。</li><li>Date(long millisec)：从1970年01月01日00时（格林威治时间）开始以毫秒计算时间，计算 millisec 毫秒。如果运行 Java 程序的本地时区是北京时区（与格林威治时间相差 8 小时），Date dt1=new Date(1000);，那么对象 dt1 就是1970年01月01日08时00分01秒。</li></ul><p>请看一个显示日期时间的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Date da=new Date();  //创建时间对象</div><div class="line">        System.out.println(da); //显示时间和日期</div><div class="line">        long msec=da.getTime();</div><div class="line">        System.out.println(&quot;从1970年1月1日0时到现在共有：&quot; + msec + &quot;毫秒&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mon Feb 05 22:50:05 CST 2007</div><div class="line">从1970年1月1日0时到现在共有：1170687005390 毫秒</div></pre></td></tr></table></figure><p>一些比较常用的 Date 类方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>boolean after(Date date)</td><td>若调用 Date 对象所包含的日期比 date 指定的对象所包含的日期晚，返回 true，否则返回 false。</td></tr><tr><td>boolean before(Date date)</td><td>若调用 Date 对象所包含的日期比 date 指定的对象所包含的日期早，返回 true，否则返回 false。</td></tr><tr><td>Object clone()</td><td>复制调用 Date 对象。</td></tr><tr><td>int compareTo(Date date)</td><td>比较调用对象所包含的日期和指定的对象包含的日期，若相等返回 0；若前者比后者早，返回负值；否则返回正值。</td></tr><tr><td>long getTime()</td><td>以毫秒数返回从 1970 年 01 月 01 日 00 时到目前的时间。</td></tr><tr><td>int hashCode()</td><td>返回调用对象的散列值。</td></tr><tr><td>void setTime(long time)</td><td>根据 time 的值，设置时间和日期。time 值从 1970 年 01 月 01 日 00 时开始计算。</td></tr><tr><td>String toString()</td><td>把调用的 Date 对象转换成字符串并返回结果。</td></tr><tr><td>public Static String valueOf(type variable)</td><td>把 variable 转换为字符串。</td></tr></tbody></table></div><p>Date 对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。若需要修改时间显示的格式可以使用“SimpleDateFormat(String pattern)”方法。</p><p>例如，用不同的格式输出时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Date da=new Date();</div><div class="line">        System.out.println(da);</div><div class="line">        SimpleDateFormat ma1=new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 E 北京时间&quot;);</div><div class="line">        System.out.println(ma1.format(da));</div><div class="line">        SimpleDateFormat ma2=new SimpleDateFormat(&quot;北京时间：yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;);</div><div class="line">        System.out.println(ma2.format(-1000));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sun Jan 04 17:31:36 CST 2015</div><div class="line">2015 年 01 月 04 日 星期日 北京时间</div><div class="line">北京时间：1970 年 01 月 01 日 07 时 59 分 59 秒</div></pre></td></tr></table></figure><h2 id="3-2-Calendar-类"><a href="#3-2-Calendar-类" class="headerlink" title="3.2 Calendar 类"></a>3.2 Calendar 类</h2><p>抽象类 Calendar 提供了一组方法，允许把以毫秒为单位的时间转换成一些有用的时间组成部分。Calendar 不能直接创建对象，但可以使用静态方法 getInstance() 获得代表当前日期的日历对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Calendar calendar=Calendar.getInstance();</div></pre></td></tr></table></figure><p>该对象可以调用下面的方法将日历翻到指定的一个时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void set(int year,int month,int date);</div><div class="line">void set(int year,int month,int date,int hour,int minute);</div><div class="line">void set(int year,int month,int date,int hour,int minute,int second);</div></pre></td></tr></table></figure><p>若要调用有关年份、月份、小时、星期等信息，可以通过调用下面的方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int get(int field);</div></pre></td></tr></table></figure><p>其中，参数 field 的值由 Calendar 类的静态常量决定。其中：YEAR 代表年，MONTH 代表月，HOUR 代表小时，MINUTE 代表分，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calendar.get(Calendar.MONTH);</div></pre></td></tr></table></figure><p>如果返回值为 0 代表当前日历是一月份，如果返回 1 代表二月份，依此类推。</p><p>由 Calendar 定义的一些常用方法如下表所示：</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>abstract void add(int which,int val)</td><td>将 val 加到 which 所指定的时间或者日期中，如果需要实现减的功能，可以加一个负数。which 必须是 Calendar 类定义的字段之一，如 Calendar.HOUR</td></tr><tr><td>boolean after(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期晚，返回 true，否则返回 false</td></tr><tr><td>boolean before(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期早，返回 true，否则返回 false</td></tr><tr><td>final void clear()</td><td>对调用对象包含的所有时间组成部分清零</td></tr><tr><td>final void clear(int which)</td><td>对调用对象包含的 which 所指定的时间组成部分清零</td></tr><tr><td>boolean equals(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期和 calendarObj 指定的对象所包含的日期相等，返回 true，否则返回 false</td></tr><tr><td>int get(int calendarField)</td><td>返回调用 Calendar 对象的一个时间组成部分的值，这个组成部分由 calendarField指定，可以被返回的组成部分如：Calendar.YEAR，Calendar.MONTH 等</td></tr><tr><td>static Calendar getInstance()</td><td>返回使用默认地域和时区的一个 Calendar 对象</td></tr><tr><td>final Date getTime()</td><td>返回一个和调用对象时间相等的 Date 对象</td></tr><tr><td>final boolean isSet(int which)</td><td>如果调用对象所包含的 which 指定的时间部分被设置了，返回 true，否则返回 false</td></tr><tr><td>final void set(int year,int month)</td><td>设置调用对象的各种日期和时间部分</td></tr><tr><td>final void setTime(Date d)</td><td>从 Date 对象 d 中获得日期和时间部分</td></tr><tr><td>void setTimeZone(TimeZone t)</td><td>设置调用对象的时区为 t 指定的那个时区</td></tr></tbody></table></div><h2 id="3-3-GregorianCalendar-类"><a href="#3-3-GregorianCalendar-类" class="headerlink" title="3.3 GregorianCalendar 类"></a>3.3 GregorianCalendar 类</h2><p>GregorianCalendar 是一个具体实现 Calendar 类的类，该类实现了公历日历。Calendar 类的 getInstance() 方法返回一个 GregorianCalendar，它被初始化为默认的地域和时区下的当前日期和时间。</p><p>GregorianCalendar 类定义了两个字段：AD 和 BC，分别代表公元前和公元后。其默认的构造方法 GregorianCalendar() 以默认的地域和时区的当前日期和时间初始化对象，另外也可以指定地域和时区来建立一个 GregorianCalendar 对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GregorianCalendar(Locale locale);</div><div class="line">GregorianCalendar(TimeZone timeZone);</div><div class="line">GregorianCalendar(TimeZone timeZone,Locale locale);</div></pre></td></tr></table></figure><p>GregorianCalendar 类提供了 Calendar 类中所有的抽象方法的实现，同时还提供了一些附加的方法，其中用来判断闰年的方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean isLeapYear(int year);</div></pre></td></tr></table></figure><p>如果 year 是闰年，该方法返回 true，否则返回 false。</p><h1 id="四、哈希表及其应用"><a href="#四、哈希表及其应用" class="headerlink" title="四、哈希表及其应用"></a>四、哈希表及其应用</h1><p>哈希表也称为散列表，是用来存储群体对象的集合类结构。</p><h2 id="4-1-什么是哈希表"><a href="#4-1-什么是哈希表" class="headerlink" title="4.1 什么是哈希表"></a>4.1 什么是哈希表</h2><p>数组和向量都可以存储对象，但对象的存储位置是随机的，也就是说对象本身与其存储位置之间没有必然的联系。当要查找一个对象时，只能以某种顺序（如顺序查找或二分查找）与各个元素进行比较，当数组或向量中的元素数量很多时，查找的效率会明显的降低。</p><p>一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。如果此对象在集合中，则必定在存储位置 f(k)上，因此不需要与集合中的其他元素进行比较。称这种对应关系 f 为哈希（hash）方法，按照这种思想建立的表为哈希表。</p><p>Java 使用哈希表类（Hashtable）来实现哈希表，以下是与哈希表相关的一些概念：</p><ul><li>容量（Capacity）：Hashtable 的容量不是固定的，随对象的加入其容量也可以自动增长。</li><li>关键字（Key）：每个存储的对象都需要有一个关键字，key 可以是对象本身，也可以是对象的一部分（如某个属性）。要求在一个 Hashtable 中的所有关键字都是唯一的。</li><li>哈希码（Hash Code）：若要将对象存储到 Hashtable 上，就需要将其关键字 key 映射到一个整型数据，成为 key 的哈希码。</li><li>项（Item）：Hashtable 中的每一项都有两个域，分别是关键字域 key 和值域 value（存储的对象）。Key 和 value 都可以是任意的 Object 类型的对象，但不能为空。</li><li>装填因子（Load Factor）：装填因子表示为哈希表的装满程度，其值等于元素数比上哈希表的长度。</li></ul><h2 id="4-2-哈希表的使用"><a href="#4-2-哈希表的使用" class="headerlink" title="4.2 哈希表的使用"></a>4.2 哈希表的使用</h2><p>哈希表类主要有三种形式的构造方法：</p><ul><li>Hashtable(); //默认构造函数，初始容量为 101，最大填充因子 0.75</li><li>Hashtable(int capacity);</li><li>Hashtable(int capacity,float loadFactor)</li></ul><p>哈希表类的主要方法如下表所示。</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>void clear()</td><td>重新设置并清空哈希表</td></tr><tr><td>boolean contains(Object value)</td><td>确定哈希表内是否包含了给定的对象，若有返回 true，否则返回 false</td></tr><tr><td>boolean containsKey(Object key)</td><td>确定哈希表内是否包含了给定的关键字，若有返回 true，否则返回 false</td></tr><tr><td>boolean isEmpty()</td><td>确认哈希表是否为空，若是返回 true，否则返回 false</td></tr><tr><td>Object get(Object key)</td><td>获取对应关键字的对象，若不存在返回 null</td></tr><tr><td>void rehash()</td><td>再哈希，扩充哈希表使之可以保存更多的元素，当哈希表达到饱和时，系统自动调用此方法</td></tr><tr><td>Object put(Object key,Object value)</td><td>用给定的关键字把对象保存到哈希表中，此处的关键字和元素均不可为空</td></tr><tr><td>Object remove(Object key)</td><td>从哈希表中删除与给定关键字相对应的对象，若该对象不存在返回 null</td></tr><tr><td>int size()</td><td>返回哈希表的大小</td></tr><tr><td>String toString()</td><td>将哈希表内容转换为字符串</td></tr></tbody></table></div><p>哈希表的创建也可以通过 new 操作符实现。其语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashTable has=new HashTable();</div></pre></td></tr></table></figure><p>哈希表的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//*** ep8_12.java **********</div><div class="line">import java.util.*;</div><div class="line">class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Hashtable has=new Hashtable();</div><div class="line">        has.put(&quot;one&quot;,new Integer(1));</div><div class="line">        has.put(&quot;two&quot;,new Integer(2));</div><div class="line">        has.put(&quot;three&quot;,new Integer(3));</div><div class="line">        has.put(&quot;four&quot;,new Double(12.3));</div><div class="line">        Set s=has.keySet();</div><div class="line">        for(Iterator&lt;String&gt; i=s.iterator();i.hasNext();)&#123;</div><div class="line">            System.out.println(has.get(i.next()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Java基础类库&quot;&gt;&lt;a href=&quot;#一、Java基础类库&quot; class=&quot;headerlink&quot; title=&quot;一、Java基础类库&quot;&gt;&lt;/a&gt;一、Java基础类库&lt;/h1&gt;&lt;p&gt;Java 的类库是 Java 语言提供的已经实现的标准类的集合，是 Java 编程的 API（Application Program Interface），它可以帮助开发者方便、快捷地开发 Java 程序。这些类根据实现的功能不同，可以划分为不同的集合，每个集合组成一个包，称为类库。Java 类库中大部分都是由Sun 公司提供的，这些类库称为基础类库。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="常用库类" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%BA%93%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（7）：深入理解java异常处理机制</title>
    <link href="http://yoursite.com/2017/08/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/08/26/Java学习笔记（7）：深入理解java异常处理机制/</id>
    <published>2017-08-26T14:20:45.000Z</published>
    <updated>2018-11-05T16:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、java异常"><a href="#一、java异常" class="headerlink" title="一、java异常"></a>一、java异常</h2><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p><a id="more"></a><p>Java异常类层次结构图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxn0cvo74j31100lg3zm.jpg" alt=""></p><p> 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p><h3 id="1-1-Exception（异常）和-Error（错误）"><a href="#1-1-Exception（异常）和-Error（错误）" class="headerlink" title="1.1 Exception（异常）和 Error（错误）"></a>1.1 Exception（异常）和 Error（错误）</h3><ul><li>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。<ul><li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li><li>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</li></ul></li></ul><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p><h3 id="1-2-可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）"><a href="#1-2-可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）" class="headerlink" title="1.2 可查异常（checked exceptions）和不可查异常（unchecked exceptions）"></a>1.2 可查异常（checked exceptions）和不可查异常（unchecked exceptions）</h3><p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p><blockquote><p>可查异常（编译器要求必须处置的异常）：</p></blockquote><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><blockquote><p>不可查异常(编译器不要求强制处置的异常):</p></blockquote><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h3 id="1-3-运行时异常和非运行时异常"><a href="#1-3-运行时异常和非运行时异常" class="headerlink" title="1.3 运行时异常和非运行时异常"></a>1.3 运行时异常和非运行时异常</h3><p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p><blockquote><p>运行时异常：</p></blockquote><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><blockquote><p>非运行时异常 （编译异常）：</p></blockquote><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h2 id="二、处理异常机制"><a href="#二、处理异常机制" class="headerlink" title="二、处理异常机制"></a>二、处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><blockquote><p>抛出异常：</p></blockquote><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p><blockquote><p>捕获异常：</p></blockquote><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><p>对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p><p>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p><p>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p><p>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p><p>能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</p><p>从方法中抛出的任何异常都必须使用throws子句。</p><p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p><p>总体来说，Java规定，对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p><h3 id="2-1-捕获异常：try、catch和finally"><a href="#2-1-捕获异常：try、catch和finally" class="headerlink" title="2.1 捕获异常：try、catch和finally"></a>2.1 捕获异常：try、catch和finally</h3><h4 id="2-1-1-try-catch语句"><a href="#2-1-1-try-catch语句" class="headerlink" title="2.1.1 try-catch语句"></a>2.1.1 try-catch语句</h4><p>在Java中，异常通过try-catch语句捕获。其一般语法形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">    // 可能会发生异常的程序代码  </div><div class="line">&#125; catch (Type1 id1)&#123;  </div><div class="line">    // 捕获并处置try抛出的异常类型Type1  </div><div class="line">&#125;  </div><div class="line">catch (Type2 id2)&#123;  </div><div class="line">     //捕获并处置try抛出的异常类型Type2  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关键词try后的一对大括号将一块可能发生异常的代码包起来，称为监控区域。Java方法在运行过程中出现异常，则创建异常对象。将异常抛出监控区域之 外，由Java运行时系统试图寻找匹配的catch子句以捕获异常。若有匹配的catch子句，则运行其异常处理代码，try-catch语句结束。</p><p>匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。</p><blockquote><p>例1  捕捉throw语句抛出的“除数为0”异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int a = 6;  </div><div class="line">        int b = 0;  </div><div class="line">        try &#123; // try监控区域  </div><div class="line">              </div><div class="line">            if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出异常  </div><div class="line">            System.out.println(&quot;a/b的值是：&quot; + a / b);  </div><div class="line">        &#125;  </div><div class="line">        catch (ArithmeticException e) &#123; // catch捕捉异常  </div><div class="line">            System.out.println(&quot;程序出现异常，变量b不能为0。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序出现异常，变量b不能为0。</div><div class="line">程序正常结束。</div></pre></td></tr></table></figure><p>在try监控区域通过if语句进行判断，当“除数为0”的错误条件成立时引发ArithmeticException异常，创建 ArithmeticException异常对象，并由throw语句将异常抛给Java运行时系统，由系统寻找匹配的异常处理器catch并运行相应异 常处理代码，打印输出“程序出现异常，变量b不能为0。”try-catch语句结束，继续程序流程。</p><p>事实上，“除数为0”等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。</p><blockquote><p>例2  捕捉运行时系统自动抛出“除数为0”引发的ArithmeticException异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">        int a = 6;  </div><div class="line">        int b = 0;  </div><div class="line">        try &#123;  </div><div class="line">            System.out.println(&quot;a/b的值是：&quot; + a / b);  </div><div class="line">        &#125; catch (ArithmeticException e) &#123;  </div><div class="line">            System.out.println(&quot;程序出现异常，变量b不能为0。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序出现异常，变量b不能为0。</div><div class="line">                  程序正常结束。</div></pre></td></tr></table></figure><p>例2中的语句System.out.println(“a/b的值是：” + a/b);在运行中出现“除数为0”错误，引发ArithmeticException异常。运行时系统创建异常对象并抛出监控区域，转而匹配合适的异常处理器catch，并执行相应的异常处理代码。由于检查运行时异常的代价远大于捕捉异常所带来的益处，运行时异常不可查。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。</p><blockquote><p>例3  不捕捉、也不声明抛出运行时异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int a, b;  </div><div class="line">        a = 6;  </div><div class="line">        b = 0; // 除数b 的值为0  </div><div class="line">        System.out.println(a / b);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</div><div class="line">at Test.TestException.main(TestException.java:8)</div></pre></td></tr></table></figure><blockquote><p>例4  程序可能存在除数为0异常和数组下标越界异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int[] intArray = new int[3];  </div><div class="line">        try &#123;  </div><div class="line">            for (int i = 0; i &lt;= intArray.length; i++) &#123;  </div><div class="line">                intArray[i] = i;  </div><div class="line">                System.out.println(&quot;intArray[&quot; + i + &quot;] = &quot; + intArray[i]);  </div><div class="line">                System.out.println(&quot;intArray[&quot; + i + &quot;]模 &quot; + (i - 2) + &quot;的值:  &quot;  </div><div class="line">                        + intArray[i] % (i - 2));  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;  </div><div class="line">            System.out.println(&quot;intArray数组下标越界异常。&quot;);  </div><div class="line">        &#125; catch (ArithmeticException e) &#123;  </div><div class="line">            System.out.println(&quot;除数为0异常。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">intArray[0] = 0</div><div class="line">intArray[0]模 -2的值:  0</div><div class="line">intArray[1] = 1</div><div class="line">intArray[1]模 -1的值:  0</div><div class="line">intArray[2] = 2</div><div class="line">除数为0异常。</div><div class="line">程序正常结束。</div></pre></td></tr></table></figure><p>例4中程序可能会出现除数为0异常，还可能会出现数组下标越界异常。程序运行过程中ArithmeticException异常类型是先行匹配的，因此执行相匹配的catch语句：</p><figure class="highlight plain"><figcaption><span>(ArithmeticException e)&#123;  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     System.out.println(&quot;除数为0异常。&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p><p>Java通过异常类描述异常类型，异常类的层次结构如图1所示。对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</p><p>RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</p><h4 id="2-1-2-try-catch-finally语句"><a href="#2-1-2-try-catch-finally语句" class="headerlink" title="2.1.2 try-catch-finally语句"></a>2.1.2 try-catch-finally语句</h4><p> try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。try-catch-finally语句的一般语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">    // 可能会发生异常的程序代码  </div><div class="line">&#125; catch (Type1 id1) &#123;  </div><div class="line">    // 捕获并处理try抛出的异常类型Type1  </div><div class="line">&#125; catch (Type2 id2) &#123;  </div><div class="line">    // 捕获并处理try抛出的异常类型Type2  </div><div class="line">&#125; finally &#123;  </div><div class="line">    // 无论是否发生异常，都将执行的语句块  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>例5  带finally子句的异常处理程序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String args[]) &#123;  </div><div class="line">        int i = 0;  </div><div class="line">        String greetings[] = &#123; &quot; Hello world !&quot;, &quot; Hello World !! &quot;,  </div><div class="line">                &quot; HELLO WORLD !!!&quot; &#125;;  </div><div class="line">        while (i &lt; 4) &#123;  </div><div class="line">            try &#123;  </div><div class="line">                // 特别注意循环控制变量i的设计，避免造成无限循环  </div><div class="line">                System.out.println(greetings[i++]);  </div><div class="line">            &#125; catch (ArrayIndexOutOfBoundsException e) &#123;  </div><div class="line">                System.out.println(&quot;数组下标越界异常&quot;);  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                System.out.println(&quot;--------------------------&quot;);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hello world !</div><div class="line">--------------------------</div><div class="line">Hello World !!</div><div class="line">--------------------------</div><div class="line">HELLO WORLD !!!</div><div class="line">--------------------------</div><div class="line">数组下标越界异常</div><div class="line">--------------------------</div></pre></td></tr></table></figure></p><pre><code> 在例5中，请特别注意try子句中语句块的设计，如果设计为如下，将会出现死循环。如果设计为：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">      System.out.println (greetings[i]); i++;  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">小结：</div><div class="line"></div><div class="line">try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</div><div class="line">catch 块：用于处理try捕获到的异常。</div><div class="line">finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将</div><div class="line">在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：</div><div class="line"></div><div class="line">1. 在finally语句块中发生了异常。</div><div class="line">2. 在前面的代码中用了System.exit()退出程序。</div><div class="line">3. 程序所在的线程死亡。</div><div class="line">4. 关闭CPU。</div><div class="line"></div><div class="line">#### 2.1.3 try-catch-finally 规则</div><div class="line"></div><div class="line">1. 必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</div><div class="line">2. 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</div><div class="line">3. catch 块与相应的异常类的类型相关。</div><div class="line">4. 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</div><div class="line">5. 可嵌套 try-catch-finally 结构。</div><div class="line">6. 在 try-catch-finally 结构中，可重新抛出异常。</div><div class="line">7. 除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。</div><div class="line"></div><div class="line">#### 2.1.4 try、catch、finally语句块的执行顺序</div><div class="line"></div><div class="line"></div><div class="line">1. 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</div><div class="line"></div><div class="line">2. 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</div><div class="line"></div><div class="line">3. 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 2.2 抛出异常</div><div class="line">任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</div><div class="line"></div><div class="line">#### 2.2.1 throws抛出异常</div><div class="line"></div><div class="line">如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理。</div><div class="line"></div><div class="line">throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：</div></pre></td></tr></table></figure><p>methodname throws Exception1,Exception2,..,ExceptionN<br>                    {<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">方法名后的throws Exception1,Exception2,...,ExceptionN 为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。例如：</div></pre></td></tr></table></figure></p><p>import java.lang.Exception;<br>public class TestException {<br>    static void pop() throws NegativeArraySizeException {<br>        // 定义方法并抛出NegativeArraySizeException异常<br>        int[] arr = new int[-3]; // 创建数组<br>    }  </p><pre><code>public static void main(String[] args) { // 主方法      try { // try语句处理异常信息          pop(); // 调用pop()方法      } catch (NegativeArraySizeException e) {          System.out.println(&quot;pop()方法抛出的异常&quot;);// 输出异常信息      }  }  </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。 pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。</div><div class="line"></div><div class="line"> Throws抛出异常的规则：</div><div class="line"></div><div class="line">1. 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</div><div class="line">2. 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</div><div class="line">3. 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</div><div class="line">4. 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</div><div class="line"></div><div class="line">例如：</div></pre></td></tr></table></figure></p><p>void method1() throws IOException{}  //合法    </p><p>//编译错误，必须捕获或声明抛出IOException<br>void method2(){<br>  method1();<br>}    </p><p>//合法，声明抛出IOException<br>void method3()throws IOException {<br>  method1();<br>}    </p><p>//合法，声明抛出Exception，IOException是Exception的子类<br>void method4()throws Exception {<br>  method1();<br>}    </p><p>//合法，捕获IOException<br>void method5(){<br> try{<br>    method1();<br> }catch(IOException e){…}<br>}    </p><p>//编译错误，必须捕获或声明抛出Exception<br>void method6(){<br>  try{<br>    method1();<br>  }catch(IOException e){throw new Exception();}<br>}    </p><p>//合法，声明抛出Exception<br>void method7()throws Exception{<br> try{<br>  method1();<br> }catch(IOException e){throw new Exception();}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">判断一个方法可能会出现异常的依据如下：</div><div class="line"></div><div class="line">1. 方法中有throw语句。例如，以上method7()方法的catch代码块有throw语句。</div><div class="line">2. 调用了其他方法，其他方法用throws子句声明抛出某种异常。例如，method3()方法调用了method1()方法，method1()方法声明抛出IOException，因此，在method3()方法中可能会出现IOException。</div><div class="line"></div><div class="line"></div><div class="line">#### 2.2.2 throw抛出异常</div><div class="line"></div><div class="line">throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。</div><div class="line"></div><div class="line">我们知道，异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。该语句的语法格式为：</div></pre></td></tr></table></figure></p><p>throw new exceptionname;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如抛出一个IOException类的异常对象：</div></pre></td></tr></table></figure></p><p> throw new IOException;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：</div></pre></td></tr></table></figure></p><p>throw new String(“exception”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这是因为String 不是Throwable 类的子类。</div><div class="line"></div><div class="line">如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</div><div class="line"></div><div class="line">如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</div></pre></td></tr></table></figure></p><p>package Test;<br>import java.lang.Exception;<br>public class TestException {<br>    static int quotient(int x, int y) throws MyException { // 定义方法抛出异常<br>        if (y &lt; 0) { // 判断参数是否小于0<br>            throw new MyException(“除数不能是负数”); // 异常信息<br>        }<br>        return x/y; // 返回值<br>    }<br>    public static void main(String args[]) { // 主方法<br>        int  a =3;<br>        int  b =0;<br>        try { // try语句包含可能发生异常的语句<br>            int result = quotient(a, b); // 调用方法quotient()<br>        } catch (MyException e) { // 处理自定义异常<br>            System.out.println(e.getMessage()); // 输出异常信息<br>        } catch (ArithmeticException e) { // 处理ArithmeticException异常<br>            System.out.println(“除数不能为0”); // 输出提示信息<br>        } catch (Exception e) { // 处理其他异常<br>            System.out.println(“程序发生了其他的异常”); // 输出提示信息<br>        }<br>    }  </p><p>}<br>class MyException extends Exception { // 创建自定义异常类<br>    String message; // 定义String类型变量<br>    public MyException(String ErrorMessagr) { // 父类方法<br>        message = ErrorMessagr;<br>    }  </p><pre><code>public String getMessage() { // 覆盖getMessage()方法      return message;  }  </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 2.3 异常链</div><div class="line">&gt; 如果调用quotient(3,-1)</div><div class="line"></div><div class="line">将发生MyException异常，程序调转到catch (MyException e)代码块中执行；</div><div class="line">&gt; 如果调用quotient(5,0)</div><div class="line"></div><div class="line">将会因“除数为0”错误引发ArithmeticException异常，属于运行时异常类，由Java运行时系统自动抛出。quotient（）方法没有捕捉ArithmeticException异常，Java运行时系统将沿方法调用栈查到main方法，将抛出的异常上传至quotient（）方法的调用者：</div></pre></td></tr></table></figure></p><p>int result = quotient(a, b); // 调用方法quotient()由于该语句在try监控区域内，因此传回的“除数为0”的ArithmeticException异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由Java运行时系统抛出，并匹配catch子句：</div></pre></td></tr></table></figure></p><p>catch (ArithmeticException e) { // 处理ArithmeticException异常<br>System.out.println(“除数不能为0”); // 输出提示信息<br>}<br>```</p><p>处理结果是输出“除数不能为0”。Java这种向上传递异常信息的处理机制，形成异常链。</p><p>Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。</p><blockquote><p>如还有其他异常发生</p></blockquote><p>将使用catch (Exception e)捕捉异常。由于Exception是所有异常类的父类，如果将catch (Exception e)代码块放在其他两个代码块的前面，后面的代码块将永远得不到执行，就没有什么意义了，所以catch语句的顺序不可掉换。</p><h3 id="2-4-Throwable类中的常用方法"><a href="#2-4-Throwable类中的常用方法" class="headerlink" title="2.4 Throwable类中的常用方法"></a>2.4 Throwable类中的常用方法</h3><p>注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:</p><ul><li>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</li><li>getMeage()：返回异常的消息信息。</li><li>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</li></ul><p>有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</p><h2 id="三、Java常见异常"><a href="#三、Java常见异常" class="headerlink" title="三、Java常见异常"></a>三、Java常见异常</h2><p>  在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><h3 id="3-1-runtimeException子类"><a href="#3-1-runtimeException子类" class="headerlink" title="3.1 runtimeException子类:"></a>3.1 runtimeException子类:</h3><ul><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException：数组长度为负异常</li><li>java.lang.ArrayStoreException：数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException：安全性异常</li><li>java.lang.IllegalArgumentException：非法参数异常</li></ul><h3 id="3-2-IOException"><a href="#3-2-IOException" class="headerlink" title="3.2 IOException"></a>3.2 IOException</h3><ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException：文件已结束异常</li><li>FileNotFoundException ：文件未找到异常<h3 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h3></li><li>ClassCastException：类型转换异常类</li><li>ArrayStoreException：数组中包含不兼容的值抛出的异常</li><li>SQLException：操作数据库异常类</li><li>NoSuchFieldException：字段未找到异常</li><li>NoSuchMethodException：方法未找到抛出的异常</li><li>NumberFormatException：字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException：字符串索引超出范围抛出的异常</li><li>IllegalAccessException：不允许访问某类异常</li><li>InstantiationException：当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul><h2 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h2><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤。</p><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、java异常&quot;&gt;&lt;a href=&quot;#一、java异常&quot; class=&quot;headerlink&quot; title=&quot;一、java异常&quot;&gt;&lt;/a&gt;一、java异常&lt;/h2&gt;&lt;p&gt;异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（6）：异常处理</title>
    <link href="http://yoursite.com/2017/08/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/25/Java学习笔记（6）：异常处理/</id>
    <published>2017-08-25T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、异常处理基础"><a href="#一、异常处理基础" class="headerlink" title="一、异常处理基础"></a>一、异常处理基础</h1><p>Java异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（catch）并处理。异常可能是由Java运行时系统产生，或者是由你的手工代码产生。被Java抛出的异常与违反语言规范或超出Java执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。</p><a id="more"></a><p>Java异常处理通过5个关键字控制：try、catch、throw、throws和 finally。下面讲述它们如何工作的。程序声明了你想要的异常监控包含在一个try块中。如果在try块中发生异常，它被抛出。你的代码可以捕捉这个异常（用catch）并且用某种合理的方法处理该异常。系统产生的异常被Java运行时系统自动抛出。手动抛出一个异常，用关键字throw。任何被抛出方法的异常都必须通过throws子句定义。任何在方法返回前绝对被执行的代码被放置在finally块中。</p><p>下面是一个异常处理块的通常形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    // block of code to monitor for errors</div><div class="line">&#125;</div><div class="line">catch (ExceptionType1 exOb) &#123;</div><div class="line">    // exception handler for ExceptionType1</div><div class="line">&#125;</div><div class="line">catch (ExceptionType2 exOb) &#123;</div><div class="line">    // exception handler for ExceptionType2</div><div class="line">&#125;</div><div class="line">// ...</div><div class="line">finally &#123;</div><div class="line">    // block of code to be executed before try block ends</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里，ExceptionType 是发生异常的类型。下面将介绍怎样应用这个框架。</p><h1 id="二、异常类型"><a href="#二、异常类型" class="headerlink" title="二、异常类型"></a>二、异常类型</h1><p>所有异常类型都是内置类Throwable的子类。因此，Throwable在异常类层次结构的顶层。紧接着Throwable下面的是两个把异常分成两个不同分支的子类。一个分支是Exception。该类用于用户程序可能捕捉的异常情况。它也是你可以用来创建你自己用户异常类型子类的类。在Exception分支中有一个重要子类RuntimeException。该类型的异常自动为你所编写的程序定义并且包括被零除和非法数组索引这样的错误。</p><p>另一类分支由Error作为顶层，Error定义了在通常环境下不希望被程序捕获的异常。Error类型的异常用于Java运行时系统来显示与运行时系统本身有关的错误。堆栈溢出是这种错误的一例。本章将不讨论关于Error类型的异常处理，因为它们通常是灾难性的致命错误，不是你的程序可以控制的。</p><h1 id="三、未被捕获的异常"><a href="#三、未被捕获的异常" class="headerlink" title="三、未被捕获的异常"></a>三、未被捕获的异常</h1><p>在你学习在程序中处理异常之前，看一看如果你不处理它们会有什么情况发生是很有好处的。下面的小程序包括一个故意导致被零除错误的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Exc0 &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int d = 0;</div><div class="line">        int a = 42 / d;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当Java运行时系统检查到被零除的情况，它构造一个新的异常对象然后抛出该异常。这导致Exc0的执行停止，因为一旦一个异常被抛出，它必须被一个异常处理程序捕获并且被立即处理。该例中，我们没有提供任何我们自己的异常处理程序，所以异常被Java运行时系统的默认处理程序捕获。任何不是被你程序捕获的异常最终都会被该默认处理程序处理。默认处理程序显示一个描述异常的字符串，打印异常发生处的堆栈轨迹并且终止程序。</p><p>下面是由标准javaJDK运行时解释器执行该程序所产生的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.ArithmeticException: / by zero</div><div class="line">at Exc0.main(Exc0.java:4)</div></pre></td></tr></table></figure><p>注意，类名Exc0，方法名main，文件名Exc0.java和行数4是怎样被包括在一个简单的堆栈使用轨迹中的。还有，注意抛出的异常类型是Exception的一个名为ArithmeticException的子类，该子类更明确的描述了何种类型的错误方法。本章后面部分将讨论，Java提供多个内置的与可能产生的不同种类运行时错误相匹配的异常类型。</p><p>堆栈轨迹将显示导致错误产生的方法调用序列。例如，下面是前面程序的另一个版本，它介绍了相同的错误，但是错误是在main( )方法之外的另一个方法中产生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    static void subroutine() &#123;</div><div class="line">        int d = 0;</div><div class="line">        int a = 10 / d;</div><div class="line">    &#125;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        Exc1.subroutine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认异常处理器的堆栈轨迹结果表明了整个调用栈是怎样显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.ArithmeticException: / by zero</div><div class="line">at Exc1.subroutine(Exc1.java:4)</div><div class="line">at Exc1.main(Exc1.java:7)</div></pre></td></tr></table></figure><p>如你所见，栈底是main的第7行，该行调用了subroutine( )方法。该方法在第4行导致了异常。调用堆栈对于调试来说是很重要的，因为它查明了导致错误的精确的步骤。</p><h1 id="四、try和catch的使用"><a href="#四、try和catch的使用" class="headerlink" title="四、try和catch的使用"></a>四、try和catch的使用</h1><p>尽管由Java运行时系统提供的默认异常处理程序对于调试是很有用的，但通常你希望自己处理异常。这样做有两个好处。第一，它允许你修正错误。第二，它防止程序自动终止。大多数用户对于在程序终止运行和在无论何时错误发生都会打印堆栈轨迹感到很烦恼（至少可以这么说）。幸运的是，这很容易避免。为防止和处理一个运行时错误，只需要把你所要监控的代码放进一个try块就可以了。紧跟着try块的，包括一个说明你希望捕获的错误类型的catch子句。完成这个任务很简单，下面的程序包含一个处理因为被零除而产生的ArithmeticException 异常的try块和一个catch子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int d, a;</div><div class="line">        try &#123; // monitor a block of code.</div><div class="line">            d = 0;</div><div class="line">            a = 42 / d;</div><div class="line">            System.out.println(&quot;This will not be printed.&quot;);</div><div class="line">        &#125; catch (ArithmeticException e) &#123; // catch divide-by-zero error</div><div class="line">            System.out.println(&quot;Division by zero.&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;After catch statement.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Division by zero.</div><div class="line">After catch statement.</div></pre></td></tr></table></figure><p>注意在try块中的对println( )的调用是永远不会执行的。一旦异常被引发，程序控制由try块转到catch块。执行永远不会从catch块“返回”到try块。因此，“This will not be printed。”将不会被显示。一旦执行了catch语句，程序控制从整个try/catch机制的下面一行继续。</p><p>一个try和它的catch语句形成了一个单元。catch子句的范围限制于try语句前面所定义的语句。一个catch语句不能捕获另一个try声明所引发的异常（除非是嵌套的try语句情况）。</p><p>被try保护的语句声明必须在一个大括号之内（也就是说，它们必须在一个块中）。你不能单独使用try。</p><p>构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。例如，下面的程序中，每一个for循环的反复得到两个随机整数。这两个整数分别被对方除，结果用来除12345。最后的结果存在a中。如果一个除法操作导致被零除错误，它将被捕获，a的值设为零，程序继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//Handle an exception and move on.</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int a=0, b=0, c=0;</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        for(int i=0; i&lt;30; i++) &#123;</div><div class="line">            try &#123;</div><div class="line">                b = r.nextInt();</div><div class="line">                c = r.nextInt();</div><div class="line">                a = 12345 / (b/c);</div><div class="line">            &#125; catch (ArithmeticException e) &#123;</div><div class="line">                System.out.println(&quot;Division by zero.&quot;);</div><div class="line">                a = 0; // set a to zero and continue</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;a: &quot; + a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Throwable重载toString( )方法（由Object定义），所以它返回一个包含异常描述的字符串。你可以通过在println( )中传给异常一个参数来显示该异常的描述。例如，前面程序的catch块可以被重写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//Handle an exception and move on.</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int a=0, b=0, c=0;</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        for(int i=0; i&lt;30; i++) &#123;</div><div class="line">            try &#123;</div><div class="line">                b = r.nextInt();</div><div class="line">                c = r.nextInt();</div><div class="line">                a = 12345 / (b/c);</div><div class="line">            &#125; catch (ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Exception: &quot; + e);</div><div class="line">            a = 0; // set a to zero and continue</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;a: &quot; + a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当这个版本代替原程序中的版本，程序在标准javaJDK解释器下运行，每一个被零除错误显示下面的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception: java.lang.ArithmeticException: / by zero</div></pre></td></tr></table></figure><p>尽管在上下文中没有特殊的值，显示一个异常描述的能力在其他情况下是很有价值的——特别是当你对异常进行实验和调试时。</p><h1 id="五、多重catch语句的使用"><a href="#五、多重catch语句的使用" class="headerlink" title="五、多重catch语句的使用"></a>五、多重catch语句的使用</h1><p>某些情况，由单个代码段可能引起多个异常。处理这种情况，你可以定义两个或更多的catch子句，每个子句捕获一种类型的异常。当异常被引发时，每一个catch子句被依次检查，第一个匹配异常类型的子句执行。当一个catch语句执行以后，其他的子句被旁路，执行从try/catch块以后的代码开始继续。下面的例子设计了两种不同的异常类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//Demonstrate multiple catch statements.</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">            System.out.println(&quot;a = &quot; + a);</div><div class="line">            int b = 42 / a;</div><div class="line">            int c[] = &#123; 1 &#125;;</div><div class="line">            c[42] = 99;</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">            System.out.println(&quot;Array index oob: &quot; + e);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;After try/catch blocks.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序在没有命令行参数的起始条件下运行导致被零除异常，因为a为0。如果你提供一个命令行参数，它将幸免于难，把a设成大于零的数值。但是它将导致ArrayIndexOutOf BoundsException异常，因为整型数组c的长度为1，而程序试图给c[42]赋值。下面是运行在两种不同情况下程序的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\&gt;java MultiCatch</div><div class="line">a = 0</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero After try/catch blocks.</div><div class="line">C:\&gt;java MultiCatch TestArg</div><div class="line">a = 1</div><div class="line">Array index oob: java.lang.ArrayIndexOutOfBoundsException After try/catch blocks.</div></pre></td></tr></table></figure><p>当你用多catch语句时，记住异常子类必须在它们任何父类之前使用是很重要的。这是因为运用父类的catch语句将捕获该类型及其所有子类类型的异常。这样，如果子类在父类后面，子类将永远不会到达。而且，Java中不能到达的代码是一个错误。例如，考虑下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//This program contains an error.</div><div class="line">//A subclass must come before its superclass in a series of catch statements. If not,unreachable code will be created and acompile-time error will result.</div><div class="line">//*/</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = 0;</div><div class="line">            int b = 42 / a;</div><div class="line">        &#125; catch(Exception e) &#123;</div><div class="line">            System.out.println(&quot;Generic Exception catch.&quot;);</div><div class="line">        &#125;</div><div class="line">        /* This catch is never reached because</div><div class="line">        ArithmeticException is a subclass of Exception. */</div><div class="line">        catch(ArithmeticException e) &#123; // ERROR - unreachable</div><div class="line">            System.out.println(&quot;This is never reached.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你试着编译该程序，你会收到一个错误消息，该错误消息说明第二个catch语句不会到达，因为该异常已经被捕获。因为ArithmeticException 是Exception的子类，第一个catch语句将处理所有的面向Exception的错误，包括ArithmeticException。这意味着第二个catch语句永远不会执行。为修改程序，颠倒两个catch语句的次序。</p><h1 id="六、try语句的嵌套"><a href="#六、try语句的嵌套" class="headerlink" title="六、try语句的嵌套"></a>六、try语句的嵌套</h1><p>Try语句可以被嵌套。也就是说，一个try语句可以在另一个try块内部。每次进入try语句，异常的前后关系都会被推入堆栈。如果一个内部的try语句不含特殊异常的catch处理程序，堆栈将弹出，下一个try语句的catch处理程序将检查是否与之匹配。这个过程将继续直到一个catch语句匹配成功，或者是直到所有的嵌套try语句被检查耗尽。如果没有catch语句匹配，Java的运行时系统将处理这个异常。下面是运用嵌套try语句的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//An example of nested try statements.</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">            /* If no command-line args are present,the following statement will generate a divide-by-zero exception. */</div><div class="line">            int b = 42 / a;</div><div class="line">            System.out.println(&quot;a = &quot; + a);</div><div class="line">            try &#123; // nested try block</div><div class="line">                /* If one command-line arg is used,then a divide-by-zero exception will be generated by the following code. */</div><div class="line">                if(a==1) a = a/(a-a); // division by zero</div><div class="line">                /* If two command-line args are used,then generate an out-of-bounds exception. */</div><div class="line">                if(a==2) &#123;</div><div class="line">                    int c[] = &#123; 1 &#125;;</div><div class="line">                    c[42] = 99; // generate an out-of-bounds exception</div><div class="line">                &#125;</div><div class="line">            &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">                System.out.println(&quot;Array index out-of-bounds: &quot; + e);</div><div class="line">            &#125;</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如你所见，该程序在一个try块中嵌套了另一个try块。程序工作如下：当你在没有命令行参数的情况下执行该程序，外面的try块将产生一个被零除的异常。程序在有一个命令行参数条件下执行，由嵌套的try块产生一个被零除的错误。因为内部的块不匹配这个异常，它将把异常传给外部的try块，在那里异常被处理。如果你在具有两个命令行参数的条件下执行该程序，由内部try块产生一个数组边界异常。下面的结果阐述了每一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">C:\&gt;java NestTry</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero</div><div class="line">C:\&gt;java NestTry One</div><div class="line">a = 1</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero</div><div class="line">C:\&gt;java NestTry One Two</div><div class="line">a = 2</div><div class="line">Array index out-of-bounds: java.lang.ArrayIndexOutOfBoundsException</div></pre></td></tr></table></figure><p>当有方法调用时，try语句的嵌套可以很隐蔽的发生。例如，你可以把对方法的调用放在一个try块中。在该方法内部，有另一个try语句。这种情况下，方法内部的try仍然是嵌套在外部调用该方法的try块中的。下面是前面例子的修改，嵌套的try块移到了方法nesttry( )的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//Try statements can be implicitly nested via calls to methods. */</div><div class="line">class Demo &#123;</div><div class="line">    static void nesttry(int a) &#123;</div><div class="line">        try &#123; // nested try block</div><div class="line">            /* If one command-line arg is used,then a divide-by-zero exception will be generated by the following code. */</div><div class="line">            if(a==1) a = a/(a-a); // division by zero</div><div class="line">            /* If two command-line args are used,then generate an out-of-bounds exception. */</div><div class="line">            if(a==2) &#123;</div><div class="line">                int c[] = &#123; 1 &#125;;</div><div class="line">                c[42] = 99; // generate an out-of-bounds exception</div><div class="line">            &#125;</div><div class="line">        &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">            System.out.println(&quot;Array index out-of-bounds: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">           /* If no command-line args are present,the following statement will generate a divide-by-zero exception. */</div><div class="line">           int b = 42 / a;</div><div class="line">           System.out.println(&quot;a = &quot; + a);</div><div class="line">           nesttry(a);</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序的输出与前面的例子相同。</p><h1 id="八、throws子句"><a href="#八、throws子句" class="headerlink" title="八、throws子句"></a>八、throws子句</h1><p>如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。做到这点你可以在方法声明中包含一个throws子句。一个 throws 子句列举了一个方法可能抛出的所有异常类型。这对于除Error或RuntimeException及它们子类以外类型的所有异常是必要的。一个方法可以抛出的所有其他类型的异常必须在throws子句中声明。如果不这样做，将会导致编译错误。</p><p>下面是包含一个throws子句的方法声明的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type method-name(parameter-list) throws exception-list&#123;</div><div class="line">    // body of method</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里，exception-list是该方法可以抛出的以有逗号分割的异常列表。</p><p>下面是一个不正确的例子。该例试图抛出一个它不能捕获的异常。因为程序没有指定一个throws子句来声明这一事实，程序将不会编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//this program contains an error and will not compile.</div><div class="line">class ThrowsDemo &#123;</div><div class="line">    static void throwOne() &#123;</div><div class="line">        System.out.println(&quot;Inside throwOne.&quot;);</div><div class="line">        throw new IllegalAccessException(&quot;demo&quot;);</div><div class="line">    &#125;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        throwOne();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为编译该程序，需要改变两个地方。第一，需要声明throwOne( )引发IllegalAccess Exception异常。第二，main( )必须定义一个try/catch 语句来捕获该异常。正确的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//This is now correct.</div><div class="line">class Demo &#123;</div><div class="line">    static void throwOne() throws IllegalAccessException &#123;</div><div class="line">      System.out.println(&quot;Inside throwOne.&quot;);</div><div class="line">      throw new IllegalAccessException(&quot;demo&quot;);</div><div class="line">   &#125;</div><div class="line">   public static void main(String args[]) &#123;</div><div class="line">      try &#123;</div><div class="line">         throwOne();</div><div class="line">      &#125; catch (IllegalAccessException e) &#123;</div><div class="line">         System.out.println(&quot;Caught &quot; + e);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是例题的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inside throwOne</div><div class="line">caught java.lang.IllegalAccessException: demo</div></pre></td></tr></table></figure><h1 id="九、finally块"><a href="#九、finally块" class="headerlink" title="九、finally块"></a>九、finally块</h1><p>当异常被抛出，通常方法的执行将作一个陡峭的非线性的转向。依赖于方法是怎样编码的，异常甚至可以导致方法过早返回。这在一些方法中是一个问题。例如，如果一个方法打开一个文件项并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。finally关键字为处理这种意外而设计。finally创建一个代码块。该代码块在一个try/catch 块完成之后另一个try/catch出现之前执行。finally块无论有没有异常抛出都会执行。如果异常被抛出，finally甚至是在没有与该异常相匹配的catch子句情况下也将执行。一个方法将从一个try/catch块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句，finally子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时被分配的其他资源是很有用的。finally子句是可选项，可以有也可以无。然而每一个try语句至少需要一个catch或finally子句。</p><p>下面的例子显示了3种不同的退出方法。每一个都执行了finally子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Demonstrate finally.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="comment">// Through an exception out of the method.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procA"</span>);</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"demo"</span>);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procA's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Return from within a try block.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procB"</span>);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procB's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Execute a try block normally.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procC"</span>);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procC's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">          procA();</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          System.out.println(<span class="string">"Exception caught"</span>);</div><div class="line">       &#125;</div><div class="line">       procB();</div><div class="line">       procC();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该例中，procA( )过早地通过抛出一个异常中断了try。Finally子句在退出时执行。procB( )的try语句通过一个return语句退出。在procB( )返回之前finally子句执行。在procC（）中，try语句正常执行，没有错误。然而，finally块仍将执行。</p><p>注意：如果finally块与一个try联合使用，finally块将在try结束之前执行。</p><p>下面是上述程序产生的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">inside procA</div><div class="line">procA’s finally</div><div class="line">Exception caught</div><div class="line">inside procB</div><div class="line">procB’s finally</div><div class="line">inside procC</div><div class="line">procC’s finally</div></pre></td></tr></table></figure><h1 id="十、内置异常"><a href="#十、内置异常" class="headerlink" title="十、内置异常"></a>十、内置异常</h1><p>在标准包java.lang中，Java定义了若干个异常类。前面的例子曾用到其中一些。这些异常一般是标准类RuntimeException的子类。因为java.lang实际上被所有的Java程序引入，多数从RuntimeException派生的异常都自动可用。而且，它们不需要被包含在任何方法的throws列表中。Java语言中，这被叫做未经检查的异常（unchecked exceptions ）。因为编译器不检查它来看一个方法是否处理或抛出了这些异常。 java.lang中定义的未经检查的异常列于表10-1。表10-2列出了由 java.lang定义的必须在方法的throws列表中包括的异常，如果这些方法能产生其中的某个异常但是不能自己处理它。这些叫做受检查的异常（checked exceptions）。Java定义了几种与不同类库相关的其他的异常类型。</p><blockquote><p>Java 的 java.lang 中定义的未检查异常子类</p></blockquote><div class="table-container"><table><thead><tr><th>异常</th><th>说明</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>算术错误，如被0除</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标出界</td></tr><tr><td>ArrayStoreException</td><td>数组元素赋值类型不兼容</td></tr><tr><td>ClassCastException</td><td>非法强制转换类型</td></tr><tr><td>IllegalArgumentException</td><td>调用方法的参数非法</td></tr><tr><td>IllegalMonitorStateException</td><td>非法监控操作，如等待一个未锁定线程</td></tr><tr><td>IllegalStateException</td><td>环境或应用状态不正确</td></tr><tr><td>IllegalThreadStateException</td><td>请求操作与当前线程状态不兼容</td></tr><tr><td>IndexOutOfBoundsException</td><td>某些类型索引越界</td></tr><tr><td>NullPointerException</td><td>非法使用空引用</td></tr><tr><td>NumberFormatException</td><td>字符串到数字格式非法转换</td></tr><tr><td>SecurityException</td><td>试图违反安全性</td></tr><tr><td>StringIndexOutOfBounds</td><td>试图在字符串边界之外索引</td></tr><tr><td>UnsupportedOperationException</td><td>遇到不支持的操作</td></tr></tbody></table></div><blockquote><p> java.lang 中定义的检查异常</p></blockquote><div class="table-container"><table><thead><tr><th>异常</th><th>意义</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>找不到类</td></tr><tr><td>CloneNotSupportedException</td><td>试图克隆一个不能实现Cloneable接口的对象</td></tr><tr><td>IllegalAccessException</td><td>对一个类的访问被拒绝</td></tr><tr><td>InstantiationException</td><td>试图创建一个抽象类或者抽象接口的对象</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断</td></tr><tr><td>NoSuchFieldException</td><td>请求的字段不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table></div><h1 id="十一、创建自己的异常子类"><a href="#十一、创建自己的异常子类" class="headerlink" title="十一、创建自己的异常子类"></a>十一、创建自己的异常子类</h1><p>尽管Java的内置异常处理大多数常见错误，你也许希望建立你自己的异常类型来处理你所应用的特殊情况。这是非常简单的：只要定义Exception的一个子类就可以了（Exception当然是Throwable的一个子类）。你的子类不需要实际执行什么——它们在类型系统中的存在允许你把它们当成异常使用。Exception类自己没有定义任何方法。当然，它继承了Throwable提供的一些方法。因此，所有异常，包括你创建的，都可以获得Throwable定义的方法。这些方法显示在表10-3中。你还可以在你创建的异常类中覆盖一个或多个这样的方法。</p><blockquote><p>Throwable 定义的方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Throwable fillInStackTrace( )</td><td>返回一个包含完整堆栈轨迹的Throwable对象，该对象可能被再次引发。</td></tr><tr><td>String getLocalizedMessage( )</td><td>返回一个异常的局部描述</td></tr><tr><td>String getMessage( )</td><td>返回一个异常的描述</td></tr><tr><td>void printStackTrace( )</td><td>显示堆栈轨迹</td></tr><tr><td>void printStackTrace(PrintStreamstream)</td><td>把堆栈轨迹送到指定的流</td></tr><tr><td>void printStackTrace(PrintWriterstream)</td><td>把堆栈轨迹送到指定的流</td></tr><tr><td>String toString( )</td><td>返回一个包含异常描述的String对象。当输出一个Throwable对象时，该方法被println( )调用</td></tr></tbody></table></div><p>下面的例子声明了Exception的一个新子类，然后该子类当作方法中出错情形的信号。它重载了toString( )方法，这样可以用println( )显示异常的描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//This program creates a custom exception type.</div><div class="line">class MyException extends Exception &#123;</div><div class="line">    private int detail;</div><div class="line">    MyException(int a) &#123;</div><div class="line">        detail = a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;MyException[&quot; + detail + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ExceptionDemo &#123;</div><div class="line">    static void compute(int a) throws MyException &#123;</div><div class="line">        System.out.println(&quot;Called compute(&quot; + a + &quot;)&quot;);</div><div class="line">       if(a &gt; 10)</div><div class="line">          throw new MyException(a);</div><div class="line">       System.out.println(&quot;Normal exit&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">       try &#123;</div><div class="line">           compute(1);</div><div class="line">           compute(20);</div><div class="line">        &#125; catch (MyException e) &#123;</div><div class="line">            System.out.println(&quot;Caught &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该例题定义了Exception的一个子类MyException。该子类非常简单：它只含有一个构造函数和一个重载的显示异常值的toString( )方法。ExceptionDemo类定义了一个compute( )方法。该方法抛出一个MyException对象。当compute( )的整型参数比10大时该异常被引发。</p><p>main( )方法为MyException设立了一个异常处理程序，然后用一个合法的值和不合法的值调用compute( )来显示执行经过代码的不同路径。下面是结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Called compute(1)</div><div class="line">Normal exit</div><div class="line">Called compute(20)</div><div class="line">Caught MyException[20]</div></pre></td></tr></table></figure><h1 id="十二、断言"><a href="#十二、断言" class="headerlink" title="十二、断言"></a>十二、断言</h1><p>断言用于证明和测试程序的假设，比如“这里的值大于 5”。<br>断言可以在运行时从代码中完全删除，所以对代码的运行速度没有影响。</p><p>断言有两种方法：</p><ul><li>一种是 assert&lt;&lt;布尔表达式&gt;&gt; ；</li><li>另一种是 assert&lt;&lt;布尔表达式&gt;&gt; ：&lt;&lt;细节描述&gt;&gt;。</li></ul><p>如果布尔表达式的值为false ， 将抛出AssertionError 异常； 细节描述是AssertionError异常的描述文本使用 javac –source 1.4 MyClass.java 的方式进行编译示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                x = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</div><div class="line">                <span class="comment">/* Ignore */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Testing assertion that x == 10"</span>);</div><div class="line">        <span class="keyword">assert</span> x == <span class="number">10</span> : <span class="string">"Our assertion failed"</span>;</div><div class="line">        System.out.println(<span class="string">"Test passed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于引入了一个新的关键字，所以在编译的时候就需要增加额外的参数，要编译成功，必须使用 JDK1.4 的 javac 并加上参数’-source 1.4′,例如可以使用以下的命令编译上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -source 1.4 AssertExample.java</div></pre></td></tr></table></figure><p>以上程序运行使用断言功能也需要使用额外的参数（并且需要一个数字的命令行参数），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -ea AssertExample 1</div></pre></td></tr></table></figure><p>程序的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Testing assertion that x == 10</div><div class="line">Exception in thread “main” java.lang.AssertionError:Our assertion failed</div><div class="line">at AssertExample.main(AssertExample.java:20)</div></pre></td></tr></table></figure><p>由于输入的参数不等于 10，因此断言功能使得程序运行时抛出断言错误，注意是错误， 这意味着程序发生严重错误并且将强制退出。断言使用 boolean 值，如果其值不为 true 则 抛出 AssertionError 并终止程序的运行。</p><p>断言推荐使用方法</p><p>用于验证方法中的内部逻辑，包括：</p><ul><li>内在不变式</li><li>控制流程不变式</li><li>后置条件和类不变式</li></ul><p>注意：不推荐用于公有方法内的前置条件的检查。</p><p>运行时要屏蔽断言，可以用如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java –disableassertions 或 java –da 类名</div></pre></td></tr></table></figure><p>运行时要允许断言，可以用如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java –enableassertions 或 java –ea类名</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、异常处理基础&quot;&gt;&lt;a href=&quot;#一、异常处理基础&quot; class=&quot;headerlink&quot; title=&quot;一、异常处理基础&quot;&gt;&lt;/a&gt;一、异常处理基础&lt;/h1&gt;&lt;p&gt;Java异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（catch）并处理。异常可能是由Java运行时系统产生，或者是由你的手工代码产生。被Java抛出的异常与违反语言规范或超出Java执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（5）：static、final关键字和Object类</title>
    <link href="http://yoursite.com/2017/08/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9Astatic%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CObject%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/08/24/Java学习笔记（5）：static、final关键字和Object类/</id>
    <published>2017-08-24T14:20:45.000Z</published>
    <updated>2018-11-05T16:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、static关键字"><a href="#一、static关键字" class="headerlink" title="一、static关键字"></a>一、static关键字</h1><p>static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。请看下面的例子：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    static int i = 10;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    Demo() &#123;</div><div class="line">        this.j = 20;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;类变量 i=&quot; + Demo.i);</div><div class="line">        Demo obj = new Demo();</div><div class="line">        System.out.println(&quot;实例变量 j=&quot; + obj.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">类变量 i=10</div><div class="line">实例变量 j=20</div></pre></td></tr></table></figure><h2 id="1-1-static的内存分配"><a href="#1-1-static的内存分配" class="headerlink" title="1.1 static的内存分配"></a>1.1 static的内存分配</h2><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存。实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响，改变 a 对象的实例变量不会影响 b 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</div><div class="line">        obj1.i = <span class="number">10</span>;</div><div class="line">        obj1.j = <span class="number">20</span>;</div><div class="line">       </div><div class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</div><div class="line">       </div><div class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</div><div class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1.i=10, obj1.j=20</div><div class="line">obj2.i=10, obj2.j=0</div></pre></td></tr></table></figure><p>注意：静态变量虽然也可以通过对象来访问，但是不被提倡，编译器也会产生警告。</p><p>上面的代码中，i 是静态变量，通过 obj1 改变 i 的值，会影响到 obj2；j 是实例变量，通过 obj1 改变 j 的值，不会影响到 obj2。这是因为 obj1.i 和 obj2.i 指向同一个内存空间，而 obj1.j 和 obj2.j 指向不同的内存空间，请看下图：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxn1tg594j307608w0sl.jpg" alt=""></p><p>注意：static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p><p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p><h2 id="1-2-静态方法"><a href="#1-2-静态方法" class="headerlink" title="1.2 静态方法"></a>1.2 静态方法</h2><p>静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow() 方法就是一个静态方法，语法为 Math.pow(x, a)，用来计算 x 的 a 次幂，在使用时无需创建任何 Math 对象。</p><p>因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。</p><p>以下情形可以使用静态方法：</p><ul><li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如 Math.pow()）。</li><li>一个方法只需要访问类的静态变量。</li></ul><p>读者肯定注意到，main() 也是一个静态方法，不对任何对象进行操作。实际上，在程序启动时还没有任何对象，main() 方法是程序的入口，将被执行并创建程序所需的对象。</p><p>关于静态变量和静态方法的总结：</p><ul><li>一个类的静态方法只能访问静态变量；</li><li>一个类的静态方法不能够直接调用非静态方法；</li><li>如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；</li><li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li><li>静态方法不能被非静态方法覆盖；</li><li>构造方法不允许声明为 static 的；</li><li>局部变量不能使用static修饰。</li></ul><p>静态方法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    static int sum(int x, int y)&#123;</div><div class="line">        return x + y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int sum = Demo.sum(10, 10);</div><div class="line">        System.out.println(&quot;10+10=&quot; + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10+10=20</div></pre></td></tr></table></figure><p>static 方法不需它所属的类的任何实例就会被调用，因此没有 this 值，不能访问实例变量，否则会引起编译错误。</p><p>注意：实例变量只能通过对象来访问，不能通过类访问。</p><h2 id="1-3-静态初始器（静态块）"><a href="#1-3-静态初始器（静态块）" class="headerlink" title="1.3 静态初始器（静态块）"></a>1.3 静态初始器（静态块）</h2><p>块是由大括号包围的一段代码。静态初始器(Static Initializer)是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static int i;</div><div class="line">    static&#123;</div><div class="line">        i = 10;</div><div class="line">        System.out.println(&quot;Now in static block.&quot;);</div><div class="line">    &#125;</div><div class="line">    public void test() &#123;</div><div class="line">        System.out.println(&quot;test method: i=&quot; + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;Demo.i=&quot; + Demo.i);</div><div class="line">        new Demo().test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Now in static block.</div><div class="line">Demo.i=10</div><div class="line">test method: i=10</div></pre></td></tr></table></figure><h2 id="1-4-静态导入"><a href="#1-4-静态导入" class="headerlink" title="1.4 静态导入"></a>1.4 静态导入</h2><p>静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。</p><p>一般我们导入类都这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import packageName.className;  // 导入某个特定的类</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import packageName.*;  // 导入包中的所有类</div></pre></td></tr></table></figure><p>而静态导入可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static packageName.className.methonName;  // 导入某个特定的静态方法</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static packageName.className.*;  // 导入类中的所有静态成员</div></pre></td></tr></table></figure><p>导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。</p><p>对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line">import static java.lang.Math.random;</div><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        out.println(&quot;产生的一个随机数：&quot; + random());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">产生的一个随机数：0.05800891549018705</div></pre></td></tr></table></figure><h1 id="二、final关键字"><a href="#二、final关键字" class="headerlink" title="二、final关键字"></a>二、final关键字</h1><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被子类重写。</li><li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li><li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li><li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li></ul><p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p><p>事实上，为确保终态性，提供了上述方法和常量的 java.lang.Math 类也已被定义为final 的。</p><p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p><p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。下面是一个正确定义 final 变量的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final int MAX_ARRAY_SIZE = 25;  // 常量名一般大写</div></pre></td></tr></table></figure><p>常量因为有 final 修饰，所以不能被继承。<br>请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static final int TOTAL_NUMBER = 5;</div><div class="line">    public int id;</div><div class="line">    public Demo() &#123;</div><div class="line">        // 非法，对final变量TOTAL_NUMBER进行二次赋值了</div><div class="line">        // 因为++TOTAL_NUMBER相当于 TOTAL_NUMBER=TOTAL_NUMBER+1</div><div class="line">        id = ++TOTAL_NUMBER;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Demo t = new Demo();</div><div class="line">        final int i = 10;</div><div class="line">        final int j;</div><div class="line">        j = 20;</div><div class="line">        j = 30;  // 非法，对final变量进行二次赋值</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类，例如 Java.lang.String 就是一个 final 类。这样做是出于安全原因，因为要保证一旦有字符串的引用，就必须是类 String 的字符串，而不是某个其它类的字符串（String 类可能被恶意继承并篡改）。</p><p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖；变量也可以被 final 修饰，被 final 修饰的变量在创建对象以后就不允许改变它们的值了。一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。</p><p>被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。在Java中，被 static 或 private 修饰的方法会被隐式的声明为 final，因为动态绑定没有意义。</p><p>由于动态绑定会消耗资源并且很多时候没有必要，所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。</p><p>这样的认识未免有些偏激，因为 JVM 中的即时编译器能够实时监控程序的运行信息，可以准确的知道类之间的继承关系。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 变量。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName() 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p><h1 id="三、Object类"><a href="#三、Object类" class="headerlink" title="三、Object类"></a>三、Object类</h1><p>Object 类位于 java.lang 包中，是所有 Java 类的祖先，Java 中的每个类都由它扩展而来。定义Java类时如果没有显示的指明父类，那么就默认继承了 Object 类。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实际上是下面代码的简写形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Demo extends Object&#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Java中，只有基本类型不是对象，例如数值、字符和布尔型的值都不是对象，所有的数组类型，不管是对象数组还是基本类型数组都是继承自 Object 类。</p><p>Object 类定义了一些有用的方法，由于是根类，这些方法在其他类中都存在，一般是进行了重载或覆盖，实现了各自的具体功能。</p><h2 id="3-1-equals-方法"><a href="#3-1-equals-方法" class="headerlink" title="3.1 equals() 方法"></a>3.1 equals() 方法</h2><p>Object 类中的 equals() 方法用来检测一个对象是否等价于另外一个对象，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj1.equals(obj2);</div></pre></td></tr></table></figure><p>在Java中，数据等价的基本含义是指两个数据的值相等。在通过 equals() 和“==”进行比较的时候，引用类型数据比较的是引用，即内存地址，基本数据类型比较的是值。</p><p>在Java中，数据等价的基本含义是指两个数据的值相等。在通过 equals() 和“==”进行比较的时候，引用类型数据比较的是引用，即内存地址，基本数据类型比较的是值。</p><p>注意：</p><ul><li>equals()方法只能比较引用类型，“==”可以比较引用类型及基本类型。</li><li>当用 equals() 方法进行比较时，对类 File、String、Date 及包装类来说，是比较类型及内容而不考虑引用的是否是同一个实例。</li><li>用“==”进行比较时，符号两边的数据类型必须一致（可自动转换的数据类型除外），否则编译出错，而用 equals 方法比较的两个数据只要都是引用类型即可。</li></ul><h2 id="3-2-hashCode-方法"><a href="#3-2-hashCode-方法" class="headerlink" title="3.2 hashCode()方法"></a>3.2 hashCode()方法</h2><p>散列码(hashCode)是按照一定的算法由对象得到的一个数值，散列码没有规律。如果 x 和 y 是不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。</p><p>hashCode() 方法主要用来在集合中实现快速查找等操作，也可以用于对象的比较。</p><p>在 Java 中，对 hashCode 的规定如下：</p><ul><li>在同一个应用程序执行期间，对同一个对象调用 hashCode()，必须返回相同的整数结果——前提是 equals() 所比较的信息都不曾被改动过。至于同一个应用程序在不同执行期所得的调用结果，无需一致。</li><li>如果两个对象被 equals() 方法视为相等，那么对这两个对象调用 hashCode() 必须获得相同的整数结果。</li><li>如果两个对象被 equals() 方法视为不相等，那么对这两个对象调用 hashCode() 不必产生不同的整数结果。然而程序员应该意识到，对不同对象产生不同的整数结果，有可能提升hashTable的效率。</li><li>简单地说：如果两个对象相同，那么它们的 hashCode 值一定要相同；如果两个对象的 hashCode 值相同，它们并不一定相同。在 Java 规范里面规定，一般是覆盖 equals() 方法应该连带覆盖 hashCode() 方法。</li></ul><h2 id="3-3-toString-方法"><a href="#3-3-toString-方法" class="headerlink" title="3.3 toString()方法"></a>3.3 toString()方法</h2><p>toString() 方法是 Object 类中定义的另一个重要方法，是对象的字符串表现形式，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public String toString()</div></pre></td></tr></table></figure><p>返回值是 String 类型，用于描述当前对象的有关信息。Object 类中实现的 toString() 方法是返回当前对象的类型和内存地址信息，但在一些子类（如 String、Date 等）中进行了 重写，也可以根据需要在用户自定义类型中重写 toString() 方法，以返回更适用的信息。</p><p>除显式调用对象的 toString() 方法外，在进行 String 与其它类型数据的连接操作时，会自动调用 toString() 方法。</p><p>以上几种方法，在Java中是经常用到的，这里仅作简单介绍，让大家对Object类和其他类有所了解，详细说明请参考 Java API 文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、static关键字&quot;&gt;&lt;a href=&quot;#一、static关键字&quot; class=&quot;headerlink&quot; title=&quot;一、static关键字&quot;&gt;&lt;/a&gt;一、static关键字&lt;/h1&gt;&lt;p&gt;static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。请看下面的例子：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（4）：多态</title>
    <link href="http://yoursite.com/2017/08/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2017/08/23/Java学习笔记（4）：多态/</id>
    <published>2017-08-23T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h1><p>在Java中，父类的变量可以引用父类的实例，也可以引用子类的实例。请读者先看一段代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal obj = new Animal();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Cat();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Dog();</div><div class="line">        obj.cry();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal&#123;</div><div class="line">    // 动物的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;不知道怎么叫&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    // 猫的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;喵喵~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    // 狗的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;汪汪~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">不知道怎么叫</div><div class="line">喵喵~</div><div class="line">汪汪~</div></pre></td></tr></table></figure><p>上面的代码，定义了三个类，分别是 Animal、Cat 和 Dog，Cat 和 Dog 类都继承自 Animal 类。obj 变量的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例，这是正确的。也就是说，父类的变量可以引用父类的实例，也可以引用子类的实例。注意反过来是错误的，因为所有的猫都是动物，但不是所有的动物都是猫。</p><p>可以看出，obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为多态。多态是指一个事物有不同的表现形式或形态。</p><p>再比如“人类”，也有很多不同的表达或实现，TA 可以是司机、教师、医生等，你憎恨自己的时候会说“下辈子重新做人”，那么你下辈子成为司机、教师、医生都可以，我们就说“人类”具备了多态性。</p><p>多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal obj = new Animal();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Cat();</div><div class="line">        obj.bark();</div><div class="line"></div><div class="line">        obj = new Dog();</div><div class="line">        obj.cry();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal&#123;</div><div class="line">    // 动物的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;不知道怎么叫&quot;);</div><div class="line">    &#125;</div><div class="line">    public void bark() &#123;</div><div class="line">    System.out.println(&quot;哈哈！！&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    // 猫的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;喵喵~&quot;);</div><div class="line">    &#125;</div><div class="line">    public void bark()&#123;</div><div class="line">    System.out.println(&quot;丫丫！！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    // 狗的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;汪汪~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面的例子可以看出，多态的一个好处是：当子类比较多时，也不需要定义多个变量，可以只定义一个父类类型的变量来引用不同子类的实例。请再看下面的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        // 借助多态，主人可以给很多动物喂食</div><div class="line">        Master ma = new Master();</div><div class="line">        ma.feed(new Animal(), new Food());</div><div class="line">        ma.feed(new Cat(), new Fish());</div><div class="line">        ma.feed(new Dog(), new Bone());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Animal类及其子类</div><div class="line">class Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一个小动物，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一只小猫咪，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一只狗狗，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Food及其子类</div><div class="line">class Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;食物&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Fish extends Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;鱼&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bone extends Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;骨头&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Master类</div><div class="line">class Master&#123;</div><div class="line">    public void feed(Animal an, Food f)&#123;</div><div class="line">        an.eat(f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我是一个小动物，正在吃事物</div><div class="line">我是一只小猫咪，正在吃鱼</div><div class="line">我是一只狗狗，正在吃骨头</div></pre></td></tr></table></figure><p>Master 类的 feed 方法有两个参数，分别是 Animal 类型和 Food 类型，因为是父类，所以可以将子类的实例传递给它，这样 Master 类就不需要多个方法来给不同的动物喂食。</p><h1 id="二、动态绑定"><a href="#二、动态绑定" class="headerlink" title="二、动态绑定"></a>二、动态绑定</h1><p>为了理解多态的本质，下面讲一下Java调用方法的详细流程。</p><ul><li>1) 编译器查看对象的声明类型和方法名。</li></ul><p>假设调用 obj.func(param)，obj 为 Cat 类的对象。需要注意的是，有可能存在多个名字为func但参数签名不一样的方法。例如，可能存在方法 func(int) 和 func(String)。编译器将会一一列举所有 Cat 类中名为func的方法和其父类 Animal 中访问属性为 public 且名为func的方法。</p><p>这样，编译器就获得了所有可能被调用的候选方法列表。</p><ul><li>2) 接下来，编泽器将检查调用方法时提供的参数签名。</li></ul><p>如果在所有名为func的方法中存在一个与提供的参数签名完全匹配的方法，那么就选择这个方法。这个过程被称为重载解析(overloading resolution)。例如，如果调用 func(“hello”)，编译器会选择 func(String)，而不是 func(int)。由于自动类型转换的存在，例如 int 可以转换为 double，如果没有找到与调用方法参数签名相同的方法，就进行类型转换后再继续查找，如果最终没有匹配的类型或者有多个方法与之匹配，那么编译错误。</p><p>这样，编译器就获得了需要调用的方法名字和参数签名。</p><ul><li>3) 如果方法的修饰符是private、static、final（static和final将在后续讲解），或者是构造方法，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式 称为静态绑定(static binding)。</li></ul><p>与此对应的是，调用的方法依赖于对象的实际类型， 并在运行时实现动态绑。例如调用 func(“hello”)，编泽器将采用动态绑定的方式生成一条调用 func(String) 的指令。</p><ul><li>4)当程序运行，并且釆用动态绑定调用方法时，JVM一定会调用与 obj 所引用对象的实际类型最合适的那个类的方法。我们已经假设 obj 的实际类型是 Cat，它是 Animal 的子类，如果 Cat 中定义了 func(String)，就调用它，否则将在 Animal 类及其父类中寻找。</li></ul><p>每次调用方法都要进行搜索，时间开销相当大，因此，JVM预先为每个类创建了一个方法表(method lable)，其中列出了所有方法的名称、参数签名和所属的类。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在上面的例子中，JVM 搜索 Cat 类的方法表，以便寻找与调用 func(“hello”) 相匹配的方法。这个方法既有可能是 Cat.func(String)，也有可能是 Animal.func(String)。注意，如果调用super.func(“hello”)，编译器将对父类的方法表迸行搜索。</p><p>假设 Animal 类包含cry()、getName()、getAge() 三个方法，那么它的方法表如下：</p><ul><li>cry() -&gt; Animal.cry()</li><li>getName() -&gt; Animal.getName()</li><li>getAge() -&gt; Animal.getAge()</li></ul><p>实际上，Animal 也有默认的父类 Object（后续会讲解），会继承 Object 的方法，所以上面列举的方法并不完整。</p><p>假设 Cat 类覆盖了 Animal 类中的 cry() 方法，并且新增了一个方法 climbTree()，那么它的参数列表为：</p><ul><li>cry() -&gt; Cat.cry()</li><li>getName() -&gt; Animal.getName()</li><li>getAge() -&gt; Animal.getAge()</li><li>climbTree() -&gt; Cat.climbTree()</li></ul><p>在运行的时候，调用 obj.cry() 方法的过程如下：</p><ul><li>JVM 首先访问 obj 的实际类型的方法表，可能是 Animal 类的方法表，也可能是 Cat 类及其子类的方法表。</li><li>JVM 在方法表中搜索与 cry() 匹配的方法，找到后，就知道它属于哪个类了。</li><li>JVM 调用该方法。</li></ul><h1 id="三、instanceof运算符"><a href="#三、instanceof运算符" class="headerlink" title="三、instanceof运算符"></a>三、instanceof运算符</h1><p>多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型 。 C++使用runtime-type information(RTTI)，Java 使用 instanceof 操作符。instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 引用 People 类的实例</div><div class="line">        People obj = new People();</div><div class="line">        if(obj instanceof Object)&#123;</div><div class="line">            System.out.println(&quot;我是一个对象&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof People)&#123;</div><div class="line">            System.out.println(&quot;我是人类&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof Teacher)&#123;</div><div class="line">            System.out.println(&quot;我是一名教师&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof President)&#123;</div><div class="line">            System.out.println(&quot;我是校长&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(&quot;-----------&quot;);  // 分界线</div><div class="line">       </div><div class="line">        // 引用 Teacher 类的实例</div><div class="line">        obj = new Teacher();</div><div class="line">        if(obj instanceof Object)&#123;</div><div class="line">            System.out.println(&quot;我是一个对象&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof People)&#123;</div><div class="line">            System.out.println(&quot;我是人类&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof Teacher)&#123;</div><div class="line">            System.out.println(&quot;我是一名教师&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof President)&#123;</div><div class="line">            System.out.println(&quot;我是校长&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class People&#123; &#125;</div><div class="line">class Teacher extends People&#123; &#125;</div><div class="line">class President extends Teacher&#123; &#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">我是一个对象</div><div class="line">我是人类</div><div class="line">———–</div><div class="line">我是一个对象</div><div class="line">我是人类</div><div class="line">我是一名教师</div></pre></td></tr></table></figure><p>可以看出，如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。</p><h1 id="四、多态对象的类型转换"><a href="#四、多态对象的类型转换" class="headerlink" title="四、多态对象的类型转换"></a>四、多态对象的类型转换</h1><p>这里所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，java 运行时将抛出 java.lang.ClassCastException 异常。在继承链中，我们将子类向父类转换称为“向上转型”，将父类向子类转换称为“向下转型”。很多时候，我们会将变量定义为父类的类型，却引用子类的对象，这个过程就是向上转型。程序运行时通过动态绑定来实现对子类方法的调用，也就是多态性。</p><p>然而有些时候为了完成某些父类没有的功能，我们需要将向上转型后的子类对象再转成子类，调用子类的方法，这就是向下转型。</p><p>注意：不能直接将父类的对象强制转换为子类类型，只能将向上转型后的子类对象再次转换为子类类型。也就是说，子类对象必须向上转型后，才能再向下转型。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SuperClass superObj = new SuperClass();</div><div class="line">        SonClass sonObj = new SonClass();</div><div class="line"></div><div class="line">        // 下面的代码运行时会抛出异常，不能将父类对象直接转换为子类类型</div><div class="line">        // SonClass sonObj2 = (SonClass)superObj;</div><div class="line"></div><div class="line">        // 先向上转型，再向下转型</div><div class="line">        superObj = sonObj;</div><div class="line">        SonClass sonObj1 = (SonClass)superObj;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SuperClass&#123; &#125;</div><div class="line">class SonClass extends SuperClass&#123; &#125;</div></pre></td></tr></table></figure><p>将第7行的注释去掉，运行时会抛出异常，但是编译可以通过。</p><p>因为向下转型存在风险，所以在接收到父类的一个引用时，请务必使用 instanceof 运算符来判断该对象是否是你所要的子类，请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SuperClass superObj = new SuperClass();</div><div class="line">        SonClass sonObj = new SonClass();</div><div class="line"></div><div class="line">        // superObj 不是 SonClass 类的实例</div><div class="line">        if(superObj instanceof SonClass)&#123;</div><div class="line">            SonClass sonObj1 = (SonClass)superObj;</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;①不能转换&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        superObj = sonObj;</div><div class="line">        // superObj 是 SonClass 类的实例</div><div class="line">        if(superObj instanceof SonClass)&#123;</div><div class="line">            SonClass sonObj2 = (SonClass)superObj;</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;②不能转换&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SuperClass&#123; &#125;</div><div class="line">class SonClass extends SuperClass&#123; &#125;</div></pre></td></tr></table></figure><p>运行结果：<br>①不能转换</p><p>总结：对象的类型转换在程序运行时检查，向上转型会自动进行，向下转型的对象必须是当前引用类型的子类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、多态&quot;&gt;&lt;a href=&quot;#一、多态&quot; class=&quot;headerlink&quot; title=&quot;一、多态&quot;&gt;&lt;/a&gt;一、多态&lt;/h1&gt;&lt;p&gt;在Java中，父类的变量可以引用父类的实例，也可以引用子类的实例。请读者先看一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（3）：继承、覆盖、重载</title>
    <link href="http://yoursite.com/2017/08/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/08/22/Java学习笔记（3）：继承/</id>
    <published>2017-08-22T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、继承的概念与实现"><a href="#一、继承的概念与实现" class="headerlink" title="一、继承的概念与实现"></a>一、继承的概念与实现</h1><p>继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。</p><a id="more"></a><p>继承使用 extends 关键字。<br>例如我们已经定义了一个类 People：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    int height;</div><div class="line">   </div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果现在需要定义一个类 Teacher，它也有 name、age、height 属性和 say() 方法，另外还需要增加 school、seniority、subject 属性和 lecturing() 方法，怎么办呢？我们要重新定义一个类吗？</p><p>完全没必要，可以先继承 People 类的成员，再增加自己的成员即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Teacher extends People&#123;</div><div class="line">    String school;  // 所在学校</div><div class="line">    String subject;  // 学科</div><div class="line">    int seniority;  // 教龄</div><div class="line">   </div><div class="line">    // 覆盖 People 类中的 say() 方法</div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    void lecturing()&#123;</div><div class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对程序的说明</p><ul><li>name 和 age 变量虽然没有在 Teacher 中定义，但是已在 People 中定义，可以直接拿来用。</li><li>Teacher 是 People 的子类，People 是Teacher 类的父类。</li><li>子类可以覆盖父类的方法。</li><li>子类可以继承父类除private以为的所有的成员。</li><li>构造方法不能被继承。</li></ul><p>继承是在维护和可靠性方面的一个伟大进步。如果在 People 类中进行修改，那么 Teacher 类就会自动修改，而不需要程序员做任何工作，除了对它进行编译。</p><p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。</p><p>最后对上面的代码进行整理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Teacher t = new Teacher();</div><div class="line">        t.name = &quot;小布&quot;;</div><div class="line">        t.age = 70;</div><div class="line">        t.school = &quot;清华大学&quot;;</div><div class="line">        t.subject = &quot;Java&quot;;</div><div class="line">        t.seniority = 12;</div><div class="line">        t.say();</div><div class="line">        t.lecturing();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class People&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    int height;</div><div class="line">   </div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Teacher extends People&#123;</div><div class="line">    String school;  // 所在学校</div><div class="line">    String subject;  // 学科</div><div class="line">    int seniority;  // 教龄</div><div class="line">   </div><div class="line">    // 覆盖 People 类中的 say() 方法</div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    void lecturing()&#123;</div><div class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我叫小布，在清华大学教Java，有12年教龄</div><div class="line">我已经70岁了，依然站在讲台上讲课</div></pre></td></tr></table></figure><p>注意：构造方法不能被继承，掌握这一点很重要。 一个类能得到构造方法，只有两个办法：编写构造方法，或者根本没有构造方法，类有一个默认的构造方法。</p><h1 id="二、super关键字"><a href="#二、super关键字" class="headerlink" title="二、super关键字"></a>二、super关键字</h1><p>super 关键字与 this 类似，this 用来表示当前类的实例，super 用来表示父类。super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。</p><p>super 关键字的功能：</p><ul><li>调用父类中声明为 private 的变量。</li><li>点取已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h2 id="2-1-调用隐藏变量和被覆盖的方法"><a href="#2-1-调用隐藏变量和被覆盖的方法" class="headerlink" title="2.1 调用隐藏变量和被覆盖的方法"></a>2.1 调用隐藏变量和被覆盖的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Dog obj = new Dog();</div><div class="line">        obj.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Animal&#123;</div><div class="line">    private String desc = &quot;Animals are human&apos;s good friends&quot;;</div><div class="line">    // 必须要声明一个 getter 方法</div><div class="line">    public String getDesc() &#123; return desc; &#125;</div><div class="line"></div><div class="line">    public void move()&#123;</div><div class="line">        System.out.println(&quot;Animals can move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Dog extends Animal&#123;</div><div class="line">    public void move()&#123;</div><div class="line">        super.move();  // 调用父类的方法</div><div class="line">        System.out.println(&quot;Dogs can walk and run&quot;);</div><div class="line">        // 通过 getter 方法调用父类隐藏变量</div><div class="line">        System.out.println(&quot;Please remember: &quot; + super.getDesc());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animals can move</div><div class="line">Dogs can walk and run</div><div class="line">Please remember: Animals are human’s good friends</div></pre></td></tr></table></figure><p>move() 方法也可以定义在某些祖先类中，比如父类的父类，Java 具有追溯性，会一直向上找，直到找到该方法为止。</p><p>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p><h2 id="2-2-调用父类的构造方法"><a href="#2-2-调用父类的构造方法" class="headerlink" title="2.2 调用父类的构造方法"></a>2.2 调用父类的构造方法</h2><p>在许多情况下，使用默认构造方法来对父类对象进行初始化。当然也可以使用 super 来显示调用父类的构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Dog obj = new Dog(&quot;花花&quot;, 3);</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Animal&#123;</div><div class="line">    String name;</div><div class="line">    public Animal(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Dog extends Animal&#123;</div><div class="line">    int age;</div><div class="line">    public Dog(String name, int age)&#123;</div><div class="line">        super(name);</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void say()&#123;</div><div class="line">        System.out.println(&quot;我是一只可爱的小狗，我的名字叫&quot; + name + &quot;，我&quot; + age + &quot;岁了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是一只可爱的小狗，我的名字叫花花，我3岁了</div></pre></td></tr></table></figure><p>注意：无论是 super() 还是 this()，都必须放在构造方法的第一行。</p><p>值得注意的是：</p><ul><li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li><li>不能在构造方法以外的任何方法内调用构造方法。</li><li>在一个构造方法内只能调用一个构造方法。</li></ul><p>如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。</p><p>最后注意 super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</p><h1 id="三、继承中的方法的覆盖和重载"><a href="#三、继承中的方法的覆盖和重载" class="headerlink" title="三、继承中的方法的覆盖和重载"></a>三、继承中的方法的覆盖和重载</h1><h2 id="3-1-覆盖"><a href="#3-1-覆盖" class="headerlink" title="3.1 覆盖"></a>3.1 覆盖</h2><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p><p>注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>);</div><div class="line">        myDog.say();  <span class="comment">// 子类的实例调用子类中的方法</span></div><div class="line">       </div><div class="line">        Animal myAnmial = <span class="keyword">new</span> Animal(<span class="string">"贝贝"</span>);</div><div class="line">        myAnmial.say();  <span class="comment">// 父类的实例调用父类中的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小动物，我的名字叫"</span> + name + <span class="string">"，我会发出叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="comment">// 构造方法不能被继承，通过super()调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 覆盖say() 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我的名字叫"</span> + name + <span class="string">"，我会发出汪汪的叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是一只小狗，我的名字叫花花，我会发出汪汪的叫声</div><div class="line">我是一只小动物，我的名字叫贝贝，我会发出叫声</div></pre></td></tr></table></figure><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><h2 id="3-2-重载"><a href="#3-2-重载" class="headerlink" title="3.2 重载"></a>3.2 重载</h2><p>前面已经对Java方法重载进行了说明，这里再强调一下，Java父类和子类中的方法都会参与重载，例如，父类中有一个方法是 func(){ … }，子类中有一个方法是 func(int i){ … }，就构成了方法的重载。</p><p>覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、继承的概念与实现&quot;&gt;&lt;a href=&quot;#一、继承的概念与实现&quot; class=&quot;headerlink&quot; title=&quot;一、继承的概念与实现&quot;&gt;&lt;/a&gt;一、继承的概念与实现&lt;/h1&gt;&lt;p&gt;继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（2）：类与对象</title>
    <link href="http://yoursite.com/2017/08/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/08/21/Java学习笔记（2）：类与对象/</id>
    <published>2017-08-21T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类的定义及其实例化"><a href="#一、类的定义及其实例化" class="headerlink" title="一、类的定义及其实例化"></a>一、类的定义及其实例化</h1><p>类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。</p><a id="more"></a><p>下面通过一个简单的例子来理解Java中类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;  <span class="comment">// 汪汪叫</span></div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;  <span class="comment">// 饥饿</span></div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对示例的说明：</p><ul><li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符将在下节讲解。</li><li>class 是定义类的关键字。</li><li>Dog 是类名称。</li><li>name、age是类的成员变量，也叫属性；bark()、hungry() 是类中的函数，也叫方法。</li></ul><p>一个类可以包含以下类型变量：</p><ul><li>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种，将在下节讲解。</li></ul><h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>构造方法的名称必须与类的名称相同，并且没有返回值。</p><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p><p>下面是一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="comment">// 构造方法，没有返回值</span></div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="comment">// 普通方法，必须有返回值</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建对象时传递的参数要与构造方法参数列表对应</span></div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div></pre></td></tr></table></figure><p>说明：</p><ul><li>构造方法不能被显示调用。</li><li>构造方法不能有返回值，因为没有变量来接收返回值。<h2 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h2>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。</li></ul><p>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p><ul><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字new来创建一个对象。</li><li>初始化：使用new创建对象时，会调用构造方法初始化对象。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Dog myDog;  // 声明一个对象</div><div class="line">myDog = new Dog(&quot;花花&quot;, 3);  // 实例化</div></pre></td></tr></table></figure><p>也可以在声明的同时进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog myDog = new Dog(&quot;花花&quot;, 3);</div></pre></td></tr></table></figure><h2 id="1-3-访问成员变量和方法"><a href="#1-3-访问成员变量和方法" class="headerlink" title="1.3 访问成员变量和方法"></a>1.3 访问成员变量和方法</h2><p>通过已创建的对象来访问成员变量和成员方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//实例化</div><div class="line">Dog myDog = new Dog(&quot;花花&quot;, 3);</div><div class="line">// 通过点号访问成员变量</div><div class="line">myDog.name;</div><div class="line">// 通过点号访问成员方法</div><div class="line">myDog.bark();</div></pre></td></tr></table></figure><p>下面的例子演示了如何访问成员变量和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">        <span class="comment">// 访问成员变量</span></div><div class="line">        String name = myDog.name;</div><div class="line">        <span class="keyword">int</span> age = myDog.age;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我名字叫"</span> + name + <span class="string">"，我"</span> + age + <span class="string">"岁了"</span>);</div><div class="line">        <span class="comment">// 访问方法</span></div><div class="line">        myDog.bark();</div><div class="line">        myDog.hungry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div><div class="line">我是一只小狗，我名字叫花花，我3岁了</div><div class="line">汪汪，不要过来</div><div class="line">主人，我饿了</div></pre></td></tr></table></figure><h1 id="二、Java访问修饰符"><a href="#二、Java访问修饰符" class="headerlink" title="二、Java访问修饰符"></a>二、Java访问修饰符</h1><p>Java 通过修饰符来控制类、属性和方法的访问权限和其他功能，通常放在语句的最前端。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class className &#123;</div><div class="line">    // body of class</div><div class="line">&#125;</div><div class="line">private boolean myFlag;</div><div class="line">static final double weeks = 9.5;</div><div class="line">protected static final int BOXWIDTH = 42;</div><div class="line">public static void main(String[] arguments) &#123;</div><div class="line">    // body of method</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java 的修饰符很多，分为访问修饰符和非访问修饰符。本节仅介绍访问修饰符，非访问修饰符会在后续介绍。</p><p>访问修饰符也叫访问控制符，是指能够控制类、成员变量、方法的使用权限的关键字。</p><p>在面向对象编程中，访问控制符是一个很重要的概念，可以使用它来保护对类、变量、方法和构造方法的访问。</p><p>Java支持四种不同的访问权限：</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>公有的，对所有类可见</td></tr><tr><td>protected</td><td>受保护的，对同一包内的类和所有子类可见</td></tr><tr><td>private</td><td>私有的，在同一类内可见</td></tr><tr><td>默认的</td><td>在同一包内可见。默认不使用任何修饰符</td></tr></tbody></table></div><h2 id="2-1-public：公有的"><a href="#2-1-public：公有的" class="headerlink" title="2.1 public：公有的"></a>2.1 public：公有的</h2><p>被声明为public的类、方法、构造方法和接口能够被任何其他类访问。</p><p>如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p><p>下面的方法使用了公有访问控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arguments)</span> </span>&#123;</div><div class="line">    <span class="comment">// body of method</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java程序的main() 方法必须设置成公有的，否则，Java解释器将不能运行该类。</p><h2 id="2-2-protected：受保护的"><a href="#2-2-protected：受保护的" class="headerlink" title="2.2 protected：受保护的"></a>2.2 protected：受保护的</h2><p>被声明为protected的变量、方法和构造方法不能被同一个包中的任何其他类访问，也不能够被不同包中的子类访问。</p><p>protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。</p><p>子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p><p>下面的父类使用了protected访问修饰符，子类重载了父类的bark()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teddy</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123;  <span class="comment">// 泰迪</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，我好怕，不要跟着我"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果把bark()方法声明为private，那么除了Dog之外的类将不能访问该方法。如果把bark()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。</p><h2 id="2-3-private：私有的"><a href="#2-3-private：私有的" class="headerlink" title="2.3 private：私有的"></a>2.3 private：私有的</h2><p>私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。</p><p>声明为私有访问类型的变量只能通过类中公共的Getter/Setter方法被外部类访问。</p><p>private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p><p>下面的类使用了私有访问修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dog&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>例子中，Dog类中的name、age变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两对public方法，getName()/setName() 和 getAge()/setAge()，它们用来获取和设置私有变量的值。</p><p>this 是Java中的一个关键字，接下来会讲到。</p><p>在类中定义访问私有变量的方法，习惯上是这样命名的：在变量名称前面加“get”或“set”，并将变量的首字母大写。例如，获取私有变量 name 的方法为 getName()，设置 name 的方法为 setName()。这些方法经常使用，也有了特定的称呼，称为 Getter 和 Setter 方法。</p><h2 id="2-4-默认的：不使用任何关键字"><a href="#2-4-默认的：不使用任何关键字" class="headerlink" title="2.4 默认的：不使用任何关键字"></a>2.4 默认的：不使用任何关键字</h2><p>不使用任何修饰符声明的属性和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。</p><p>如下例所示，类、变量和方法的定义没有使用任何修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Dog&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">  </div><div class="line">    void bark()&#123;  // 汪汪叫</div><div class="line">        System.out.println(&quot;汪汪，不要过来&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void hungry()&#123;  // 饥饿</div><div class="line">        System.out.println(&quot;主人，我饿了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-5-访问控制和继承"><a href="#2-5-访问控制和继承" class="headerlink" title="2.5 访问控制和继承"></a>2.5 访问控制和继承</h2><p>请注意以下方法继承的规则：</p><ul><li>父类中声明为public的方法在子类中也必须为public。</li><li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li><li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li><li>父类中声明为private的方法，不能够被继承。</li></ul><h2 id="2-6-如何使用访问控制符"><a href="#2-6-如何使用访问控制符" class="headerlink" title="2.6 如何使用访问控制符"></a>2.6 如何使用访问控制符</h2><p>访问控制符可以让我们很方便的控制代码的权限：</p><ul><li>当需要让自己编写的类被所有的其他类访问时，就可以将类的访问控制符声明为 public。</li><li>当需要让自己的类只能被自己的包中的类访问时，就可以省略访问控制符。</li><li>当需要控制一个类中的成员数据时，可以将这个类中的成员数据访问控制符设置为 public、protected，或者省略。</li></ul><h1 id="三、Java变量的作用域"><a href="#三、Java变量的作用域" class="headerlink" title="三、Java变量的作用域"></a>三、Java变量的作用域</h1><p>在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。</p><ul><li>类级变量：又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</li><li>对象实例级变量：就是成员变量，实例化后才会分配内存空间，才能访问。</li><li>方法级变量：就是在方法内部定义的变量，就是局部变量。</li><li>块级变量：就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int age = 3;</div><div class="line">    String name = &quot;www.yq1012.com&quot;;</div><div class="line">    // 正确，在块内部可以访问 age 和 name 变量</div><div class="line">    System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</div><div class="line">&#125;</div><div class="line">// 错误，在块外部无法访问 age 和 name 变量</div><div class="line">System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</div></pre></td></tr></table></figure><p>说明：</p><ul><li>方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。</li><li>块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。</li><li>方法级和块级的变量必须被显示地初始化，否则不能访问。<br>演示代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">lic class Demo&#123;</div><div class="line">    public static String name = &quot;程序员&quot;;  // 类级变量</div><div class="line">    public int i; // 对象实例级变量</div><div class="line"></div><div class="line">    // 属性块，在类初始化属性时候运行</div><div class="line">    &#123;</div><div class="line">        int j = 2;// 块级变量</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void test1() &#123;</div><div class="line">        int j = 3;  // 方法级变量</div><div class="line">        if(j == 3) &#123;</div><div class="line">            int k = 5;  // 块级变量</div><div class="line">        &#125;</div><div class="line">        // 这里不能访问块级变量，块级变量只能在块内部访问</div><div class="line">        System.out.println(&quot;name=&quot; + name + &quot;, i=&quot; + i + &quot;, j=&quot; + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 不创建对象，直接通过类名访问类级变量</div><div class="line">        System.out.println(Demo.name);</div><div class="line">       </div><div class="line">        // 创建对象并访问它的方法</div><div class="line">        Demo t = new Demo();</div><div class="line">        t.test1();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序员</div><div class="line">name=程序员, i=0, j=3</div></pre></td></tr></table></figure><h1 id="四、this关键字"><a href="#四、this关键字" class="headerlink" title="四、this关键字"></a>四、this关键字</h1><p>this 关键字用来表示当前对象本身，或当前类的一个实例，通过 this 可以调用本对象的所有方法和属性。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y = <span class="number">15</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 通过 this 点取成员变量</span></div><div class="line">        <span class="keyword">int</span> z = <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">        System.out.println(<span class="string">"x + y = "</span> + z);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo();</div><div class="line">        obj.sum();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x + y = 25</div></pre></td></tr></table></figure><p>上面的程序中，obj 是 Demo 类的一个实例，this 与 obj 等价，执行 int z = this.x + this.y;，就相当于执行 int z = obj.x + obj.y;。</p><p>注意：this 只有在类实例化后才有意义。</p><h2 id="4-1-使用this区分同名变量"><a href="#4-1-使用this区分同名变量" class="headerlink" title="4.1 使用this区分同名变量"></a>4.1 使用this区分同名变量</h2><p>成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，怎么办呢？这时候只能使用this，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="comment">//构造方法</span></div><div class="line">    Demo(String name, <span class="keyword">int</span> age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//普通方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"网站的名字是"</span> + name + <span class="string">"，已经成立了"</span> + age + <span class="string">"年"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//main方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo(<span class="string">"程序员"</span>, <span class="number">3</span>);</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">网站的名字是程序员，已经成立了3年</div></pre></td></tr></table></figure><p>形参的作用域是整个方法体，是局部变量。在Demo()中，形参和成员变量重名，如果不使用this，访问到的就是局部变量name和age，而不是成员变量。在 say() 中，我们没有使用 this，因为成员变量的作用域是整个实例，当然也可以加上 this：</p><p>Java 默认将所有成员变量和成员方法与 this 关联在一起，因此使用 this 在某些情况下是多余的。</p><h2 id="4-2-作为方法名来初始化对象"><a href="#4-2-作为方法名来初始化对象" class="headerlink" title="4.2 作为方法名来初始化对象"></a>4.2 作为方法名来初始化对象</h2><p>也就是相当于调用本类的其它构造方法，它必须作为构造方法的第一句。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public String name;</div><div class="line">    public int age;</div><div class="line">   </div><div class="line">    public Demo()&#123;</div><div class="line">        this(&quot;程序员&quot;, 3);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public Demo(String name, int age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public void say()&#123;</div><div class="line">        System.out.println(&quot;网站的名字是&quot; + name + &quot;，已经成立了&quot; + age + &quot;年&quot;);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Demo obj = new Demo();</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">网站的名字是程序员，已经成立了3年</div></pre></td></tr></table></figure><p>值得注意的是：</p><ul><li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li><li>不能在构造方法以外的任何方法内调用构造方法。</li><li>在一个构造方法内只能调用一个构造方法。</li></ul><p>上述代码涉及到方法重载，即Java允许出现多个同名方法，只要参数不同就可以。后续章节会讲解。</p><h2 id="4-3-作为参数传递"><a href="#4-3-作为参数传递" class="headerlink" title="4.3 作为参数传递"></a>4.3 作为参数传递</h2><p>需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        B b = new B(new A());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">    public A()&#123;</div><div class="line">        new B(this).print();  // 匿名对象</div><div class="line">    &#125;</div><div class="line">    public void print()&#123;</div><div class="line">        System.out.println(&quot;Hello from A!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">    A a;</div><div class="line">    public B(A a)&#123;</div><div class="line">        this.a = a;</div><div class="line">    &#125;</div><div class="line">    public void print() &#123;</div><div class="line">        a.print();</div><div class="line">        System.out.println(&quot;Hello from B!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello from A!</div><div class="line">Hello from B!</div></pre></td></tr></table></figure><p>匿名对象就是没有名字的对象。如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); 等价于 ( new B(this) ).print();，先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。</p><h1 id="五、方法重载"><a href="#五、方法重载" class="headerlink" title="五、方法重载"></a>五、方法重载</h1><p>在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><p>下面看一个详细的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // 一个普通的方法，不带参数</div><div class="line">    void test()&#123;</div><div class="line">        System.out.println(&quot;No parameters&quot;);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个整型参数</div><div class="line">    void test(int a)&#123;</div><div class="line">        System.out.println(&quot;a: &quot; + a);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了两个参数</div><div class="line">    void test(int a,int b)&#123;</div><div class="line">        System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个双精度参数</div><div class="line">    double test(double a)&#123;</div><div class="line">        System.out.println(&quot;double a: &quot; + a);</div><div class="line">        return a*a;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Demo obj= new Demo();</div><div class="line">        obj.test();</div><div class="line">        obj.test(2);</div><div class="line">        obj.test(2,3);</div><div class="line">        obj.test(2.0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">No parameters</div><div class="line">a: 2</div><div class="line">a and b: 2 3</div><div class="line">double a: 2.0</div></pre></td></tr></table></figure><p>通过上面的实例，读者可以看出，重载就是在一个类中，有相同的函数名称，但形参不同的函数。重载的结果，可以让一个程序段尽量减少代码和方法的种类。<br>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><p>方法的重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>方法重载的实现：</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。</li></ul><h1 id="六、基本运行顺序"><a href="#六、基本运行顺序" class="headerlink" title="六、基本运行顺序"></a>六、基本运行顺序</h1><p>我们以下面的类来说明一个基本的 Java 类的运行顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</div><div class="line">        name = <span class="string">"java学习"</span>;</div><div class="line">        age = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo();</div><div class="line">        System.out.println(obj.name + <span class="string">"的年龄是"</span> + obj.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>基本运行顺序是：</p><ul><li>先运行到第 9 行，这是程序的入口。</li><li>然后运行到第 10 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li><li>就运行到第 5 行，注意：可能很多人觉得接下来就应该运行第 6 行了，错！初始化一个类，必须先初始化它的属性。</li><li>因此运行到第 2 行，然后是第 3 行。</li><li>属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 6 行、第 7 行。</li><li>然后是第8行，表示 new 一个Demo实例完成。</li><li>然后回到 main 方法中执行第 11 行。</li><li>然后是第 12 行，main方法执行完毕。</li></ul><p>作为程序员，应该清楚程序的基本运行过程，否则糊里糊涂的，不利于编写代码，也不利于技术上的发展。</p><h1 id="七、包装类、拆箱和装箱"><a href="#七、包装类、拆箱和装箱" class="headerlink" title="七、包装类、拆箱和装箱"></a>七、包装类、拆箱和装箱</h1><p>虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p><p>基本类型和对应的包装类可以相互装换：</p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><h2 id="7-1-包装类的应用"><a href="#7-1-包装类的应用" class="headerlink" title="7.1 包装类的应用"></a>7.1 包装类的应用</h2><p>八个包装类的使用比较相似，下面是常见的应用场景。</p><ul><li>1）实现 int 和 Integer 的相互转换</li></ul><p>可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        Integer obj = new Integer(m);  // 手动装箱</div><div class="line">        int n = obj.intValue();  // 手动拆箱</div><div class="line">        System.out.println(&quot;n = &quot; + n);</div><div class="line">       </div><div class="line">        Integer obj1 = new Integer(500);</div><div class="line">        System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><ul><li>2）将字符串转换为整数</li></ul><p>Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(String s, int radix);</div></pre></td></tr></table></figure><p>s 为要转换的字符串，radix 为进制，可选，默认为十进制。</p><p>下面的代码将会告诉你什么样的字符串可以转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String str[] = &#123;&quot;123&quot;, &quot;123abc&quot;, &quot;abc123&quot;, &quot;abcxyz&quot;&#125;;</div><div class="line">       </div><div class="line">        for(String str1 : str)&#123;</div><div class="line">            try&#123;</div><div class="line">                int m = Integer.parseInt(str1, 10);</div><div class="line">                System.out.println(str1 + &quot; 可以转换为整数 &quot; + m);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                System.out.println(str1 + &quot; 无法转换为整数&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">123 可以转换为整数 123</div><div class="line">123abc 无法转换为整数</div><div class="line">abc123 无法转换为整数</div><div class="line">abcxyz 无法转换为整数</div></pre></td></tr></table></figure><ul><li>3）将整数转换为字符串</li></ul><p>Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        String s = Integer.toString(m);</div><div class="line">        System.out.println(&quot;s = &quot; + s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = 500</div></pre></td></tr></table></figure><h2 id="7-2-自动拆箱和装箱"><a href="#7-2-自动拆箱和装箱" class="headerlink" title="7.2 自动拆箱和装箱"></a>7.2 自动拆箱和装箱</h2><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p><p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</div><div class="line">        Integer obj = m;  <span class="comment">// 自动装箱</span></div><div class="line">        <span class="keyword">int</span> n = obj;  <span class="comment">// 自动拆箱</span></div><div class="line">        System.out.println(<span class="string">"n = "</span> + n);</div><div class="line">      </div><div class="line">        Integer obj1 = <span class="number">500</span>;</div><div class="line">        System.out.println(<span class="string">"obj 等价于 obj1？"</span> + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><p>自动拆箱装箱是常用的一个功能，需要重点掌握。</p><h1 id="八、源文件的声明规则"><a href="#八、源文件的声明规则" class="headerlink" title="八、源文件的声明规则"></a>八、源文件的声明规则</h1><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：</p><ul><li>一个源文件中只能有一个public类。</li><li>一个源文件可以有多个非public类。</li><li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li><li>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在后续章节介绍。</li><li>除了上面提到的几种类型，Java还有一些特殊的类，如内部类、匿名类。</li></ul><h2 id="8-1-一个简单的例子"><a href="#8-1-一个简单的例子" class="headerlink" title="8.1 一个简单的例子"></a>8.1 一个简单的例子</h2><p>在该例子中，我们创建两个类 Employee 和 EmployeeTest，分别放在包 p1 和 p2 中。</p><p>Employee类有四个成员变量，分别是 name、age、designation和salary。该类显式声明了一个构造方法，该方法只有一个参数。</p><p>在Eclipse中，创建一个包，命名为 p1，在该包中创建一个类，命名为 Employee，将下面的代码复制到源文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p1;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">    String designation;</div><div class="line">    <span class="keyword">double</span> salary;</div><div class="line">    <span class="comment">// Employee 类的构造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置age的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empAge</span><span class="params">(<span class="keyword">int</span> empAge)</span></span>&#123;</div><div class="line">        age =  empAge;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置designation的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empDesignation</span><span class="params">(String empDesig)</span></span>&#123;</div><div class="line">        designation = empDesig;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置salary的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empSalary</span><span class="params">(<span class="keyword">double</span> empSalary)</span></span>&#123;</div><div class="line">        salary = empSalary;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 输出信息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Name:"</span>+ name );</div><div class="line">        System.out.println(<span class="string">"Age:"</span> + age );</div><div class="line">        System.out.println(<span class="string">"Designation:"</span> + designation );</div><div class="line">        System.out.println(<span class="string">"Salary:"</span> + salary);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序都是从main方法开始执行。为了能运行这个程序，必须包含main方法并且创建一个对象。</p><p>下面给出EmployeeTest类，该类创建两个Employee对象，并调用方法设置变量的值。</p><p>在Eclipse中再创建一个包，命名为 p2，在该包中创建一个类，命名为 EmployeeTest，将下面的代码复制到源文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p2;</div><div class="line"><span class="keyword">import</span> p1.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建两个对象</span></div><div class="line">        Employee empOne = <span class="keyword">new</span> Employee(<span class="string">"James Smith"</span>);</div><div class="line">        Employee empTwo = <span class="keyword">new</span> Employee(<span class="string">"Mary Anne"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 调用这两个对象的成员方法</span></div><div class="line">        empOne.empAge(<span class="number">26</span>);</div><div class="line">        empOne.empDesignation(<span class="string">"Senior Software Engineer"</span>);</div><div class="line">        empOne.empSalary(<span class="number">1000</span>);</div><div class="line">        empOne.printEmployee();</div><div class="line"></div><div class="line">        empTwo.empAge(<span class="number">21</span>);</div><div class="line">        empTwo.empDesignation(<span class="string">"Software Engineer"</span>);</div><div class="line">        empTwo.empSalary(<span class="number">500</span>);</div><div class="line">        empTwo.printEmployee();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译并运行 EmployeeTest 类，可以看到如下的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Name:James Smith</div><div class="line">Age:26</div><div class="line">Designation:Senior Software Engineer</div><div class="line">Salary:1000.0</div><div class="line">Name:Mary Anne</div><div class="line">Age:21</div><div class="line">Designation:Software Engineer</div><div class="line">Salary:500.0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、类的定义及其实例化&quot;&gt;&lt;a href=&quot;#一、类的定义及其实例化&quot; class=&quot;headerlink&quot; title=&quot;一、类的定义及其实例化&quot;&gt;&lt;/a&gt;一、类的定义及其实例化&lt;/h1&gt;&lt;p&gt;类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（1）：语法基础</title>
    <link href="http://yoursite.com/2017/08/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/08/20/Java学习笔记（1）：语法基础/</id>
    <published>2017-08-20T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。</p><a id="more"></a><p>先来看一个 HelloWorld.java 程序。这个程序在屏幕上打印出一串字符”Hello World!”:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序中包括Java的一些基本特征：</p><ul><li>类(class)：上面程序定义了一个 类 HelloWorld，该类的名字与.java文件的名字相同。</li><li>方法(method)：类的内部定义了该类的一个 方法 main。</li><li>语句(statement)：真正的“打印”功能由一个语句实现，即: System.out.println(“Hello World!”);</li></ul><p>下面两点有关Java的书写方式：</p><ul><li>Java中的语句要以 ; 结尾 (与C/C++相同)。</li><li>用花括号 {} 来整合语句，形成程序块。通过程序块，我们可以知道程序的不同部分的范围，比如类从哪里开始，到哪里结束。</li></ul><h2 id="一、编译与运行"><a href="#一、编译与运行" class="headerlink" title="一、编译与运行"></a>一、编译与运行</h2><p>Java程序要经过编译器编译才能执行。在Linux或Mac下，可以下载安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads" target="_blank" rel="noopener">Java JDK</a></p><p>使用 javac 来编译。在命令行中输入下面语句 编译 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$javac HelloWorld.java</div></pre></td></tr></table></figure><p>当前路径下，将有一个名为HelloWorld.class的文件生成。<br>使用 java 命令来 运行 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$java HelloWorld</div></pre></td></tr></table></figure><p>Java会搜寻该类中的main方法，并执行。</p><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p>计算机语言通常需要在内存中存放数据，比如C语言中的变量，Java也有类似的变量。Java和C语言都是静态类型的语言。在使用变量之前，要声明变量的类型。</p><p>变量(variable) 占据一定的内存空间。不同类型的变量占据不同的大小。Java中的变量类型如下：</p><div class="table-container"><table><thead><tr><th>变量类型</th><th>存储大小</th><th>例值</th><th>注释</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>3</td><td>字节</td></tr><tr><td>int</td><td>4bytes</td><td>3</td><td>整数</td></tr><tr><td>short</td><td>2bytes</td><td>3</td><td>短整数</td></tr><tr><td>long</td><td>8bytes</td><td>3</td><td>长整数</td></tr><tr><td>float</td><td>4bytes</td><td>1.2</td><td>单精度浮点数</td></tr><tr><td>double</td><td>8bytes</td><td>1.2</td><td>双精度浮点数</td></tr><tr><td>char</td><td>2bytes</td><td>‘a’</td><td>字符</td></tr><tr><td>boolean</td><td>1bit</td><td>true</td><td>布尔值</td></tr></tbody></table></div><p>在Java中，变量需要先 声明(declare)才能使用。在声明中，我说明变量的类型，赋予变量以特别名字，以便在后面的程序中调用它。你可以在程序中的任意位置声明变量。 比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        a = <span class="number">5</span>;</div><div class="line">        System.out.println(a);  <span class="comment">// print an integer</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面a是变量名。可以在声明变量的同时，给变量赋值，比如 int a = 5;</p><ul><li>“变量”的概念实际上来自于面向过程的编程语言。在Java中，所谓的变量实际上是 “基本类型” (premitive type) 。我们将在类的讲解中更多深入。</li></ul><p>上面的程序还可以看到，Java中，可用 // 引领注释。</p><h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><p>Java中有 数组(array) 。数组包含相同类型的多个数据。我用下面方法来声明一个整数数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a;</div></pre></td></tr></table></figure><p>在声明数组时，数组所需的空间并没有真正分配给数组。我可以在声明的同时，用new来创建数组所需空间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a = new int[100];</div></pre></td></tr></table></figure><p>这里创建了可以容纳100个整数的数组。相应的内存分配也完成了。</p><p>我还可以在声明的同时，给数组赋值。数组的大小也同时确定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a = new int[] &#123;1, 3, 5, 7, 9&#125;;</div></pre></td></tr></table></figure><h3 id="2-1-数组初始化"><a href="#2-1-数组初始化" class="headerlink" title="2.1 数组初始化"></a>2.1 数组初始化</h3><p>你可以在声明数组的同时进行初始化（静态初始化），也可以在声明以后进行初始化（动态初始化）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 静态初始化</div><div class="line">// 静态初始化的同时就为数组元素分配空间并赋值</div><div class="line">int intArray[] = &#123;1,2,3,4&#125;;</div><div class="line">String stringArray[] = &#123;&quot;程序员&quot;, &quot;http://www.baidu.com&quot;, &quot;一切编程语言都是纸老虎&quot;&#125;;</div><div class="line"></div><div class="line">// 动态初始化</div><div class="line">float floatArray[] = new float[3];</div><div class="line">floatArray[0] = 1.0f;</div><div class="line">floatArray[1] = 132.63f;</div><div class="line">floatArray[2] = 100F;</div></pre></td></tr></table></figure><h3 id="2-2-数组引用"><a href="#2-2-数组引用" class="headerlink" title="2.2 数组引用"></a>2.2 数组引用</h3><p>可以通过下标来引用数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName[index];</div></pre></td></tr></table></figure><p>index从0开始。与C、C++不同，Java对数组元素要进行越界检查以保证安全性。</p><p>每个数组都有一个length属性来指明它的长度，例如 intArray.length 指明数组 intArray 的长度。</p><p>其他类型的数组与整数数组相似。</p><h3 id="2-3-数组的遍历"><a href="#2-3-数组的遍历" class="headerlink" title="2.3 数组的遍历"></a>2.3 数组的遍历</h3><p>实际开发中，经常需要遍历数组以获取数组中的每一个元素。最容易想到的方法是for循环，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int arrayDemo[] = &#123;1, 2, 4, 7, 9, 192, 100&#125;;</div><div class="line">for(int i=0,len=arrayDemo.length; i&lt;len; i++)&#123;</div><div class="line">    System.out.println(arrayDemo[i] + &quot;, &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，Java提供了”增强版“的for循环，专门用来遍历数组，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for( arrayType varName: arrayName )&#123;</div><div class="line">    // Some Code</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>arrayType 为数组类型（也是数组元素的类型）；varName 是用来保存当前元素的变量，每次循环它的值都会改变；arrayName 为数组名称。</p><p>每循环一次，就会获取数组中下一个元素的值，保存到 varName 变量，直到数组结束。即，第一次循环 varName 的值为第0个元素，第二次循环为第1个元素……例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int arrayDemo[] = &#123;1, 2, 4, 7, 9, 192, 100&#125;;</div><div class="line">for(int x: arrayDemo)&#123;</div><div class="line">    System.out.println(x + &quot;, &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种增强版的for循环也被称为”foreach循环“，它是普通for循环语句的特殊简化版。所有的foreach循环都可以被改写成for循环。</p><p>但是，如果你希望使用数组的索引，那么增强版的 for 循环无法做到。</p><h3 id="2-4-二维数组"><a href="#2-4-二维数组" class="headerlink" title="2.4 二维数组"></a>2.4 二维数组</h3><p>二维数组的声明、初始化和引用与一维数组相似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int intArray[ ][ ] = &#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;4,5&#125; &#125;;</div><div class="line">int a[ ][ ] = new int[2][3];</div><div class="line">a[0][0] = 12;</div><div class="line">a[0][1] = 34;</div><div class="line">// ......</div><div class="line">a[1][2] = 93;</div></pre></td></tr></table></figure><p>Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int intArray[ ][ ] = &#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;3,4,5&#125; &#125;;</div><div class="line">int a[ ][ ] = new int[2][ ];</div><div class="line">a[0] = new int[3];</div><div class="line">a[1] = new int[5];</div></pre></td></tr></table></figure><p>【示例】通过二维数组计算两个矩阵的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 第一个矩阵（动态初始化一个二维数组）</span></div><div class="line">        <span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</div><div class="line">        <span class="comment">// 第二个矩阵（静态初始化一个二维数组）</span></div><div class="line">        <span class="keyword">int</span> b[][] = &#123; &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>&#125;, &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,-<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">18</span>&#125; &#125;;</div><div class="line">        <span class="comment">// 结果矩阵</span></div><div class="line">        <span class="keyword">int</span> c[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>];</div><div class="line">       </div><div class="line">        <span class="comment">// 初始化第一个矩阵</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span> ;j++)</div><div class="line">                a[i][j] = (i+<span class="number">1</span>) * (j+<span class="number">2</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 计算矩阵乘积</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</div><div class="line">                c[i][j]=<span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++)</div><div class="line">                    c[i][j] += a[i][k] * b[k][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 输出结算结果</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</div><div class="line">                System.out.printf(<span class="string">"%-5d"</span>, c[i][j]);</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">25   65   14   -65</div><div class="line">50   130  28   -130</div></pre></td></tr></table></figure><blockquote><p>几点说明</p></blockquote><ul><li>上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。</li><li>如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。</li><li>正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。</li></ul><h2 id="三、表达式"><a href="#三、表达式" class="headerlink" title="三、表达式"></a>三、表达式</h2><p>表达式 是变量、常量和运算符的组合，它表示一个数据。 1 + 1 是常见的表达式。再比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        a = <span class="number">5</span> + <span class="number">1</span>;</div><div class="line">        System.out.println(a);  <span class="comment">// print an integer</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的5 + 1也是一个表达式，等于6。</p><h3 id="3-1-数学表达式"><a href="#3-1-数学表达式" class="headerlink" title="3.1 数学表达式"></a>3.1 数学表达式</h3><p>数学运算，结果为一个数值</p><div class="table-container"><table><thead><tr><th>1 + 2</th><th>加法</th></tr></thead><tbody><tr><td>4 - 3.4</td><td>减法</td></tr><tr><td>7 * 1.5</td><td>乘法</td></tr><tr><td>3.5 / 7</td><td>除法</td></tr><tr><td>7 % 2</td><td>求余数</td></tr></tbody></table></div><h3 id="3-2-关系表达式"><a href="#3-2-关系表达式" class="headerlink" title="3.2 关系表达式"></a>3.2 关系表达式</h3><p>判断表达式是否成立。即一个boolean值，真假</p><div class="table-container"><table><thead><tr><th>a &gt; 4.2</th><th>大于</th></tr></thead><tbody><tr><td>3.4 &gt;= b</td><td>大于等于</td></tr><tr><td>1.5 &lt; 9</td><td>小于</td></tr><tr><td>6 &lt;= 1</td><td>小于等于</td></tr><tr><td>2 == 2</td><td>等于</td></tr><tr><td>2 != 2</td><td>不等于</td></tr></tbody></table></div><h3 id="3-3-布林表达式"><a href="#3-3-布林表达式" class="headerlink" title="3.3 布林表达式"></a>3.3 布林表达式</h3><p>两个boolean值的与、或、非的逻辑关系</p><div class="table-container"><table><thead><tr><th>true &amp;&amp; false</th><th>and</th></tr></thead><tbody><tr><td>(3 &gt; 1)</td><td></td><td>(2 == 1)</td><td>or</td></tr><tr><td>! true</td><td>not</td></tr></tbody></table></div><h3 id="3-4-位运算"><a href="#3-4-位运算" class="headerlink" title="3.4 位运算"></a>3.4 位运算</h3><p>对整数的二进制形式逐位进行逻辑运算，得到一个整数</p><div class="table-container"><table><thead><tr><th>&amp;</th><th>and</th></tr></thead><tbody><tr><td></td><td></td><td>or</td></tr><tr><td>^</td><td>xor</td></tr><tr><td>~</td><td>not</td></tr><tr><td>5 &lt;&lt; 3</td><td>0b101 left shift 3 bits</td></tr><tr><td>6 &gt;&gt; 1</td><td>0b110 right shift 1 bit</td></tr></tbody></table></div><p>还有下列在C中常见的运算符，我会在用到的时候进一步解释:</p><div class="table-container"><table><thead><tr><th>m ++</th><th>变量m加1</th></tr></thead><tbody><tr><td>n —</td><td>变量n减1</td></tr><tr><td>condition ? x1 : x2</td><td>condition为一个boolean值。根据condition，取x1或x2的值</td></tr></tbody></table></div><h2 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h2><p>Java中控制结构(control flow)的语法与C类似。它们都使用{}来表达隶属关系。</p><h3 id="4-1-选择（if）"><a href="#4-1-选择（if）" class="headerlink" title="4.1 选择（if）"></a>4.1 选择（if）</h3><p>condition是一个表示真假值的表达式。statements;是语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (conditon1) &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-循环（while）"><a href="#4-2-循环（while）" class="headerlink" title="4.2 循环（while）"></a>4.2 循环（while）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">while (condition) &#123;</div><div class="line"></div><div class="line">statements;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-循环（do…while）"><a href="#4-2-循环（do…while）" class="headerlink" title="4.2 循环（do…while）"></a>4.2 循环（do…while）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">statements;</div><div class="line">&#125;<span class="keyword">while</span>(condition);  <span class="comment">// 注意结尾的;</span></div></pre></td></tr></table></figure><h3 id="4-3-循环（for）"><a href="#4-3-循环（for）" class="headerlink" title="4.3 循环（for）"></a>4.3 循环（for）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (initial; condition; update) &#123;</div><div class="line">statements;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-4-跳出或跳出循环"><a href="#4-4-跳出或跳出循环" class="headerlink" title="4.4 跳出或跳出循环"></a>4.4 跳出或跳出循环</h3><p>在循环中，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">break</span>; <span class="comment">// 跳出循环</span></div><div class="line"><span class="keyword">continue</span>; <span class="comment">// 直接进入下一循环</span></div></pre></td></tr></table></figure><h3 id="4-5-选择（switch）"><a href="#4-5-选择（switch）" class="headerlink" title="4.5 选择（switch）"></a>4.5 选择（switch）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(expression) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line">...</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><p>从表面上看，字符串就是双引号之间的数据，例如“java”等。在Java中，可以使用下面的方法定义字符串：<br>String stringName = “string content”;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String webName = &quot;java学习&quot;;</div></pre></td></tr></table></figure><p>字符串可以通过“+”连接，基本数据类型与字符串进行“+”操作一般也会自动转换为字符串，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String stuName = <span class="string">"小明"</span>;</div><div class="line">        <span class="keyword">int</span> stuAge = <span class="number">17</span>;</div><div class="line">        <span class="keyword">float</span> stuScore = <span class="number">92.5f</span>;</div><div class="line">       </div><div class="line">        String info = stuName + <span class="string">"的年龄是 "</span> + stuAge + <span class="string">"，成绩是 "</span> + stuScore;</div><div class="line">        System.out.println(info);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>String字符串与数组有一个共同点，就是它们被初始化后，长度是不变的，并且内容也不变。如果要改变它的值，就会产生一个新的字符串，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Hello &quot;;</div><div class="line">str += &quot;World!&quot;;</div></pre></td></tr></table></figure><p>这个赋值表达式看起来有点像简单的接龙，在str后面直接加上一个“World!”字符串，形成最后的字符串“Hello World!”。其运行原理是这样的：程序首先产生了str1字符串，并在内存中申请了一段空间。此时要追加新的字符串是不可能的，因为字符串被初始化后，长度是固定的。如果要改变它，只有放弃原来的空间，重新申请能够容纳“Hello World!”字符串的内存空间，然后将“Hello World!”字符串放到内存中。</p><p>实际上，String 是java.lang包下的一个类，按照标准的面向对象的语法，其格式应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String stringName = new String(&quot;string content&quot;);</div></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String url = new String(&quot;http://www.baidu.com&quot;);</div></pre></td></tr></table></figure><p>但是由于String特别常用，所以Java提供了一种简化的语法。</p><p>使用简化语法的另外一个原因是，按照标准的面向对象的语法，在内存使用上存在比较大的浪费。例如String str = new String(“abc”);实际上创建了两个String对象，一个是”abc”对象，存储在常量空间中，一个是使用new关键字为对象str申请的空间。</p><h3 id="5-1-常用的String对象方法"><a href="#5-1-常用的String对象方法" class="headerlink" title="5.1 常用的String对象方法"></a>5.1 常用的String对象方法</h3><h4 id="5-1-2-length-方法"><a href="#5-1-2-length-方法" class="headerlink" title="5.1.2 length()方法"></a>5.1.2 length()方法</h4><p>length() 返回字符串的长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str1 = &quot;微学苑&quot;;</div><div class="line">String str2 = &quot;weixueyuan&quot;;</div><div class="line">System.out.println(&quot;The lenght of str1 is &quot; + str1.length());</div><div class="line">System.out.println(&quot;The lenght of str2 is &quot; + str2.length());</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The lenght of str1 is 3</div><div class="line">The lenght of str2 is 10</div></pre></td></tr></table></figure><h4 id="5-1-2-charAt-方法"><a href="#5-1-2-charAt-方法" class="headerlink" title="5.1.2 charAt()方法"></a>5.1.2 charAt()方法</h4><p>charAt() 方法的作用是按照索引值获得字符串中的指定字符。Java规定，字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;123456789&quot;;</div><div class="line">System.out.println(str.charAt(0) + &quot;    &quot; + str.charAt(5) + &quot;    &quot; + str.charAt(8))</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1    6    9</div></pre></td></tr></table></figure><h4 id="5-1-3-contain-方法"><a href="#5-1-3-contain-方法" class="headerlink" title="5.1.3 contain()方法"></a>5.1.3 contain()方法</h4><p>contains() 方法用来检测字符串是否包含某个子串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;baidu&quot;;</div><div class="line">System.out.println(str.contains(&quot;bai&quot;));</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">true</div></pre></td></tr></table></figure><h4 id="5-1-4-replace-方法"><a href="#5-1-4-replace-方法" class="headerlink" title="5.1.4 replace()方法"></a>5.1.4 replace()方法</h4><p>字符串替换，用来替换字符串中所有指定的子串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ring str1 = &quot;The url of baidu is www.google.com!&quot;;</div><div class="line">String str2 = str1.replace(&quot;baidu&quot;, &quot;google&quot;);</div><div class="line">System.out.println(str1);</div><div class="line">System.out.println(str2);</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The url of baidu is www.google.com!</div><div class="line">The url of google is www.google.com!</div></pre></td></tr></table></figure><p>注意：replace() 方法不会改变原来的字符串，而是生成一个新的字符串。</p><h4 id="5-1-5-split-方法"><a href="#5-1-5-split-方法" class="headerlink" title="5.1.5 split()方法"></a>5.1.5 split()方法</h4><p>以指定字符串作为分隔符，对当前字符串进行分割，分割的结果是一个数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        String str = &quot;wei_xue_yuan_is_good&quot;;</div><div class="line">        String strArr[] = str.split(&quot;_&quot;);</div><div class="line">        System.out.println(Arrays.toString(strArr));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[wei, xue, yuan, is, good]</div></pre></td></tr></table></figure><p>以上仅仅列举了几个常用的String对象的方法，更多方法和详细解释请参考API文档。</p><h3 id="5-2-StringBuffer与StringBuider"><a href="#5-2-StringBuffer与StringBuider" class="headerlink" title="5.2 StringBuffer与StringBuider"></a>5.2 StringBuffer与StringBuider</h3><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p><p>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</p><p>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。</p><p>StringBuffer不像String，只能通过 new 来创建对象，不支持简写方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuffer str1 = new StringBuffer();  // 分配16个字节长度的缓冲区</div><div class="line">StringBuffer str2 = =new StringBuffer(512);  // 分配512个字节长度的缓冲区</div><div class="line">// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区</div><div class="line">StringBuffer str3 = new StringBuffer(&quot;www.baidu.com&quot;);</div></pre></td></tr></table></figure><h4 id="5-2-1-StringBuffer类的主要方法"><a href="#5-2-1-StringBuffer类的主要方法" class="headerlink" title="5.2.1 StringBuffer类的主要方法"></a>5.2.1 StringBuffer类的主要方法</h4><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p><ul><li>1) append() 方法</li></ul><p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(“biancheng100”);</div><div class="line">str.append(true);</div></pre></td></tr></table></figure><p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p><p>字符串的”+“操作实际上也是先创建一个StringBuffer对象，然后调用append()方法将字符串片段拼接起来，最后调用toString()方法转换为字符串。</p><p>这样看来，String的连接操作就比StringBuffer多出了一些附加操作，效率上必然会打折扣。</p><p>但是，对于长度较小的字符串，”+“操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率。</p><ul><li>2) deleteCharAt()</li></ul><p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str. deleteCharAt(3);</div></pre></td></tr></table></figure><p>该代码将会删除索引值为3的字符，即”d“字符。</p><p>你也可以通过delete()方法一次性删除多个字符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StingBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.delete(1, 4);</div></pre></td></tr></table></figure><p>该代码会删除索引值为1~4之间的字符，包括索引值1，但不包括4。</p><ul><li>3) insert()方法</li></ul><p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.insert(3, &quot;xyz&quot;);</div></pre></td></tr></table></figure><p>最后str所指向的字符串为 abcdxyzef。</p><ul><li>4) setCharAt() 方法</li></ul><p>setCharAt() 方法用来修改指定位置的字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.setCharAt(3, &apos;z&apos;);</div></pre></td></tr></table></figure><p>该代码将把索引值为3的字符修改为 z，最后str所指向的字符串为 abczef。</p><p>以上仅仅是部分常用方法的简单说明，更多方法和解释请查阅API文档。</p><h4 id="5-2-2-String和StringBuffer的效率对比"><a href="#5-2-2-String和StringBuffer的效率对比" class="headerlink" title="5.2.2 String和StringBuffer的效率对比"></a>5.2.2 String和StringBuffer的效率对比</h4><p>为了更加明显地看出它们的执行效率，下面的代码，将26个英文字母加了10000次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String fragment = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">10000</span>;</div><div class="line">       </div><div class="line">        <span class="comment">// 通过String对象</span></div><div class="line">        <span class="keyword">long</span> timeStart1 = System.currentTimeMillis();</div><div class="line">        String str1 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str1 += fragment;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd1 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"String: "</span> + (timeEnd1 - timeStart1) + <span class="string">"ms"</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 通过StringBuffer</span></div><div class="line">        <span class="keyword">long</span> timeStart2 = System.currentTimeMillis();</div><div class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str2.append(fragment);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (timeEnd2 - timeStart2) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 5287ms</div><div class="line">StringBuffer: 3ms</div></pre></td></tr></table></figure><p>结论很明显，StringBuffer的执行效率比String快上千倍，这个差异随着叠加次数的增加越来越明显，当叠加次数达到30000次的时候，运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 35923ms</div><div class="line">StringBuffer: 8ms</div></pre></td></tr></table></figure><p>所以，强烈建议在涉及大量字符串操作时使用StringBuffer。</p><h4 id="5-2-3-StringBuilder类"><a href="#5-2-3-StringBuilder类" class="headerlink" title="5.2.3 StringBuilder类"></a>5.2.3 StringBuilder类</h4><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p><p>StringBuffer、StringBuilder、String中都实现了CharSequence接口。CharSequence是一个定义字符串操作的接口，它只包括length()、charAt(int index)、subSequence(int start, int end) 这几个API。</p><p>StringBuffer、StringBuilder、String对CharSequence接口的实现过程不一样，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15024502085934.png" alt=""></p><p>可见，String直接实现了CharSequence接口；StringBuilder 和 StringBuffer都是可变的字符序列，它们都继承于AbstractStringBuilder，实现了CharSequence接口。</p><p>总结一下：</p><ul><li>线程安全：<ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul></li><li><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul></li><li><p>使用环境：</p><ul><li>操作少量的数据使用 String；</li><li>单线程操作大量数据使用 StringBuilder；</li><li>多线程操作大量数据使用 StringBuffer。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（11）：Java HashMap源码全剖析</title>
    <link href="http://yoursite.com/2017/08/19/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%8811%EF%BC%89%EF%BC%9AJava%20HashMap%E6%BA%90%E7%A0%81%E5%85%A8%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/19/Java集合学习手册（11）：Java HashMap源码全剖析/</id>
    <published>2017-08-19T14:20:45.000Z</published>
    <updated>2018-11-05T16:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap简介 HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。</p><a id="more"></a><p>HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。</p><p>HashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</p><h2 id="一、HashMap源码剖析"><a href="#一、HashMap源码剖析" class="headerlink" title="一、HashMap源码剖析"></a>一、HashMap源码剖析</h2><p>HashMap的源码如下（加入了比较详细的注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div></pre></td><td class="code"><pre><div class="line">package java.util;    </div><div class="line">import java.io.*;    </div><div class="line">   </div><div class="line">public class HashMap&lt;K,V&gt;    </div><div class="line">    extends AbstractMap&lt;K,V&gt;    </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable    </div><div class="line">&#123;    </div><div class="line">   </div><div class="line">    // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。    </div><div class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16;    </div><div class="line">   </div><div class="line">    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）    </div><div class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    </div><div class="line">   </div><div class="line">    // 默认加载因子为0.75   </div><div class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;    </div><div class="line">   </div><div class="line">    // 存储数据的Entry数组，长度是2的幂。    </div><div class="line">    // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表    </div><div class="line">    transient Entry[] table;    </div><div class="line">   </div><div class="line">    // HashMap的底层数组中已用槽的数量    </div><div class="line">    transient int size;    </div><div class="line">   </div><div class="line">    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    </div><div class="line">    int threshold;    </div><div class="line">   </div><div class="line">    // 加载因子实际大小    </div><div class="line">    final float loadFactor;    </div><div class="line">   </div><div class="line">    // HashMap被改变的次数    </div><div class="line">    transient volatile int modCount;    </div><div class="line">   </div><div class="line">    // 指定“容量大小”和“加载因子”的构造函数    </div><div class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;    </div><div class="line">        if (initialCapacity &lt; 0)    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +    </div><div class="line">                                               initialCapacity);    </div><div class="line">        // HashMap的最大容量只能是MAXIMUM_CAPACITY    </div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)    </div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;    </div><div class="line">        //加载因此不能小于0  </div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +    </div><div class="line">                                               loadFactor);    </div><div class="line">   </div><div class="line">        // 找出“大于initialCapacity”的最小的2的幂    </div><div class="line">        int capacity = 1;    </div><div class="line">        while (capacity &lt; initialCapacity)    </div><div class="line">            capacity &lt;&lt;= 1;    </div><div class="line">   </div><div class="line">        // 设置“加载因子”    </div><div class="line">        this.loadFactor = loadFactor;    </div><div class="line">        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    </div><div class="line">        threshold = (int)(capacity * loadFactor);    </div><div class="line">        // 创建Entry数组，用来保存数据    </div><div class="line">        table = new Entry[capacity];    </div><div class="line">        init();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 指定“容量大小”的构造函数    </div><div class="line">    public HashMap(int initialCapacity) &#123;    </div><div class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 默认构造函数。    </div><div class="line">    public HashMap() &#123;    </div><div class="line">        // 设置“加载因子”为默认加载因子0.75    </div><div class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR;    </div><div class="line">        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    </div><div class="line">        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);    </div><div class="line">        // 创建Entry数组，用来保存数据    </div><div class="line">        table = new Entry[DEFAULT_INITIAL_CAPACITY];    </div><div class="line">        init();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 包含“子Map”的构造函数    </div><div class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,    </div><div class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);    </div><div class="line">        // 将m中的全部元素逐个添加到HashMap中    </div><div class="line">        putAllForCreate(m);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    //求hash值的方法，重新计算hash值  </div><div class="line">    static int hash(int h) &#123;    </div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    </div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率   </div><div class="line">    // h &amp; (length-1)保证返回值的小于length    </div><div class="line">    static int indexFor(int h, int length) &#123;    </div><div class="line">        return h &amp; (length-1);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    public int size() &#123;    </div><div class="line">        return size;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    public boolean isEmpty() &#123;    </div><div class="line">        return size == 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取key对应的value    </div><div class="line">    public V get(Object key) &#123;    </div><div class="line">        if (key == null)    </div><div class="line">            return getForNullKey();    </div><div class="line">        // 获取key的hash值    </div><div class="line">        int hash = hash(key.hashCode());    </div><div class="line">        // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">             e != null;    </div><div class="line">             e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            //判断key是否相同  </div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))    </div><div class="line">                return e.value;    </div><div class="line">        &#125;  </div><div class="line">        //没找到则返回null  </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取“key为null”的元素的值    </div><div class="line">    // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    </div><div class="line">    private V getForNullKey() &#123;    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">            if (e.key == null)    </div><div class="line">                return e.value;    </div><div class="line">        &#125;    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashMap是否包含key    </div><div class="line">    public boolean containsKey(Object key) &#123;    </div><div class="line">        return getEntry(key) != null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“键为key”的键值对    </div><div class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;    </div><div class="line">        // 获取哈希值    </div><div class="line">        // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">             e != null;    </div><div class="line">             e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))    </div><div class="line">                return e;    </div><div class="line">        &#125;    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将“key-value”添加到HashMap中    </div><div class="line">    public V put(K key, V value) &#123;    </div><div class="line">        // 若“key为null”，则将该键值对添加到table[0]中。    </div><div class="line">        if (key == null)    </div><div class="line">            return putForNullKey(value);    </div><div class="line">        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    </div><div class="line">        int hash = hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    </div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </div><div class="line">                V oldValue = e.value;    </div><div class="line">                e.value = value;    </div><div class="line">                e.recordAccess(this);    </div><div class="line">                return oldValue;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    </div><div class="line">        modCount++;  </div><div class="line">        //将key-value添加到table[i]处  </div><div class="line">        addEntry(hash, key, value, i);    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    </div><div class="line">    private V putForNullKey(V value) &#123;    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">            if (e.key == null) &#123;    </div><div class="line">                V oldValue = e.value;    </div><div class="line">                e.value = value;    </div><div class="line">                e.recordAccess(this);    </div><div class="line">                return oldValue;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    </div><div class="line">        modCount++;    </div><div class="line">        addEntry(0, null, value, 0);    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建HashMap对应的“添加方法”，    </div><div class="line">    // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap    </div><div class="line">    // 而put()是对外提供的往HashMap中添加元素的方法。    </div><div class="line">    private void putForCreate(K key, V value) &#123;    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">   </div><div class="line">        // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;    </div><div class="line">                e.value = value;    </div><div class="line">                return;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中    </div><div class="line">        createEntry(hash, key, value, i);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将“m”中的全部元素都添加到HashMap中。    </div><div class="line">    // 该方法被内部的构造HashMap的方法所调用。    </div><div class="line">    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        // 利用迭代器将元素逐个添加到HashMap中    </div><div class="line">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;    </div><div class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();    </div><div class="line">            putForCreate(e.getKey(), e.getValue());    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 重新调整HashMap的大小，newCapacity是调整后的容量    </div><div class="line">    void resize(int newCapacity) &#123;    </div><div class="line">        Entry[] oldTable = table;    </div><div class="line">        int oldCapacity = oldTable.length;   </div><div class="line">        //如果就容量已经达到了最大值，则不能再扩容，直接返回  </div><div class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;    </div><div class="line">            threshold = Integer.MAX_VALUE;    </div><div class="line">            return;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    </div><div class="line">        // 然后，将“新HashMap”赋值给“旧HashMap”。    </div><div class="line">        Entry[] newTable = new Entry[newCapacity];    </div><div class="line">        transfer(newTable);    </div><div class="line">        table = newTable;    </div><div class="line">        threshold = (int)(newCapacity * loadFactor);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将HashMap中的全部元素都添加到newTable中    </div><div class="line">    void transfer(Entry[] newTable) &#123;    </div><div class="line">        Entry[] src = table;    </div><div class="line">        int newCapacity = newTable.length;    </div><div class="line">        for (int j = 0; j &lt; src.length; j++) &#123;    </div><div class="line">            Entry&lt;K,V&gt; e = src[j];    </div><div class="line">            if (e != null) &#123;    </div><div class="line">                src[j] = null;    </div><div class="line">                do &#123;    </div><div class="line">                    Entry&lt;K,V&gt; next = e.next;    </div><div class="line">                    int i = indexFor(e.hash, newCapacity);    </div><div class="line">                    e.next = newTable[i];    </div><div class="line">                    newTable[i] = e;    </div><div class="line">                    e = next;    </div><div class="line">                &#125; while (e != null);    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将&quot;m&quot;的全部元素都添加到HashMap中    </div><div class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        // 有效性判断    </div><div class="line">        int numKeysToBeAdded = m.size();    </div><div class="line">        if (numKeysToBeAdded == 0)    </div><div class="line">            return;    </div><div class="line">   </div><div class="line">        // 计算容量是否足够，    </div><div class="line">        // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。    </div><div class="line">        if (numKeysToBeAdded &gt; threshold) &#123;    </div><div class="line">            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);    </div><div class="line">            if (targetCapacity &gt; MAXIMUM_CAPACITY)    </div><div class="line">                targetCapacity = MAXIMUM_CAPACITY;    </div><div class="line">            int newCapacity = table.length;    </div><div class="line">            while (newCapacity &lt; targetCapacity)    </div><div class="line">                newCapacity &lt;&lt;= 1;    </div><div class="line">            if (newCapacity &gt; table.length)    </div><div class="line">                resize(newCapacity);    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 通过迭代器，将“m”中的元素逐个添加到HashMap中。    </div><div class="line">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;    </div><div class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();    </div><div class="line">            put(e.getKey(), e.getValue());    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键为key”元素    </div><div class="line">    public V remove(Object key) &#123;    </div><div class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);    </div><div class="line">        return (e == null ? null : e.value);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键为key”的元素    </div><div class="line">    final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;    </div><div class="line">        // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        Entry&lt;K,V&gt; prev = table[i];    </div><div class="line">        Entry&lt;K,V&gt; e = prev;    </div><div class="line">   </div><div class="line">        // 删除链表中“键为key”的元素    </div><div class="line">        // 本质是“删除单向链表中的节点”    </div><div class="line">        while (e != null) &#123;    </div><div class="line">            Entry&lt;K,V&gt; next = e.next;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;    </div><div class="line">                modCount++;    </div><div class="line">                size--;    </div><div class="line">                if (prev == e)    </div><div class="line">                    table[i] = next;    </div><div class="line">                else   </div><div class="line">                    prev.next = next;    </div><div class="line">                e.recordRemoval(this);    </div><div class="line">                return e;    </div><div class="line">            &#125;    </div><div class="line">            prev = e;    </div><div class="line">            e = next;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        return e;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键值对”    </div><div class="line">    final Entry&lt;K,V&gt; removeMapping(Object o) &#123;    </div><div class="line">        if (!(o instanceof Map.Entry))    </div><div class="line">            return null;    </div><div class="line">   </div><div class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;    </div><div class="line">        Object key = entry.getKey();    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        Entry&lt;K,V&gt; prev = table[i];    </div><div class="line">        Entry&lt;K,V&gt; e = prev;    </div><div class="line">   </div><div class="line">        // 删除链表中的“键值对e”    </div><div class="line">        // 本质是“删除单向链表中的节点”    </div><div class="line">        while (e != null) &#123;    </div><div class="line">            Entry&lt;K,V&gt; next = e.next;    </div><div class="line">            if (e.hash == hash &amp;&amp; e.equals(entry)) &#123;    </div><div class="line">                modCount++;    </div><div class="line">                size--;    </div><div class="line">                if (prev == e)    </div><div class="line">                    table[i] = next;    </div><div class="line">                else   </div><div class="line">                    prev.next = next;    </div><div class="line">                e.recordRemoval(this);    </div><div class="line">                return e;    </div><div class="line">            &#125;    </div><div class="line">            prev = e;    </div><div class="line">            e = next;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        return e;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 清空HashMap，将所有的元素设为null    </div><div class="line">    public void clear() &#123;    </div><div class="line">        modCount++;    </div><div class="line">        Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length; i++)    </div><div class="line">            tab[i] = null;    </div><div class="line">        size = 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 是否包含“值为value”的元素    </div><div class="line">    public boolean containsValue(Object value) &#123;    </div><div class="line">    // 若“value为null”，则调用containsNullValue()查找    </div><div class="line">    if (value == null)    </div><div class="line">            return containsNullValue();    </div><div class="line">   </div><div class="line">    // 若“value不为null”，则查找HashMap中是否有值为value的节点。    </div><div class="line">    Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)    </div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)    </div><div class="line">                if (value.equals(e.value))    </div><div class="line">                    return true;    </div><div class="line">    return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 是否包含null值    </div><div class="line">    private boolean containsNullValue() &#123;    </div><div class="line">    Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)    </div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)    </div><div class="line">                if (e.value == null)    </div><div class="line">                    return true;    </div><div class="line">    return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 克隆一个HashMap，并返回Object对象    </div><div class="line">    public Object clone() &#123;    </div><div class="line">        HashMap&lt;K,V&gt; result = null;    </div><div class="line">        try &#123;    </div><div class="line">            result = (HashMap&lt;K,V&gt;)super.clone();    </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;    </div><div class="line">            // assert false;    </div><div class="line">        &#125;    </div><div class="line">        result.table = new Entry[table.length];    </div><div class="line">        result.entrySet = null;    </div><div class="line">        result.modCount = 0;    </div><div class="line">        result.size = 0;    </div><div class="line">        result.init();    </div><div class="line">        // 调用putAllForCreate()将全部元素添加到HashMap中    </div><div class="line">        result.putAllForCreate(this);    </div><div class="line">   </div><div class="line">        return result;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Entry是单向链表。    </div><div class="line">    // 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    </div><div class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">        final K key;    </div><div class="line">        V value;    </div><div class="line">        // 指向下一个节点    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        final int hash;    </div><div class="line">   </div><div class="line">        // 构造函数。    </div><div class="line">        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">            value = v;    </div><div class="line">            next = n;    </div><div class="line">            key = k;    </div><div class="line">            hash = h;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final K getKey() &#123;    </div><div class="line">            return key;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V getValue() &#123;    </div><div class="line">            return value;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V setValue(V newValue) &#123;    </div><div class="line">            V oldValue = value;    </div><div class="line">            value = newValue;    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 判断两个Entry是否相等    </div><div class="line">        // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">        // 否则，返回false    </div><div class="line">        public final boolean equals(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry e = (Map.Entry)o;    </div><div class="line">            Object k1 = getKey();    </div><div class="line">            Object k2 = e.getKey();    </div><div class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">                Object v1 = getValue();    </div><div class="line">                Object v2 = e.getValue();    </div><div class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                    return true;    </div><div class="line">            &#125;    </div><div class="line">            return false;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 实现hashCode()    </div><div class="line">        public final int hashCode() &#123;    </div><div class="line">            return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">                   (value==null ? 0 : value.hashCode());    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final String toString() &#123;    </div><div class="line">            return getKey() + &quot;=&quot; + getValue();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当从HashMap中删除元素时，绘调用recordRemoval()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    </div><div class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">        // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">        // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">        // 设置“e”为“新Entry的下一个节点”    </div><div class="line">        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    </div><div class="line">        if (size++ &gt;= threshold)    </div><div class="line">            resize(2 * table.length);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建Entry。将“key-value”插入指定位置。    </div><div class="line">    void createEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">        // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">        // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">        // 设置“e”为“新Entry的下一个节点”    </div><div class="line">        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">        size++;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。    </div><div class="line">    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。    </div><div class="line">    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;    </div><div class="line">        // 下一个元素    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        // expectedModCount用于实现fast-fail机制。    </div><div class="line">        int expectedModCount;    </div><div class="line">        // 当前索引    </div><div class="line">        int index;    </div><div class="line">        // 当前元素    </div><div class="line">        Entry&lt;K,V&gt; current;    </div><div class="line">   </div><div class="line">        HashIterator() &#123;    </div><div class="line">            expectedModCount = modCount;    </div><div class="line">            if (size &gt; 0) &#123; // advance to first entry    </div><div class="line">                Entry[] t = table;    </div><div class="line">                // 将next指向table中第一个不为null的元素。    </div><div class="line">                // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。    </div><div class="line">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)    </div><div class="line">                    ;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final boolean hasNext() &#123;    </div><div class="line">            return next != null;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 获取下一个元素    </div><div class="line">        final Entry&lt;K,V&gt; nextEntry() &#123;    </div><div class="line">            if (modCount != expectedModCount)    </div><div class="line">                throw new ConcurrentModificationException();    </div><div class="line">            Entry&lt;K,V&gt; e = next;    </div><div class="line">            if (e == null)    </div><div class="line">                throw new NoSuchElementException();    </div><div class="line">   </div><div class="line">            // 注意！！！    </div><div class="line">            // 一个Entry就是一个单向链表    </div><div class="line">            // 若该Entry的下一个节点不为空，就将next指向下一个节点;    </div><div class="line">            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。    </div><div class="line">            if ((next = e.next) == null) &#123;    </div><div class="line">                Entry[] t = table;    </div><div class="line">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)    </div><div class="line">                    ;    </div><div class="line">            &#125;    </div><div class="line">            current = e;    </div><div class="line">            return e;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 删除当前元素    </div><div class="line">        public void remove() &#123;    </div><div class="line">            if (current == null)    </div><div class="line">                throw new IllegalStateException();    </div><div class="line">            if (modCount != expectedModCount)    </div><div class="line">                throw new ConcurrentModificationException();    </div><div class="line">            Object k = current.key;    </div><div class="line">            current = null;    </div><div class="line">            HashMap.this.removeEntryForKey(k);    </div><div class="line">            expectedModCount = modCount;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // value的迭代器    </div><div class="line">    private final class ValueIterator extends HashIterator&lt;V&gt; &#123;    </div><div class="line">        public V next() &#123;    </div><div class="line">            return nextEntry().value;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // key的迭代器    </div><div class="line">    private final class KeyIterator extends HashIterator&lt;K&gt; &#123;    </div><div class="line">        public K next() &#123;    </div><div class="line">            return nextEntry().getKey();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Entry的迭代器    </div><div class="line">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;    </div><div class="line">        public Map.Entry&lt;K,V&gt; next() &#123;    </div><div class="line">            return nextEntry();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回一个“key迭代器”    </div><div class="line">    Iterator&lt;K&gt; newKeyIterator()   &#123;    </div><div class="line">        return new KeyIterator();    </div><div class="line">    &#125;    </div><div class="line">    // 返回一个“value迭代器”    </div><div class="line">    Iterator&lt;V&gt; newValueIterator()   &#123;    </div><div class="line">        return new ValueIterator();    </div><div class="line">    &#125;    </div><div class="line">    // 返回一个“entry迭代器”    </div><div class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;    </div><div class="line">        return new EntryIterator();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashMap的Entry对应的集合    </div><div class="line">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;    </div><div class="line">   </div><div class="line">    // 返回“key的集合”，实际上返回一个“KeySet对象”    </div><div class="line">    public Set&lt;K&gt; keySet() &#123;    </div><div class="line">        Set&lt;K&gt; ks = keySet;    </div><div class="line">        return (ks != null ? ks : (keySet = new KeySet()));    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Key对应的集合    </div><div class="line">    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。    </div><div class="line">    private final class KeySet extends AbstractSet&lt;K&gt; &#123;    </div><div class="line">        public Iterator&lt;K&gt; iterator() &#123;    </div><div class="line">            return newKeyIterator();    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            return containsKey(o);    </div><div class="line">        &#125;    </div><div class="line">        public boolean remove(Object o) &#123;    </div><div class="line">            return HashMap.this.removeEntryForKey(o) != null;    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“value集合”，实际上返回的是一个Values对象    </div><div class="line">    public Collection&lt;V&gt; values() &#123;    </div><div class="line">        Collection&lt;V&gt; vs = values;    </div><div class="line">        return (vs != null ? vs : (values = new Values()));    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // “value集合”    </div><div class="line">    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，    </div><div class="line">    // Values中的元素能够重复。因为不同的key可以指向相同的value。    </div><div class="line">    private final class Values extends AbstractCollection&lt;V&gt; &#123;    </div><div class="line">        public Iterator&lt;V&gt; iterator() &#123;    </div><div class="line">            return newValueIterator();    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            return containsValue(o);    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap的Entry集合”    </div><div class="line">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;    </div><div class="line">        return entrySet0();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象    </div><div class="line">    private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;    </div><div class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;    </div><div class="line">        return es != null ? es : (entrySet = new EntrySet());    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // EntrySet对应的集合    </div><div class="line">    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。    </div><div class="line">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;    </div><div class="line">        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;    </div><div class="line">            return newEntryIterator();    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;    </div><div class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());    </div><div class="line">            return candidate != null &amp;&amp; candidate.equals(e);    </div><div class="line">        &#125;    </div><div class="line">        public boolean remove(Object o) &#123;    </div><div class="line">            return removeMapping(o) != null;    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // java.io.Serializable的写入函数    </div><div class="line">    // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中    </div><div class="line">    private void writeObject(java.io.ObjectOutputStream s)    </div><div class="line">        throws IOException    </div><div class="line">    &#123;    </div><div class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =    </div><div class="line">            (size &gt; 0) ? entrySet0().iterator() : null;    </div><div class="line">   </div><div class="line">        // Write out the threshold, loadfactor, and any hidden stuff    </div><div class="line">        s.defaultWriteObject();    </div><div class="line">   </div><div class="line">        // Write out number of buckets    </div><div class="line">        s.writeInt(table.length);    </div><div class="line">   </div><div class="line">        // Write out size (number of Mappings)    </div><div class="line">        s.writeInt(size);    </div><div class="line">   </div><div class="line">        // Write out keys and values (alternating)    </div><div class="line">        if (i != null) &#123;    </div><div class="line">            while (i.hasNext()) &#123;    </div><div class="line">            Map.Entry&lt;K,V&gt; e = i.next();    </div><div class="line">            s.writeObject(e.getKey());    </div><div class="line">            s.writeObject(e.getValue());    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    private static final long serialVersionUID = 362498820763181265L;    </div><div class="line">   </div><div class="line">    // java.io.Serializable的读取函数：根据写入方式读出    </div><div class="line">    // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出    </div><div class="line">    private void readObject(java.io.ObjectInputStream s)    </div><div class="line">         throws IOException, ClassNotFoundException    </div><div class="line">    &#123;    </div><div class="line">        // Read in the threshold, loadfactor, and any hidden stuff    </div><div class="line">        s.defaultReadObject();    </div><div class="line">   </div><div class="line">        // Read in number of buckets and allocate the bucket array;    </div><div class="line">        int numBuckets = s.readInt();    </div><div class="line">        table = new Entry[numBuckets];    </div><div class="line">   </div><div class="line">        init();  // Give subclass a chance to do its thing.    </div><div class="line">   </div><div class="line">        // Read in size (number of Mappings)    </div><div class="line">        int size = s.readInt();    </div><div class="line">   </div><div class="line">        // Read the keys and values, and put the mappings in the HashMap    </div><div class="line">        for (int i=0; i&lt;size; i++) &#123;    </div><div class="line">            K key = (K) s.readObject();    </div><div class="line">            V value = (V) s.readObject();    </div><div class="line">            putForCreate(key, value);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap总的容量”    </div><div class="line">    int   capacity()     &#123; return table.length; &#125;    </div><div class="line">    // 返回“HashMap的加载因子”    </div><div class="line">    float loadFactor()   &#123; return loadFactor;   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、HashMap细节剖析"><a href="#二、HashMap细节剖析" class="headerlink" title="二、HashMap细节剖析"></a>二、HashMap细节剖析</h2><h3 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h3><p> 首先要清楚HashMap的存储结构，如下图所示：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxne3f5n0j30ao0ceglj.jpg" alt=""></p><p>图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p><h3 id="2-2-链表节点的数据结构"><a href="#2-2-链表节点的数据结构" class="headerlink" title="2.2 链表节点的数据结构"></a>2.2 链表节点的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">// Entry是单向链表。    </div><div class="line">// 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    </div><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">    final K key;    </div><div class="line">    V value;    </div><div class="line">    // 指向下一个节点    </div><div class="line">    Entry&lt;K,V&gt; next;    </div><div class="line">    final int hash;    </div><div class="line">  </div><div class="line">    // 构造函数。    </div><div class="line">    // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">        value = v;    </div><div class="line">        next = n;    </div><div class="line">        key = k;    </div><div class="line">        hash = h;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final K getKey() &#123;    </div><div class="line">        return key;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final V getValue() &#123;    </div><div class="line">        return value;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final V setValue(V newValue) &#123;    </div><div class="line">        V oldValue = value;    </div><div class="line">        value = newValue;    </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 判断两个Entry是否相等    </div><div class="line">    // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">    // 否则，返回false    </div><div class="line">    public final boolean equals(Object o) &#123;    </div><div class="line">        if (!(o instanceof Map.Entry))    </div><div class="line">            return false;    </div><div class="line">        Map.Entry e = (Map.Entry)o;    </div><div class="line">        Object k1 = getKey();    </div><div class="line">        Object k2 = e.getKey();    </div><div class="line">        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">            Object v1 = getValue();    </div><div class="line">            Object v2 = e.getValue();    </div><div class="line">            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                return true;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 实现hashCode()    </div><div class="line">    public final int hashCode() &#123;    </div><div class="line">        return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">               (value==null ? 0 : value.hashCode());    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final String toString() &#123;    </div><div class="line">        return getKey() + &quot;=&quot; + getValue();    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">    // 这里不做任何处理    </div><div class="line">    void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 当从HashMap中删除元素时，会调用recordRemoval()。    </div><div class="line">    // 这里不做任何处理    </div><div class="line">    void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。</p><h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><p>HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。</p><p>下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</p><p>另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</p><h3 id="2-4-HashMap中key和value都允许为null。"><a href="#2-4-HashMap中key和value都允许为null。" class="headerlink" title="2.4 HashMap中key和value都允许为null。"></a>2.4 HashMap中key和value都允许为null。</h3><h3 id="2-5-重点分析put和get"><a href="#2-5-重点分析put和get" class="headerlink" title="2.5 重点分析put和get"></a>2.5 重点分析put和get</h3><p>要重点分析下HashMap中用的最多的两个方法put和get。先从比较简单的get方法着手，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 获取key对应的value    </div><div class="line">public V get(Object key) &#123;    </div><div class="line">    if (key == null)    </div><div class="line">        return getForNullKey();    </div><div class="line">    // 获取key的hash值    </div><div class="line">    int hash = hash(key.hashCode());    </div><div class="line">    // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">         e != null;    </div><div class="line">         e = e.next) &#123;    </div><div class="line">        Object k;    </div><div class="line">/判断key是否相同  </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))    </div><div class="line">            return e.value;    </div><div class="line">    &#125;  </div><div class="line">没找到则返回null  </div><div class="line">    return null;    </div><div class="line">&#125;    </div><div class="line">  </div><div class="line">// 获取“key为null”的元素的值    </div><div class="line">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    </div><div class="line">private V getForNullKey() &#123;    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">        if (e.key == null)    </div><div class="line">            return e.value;    </div><div class="line">    &#125;    </div><div class="line">    return null;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。</p><p>如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p><p>put方法稍微复杂些，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  // 将“key-value”添加到HashMap中    </div><div class="line">  public V put(K key, V value) &#123;    </div><div class="line">      // 若“key为null”，则将该键值对添加到table[0]中。    </div><div class="line">      if (key == null)    </div><div class="line">          return putForNullKey(value);    </div><div class="line">      // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    </div><div class="line">      int hash = hash(key.hashCode());    </div><div class="line">      int i = indexFor(hash, table.length);    </div><div class="line">      for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">          Object k;    </div><div class="line">          // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    </div><div class="line">          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </div><div class="line">              V oldValue = e.value;    </div><div class="line">              e.value = value;    </div><div class="line">              e.recordAccess(this);    </div><div class="line">              return oldValue;    </div><div class="line">          &#125;    </div><div class="line">      &#125;    </div><div class="line">  </div><div class="line">      // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    </div><div class="line">      modCount++;  </div><div class="line">//将key-value添加到table[i]处  </div><div class="line">      addEntry(hash, key, value, i);    </div><div class="line">      return null;    </div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    </div><div class="line">private V putForNullKey(V value) &#123;    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">        if (e.key == null) &#123;    </div><div class="line">            V oldValue = e.value;    </div><div class="line">            e.value = value;    </div><div class="line">            e.recordAccess(this);    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">    // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    </div><div class="line">    modCount++;    </div><div class="line">    addEntry(0, null, value, 0);    </div><div class="line">    return null;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    </div><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">    // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">    // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">    // 设置“e”为“新Entry的下一个节点”    </div><div class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">    // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    </div><div class="line">    if (size++ &gt;= threshold)    </div><div class="line">        resize(2 * table.length);    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。</p><p>两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</p><h3 id="2-6-关于扩容"><a href="#2-6-关于扩容" class="headerlink" title="2.6 关于扩容"></a>2.6 关于扩容</h3><p>上面我们看到了扩容的方法，resize方法，它的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 重新调整HashMap的大小，newCapacity是调整后的单位    </div><div class="line">void resize(int newCapacity) &#123;    </div><div class="line">    Entry[] oldTable = table;    </div><div class="line">    int oldCapacity = oldTable.length;    </div><div class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;    </div><div class="line">        threshold = Integer.MAX_VALUE;    </div><div class="line">        return;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    </div><div class="line">    // 然后，将“新HashMap”赋值给“旧HashMap”。    </div><div class="line">    Entry[] newTable = new Entry[newCapacity];    </div><div class="line">    transfer(newTable);    </div><div class="line">    table = newTable;    </div><div class="line">    threshold = (int)(newCapacity * loadFactor);    </div><div class="line">&#125;   </div><div class="line">``` </div><div class="line">很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下：</div></pre></td></tr></table></figure><p>// 将HashMap中的全部元素都添加到newTable中<br>void transfer(Entry[] newTable) {<br>    Entry[] src = table;<br>    int newCapacity = newTable.length;<br>    for (int j = 0; j &lt; src.length; j++) {<br>        Entry<k,v> e = src[j];<br>        if (e != null) {<br>            src[j] = null;<br>            do {<br>                Entry<k,v> next = e.next;<br>                int i = indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            } while (e != null);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</div><div class="line"></div><div class="line">### 2..7 containsKey方法和containsValue方法。</div><div class="line"></div><div class="line">注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。</div><div class="line"></div><div class="line">### 2.8 求hash值和索引值的方法</div><div class="line"></div><div class="line">我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</div><div class="line"></div><div class="line">计算哈希值的方法如下：</div></pre></td></tr></table></figure></k,v></k,v></p><p>static int hash(int h) {<br>        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>    }  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。</div><div class="line"></div><div class="line">由hash值找到对应索引的方法如下：</div></pre></td></tr></table></figure><p>static int indexFor(int h, int length) {<br>        return h &amp; (length-1);<br>    }<br>```<br>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p><p>接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap简介 HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（10）：hashCode方法与equal方法</title>
    <link href="http://yoursite.com/2017/08/18/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%8810%EF%BC%89%EF%BC%9AhashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequal%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/08/18/Java集合学习手册（10）：hashCode方法与equal方法/</id>
    <published>2017-08-18T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native int hashCode();</div></pre></td></tr></table></figure><p>根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p><p>为何Object类需要这样一个方法？它有什么作用呢？今天我们就来具体探讨一下hashCode方法。</p><h2 id="一、hashCode-方法的作用"><a href="#一、hashCode-方法的作用" class="headerlink" title="一、hashCode()方法的作用"></a>一、hashCode()方法的作用</h2><p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p><p>为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）</p><p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。下面这段代码是java.util.HashMap的中put方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return putForNullKey(value);</div><div class="line">        int hash = hash(key.hashCode());</div><div class="line">        int i = indexFor(hash, table.length);</div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</p><p>有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static inline intptr_t get_next_hash(Thread * Self, oop obj) &#123;</div><div class="line">  intptr_t value = 0 ;</div><div class="line">  if (hashCode == 0) &#123;</div><div class="line">     // This form uses an unguarded global Park-Miller RNG,</div><div class="line">     // so it&apos;s possible for two threads to race and generate the same RNG.</div><div class="line">     // On MP system we&apos;ll have lots of RW access to a global, so the</div><div class="line">     // mechanism induces lots of coherency traffic.</div><div class="line">     value = os::random() ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 1) &#123;</div><div class="line">     // This variation has the property of being stable (idempotent)</div><div class="line">     // between STW operations.  This can be useful in some of the 1-0</div><div class="line">     // synchronization schemes.</div><div class="line">     intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ;</div><div class="line">     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 2) &#123;</div><div class="line">     value = 1 ;            // for sensitivity testing</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 3) &#123;</div><div class="line">     value = ++GVars.hcSequence ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 4) &#123;</div><div class="line">     value = intptr_t(obj) ;</div><div class="line">  &#125; else &#123;</div><div class="line">     // Marsaglia&apos;s xor-shift scheme with thread-specific state</div><div class="line">     // This is probably the best overall implementation -- we&apos;ll</div><div class="line">     // likely make this the default in future releases.</div><div class="line">     unsigned t = Self-&gt;_hashStateX ;</div><div class="line">     t ^= (t &lt;&lt; 11) ;</div><div class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</div><div class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</div><div class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</div><div class="line">     unsigned v = Self-&gt;_hashStateW ;</div><div class="line">     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;</div><div class="line">     Self-&gt;_hashStateW = v ;</div><div class="line">     value = v ;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  value &amp;= markOopDesc::hash_mask;</div><div class="line">  if (value == 0) value = 0xBAD ;</div><div class="line">  assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ;</div><div class="line">  TEVENT (hashCode: GENERATE) ;</div><div class="line">  return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。也就是说对于两个对象:</p><ul><li>如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；</li><li>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</li><li>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</li><li>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</li></ul><h1 id="二、equal方法和hashCode方法"><a href="#二、equal方法和hashCode方法" class="headerlink" title="二、equal方法和hashCode方法"></a>二、equal方法和hashCode方法</h1><p>在有些情况下，程序设计者在设计一个类的时候为需要重写equals方法，比如String类，但是千万要注意，在重写equals方法的同时，必须重写hashCode方法。为什么这么说呢？</p><p>下面看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">         </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">             </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 1);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里我只重写了equals方法，也就说如果两个People对象，如果它的姓名和年龄相等，则认为是同一个人。</p><p>这段代码本来的意愿是想这段代码输出结果为“1”，但是事实上它输出的是“null”。为什么呢？原因就在于重写equals方法的同时忘记重写hashCode方法。</p><p>虽然通过重写equals方法使得逻辑上姓名和年龄相同的两个对象被判定为相等的对象（跟String类类似），但是要知道默认情况下，hashCode方法是将对象的存储地址进行映射。那么上述代码的输出结果为“null”就不足为奇了。原因很简单，p1指向的对象和System.out.println(hashMap.get(new People(“Jack”, 12)));这句中的new People(“Jack”, 12)生成的是两个对象，它们的存储地址肯定不同。下面是HashMap的get方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return getForNullKey();</div><div class="line">        int hash = hash(key.hashCode());</div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != null;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">                return e.value;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>所以在hashmap进行get操作时，因为得到的hashCode值不同（注意，上述代码也许在某些情况下会得到相同的hashcode值，不过这种概率比较小，因为虽然两个对象的存储地址不同也有可能得到相同的hashcode值），所以导致在get方法中for循环不会执行，直接返回null。</p><p>因此如果想上述代码输出结果为“1”，很简单，只需要重写hashCode方法，让equals方法和hashCode方法始终在逻辑上保持一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return name.hashCode()+age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">             </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 1);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来的话，输出结果就为“1”了。</p><p>下面这段话摘自Effective Java一书：</p><ul><li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li><li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li></ul><p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p><p>“设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。</p><p>下面举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return name.hashCode()*37+age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">         </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 2);</div><div class="line">         </div><div class="line">        p1.setAge(13);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(p1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码输出的结果为“null”，想必其中的原因大家应该都清楚了。</p><p>因此，在设计hashCode方法和equals方法的时候，如果对象中的数据易变，则最好在equals方法和hashCode方法中不要依赖于该字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="HashCode()" scheme="http://yoursite.com/tags/HashCode/"/>
    
      <category term="equal()" scheme="http://yoursite.com/tags/equal/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（9）：Java 集合对比</title>
    <link href="http://yoursite.com/2017/08/17/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%889%EF%BC%89%EF%BC%9AJava%20%E9%9B%86%E5%90%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2017/08/17/Java集合学习手册（9）：Java 集合对比/</id>
    <published>2017-08-17T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、HashMap与HashTable的区别"><a href="#一、HashMap与HashTable的区别" class="headerlink" title="一、HashMap与HashTable的区别"></a>一、HashMap与HashTable的区别</h1><p>HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。</p><a id="more"></a><p>Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。</p><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：</p><div class="table-container"><table><thead><tr><th>HashMap</th><th>HashTable</th></tr></thead><tbody><tr><td>非线程安全（非线程同步）</td><td>线程安全（线程同步）</td></tr><tr><td>更适合于单线程</td><td>更适合于多线程</td></tr><tr><td>允许null值</td><td>不允许null值</td></tr><tr><td>迭代器Iterator是fail-fast迭代器</td><td>迭代器enumerator不是fail-fast的</td></tr><tr><td>初始容量为16</td><td>初始容量为11</td></tr></tbody></table></div><ul><li>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全</li></ul><p>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的</p><p>由于Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。</p><p>线程安全的实现原理：jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个变量进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个变量，就可能会出现不可预知的结果。用synchronized的关键是建立一个镜像，这个镜像可以是要修改的变量也可以其他你认为合适的对象比如方法和类，然后通过给这个镜像加锁来实现线程安全，每个线程在获得这个锁之后，要执行完才会释放它得到的锁。这样就实现了所谓的线程安全。sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p><p>我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）</p><ul><li>HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。</li></ul><p>当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p><p>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><ul><li>HashMap可以使用null作为key，而Hashtable则不允许null作为key</li></ul><p>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事。HashMap以null作为key时，总是存储在table数组的第一个节点上</p><ul><li>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类</li><li>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75</li><li>HashMap扩容时是当前容量翻倍即:$capacity<em>2$，Hashtable扩容时是容量翻倍+1即:$capacity</em>2+1$</li><li>两者计算hash的方法不同</li></ul><p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int hash = key.hashCode();</div><div class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div></pre></td></tr></table></figure><p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int indexFor(int h, int n) &#123;</div><div class="line">        return h &amp; (n-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="二、HashSet与HashMap的区别"><a href="#二、HashSet与HashMap的区别" class="headerlink" title="二、HashSet与HashMap的区别"></a>二、HashSet与HashMap的区别</h1><p>HashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。</p><p>首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。</p><h2 id="2-1-什么是HashSet"><a href="#2-1-什么是HashSet" class="headerlink" title="2.1 什么是HashSet"></a>2.1 什么是HashSet</h2><p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p><p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p><p>HashSet不是key value结构，仅仅是存储不重复的元素，相当于简化版的HashMap，只是仅仅包含HashMap中的key而已。通过查看源码也证实了这一点，HashSet内部就是使用HashMap实现，只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的，至于HashSet和Hashtable的区别，HashSet就是个简化的HashMap的。</p><p>下面是HashSet几个主要方法的实现，更具体的可以参考【Java学习手册：Java HashSet】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private transient HashMap&lt;E,Object&gt; map;</div><div class="line"> private static final Object PRESENT = new Object();</div><div class="line"> </div><div class="line"> public HashSet() &#123;</div><div class="line">   map = new HashMap&lt;E,Object&gt;();</div><div class="line">   &#125;</div><div class="line">public boolean contains(Object o) &#123;</div><div class="line">   return map.containsKey(o);</div><div class="line">   &#125;</div><div class="line">public boolean add(E e) &#123;</div><div class="line">   return map.put(e, PRESENT)==null;</div><div class="line">   &#125;</div><div class="line">public boolean add(E e) &#123;</div><div class="line">   return map.put(e, PRESENT)==null;</div><div class="line">   &#125;</div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">   return map.remove(o)==PRESENT;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">public void clear() &#123;</div><div class="line">   map.clear();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="2-2-什么是HashMap"><a href="#2-2-什么是HashMap" class="headerlink" title="2.2 什么是HashMap"></a>2.2 什么是HashMap</h2><p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p><p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p><h2 id="2-3-HashSet和HashMap的区别"><a href="#2-3-HashSet和HashMap的区别" class="headerlink" title="2.3 HashSet和HashMap的区别"></a>2.3 HashSet和HashMap的区别</h2><div class="table-container"><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用put()方法将元素放入map中</td><td>使用add()方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，equals()方法判断对象相等性，不同返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></div><h1 id="三、HashSet和TreeSet的区别"><a href="#三、HashSet和TreeSet的区别" class="headerlink" title="三、HashSet和TreeSet的区别"></a>三、HashSet和TreeSet的区别</h1><ul><li>Hashset 的底层是由hashTable实现的，add()，remove()，contains()方法的时间复杂度是O(1).可以放入null，但只能放入一个null。Treeset 底层是由红黑树实现的,add()，remove()，contains()方法的时间复杂度是O(logn)。不允许放入null值</li><li>如果需要在Treeset 中插入对象，需要实现Comparable 接口，为其指定比较策略：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TreeSet&lt;E&gt;</div><div class="line">   extends AbstractSet&lt;E&gt;</div><div class="line">   implements SortedSet&lt;E&gt;, Cloneable, java.io.Serializable</div><div class="line">public class HashSet&lt;E&gt;</div><div class="line">   extends AbstractSet&lt;E&gt;</div><div class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable</div></pre></td></tr></table></figure><p>其中SortedSet中组合了一个：Comparator&lt;? super E&gt; comparator();</p><p>HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet</p><h1 id="四、ArrayList、LinkedList、Vector的底层实现和区别"><a href="#四、ArrayList、LinkedList、Vector的底层实现和区别" class="headerlink" title="四、ArrayList、LinkedList、Vector的底层实现和区别"></a>四、ArrayList、LinkedList、Vector的底层实现和区别</h1><h2 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h2><p>ArrayList是一个可以处理变长数组的类型，这里不局限于“数”组，ArrayList是一个泛型类，可以存放任意类型的对象。顾名思义，ArrayList是一个数组列表，因此其内部是使用一个数组来存放对象的，因为Object是一切类型的父类，因而ArrayList内部是有一个Object类型的数组类存放对象。ArrayList类常用的方法有add()、clear()、get()、indexOf()、remove()、sort()、toArray()、toString()等等，同时ArrayList内部有一个私有类实现Iterator接口，因此可以使用iterator()方法得到ArrayList的迭代器，同时，还有一个私有类实现了ListIterator接口，因此ArrayList也可以调用listIterator()方法得到ListIterator迭代器。</p><p>由于ArrayList是依靠数组来存放对象的，只不过封装起来了而已，因此其一些查找方法的效率都是O(n)，跟普通的数组效率差不多，只不过这个ArrayList是一个可变”数组“，并且可以存放一切指定的对象。</p><p>另外，由于ArrayList的所有方法都是默认在单一线程下进行的，因此ArrayList不具有线程安全性。若想在多线程下使用，应该使用Colletions类中的静态方法synchronizedList()对ArrayList进行调用即可。</p><h2 id="4-2-LinkedList"><a href="#4-2-LinkedList" class="headerlink" title="4.2 LinkedList"></a>4.2 LinkedList</h2><p>LinkedList可以看做为一个双向链表，所有的操作都可以认为是一个双向链表的操作，因为它实现了Deque接口和List接口。同样，LinkedList也是线程不安全的，如果在并发环境下使用它，同样用Colletions类中的静态方法synchronizedList()对LinkedList进行调用即可。</p><p>在LinkedList的内部实现中，并不是用普通的数组来存放数据的，而是使用结点<node>来存放数据的，有一个指向链表头的结点first和一个指向链表尾的结点last。不同于ArrayList只能在数组末尾添加数据，LinkList可以很方便在链表头或者链表尾插入数据，或者在指定结点前后插入数据，还提供了取走链表头或链表尾的结点，或取走中间某个结点，还可以查询某个结点是否存在。add()方法默认在链表尾部插入数据。总之，LinkedList提供了大量方便的操作方法，并且它的插入或增加等方法的效率明显高于ArrayList类型，但是查询的效率要低一点，因为它是一个双向链表。</node></p><p>因此，LinkedList与ArrayList最大的区别是LinkedList更加灵活，并且部分方法的效率比ArrayList对应方法的效率要高很多，对于数据频繁出入的情况下，并且要求操作要足够灵活，建议使用LinkedList；对于数组变动不大，主要是用来查询的情况下，可以使用ArrayList。</p><h2 id="4-3-Vector"><a href="#4-3-Vector" class="headerlink" title="4.3 Vector"></a>4.3 Vector</h2><p>Vector也是一个类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的，即它的大部分方法都包含有关键字synchronized，因此，若对于单一线程的应用来说，最好使用ArrayList代替Vector，因为这样效率会快很多（类似的情况有StringBuffer与StringBuilder）；而在多线程程序中，为了保证数据的同步和一致性，可以使用Vector代替ArrayList实现同样的功能。</p><h1 id="五、数组-Array-和列表-ArrayList-的区别"><a href="#五、数组-Array-和列表-ArrayList-的区别" class="headerlink" title="五、数组(Array)和列表(ArrayList)的区别"></a>五、数组(Array)和列表(ArrayList)的区别</h1><ul><li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li><li>Array大小是固定的，ArrayList的大小是动态变化的。</li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>ArrayList可以存任何Object，如String等。</li></ul><p>ArrayList与数组的区别主要就是由于动态增容的效率问题了。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。因此基本类型用Array，动态变化用ArrayList。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、HashMap与HashTable的区别&quot;&gt;&lt;a href=&quot;#一、HashMap与HashTable的区别&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap与HashTable的区别&quot;&gt;&lt;/a&gt;一、HashMap与HashTable的区别&lt;/h1&gt;&lt;p&gt;HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（8）：Java 集合框架</title>
    <link href="http://yoursite.com/2017/08/16/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%888%EF%BC%89%EF%BC%9AJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/08/16/Java集合学习手册（8）：Java 集合框架/</id>
    <published>2017-08-16T14:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-1-什么是集合？"><a href="#1-1-什么是集合？" class="headerlink" title="1.1 什么是集合？"></a>1.1 什么是集合？</h2><p>Java官方的入门文档是这样描述集合的：</p><a id="more"></a><p>Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。</p><h2 id="1-2-什么是集合框架？"><a href="#1-2-什么是集合框架？" class="headerlink" title="1.2 什么是集合框架？"></a>1.2 什么是集合框架？</h2><p>Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了：</p><ul><li>Interfaces:这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构；</li><li>Implementations:这些是接口的具体实现。本质上，是一些可复用的数据结构；</li><li>Algorithms:这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。</li></ul><p>除了Java的集合框架，还有一些著名的集合框架的例子：比如C++的STL和Smalltalk的集合架构。从历史上来看，集合框架可能比较复杂，也可能有一些很陡峭的学习曲线。不过我们相信Java的集合框架会突破这样的传统，在这章你就可以自己学会。</p><h2 id="1-3-使用集合框架有什么好处？"><a href="#1-3-使用集合框架有什么好处？" class="headerlink" title="1.3 使用集合框架有什么好处？"></a>1.3 使用集合框架有什么好处？</h2><p>Java的集合框架提供了一下优点：</p><ul><li>减少编程的工作量：通过提供有用的数据结构和算法，集合框架能让你更专注的实现程序的核心功能，而不是去做一个底层的“管道工”。Java框架通过促进无关API的互操作性，使得你不用自己去实现不同API的适配</li><li>提高程序的速度与质量：集合框架提供了一些有用数据结构和算法的高性能、高质量的实现。每个接口的不同的实现也是可以互换的，所以程序可以通过切换集合来做一些调整。正因为你从实现数据结构的那些苦差事中脱离出来，你才可以有更多的实现去改善你自己程序的性能和质量</li><li>允许无关APIs的互操作：集合接口是API之间传递集合的一个“方言”，比如我的网络管理API有一个节点名的集合，而GUI工具需要一个列标题的集合，即使是分开实现它们，我们的APIs也可以无缝的接合。</li><li>省力地学习和使用新API：这是另一个领先的优势，设计者和实现者没必要在每次都重新设计API的时候都“推倒重来”地实现集合，而是直接使用标准的集合接口就好了。</li><li>促进软件的复用：符合标准集合接口的新数据结构本质上是可以复用的。对于操作这些新数据结构算法也是一样可以复用的。</li></ul><h1 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h1><p>Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p><p>Java集合类的整体框架如下：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2twzirij30us0axdi8.jpg" alt=""></p><p>从上图中可以看出，集合类主要分为两大类：Collection和Map。</p><p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p><p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。</p><p>另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p><p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p><p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p><p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p><p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是集合？&quot;&gt;&lt;a href=&quot;#1-1-什么是集合？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是集合？&quot;&gt;&lt;/a&gt;1.1 什么是集合？&lt;/h2&gt;&lt;p&gt;Java官方的入门文档是这样描述集合的：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（7）：Java LinkedList</title>
    <link href="http://yoursite.com/2017/08/15/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%887%EF%BC%89%EF%BC%9AJava%20LinkedList/"/>
    <id>http://yoursite.com/2017/08/15/Java集合学习手册（7）：Java LinkedList/</id>
    <published>2017-08-15T14:20:45.000Z</published>
    <updated>2018-11-03T12:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>LinkedList和ArrayList一样，都实现了List接口，但其内部的数据结构有本质的不同。LinkedList是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比ArrayList更加高效。但也是由于其为基于链表的，所以随机访问的效率要比ArrayList差。</p><a id="more"></a><p>看一下LinkedList的类的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt;</div><div class="line">    extends AbstractSequentialList&lt;E&gt;</div><div class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure><p>LinkedList继承自AbstractSequenceList，实现了List、Deque、Cloneable、java.io.Serializable接口。AbstractSequenceList提供了List接口骨干性的实现以减少实现List接口的复杂度，Deque接口定义了双端队列的操作。</p><p>在LinkedList中除了本身自己的方法外，还提供了一些可以使其作为栈、队列或者双端队列的方法。这些方法可能彼此之间只是名字不同，以使得这些名字在特定的环境中显得更加合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</div><div class="line">list.add(&quot;语文: 1&quot;);</div><div class="line">list.add(&quot;数学: 2&quot;);</div><div class="line">list.add(&quot;英语: 3&quot;);</div></pre></td></tr></table></figure><p>结构也相对简单一些，如下图所示：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv4t7r691j30no0bdgmc.jpg" alt=""></p><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>LinkedList是基于链表结构实现，所以在类中包含了first和last两个指针(Node)。Node中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。每个Node只能知道自己的前一个节点和后一个节点，但对于链表来说，这已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//链表的头指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></div><div class="line"><span class="comment">//存储对象的结构 Node, LinkedList的内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next; <span class="comment">// 指向下一个节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">//指向上一个节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、存储"><a href="#三、存储" class="headerlink" title="三、存储"></a>三、存储</h2><h3 id="3-1-add-E-e"><a href="#3-1-add-E-e" class="headerlink" title="3.1 add(E e)"></a>3.1 add(E e)</h3><p>该方法是在链表的end添加元素，其调用了自己的方法linkLast(E e)。</p><p>该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个newNode，其中的元素就为要添加的e；而后，我们让last指向了newNode。接下来是自身进行维护该链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</div><div class="line">     *</div><div class="line">     * @param e element to be appended to this list</div><div class="line">     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</div><div class="line">     */</div><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">* Links e as last element.</div><div class="line">*/</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-add-int-index-E-element"><a href="#3-2-add-int-index-E-element" class="headerlink" title="3.2 add(int index, E element)"></a>3.2 add(int index, E element)</h3><p>该方法是在指定index位置插入元素。如果index位置正好等于size，则调用linkLast(element)将其插入末尾；否则调用 linkBefore(element, node(index))方法进行插入。该方法的实现在下面，大家可以自己仔细的分析一下。（分析链表的时候最好能够边画图边分析）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Inserts the specified element at the specified position in this list.</div><div class="line">    * Shifts the element currently at that position (if any) and any</div><div class="line">    * subsequent elements to the right (adds one to their indices).</div><div class="line">    *</div><div class="line">    * @param index index at which the specified element is to be inserted</div><div class="line">    * @param element element to be inserted</div><div class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">    */</div><div class="line">   public void add(int index, E element) &#123;</div><div class="line">       checkPositionIndex(index);</div><div class="line"></div><div class="line">       if (index == size)</div><div class="line">           linkLast(element);</div><div class="line">       else</div><div class="line">           linkBefore(element, node(index));</div><div class="line">   &#125;</div><div class="line">   /**</div><div class="line">        * Inserts element e before non-null Node succ.</div><div class="line">        */</div><div class="line">       void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">           // assert succ != null;</div><div class="line">           final Node&lt;E&gt; pred = succ.prev;</div><div class="line">           final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">           succ.prev = newNode;</div><div class="line">           if (pred == null)</div><div class="line">               first = newNode;</div><div class="line">           else</div><div class="line">               pred.next = newNode;</div><div class="line">           size++;</div><div class="line">           modCount++;</div><div class="line">       &#125;</div></pre></td></tr></table></figure><p>LinkedList的方法实在是太多，在这没法一一举例分析。但很多方法其实都只是在调用别的方法而已，所以建议大家将其几个最核心的添加的方法搞懂就可以了，比如linkBefore、linkLast。其本质也就是链表之间的删除添加等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;LinkedList和ArrayList一样，都实现了List接口，但其内部的数据结构有本质的不同。LinkedList是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比ArrayList更加高效。但也是由于其为基于链表的，所以随机访问的效率要比ArrayList差。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（6）：Java ArrayList</title>
    <link href="http://yoursite.com/2017/08/14/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%886%EF%BC%89%EF%BC%9AJava%20ArrayList/"/>
    <id>http://yoursite.com/2017/08/14/Java集合学习手册（6）：Java ArrayList/</id>
    <published>2017-08-14T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>ArrayList可以理解为动态数组，就是Array的复杂版本。与Java中的数组相比，它的容量能动态增长。ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）</p><a id="more"></a><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）</p><p>我们先学习了解其内部的实现原理，才能更好的理解其应用。</p><h2 id="二、ArrayList的实现"><a href="#二、ArrayList的实现" class="headerlink" title="二、ArrayList的实现"></a>二、ArrayList的实现</h2><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p><h3 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ArrayList继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>ArrayList实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p><p>ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><h3 id="2-2-底层使用数组实现"><a href="#2-2-底层使用数组实现" class="headerlink" title="2.2 底层使用数组实现"></a>2.2 底层使用数组实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* The array buffer into which the elements of the ArrayList are stored.</div><div class="line">* The capacity of the ArrayList is the length of this array buffer.</div><div class="line">*/</div><div class="line">private transient Object[] elementData;</div></pre></td></tr></table></figure><h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with the specified initial capacity.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</div><div class="line"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</div><div class="line"> *         is negative</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a list containing the elements of the specified</div><div class="line"> * collection, in the order they are returned by the collection's</div><div class="line"> * iterator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ArrayList提供了三种方式的构造器：</p><ul><li>public ArrayList()：可以构造一个默认初始容量为10的空列表；</li><li>public ArrayList(int initialCapacity)：构造一个指定初始容量的空列表；</li><li>public ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li></ul><h3 id="2-4-存储"><a href="#2-4-存储" class="headerlink" title="2.4 存储"></a>2.4 存储</h3><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：</p><ul><li>set(int index, E element)：该方法首先调用rangeCheck(index)来校验index变量是否超出数组范围，超出则抛出异常。而后，取出原index位置的值，并且将新的element放入Index位置，返回oldValue。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Replaces the element at the specified position in this list with</div><div class="line"> * the specified element.</div><div class="line"> *</div><div class="line"> * @param index index of the element to replace</div><div class="line"> * @param element element to be stored at the specified position</div><div class="line"> * @return the element previously at the specified position</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line"> // 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">  * Checks if the given index is in range.  If not, throws an appropriate</div><div class="line">  * runtime exception.  This method does *not* check if the index is</div><div class="line">  * negative: It is always used immediately prior to an array access,</div><div class="line">  * which throws an ArrayIndexOutOfBoundsException if index is negative.</div><div class="line">  */</div><div class="line">  private void rangeCheck(int index) &#123;</div><div class="line">    if (index &gt;= size)</div><div class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">  &#125;</div></pre></td></tr></table></figure><ul><li>add(E e)：该方法是将指定的元素添加到列表的尾部。当容量不足时，会调用grow方法增长容量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line"> */</div><div class="line"> <span class="comment">// 将指定的元素添加到此列表的尾部。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>add(int index, E element)：在index位置插入element。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Inserts the specified element at the specified position in this</div><div class="line"> * list. Shifts the element currently at that position (if any) and</div><div class="line"> * any subsequent elements to the right (adds one to their indices).</div><div class="line"> *</div><div class="line"> * @param index index at which the specified element is to be inserted</div><div class="line"> * @param element element to be inserted</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line"> // 将指定的元素插入此列表中的指定位置。  </div><div class="line">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line">    // 如果数组长度不足，将进行扩容。</div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    // 将 elementData中从Index位置开始、长度为size-index的元素，  </div><div class="line">    // 拷贝到从下标为index+1位置开始的新的elementData数组中。  </div><div class="line">    // 即将当前位于该位置的元素以及所有后续元素右移一个位置。</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>addAll(Collection&lt;? extends E&gt; c)和addAll(int index, Collection&lt;? extends E&gt; c)：将特定Collection中的元素添加到Arraylist末尾。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Appends all of the elements in the specified collection to the end of</div><div class="line">     * this list, in the order that they are returned by the</div><div class="line">     * specified collection&apos;s Iterator.  The behavior of this operation is</div><div class="line">     * undefined if the specified collection is modified while the operation</div><div class="line">     * is in progress.  (This implies that the behavior of this call is</div><div class="line">     * undefined if the specified collection is this list, and this</div><div class="line">     * list is nonempty.)</div><div class="line">     *</div><div class="line">     * @param c collection containing elements to be added to this list</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</div><div class="line">     * @throws NullPointerException if the specified collection is null</div><div class="line">     */</div><div class="line">     // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 </div><div class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        int numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line">        System.arraycopy(a, 0, elementData, size, numNew);</div><div class="line">        size += numNew;</div><div class="line">        return numNew != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Inserts all of the elements in the specified collection into this</div><div class="line">     * list, starting at the specified position.  Shifts the element</div><div class="line">     * currently at that position (if any) and any subsequent elements to</div><div class="line">     * the right (increases their indices).  The new elements will appear</div><div class="line">     * in the list in the order that they are returned by the</div><div class="line">     * specified collection&apos;s iterator.</div><div class="line">     *</div><div class="line">     * @param index index at which to insert the first element from the</div><div class="line">     *              specified collection</div><div class="line">     * @param c collection containing elements to be added to this list</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</div><div class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">     * @throws NullPointerException if the specified collection is null</div><div class="line">     */</div><div class="line">     // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</div><div class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line"></div><div class="line">        Object[] a = c.toArray();</div><div class="line">        int numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line"></div><div class="line">        int numMoved = size - index;</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                             numMoved);</div><div class="line"></div><div class="line">        System.arraycopy(a, 0, elementData, index, numNew);</div><div class="line">        size += numNew;</div><div class="line">        return numNew != 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>在ArrayList的存储方法，其核心本质是在数组的某个位置将元素添加进入。但其中又会涉及到关于数组容量不够而增长等因素。</p><h3 id="2-5-读取"><a href="#2-5-读取" class="headerlink" title="2.5 读取"></a>2.5 读取</h3><p>这个方法就比较简单了，ArrayList能够支持随机访问的原因也是很显然的，因为它内部的数据结构是数组，而数组本身就是支持随机访问。该方法首先会判断输入的index值是否越界，然后将数组的index位置的元素返回即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Returns the element at the specified position in this list.</div><div class="line">*</div><div class="line">* @param  index index of the element to return</div><div class="line">* @return the element at the specified position in this list</div><div class="line">* @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">*/</div><div class="line">// 返回此列表中指定位置上的元素。</div><div class="line">public E get(int index) &#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    return (E) elementData[index];</div><div class="line">&#125;</div><div class="line">private void rangeCheck(int index) &#123;</div><div class="line">    if (index &gt;= size)</div><div class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-6-删除"><a href="#2-6-删除" class="headerlink" title="2.6 删除"></a>2.6 删除</h3><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。需要注意的是该方法的返回值并不相同，如下：</p><ul><li>根据下标删除：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">// 移除此列表中指定位置上的元素。</div><div class="line">    /**</div><div class="line">     * Removes the element at the specified position in this list.</div><div class="line">     * Shifts any subsequent elements to the left (subtracts one from their</div><div class="line">     * indices).</div><div class="line">     *</div><div class="line">     * @param index the index of the element to be removed</div><div class="line">     * @return the element that was removed from the list</div><div class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">     */</div><div class="line">    public E remove(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        int numMoved = size - index - 1;</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = null; // Let gc do its work</div><div class="line"></div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line"></div><div class="line">- 指定对象删除：</div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line">/**</div><div class="line">     * Removes the first occurrence of the specified element from this list,</div><div class="line">     * if it is present.  If the list does not contain the element, it is</div><div class="line">     * unchanged.  More formally, removes the element with the lowest index</div><div class="line">     * &lt;tt&gt;i&lt;/tt&gt; such that</div><div class="line">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</div><div class="line">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</div><div class="line">     * contained the specified element (or equivalently, if this list</div><div class="line">     * changed as a result of the call).</div><div class="line">     *</div><div class="line">     * @param o element to be removed from this list, if present</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</div><div class="line">     */</div><div class="line">     // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。</div><div class="line">    public boolean remove(Object o) &#123;</div><div class="line">    // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。</div><div class="line">        if (o == null) &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (elementData[index] == null) &#123;</div><div class="line">                // 类似remove(int index)，移除列表中指定位置上的元素。</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (o.equals(elementData[index])) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</p><h3 id="2-7-调整数组容量"><a href="#2-7-调整数组容量" class="headerlink" title="2.7 调整数组容量"></a>2.7 调整数组容量</h3><p>从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容有两个方法，其中开发者可以通过一个public的方法ensureCapacity(int minCapacity)来增加ArrayList的容量，而在存储元素等操作过程中，如果遇到容量不足，会调用priavte方法private void ensureCapacityInternal(int minCapacity)实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void ensureCapacity(int minCapacity) &#123;</div><div class="line">    if (minCapacity &gt; 0)</div><div class="line">        ensureCapacityInternal(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">    modCount++;</div><div class="line">    // overflow-conscious code</div><div class="line">    if (minCapacity - elementData.length &gt; 0)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Increases the capacity to ensure that it can hold at least the</div><div class="line"> * number of elements specified by the minimum capacity argument.</div><div class="line"> *</div><div class="line"> * @param minCapacity the desired minimum capacity</div><div class="line"> */</div><div class="line">private void grow(int minCapacity) &#123;</div><div class="line">    // overflow-conscious code</div><div class="line">    int oldCapacity = elementData.length;</div><div class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">    if (newCapacity - minCapacity &lt; 0)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    // minCapacity is usually close to size, so this is a win:</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍（从int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)这行代码得出）。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void trimToSize() &#123;  </div><div class="line">    modCount++;  </div><div class="line">    int oldCapacity = elementData.length;  </div><div class="line">    if (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-8-Fail-Fast机制"><a href="#2-8-Fail-Fast机制" class="headerlink" title="2.8 Fail-Fast机制"></a>2.8 Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。关于Fail-Fast的更详细的介绍，在之前HashMap中已经提到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;ArrayList可以理解为动态数组，就是Array的复杂版本。与Java中的数组相比，它的容量能动态增长。ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（5）：Java LinkedHashSet</title>
    <link href="http://yoursite.com/2017/08/13/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%885%EF%BC%89%EF%BC%9AJava%20LinkedHashSet/"/>
    <id>http://yoursite.com/2017/08/13/Java集合学习手册（5）：Java LinkedHashSet/</id>
    <published>2017-08-13T12:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>首先我们需要知道的是它是一个Set的实现，所以它其中存的肯定不是键值对，而是值。此实现与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p><a id="more"></a><p>看到上面的介绍，是不是感觉其与HashMap和LinkedHashMap的关系很像？</p><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步。</p><p>在【Java学习手册：LinkedHashMap】中，通过例子演示了HashMap和LinkedHashMap的区别。举一反三，我们现在学习的LinkedHashSet与之前的很相同，只不过之前存的是键值对，而现在存的只有值。</p><p>LinkedHashSet是可以按照插入顺序或者访问顺序进行迭代。</p><h2 id="二、LinkedHashSet的实现"><a href="#二、LinkedHashSet的实现" class="headerlink" title="二、LinkedHashSet的实现"></a>二、LinkedHashSet的实现</h2><p>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。<br>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。LinkedHashSet的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。</div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个与指定collection中的元素相同的新链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个足以包含指定collection</div><div class="line">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上几乎就是LinkedHashSet的全部代码了，那么读者可能就会怀疑了，不是说LinkedHashSet是基于LinkedHashMap实现的吗？那我为什么在源码中甚至都没有看到出现过LinkedHashMap。不要着急，我们可以看到在LinkedHashSet的构造方法中，其调用了父类的构造方法。我们可以进去看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</div><div class="line">     *</div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</div><div class="line">     * @param initialCapacity 初始容量。</div><div class="line">     * @param loadFactor 加载因子。</div><div class="line">     * @param dummy 标记。</div><div class="line">     */</div><div class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</div><div class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在父类HashSet中，专为LinkedHashSet提供的构造方法如下，该方法为包访问权限，并未对外公开。<br>由上述源代码可见，LinkedHashSet通过继承HashSet，底层使用LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>以上就是关于LinkedHashSet的内容，我们只是从概述上以及构造方法这几个方面介绍了，并不是我们不想去深入其读取或者写入方法，而是其本身没有实现，只是继承于父类HashSet的方法。</p><p>所以我们需要注意的点是：</p><ul><li>LinkedHashSet是Set的一个具体实现，其维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</li><li>LinkedHashSet继承与HashSet，并且其内部是通过LinkedHashMap来实现的。有点类似于我们之前说的LinkedHashMap其内部是基于Hashmap实现一样，不过还是有一点点区别的（具体的区别大家可以自己去思考一下）。</li><li>如果我们需要迭代的顺序为插入顺序或者访问顺序，那么LinkedHashSet是需要你首先考虑的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;首先我们需要知道的是它是一个Set的实现，所以它其中存的肯定不是键值对，而是值。此实现与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedHashSet" scheme="http://yoursite.com/tags/LinkedHashSet/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（4）：Java LinkedHashMap</title>
    <link href="http://yoursite.com/2017/08/12/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%884%EF%BC%89%EF%BC%9AJava%20LinkedHashMap/"/>
    <id>http://yoursite.com/2017/08/12/Java集合学习手册（4）：Java LinkedHashMap/</id>
    <published>2017-08-12T11:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>HashMap是无序的，HashMap在put的时候是根据key的hashcode进行hash然后放入对应的地方。所以在按照一定顺序put进HashMap中，然后遍历出HashMap的顺序跟put的顺序不同（除非在put的时候key已经按照hashcode排序好了，这种几率非常小）</p><a id="more"></a><p>JAVA在JDK1.4以后提供了LinkedHashMap来帮助我们实现了有序的HashMap。</p><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序， 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p><p>我们写一个简单的LinkedHashMap的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</div><div class="line">lmap.put(<span class="string">"语文"</span>, <span class="number">1</span>);</div><div class="line">lmap.put(<span class="string">"数学"</span>, <span class="number">2</span>);</div><div class="line">lmap.put(<span class="string">"英语"</span>, <span class="number">3</span>);</div><div class="line">lmap.put(<span class="string">"历史"</span>, <span class="number">4</span>);</div><div class="line">lmap.put(<span class="string">"政治"</span>, <span class="number">5</span>);</div><div class="line">lmap.put(<span class="string">"地理"</span>, <span class="number">6</span>);</div><div class="line">lmap.put(<span class="string">"生物"</span>, <span class="number">7</span>);</div><div class="line">lmap.put(<span class="string">"化学"</span>, <span class="number">8</span>);</div><div class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">语文: 1</div><div class="line">数学: 2</div><div class="line">英语: 3</div><div class="line">历史: 4</div><div class="line">政治: 5</div><div class="line">地理: 6</div><div class="line">生物: 7</div><div class="line">化学: 8</div></pre></td></tr></table></figure><p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0ozwtvpj30uq0r60xf.jpg" alt=""></p><blockquote><p>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order).</p></blockquote><p>没错，正如官方文档所说：LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p><h2 id="二、插入顺序、访问顺序的演示"><a href="#二、插入顺序、访问顺序的演示" class="headerlink" title="二、插入顺序、访问顺序的演示"></a>二、插入顺序、访问顺序的演示</h2><p>先做几个demo来演示一下LinkedHashMap的使用。看懂了其效果，然后再来研究其原理。</p><h3 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h3><p>看下面这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">map.put(&quot;apple&quot;, &quot;苹果&quot;);</div><div class="line">map.put(&quot;watermelon&quot;, &quot;西瓜&quot;);</div><div class="line">map.put(&quot;banana&quot;, &quot;香蕉&quot;);</div><div class="line">map.put(&quot;peach&quot;, &quot;桃子&quot;);</div><div class="line"></div><div class="line">Iterator iter = map.entrySet().iterator();</div><div class="line">while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个比较简单的测试HashMap的代码，通过控制台的输出，我们可以看到HashMap是没有顺序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">banana=香蕉</div><div class="line">apple=苹果</div><div class="line">peach=桃子</div><div class="line">watermelon=西瓜</div></pre></td></tr></table></figure><h3 id="2-2-LinkedHashMap"><a href="#2-2-LinkedHashMap" class="headerlink" title="2.2 LinkedHashMap"></a>2.2 LinkedHashMap</h3><p>我们现在将map的实现换成LinkedHashMap，其他代码不变：<code>Map&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();</code><br>看一下控制台的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apple=苹果</div><div class="line">watermelon=西瓜</div><div class="line">banana=香蕉</div><div class="line">peach=桃子</div></pre></td></tr></table></figure><p>我们可以看到，其输出顺序是完成按照插入顺序的！也就是我们上面所说的保留了插入的顺序。我们不是在上面还提到过其可以按照访问顺序进行排序么？好的，我们还是通过一个例子来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">Map&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(16,0.75f,true);</div><div class="line">map.put(&quot;apple&quot;, &quot;苹果&quot;);</div><div class="line">map.put(&quot;watermelon&quot;, &quot;西瓜&quot;);</div><div class="line">map.put(&quot;banana&quot;, &quot;香蕉&quot;);</div><div class="line">map.put(&quot;peach&quot;, &quot;桃子&quot;);</div><div class="line"></div><div class="line">map.get(&quot;banana&quot;);</div><div class="line">map.get(&quot;apple&quot;);</div><div class="line"></div><div class="line">Iterator iter = map.entrySet().iterator();</div><div class="line">while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码与之前的都差不多，但我们多了两行代码，并且初始化LinkedHashMap的时候，用的构造函数也不相同，看一下控制台的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">watermelon=西瓜</div><div class="line">peach=桃子</div><div class="line">banana=香蕉</div><div class="line">apple=苹果</div></pre></td></tr></table></figure><p>这也就是我们之前提到过的，LinkedHashMap可以选择按照访问顺序进行排序。</p><h2 id="三、LinkedHashMap的实现"><a href="#三、LinkedHashMap的实现" class="headerlink" title="三、LinkedHashMap的实现"></a>三、LinkedHashMap的实现</h2><p>对于LinkedHashMap而言，它继承于HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码：</p><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</div><div class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</div><div class="line">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 双向链表的表头元素。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* LinkedHashMap的Entry元素。</div><div class="line">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedHashMap中的Entry集成与HashMap的Entry，但是其增加了before和after的引用，指的是上一个元素和下一个元素的引用。</p><h3 id="3-2-初始化"><a href="#3-2-初始化" class="headerlink" title="3.2 初始化"></a>3.2 初始化</h3><p>通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组，但额外可以增加accessOrder这个参数，如果不设置，默认为false，代表按照插入顺序进行迭代；当然可以显式设置为true，代表以访问顺序进行迭代。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) &#123;</div><div class="line">    super(initialCapacity, loadFactor);</div><div class="line">    this.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> HashMap中的相关构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    if (initialCapacity &lt; 0)  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +  </div><div class="line">                                           initialCapacity);  </div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)  </div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;  </div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +  </div><div class="line">                                           loadFactor);  </div><div class="line">  </div><div class="line">    // Find a power of 2 &gt;= initialCapacity  </div><div class="line">    int capacity = 1;  </div><div class="line">    while (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= 1;  </div><div class="line">  </div><div class="line">    this.loadFactor = loadFactor;  </div><div class="line">    threshold = (int)(capacity * loadFactor);  </div><div class="line">    table = new Entry[capacity];  </div><div class="line">    init();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器<br>中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。</p><p>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Called by superclass constructors and pseudoconstructors (clone,</div><div class="line">* readObject) before any entries are inserted into the map.  Initializes</div><div class="line">* the chain.</div><div class="line">*/</div><div class="line">@Override</div><div class="line">void init() &#123;</div><div class="line">  header = new Entry&lt;&gt;(-1, null, null, null);</div><div class="line">  header.before = header.after = header;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-存储"><a href="#3-3-存储" class="headerlink" title="3.3 存储"></a>3.3 存储</h3><p>LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void recordAccess(HashMap m) ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。我们在之前的文章中已经讲解了HashMap的put方法，我们在这里重新贴一下HashMap的put方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</div><div class="line">        lm.modCount++;</div><div class="line">        remove();</div><div class="line">        addBefore(lm.header);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用create方法，将新元素以双向链表的的形式加入到映射中。</span></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line"></div><div class="line">    <span class="comment">// 删除最近最少使用元素的策略定义</span></div><div class="line">    Entry&lt;K,V&gt; eldest = header.after;</div><div class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</div><div class="line">        removeEntryForKey(eldest.key);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (size &gt;= threshold)</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);</div><div class="line">    table[bucketIndex] = e;</div><div class="line">    <span class="comment">// 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span></div><div class="line">    e.addBefore(header);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">    after  = existingEntry;</div><div class="line">    before = existingEntry.before;</div><div class="line">    before.after = <span class="keyword">this</span>;</div><div class="line">    after.before = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-4-读取"><a href="#3-4-读取" class="headerlink" title="3.4 读取"></a>3.4 读取</h3><p>LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用父类HashMap的getEntry()方法，取得要查找的元素。</span></div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 记录访问顺序。</span></div><div class="line">    e.recordAccess(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">    <span class="comment">// 如果定义了LinkedHashMap的迭代顺序为访问顺序，</span></div><div class="line">    <span class="comment">// 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span></div><div class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</div><div class="line">        lm.modCount++;</div><div class="line">        remove();</div><div class="line">        addBefore(lm.header);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Removes this entry from the linked list.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    before.after = after;</div><div class="line">    after.before = before;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**clear链表，设置header为初始状态*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.clear();</div><div class="line"> header.before = header.after = header;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedHashMap的这些额外操作基本上都是为了维护好那个具有访问顺序的双向链表，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p><h3 id="3-4-排序模式"><a href="#3-4-排序模式" class="headerlink" title="3.4 排序模式"></a>3.4 排序模式</h3><p>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final boolean accessOrder;</div></pre></td></tr></table></figure><p>一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    super(initialCapacity, loadFactor);  </div><div class="line">    accessOrder = false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity,  </div><div class="line">         float loadFactor,  </div><div class="line">                     boolean accessOrder) &#123;  </div><div class="line">    super(initialCapacity, loadFactor);  </div><div class="line">    this.accessOrder = accessOrder;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry<k,v> eldest)方法，在将新条目插入到映射后，put和 putAll将调用此方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</k,v></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存，则非常方便，它允许映射通过删除旧条目来减少内存损耗。</p><p>例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static final int MAX_ENTRIES = 100;  </div><div class="line">protected boolean removeEldestEntry(Map.Entry eldest) &#123;  </div><div class="line">    return size() &gt; MAX_ENTRIES;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>其实LinkedHashMap几乎和HashMap一样：从技术上来说，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p><p>在写关于LinkedHashMap的过程中，记起来之前面试的过程中遇到的一个问题，也是问我Map的哪种实现可以做到按照插入顺序进行迭代？当时脑子是突然短路的，但现在想想，也只能怪自己对这个知识点还是掌握的不够扎实，所以又从头认真的把代码看了一遍。</p><p>不过，我的建议是，大家首先首先需要记住的是：LinkedHashMap能够做到按照插入顺序或者访问顺序进行迭代，这样在我们以后的开发中遇到相似的问题，才能想到用LinkedHashMap来解决，否则就算对其内部结构非常了解，不去使用也是没有什么用的。我们学习的目的是为了更好的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;HashMap是无序的，HashMap在put的时候是根据key的hashcode进行hash然后放入对应的地方。所以在按照一定顺序put进HashMap中，然后遍历出HashMap的顺序跟put的顺序不同（除非在put的时候key已经按照hashcode排序好了，这种几率非常小）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedHashMap" scheme="http://yoursite.com/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（3）：Java HashTable</title>
    <link href="http://yoursite.com/2017/08/11/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%883%EF%BC%89%EF%BC%9AJava%20HashTable/"/>
    <id>http://yoursite.com/2017/08/11/Java集合学习手册（3）：Java HashTable/</id>
    <published>2017-08-11T10:20:45.000Z</published>
    <updated>2018-11-03T15:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对。</p><a id="more"></a><p>Hashtable在Java中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&#123;&#125;</div></pre></td></tr></table></figure><p>从源码中，我们可以看出，Hashtable继承于Dictionary类，实现了Map, Cloneable, java.io.Serializable接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类，每个键和值都是对象（源码注释为：The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values. Every key and every value is an object.）。但其Dictionary源码注释是这样的：NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class. 该话指出Dictionary这个类过时了，新的实现类应该实现Map接口。</p><h2 id="二、成员变量"><a href="#二、成员变量" class="headerlink" title="二、成员变量"></a>二、成员变量</h2><p>Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。</p><ul><li>table是一个Entry[]数组类型，而Entry（在HashMap中有讲解过）实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。</li><li>count是Hashtable的大小，它是Hashtable保存的键值对的数量。</li><li>threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。</li><li>loadFactor就是加载因子。</li><li>modCount是用来实现fail-fast机制的。</li></ul><p>变量的解释在源码注释中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * The hash table data.</div><div class="line">     */</div><div class="line">    private transient Entry&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The total number of entries in the hash table.</div><div class="line">     */</div><div class="line">    private transient int count;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The table is rehashed when its size exceeds this threshold.  (The</div><div class="line">     * value of this field is (int)(capacity * loadFactor).)</div><div class="line">     *</div><div class="line">     * @serial</div><div class="line">     */</div><div class="line">    private int threshold;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The load factor for the hashtable.</div><div class="line">     *</div><div class="line">     * @serial</div><div class="line">     */</div><div class="line">    private float loadFactor;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The number of times this Hashtable has been structurally modified</div><div class="line">     * Structural modifications are those that change the number of entries in</div><div class="line">     * the Hashtable or otherwise modify its internal structure (e.g.,</div><div class="line">     * rehash).  This field is used to make iterators on Collection-views of</div><div class="line">     * the Hashtable fail-fast.  (See ConcurrentModificationException).</div><div class="line">     */</div><div class="line">    private transient int modCount = 0;</div></pre></td></tr></table></figure><h2 id="三、构造方法"><a href="#三、构造方法" class="headerlink" title="三、构造方法"></a>三、构造方法</h2><p>Hashtable一共提供了4个构造方法：</p><ul><li>public Hashtable(int initialCapacity, float loadFactor)： 用指定初始容量和指定加载因子构造一个新的空哈希表。useAltHashing为boolean，其如果为真，则执行另一散列的字符串键，以减少由于弱哈希计算导致的哈希冲突的发生。</li><li>public Hashtable(int initialCapacity)：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</li><li>public Hashtable()：默认构造函数，容量为11，加载因子为0.75。</li><li>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)：构造一个与给定的 Map 具有相同映射关系的新哈希表。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Constructs a new, empty hashtable with the specified initial</div><div class="line">     * capacity and the specified load factor.</div><div class="line">     *</div><div class="line">     * @param      initialCapacity   the initial capacity of the hashtable.</div><div class="line">     * @param      loadFactor        the load factor of the hashtable.</div><div class="line">     * @exception  IllegalArgumentException  if the initial capacity is less</div><div class="line">     *             than zero, or if the load factor is nonpositive.</div><div class="line">     */</div><div class="line">    public Hashtable(int initialCapacity, float loadFactor) &#123;</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</div><div class="line">                                               initialCapacity);</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</div><div class="line"></div><div class="line">        if (initialCapacity==0)</div><div class="line">            initialCapacity = 1;</div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        table = new Entry[initialCapacity];</div><div class="line">        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (initialCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line">     * and default load factor (0.75).</div><div class="line">     *</div><div class="line">     * @param     initialCapacity   the initial capacity of the hashtable.</div><div class="line">     * @exception IllegalArgumentException if the initial capacity is less</div><div class="line">     *              than zero.</div><div class="line">     */</div><div class="line">    public Hashtable(int initialCapacity) &#123;</div><div class="line">        this(initialCapacity, 0.75f);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line">     * and load factor (0.75).</div><div class="line">     */</div><div class="line">    public Hashtable() &#123;</div><div class="line">        this(11, 0.75f);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new hashtable with the same mappings as the given</div><div class="line">     * Map.  The hashtable is created with an initial capacity sufficient to</div><div class="line">     * hold the mappings in the given Map and a default load factor (0.75).</div><div class="line">     *</div><div class="line">     * @param t the map whose mappings are to be placed in this map.</div><div class="line">     * @throws NullPointerException if the specified map is null.</div><div class="line">     * @since   1.2</div><div class="line">     */</div><div class="line">    public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</div><div class="line">        this(Math.max(2*t.size(), 11), 0.75f);</div><div class="line">        putAll(t);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="四、put方法"><a href="#四、put方法" class="headerlink" title="四、put方法"></a>四、put方法</h2><p>put方法的整个流程为：</p><ul><li>判断value是否为空，为空则抛出异常；</li><li>计算key的hash值，并根据hash值获得key在table数组中的位置index，如果table[index]元素不为空，则进行迭代，如果遇到相同的key，则直接替换，并返回旧value；</li><li>否则，我们可以将其插入到table[index]位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null确保value不为null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        <span class="comment">//确保key不在hashtable中</span></div><div class="line">        <span class="comment">//首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置</span></div><div class="line">        <span class="comment">//其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            <span class="comment">//如果超过阀值，就进行rehash操作</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        <span class="comment">//将值插入，返回的为null</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        <span class="comment">// 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素</span></div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>通过一个实际的例子来演示一下这个过程：<br>假设我们现在Hashtable的容量为5，已经存在了(5,5)，(13,13)，(16,16)，(17,17)，(21,21)这5个键值对，目前他们在Hashtable中的位置如下：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv0ref4jnj30g707s3yh.jpg" alt=""></p><p>现在，我们插入一个新的键值对，put(16,22)，假设key=16的索引为1.但现在索引1的位置有两个Entry了，所以程序会对链表进行迭代。迭代的过程中，发现其中有一个Entry的key和我们要插入的键值对的key相同，所以现在会做的工作就是将newValue=22替换oldValue=16，然后返回oldValue=16.<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvbb90rlej30rm0dq74c.jpg" alt=""></p><p>然后我们现在再插入一个，put(33,33)，key=33的索引为3，并且在链表中也不存在key=33的Entry，所以将该节点插入链表的第一个位置。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwvbb90rlej30rm0dq74c.jpg" alt=""></p><h2 id="五、get方法"><a href="#五、get方法" class="headerlink" title="五、get方法"></a>五、get方法</h2><p>相比较于put方法，get方法则简单很多。其过程就是首先通过hash()方法求得key的哈希值，然后根据hash值得到index索引（上述两步所用的算法与put方法都相同）。然后迭代链表，返回匹配的key的对应的value；找不到则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="六、遍历方式"><a href="#六、遍历方式" class="headerlink" title="六、遍历方式"></a>六、遍历方式</h2><p>Hashtable有多种遍历方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//1、使用keys()</div><div class="line">Enumeration&lt;String&gt; en1 = table.keys();</div><div class="line">    while(en1.hasMoreElements()) &#123;</div><div class="line">    en1.nextElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2、使用elements()</div><div class="line">Enumeration&lt;String&gt; en2 = table.elements();</div><div class="line">    while(en2.hasMoreElements()) &#123;</div><div class="line">    en2.nextElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3、使用keySet()</div><div class="line">Iterator&lt;String&gt; it1 = table.keySet().iterator();</div><div class="line">    while(it1.hasNext()) &#123;</div><div class="line">    it1.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//4、使用entrySet()</div><div class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; it2 = table.entrySet().iterator();</div><div class="line">    while(it2.hasNext()) &#123;</div><div class="line">    it2.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（2）：Java HashSet</title>
    <link href="http://yoursite.com/2017/08/10/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%882%EF%BC%89%EF%BC%9AJava%20HashSet/"/>
    <id>http://yoursite.com/2017/08/10/Java集合学习手册（2）：Java HashSet/</id>
    <published>2017-08-10T15:20:45.000Z</published>
    <updated>2018-11-03T15:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.</p></blockquote><a id="more"></a><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p><p>HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，我们先来感性的认识一下这个结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();</div><div class="line">set.add(&quot;语文&quot;);</div><div class="line">set.add(&quot;数学&quot;);</div><div class="line">set.add(&quot;英语&quot;);</div><div class="line">set.add(&quot;历史&quot;);</div><div class="line">set.add(&quot;政治&quot;);</div><div class="line">set.add(&quot;地理&quot;);</div><div class="line">set.add(&quot;生物&quot;);</div><div class="line">set.add(&quot;化学&quot;);</div></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwvba2pqjjj30x80y8jvd.jpg" alt=""></p><p>通过HashSet最简单的构造函数和几个成员变量来看一下，证明咱们上边说的，其底层是HashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"></div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</div><div class="line"> * default initial capacity (16) and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实在英文注释中已经说的比较明确了。首先有一个HashMap的成员变量，我们在HashSet的构造函数中将其初始化，默认情况下采用的是initial capacity为16，load factor为0.75。</p><h2 id="二、HashSet的实现"><a href="#二、HashSet的实现" class="headerlink" title="二、HashSet的实现"></a>二、HashSet的实现</h2><p> 对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，只不过HashSet里面的HashMap所有的value都是同一个Object而已。HashSet的源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;  </div><div class="line">    extends AbstractSet&lt;E&gt;  </div><div class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </div><div class="line">&#123;  </div><div class="line">    static final long serialVersionUID = -5024744406713321676L;  </div><div class="line">  </div><div class="line">    // 底层使用HashMap来保存HashSet中所有元素。  </div><div class="line">    private transient HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </div><div class="line">    private static final Object PRESENT = new Object();  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    public HashSet() &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * @param c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));  </div><div class="line">    addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     * @param dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </div><div class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * @return 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;  </div><div class="line">    return map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * @return 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    public int size() &#123;  </div><div class="line">    return map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * @return 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean isEmpty() &#123;  </div><div class="line">    return map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * @param o 在此set中的存在已得到测试的元素。 </div><div class="line">     * @return 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean contains(Object o) &#123;  </div><div class="line">    return map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * @param e 将添加到此set中的元素。 </div><div class="line">     * @return 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean add(E e) &#123;  </div><div class="line">    return map.put(e, PRESENT)==null;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * @param o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * @return 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean remove(Object o) &#123;  </div><div class="line">    return map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    public void clear() &#123;  </div><div class="line">    map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    public Object clone() &#123;  </div><div class="line">        try &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            return newSet;  </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;  </div><div class="line">            throw new InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。这两个方法是比较重要的，希望大家在以后的开发过程中需要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashSet" scheme="http://yoursite.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（1）：Java HashMap</title>
    <link href="http://yoursite.com/2017/08/09/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%881%EF%BC%89%EF%BC%9AJava%20HashMap/"/>
    <id>http://yoursite.com/2017/08/09/Java集合学习手册（1）：Java HashMap/</id>
    <published>2017-08-09T15:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>从本文你可以学习到：</p><a id="more"></a><ol><li>什么时候会使用HashMap？他有什么特点？</li><li>你知道HashMap的工作原理吗？</li><li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li><li>你知道hash的实现吗？为什么要这样实现？</li><li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li></ol><p>当我们执行下面的操作时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line">map.put(&quot;语文&quot;, 1);</div><div class="line">map.put(&quot;数学&quot;, 2);</div><div class="line">map.put(&quot;英语&quot;, 3);</div><div class="line">map.put(&quot;历史&quot;, 4);</div><div class="line">map.put(&quot;政治&quot;, 5);</div><div class="line">map.put(&quot;地理&quot;, 6);</div><div class="line">map.put(&quot;生物&quot;, 7);</div><div class="line">map.put(&quot;化学&quot;, 8);</div><div class="line">for(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">政治: 5</div><div class="line">生物: 7</div><div class="line">历史: 4</div><div class="line">数学: 2</div><div class="line">化学: 8</div><div class="line">语文: 1</div><div class="line">英语: 3</div><div class="line">地理: 6</div></pre></td></tr></table></figure><p>发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023464953825.png" alt=""><br>在官方文档中是这样描述HashMap的：<br>&gt;<br>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and <strong>permits null values and the null key</strong>. (<strong>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</strong>) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p><ul><li>Initial capacity： The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</li><li>Load factor： The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.</li></ul><p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。</p><h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><p>HashMap底层维护一个数组，当新建一个HashMap的时候，就会初始化一个数组。我们看一下JDK源码中的HashMap构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line"></div><div class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">            capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">        table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        init();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到其中一行为<code>table = new Entry[capacity];</code>。在构造函数中，其创建了一个Entry的数组，其大小为capacity，那么Entry又是什么结构呢？看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">transient Entry&lt;K,V&gt;[] table;</div><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    final int hash;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HashMap中的是通过transient Entry<k,v>[] table来存储数据，该变量是通过transient进行修饰的。</k,v></p><p>Entry是一个static class，其中包含了key和value，也就是键值对，另外还包含了一个next的Entry指针。我们可以总结出：Entry就是数组中的元素，每个Entry其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="三、put-方法和get-方法"><a href="#三、put-方法和get-方法" class="headerlink" title="三、put()方法和get()方法"></a>三、put()方法和get()方法</h2><h3 id="3-1-put-方法"><a href="#3-1-put-方法" class="headerlink" title="3.1 put()方法"></a>3.1 put()方法</h3><p>put函数大致的思路为：</p><ol><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><p>具体代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 对key的hashCode()做hash</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//如果当前map中无数据，执行resize方法。并且返回n</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">///如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上就完事了</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//否则的话，说明这上面有元素</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//如果这个元素的key与要插入的一样，那么就替换一下，也完事。</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//1.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="comment">//还是遍历这条链子上的数据，跟jdk7没什么区别</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//2.完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法，treeifyBin()就是将链表转换成红黑树。</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 写入</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">//判断阈值，决定是否扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一直到JDK7为止，HashMap的结构基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。</p><p>这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看红黑树）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。</p><p>JDK8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树。这就是JDK7与JDK8中HashMap实现的最大区别。JDK中Entry的名字变成了Node，原因是和红黑树的实现TreeNode相关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure><p>当冲突节点数不小于8-1时，转换成红黑树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final int TREEIFY_THRESHOLD = 8;</div></pre></td></tr></table></figure><p>总结下put的过程：</p><p>当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置， 该位置就是此对象准备往数组中存放的位置。</p><p>如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否是否值相同，map不允许<key,value>键值对重复)， 使用 equals方法进行比较，如果对此链上的 key 通过 equals 比较有一个返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖；如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面，即新值存放在数组中，旧值在新值的链表上。</key,value></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2wq3mycj30wc0gajtb.jpg" alt=""></p><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get()方法"></a>3.2 get()方法</h3><p>在理解了put之后，get就很简单了。大致思路如下：</p><ol><li>bucket里的第一个节点，直接命中；</li><li>如果有冲突，则通过key.equals(k)去查找对应的entry<ul><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。 </li></ul></li></ol><p>具体代码的实现如下：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">&#125;</div><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">        // 直接命中</div><div class="line">        if (first.hash == hash &amp;&amp; // always check first node</div><div class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            return first;</div><div class="line">        // 未命中</div><div class="line">        if ((e = first.next) != null) &#123;</div><div class="line">            // 在树中get</div><div class="line">            if (first instanceof TreeNode)</div><div class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            // 在链表中get</div><div class="line">            do &#123;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    return e;</div><div class="line">            &#125; while ((e = e.next) != null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-null-key存取"><a href="#3-3-null-key存取" class="headerlink" title="3.3 null key存取"></a>3.3 null key存取</h3><p>对于put方法来说，HashMap会对null值key进行特殊处理，总是放到table[0]位置<br>对于get方法来说，同样当key为null时会进行特殊处理，在table[0]的链表上查找key为null的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="四、hash-与indexFor"><a href="#四、hash-与indexFor" class="headerlink" title="四、hash()与indexFor()"></a>四、hash()与indexFor()</h2><h3 id="4-1-hash-方法"><a href="#4-1-hash-方法" class="headerlink" title="4.1 hash()方法"></a>4.1 hash()方法</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023472197345.png" alt=""></p><p>在对hashCode()计算hash时具体实现是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。</p><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的：</p><p>&gt;<br>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><h3 id="4-2-indexFor-方法"><a href="#4-2-indexFor-方法" class="headerlink" title="4.2 indexFor()方法"></a>4.2 indexFor()方法</h3><p>在设计hash函数时，因为目前的table长度length n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h, int n) &#123;</div><div class="line">        return h &amp; (n-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p><p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题：<br>&gt;<br>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</p><p>之前已经提过，在获取HashMap的元素时，基本分两步：</p><ol><li>首先根据hashCode()做hash，然后确定bucket的index；</li><li>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li></ol><p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p><p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。</p><h2 id="五、resize-方法"><a href="#五、resize-方法" class="headerlink" title="五、resize()方法"></a>五、resize()方法</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><p>&gt;<br>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15023478436620.png" alt=""></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2wqjck3j30eg02j0ss.jpg" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15023479367792.png" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><p>下面是代码的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        // 没超过最大值，就扩充为原来的2倍</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    // 计算新的resize上限</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        // 把每个bucket都移动到新的buckets中</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        // 原索引</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        // 原索引+oldCap</div><div class="line">                        else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    // 原索引放到bucket里</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    // 原索引+oldCap放到bucket里</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="六、remove-、clear-、containsKey-和containsValue"><a href="#六、remove-、clear-、containsKey-和containsValue" class="headerlink" title="六、remove()、clear()、containsKey()和containsValue()"></a>六、remove()、clear()、containsKey()和containsValue()</h2><h3 id="6-1-remove-方法"><a href="#6-1-remove-方法" class="headerlink" title="6.1 remove()方法"></a>6.1 remove()方法</h3><p>remove方法和put get类似，计算hash，计算index，然后遍历查找，将找到的元素从table[index]链表移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key) &#123;</div><div class="line">       Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">       return (e == null ? null : e.value);</div><div class="line">   &#125;</div><div class="line">   final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</div><div class="line">       int hash = (key == null) ? 0 : hash(key.hashCode());</div><div class="line">       int i = indexFor(hash, table.length);</div><div class="line">       Entry&lt;K,V&gt; prev = table[i];</div><div class="line">       Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">       while (e != null) &#123;</div><div class="line">           Entry&lt;K,V&gt; next = e.next;</div><div class="line">           Object k;</div><div class="line">           if (e.hash == hash &amp;&amp;</div><div class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</div><div class="line">               modCount++;</div><div class="line">               size--;</div><div class="line">               if (prev == e)</div><div class="line">                   table[i] = next;</div><div class="line">               else</div><div class="line">                   prev.next = next;</div><div class="line">               e.recordRemoval(this);</div><div class="line">               return e;</div><div class="line">           &#125;</div><div class="line">           prev = e;</div><div class="line">           e = next;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return e;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h3 id="6-2-clear-方法"><a href="#6-2-clear-方法" class="headerlink" title="6.2 clear()方法"></a>6.2 clear()方法</h3><p>clear方法非常简单，就是遍历table然后把每个位置置为null，同时修改元素个数为0<br>需要注意的是clear方法只会清楚里面的元素，并不会重置capactiy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">       modCount++;</div><div class="line">       Entry[] tab = table;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</div><div class="line">           tab[i] = <span class="keyword">null</span>;</div><div class="line">       size = <span class="number">0</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="6-3-containsKey-方法"><a href="#6-3-containsKey-方法" class="headerlink" title="6.3 containsKey()方法"></a>6.3 containsKey()方法</h3><p>containsKey方法是先计算hash然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != <span class="keyword">null</span>;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="6-4-containsValue-方法"><a href="#6-4-containsValue-方法" class="headerlink" title="6.4 containsValue()方法"></a>6.4 containsValue()方法</h3><p>containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">    if (value == null)</div><div class="line">            return containsNullValue();</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)</div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)</div><div class="line">                if (value.equals(e.value))</div><div class="line">                    return true;</div><div class="line">    return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="6-5-Fail-Fast机制"><a href="#6-5-Fail-Fast机制" class="headerlink" title="6.5 Fail-Fast机制"></a>6.5 Fail-Fast机制</h3><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>fail-fast 机制是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p><p>例如：当某一个线程A通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出 ConcurrentModificationException异常，产生 fail-fast 事件。</p><p>这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容（当然不仅仅是HashMap才会有，其他例如ArrayList也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有modCount++这句），那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  </div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p><p>注意到modCount声明为volatile，保证线程之间修改的可见性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">    if (modCount != expectedModCount)</div><div class="line">        throw new ConcurrentModificationException();</div></pre></td></tr></table></figure><p>在HashMap的API中指出：</p><p>由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><p>在上文中也提到，fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用 fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。</p><h3 id="6-6-两种遍历方式"><a href="#6-6-两种遍历方式" class="headerlink" title="6.6 两种遍历方式"></a>6.6 两种遍历方式</h3><p>第一种效率高,以后一定要使用此种方式！</p><p>　<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　Map map = <span class="keyword">new</span> HashMap();</div><div class="line">　　Iterator iter = map.entrySet().iterator();</div><div class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">　　Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">　　Object key = entry.getKey();</div><div class="line">　　Object val = entry.getValue();</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><p>　<br>第二种效率低,以后尽量少使用！<br>　<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　　Map map = <span class="keyword">new</span> HashMap();</div><div class="line">　　Iterator iter = map.keySet().iterator();</div><div class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">　　Object key = iter.next();</div><div class="line">　　Object val = map.get(key);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><h2 id="七、一些问题"><a href="#七、一些问题" class="headerlink" title="七、一些问题"></a>七、一些问题</h2><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><ol><li>什么时候会使用HashMap？他有什么特点？<br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</li></ol><ol><li><p>你知道HashMap的工作原理吗？<br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p></li><li><p>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？<br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。</p></li><li><p>你知道hash的实现吗？为什么要这样实现？<br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></li><li><p>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p></li><li><p>Java集合小抄<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。<br>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p></li><li><p>一个很棒的面试题</p></li></ol><p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！</p><p>先来些简单的问题</p><p>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</p><p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p><p>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</p><p>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p><p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p><p>“当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p><p>“如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p><p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p><p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p><p>如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p><p>热心的读者贡献了更多的关于HashMap的问题：</p><p>为什么String, Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p><p>我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</p><p>我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。</p><p>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p><ul><li>hashing的概念</li><li>HashMap中解决碰撞的方法</li><li>equals()和hashCode()的应用，以及它们在HashMap中的重要性</li><li>不可变对象的好处</li><li>HashMap多线程的条件竞争</li><li>重新调整HashMap的大小</li></ul><p>总结</p><p>HashMap的工作原理<br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p><p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;从本文你可以学习到：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（10）：0-1背包问题与部分背包问题</title>
    <link href="http://yoursite.com/2017/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%8810%EF%BC%89%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%8E%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/09/数据结构与算法题解（10）：0-1背包问题与部分背包问题/</id>
    <published>2017-08-09T12:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为$v_i$，它的重量为$w_i$。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？问题结构如下图所示：</p><a id="more"></a><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2xbly34j30di0bp0u3.jpg" alt=""></p><p>这个问题其实根据不同的情况可以归结为不同的解决方法。假定我们这里选取的物品每个都是独立的，不能选取部分。也就是说我们要么选取某个物品，要么不能选取，不能只选取一个物品的一部分。这种情况，我们称之为0-1背包问题。而如果我们可以使用部分的物品的话，这个问题则成为部分背包(fractional knapsack)问题。下面我们针对每种情况具体分析一下。</p><h2 id="一、0-1背包"><a href="#一、0-1背包" class="headerlink" title="一、0-1背包"></a>一、0-1背包</h2><h3 id="1-1-初步分析"><a href="#1-1-初步分析" class="headerlink" title="1.1 初步分析"></a>1.1 初步分析</h3><p>对于这个问题，一开始确实有点不太好入手。一堆的物品，每一个都有一定的质量和价值，我们能够装入的总重量有限制，该怎么来装使得价值最大呢？对于这n个物品，每个物品我们可能会选，也可能不选，那么我们总共就可能有2^n种组合选择方式。如果我们采用这种办法来硬算的话，则整体的时间复杂度就达到指数级别的，肯定不可行。</p><p>现在我们换一种思路。既然每一种物品都有价格和重量，我们优先挑选那些单位价格最高的是否可行呢？比如在下图中，我们有3种物品，他们的重量和价格分别是10, 20, 30 kg和60, 100, 120。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2xd0fhyj30aw0943yk.jpg" alt=""></p><p>那么按照单位价格来算的话，我们最先应该挑选的是价格为60的元素，选择它之后，背包还剩下50 - 10 = 40kg。再继续前面的选择，我们应该挑选价格为100的元素，这样背包里的总价值为60 + 100 = 160。所占用的重量为30, 剩下20kg。因为后面需要挑选的物品为30kg已经超出背包的容量了。我们按照这种思路能选择到的最多就是前面两个物品。如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2xql916j303y08pq2t.jpg" alt=""></p><p>按照我们前面的期望，这样选择得到的价值应该是最大的。可是由于有一个背包重量的限制，这里只用了30kg，还有剩下20kg浪费了。这会是最优的选择吗？我们看看所有的选择情况：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv2xx5p8mj30d3090dg1.jpg" alt=""></p><p>很遗憾，在这几种选择情况中，我们前面的选择反而是带来价值最低的。而选择重量分别为20kg和30kg的物品带来了最大的价值。看来，我们刚才这种选择最佳单位价格的方式也行不通。 </p><h3 id="1-2-动态规划"><a href="#1-2-动态规划" class="headerlink" title="1.2 动态规划"></a>1.2 动态规划</h3><p>既然前面两种办法都不可行，我们再来看看有没有别的方法。我们再来看这个问题。我们需要选择n个元素中的若干个来形成最优解，假定为k个。那么对于这k个元素a1, a2, …ak来说，它们组成的物品组合必然满足总重量&lt;=背包重量限制，而且它们的价值必然是最大的。因为它们是我们假定的最优选择嘛，肯定价值应该是最大的。假定$a_k$是我们按照前面顺序放入的最后一个物品。它的重量为$w_k$，它的价值为$v_k$。既然我们前面选择的这k个元素构成了最优选择，如果我们把这个$a_k$物品拿走，对应于$k-1$个物品来说，它们所涵盖的重量范围为$0-(W-w_k)$。假定W为背包允许承重的量。假定最终的价值是V，剩下的物品所构成的价值为$V-v_k$。这剩下的$k-1$个元素是不是构成了一个这种$W-w_k$的最优解呢？</p><p>我们可以用反证法来推导。假定拿走$a_k$这个物品后，剩下的这些物品没有构成$W-w_k$重量范围的最佳价值选择。那么我们肯定有另外$k-1$个元素，他们在$W-w_k$重量范围内构成的价值更大。如果这样的话，我们用这$k-1$个物品再加上第k个，他们构成的最终W重量范围内的价值就是最优的。这岂不是和我们前面假设的k个元素构成最佳矛盾了吗？所以我们可以肯定，在这k个元素里拿掉最后那个元素，前面剩下的元素依然构成一个最佳解。</p><p>现在我们经过前面的推理已经得到了一个基本的递推关系，就是一个最优解的子解集也是最优的。可是，我们该怎么来求得这个最优解呢？我们这样来看。假定我们定义一个函数$c[i, w]$表示到第i个元素为止，在限制总重量为w的情况下我们所能选择到的最优解。那么这个最优解要么包含有i这个物品，要么不包含，肯定是这两种情况中的一种。如果我们选择了第i个物品，那么实际上这个最优解是c[i - 1, w-wi] + vi。而如果我们没有选择第i个物品，这个最优解是c[i-1, w]。这样，实际上对于到底要不要取第i个物品，我们只要比较这两种情况，哪个的结果值更大不就是最优的么？</p><p>在前面讨论的关系里，还有一个情况我们需要考虑的就是，我们这个最优解是基于选择物品i时总重量还是在w范围内的，如果超出了呢？我们肯定不能选择它，这就和c[i-1, w]一样。</p><p>另外，对于初始的情况呢？很明显c[0, w]里不管w是多少，肯定为0。因为它表示我们一个物品都不选择的情况。c[i, 0]也一样，当我们总重量限制为0时，肯定价值为0。</p><p>这样，基于我们前面讨论的这3个部分，我们可以得到一个如下的递推公式：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv2y3oldjj30qr04qjrn.jpg" alt=""></p><p>有了这个关系，我们可以更进一步的来考虑代码实现了。我们有这么一个递归的关系，其中，后面的函数结果其实是依赖于前面的结果的。我们只要按照前面求出来最基础的最优条件，然后往后面一步步递推，就可以找到结果了。</p><p>我们再来考虑一下具体实现的细节。这一组物品分别有价值和重量，我们可以定义两个数组int[] v, int[] w。v[i]表示第i个物品的价值，w[i]表示第i个物品的重量。为了表示c[i, w]，我们可以使用一个int[i][w]的矩阵。其中i的最大值为物品的数量，而w表示最大的重量限制。按照前面的递推关系，c[i][0]和c[0][w]都是0。而我们所要求的最终结果是c[n][w]。所以我们实际中创建的矩阵是(n + 1) x (w + 1)的规格。下面是该过程的一个代码参考实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class DynamicKnapSack &#123;</div><div class="line">    private int[] v;</div><div class="line">    private int[] w;</div><div class="line">    private int[][] c;</div><div class="line">    private int weight;</div><div class="line"></div><div class="line">    public DynamicKnapSack(int length, int weight, int[] vin, int[] win) &#123;</div><div class="line">        v = new int[length + 1];</div><div class="line">        w = new int[length + 1];</div><div class="line">        c = new int[length + 1][weight + 1];</div><div class="line">        this.weight = weight;</div><div class="line">        for(int i = 0; i &lt; length + 1; i++) &#123;</div><div class="line">            v[i] = vin[i];</div><div class="line">            w[i] = win[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void solve() &#123;</div><div class="line">       for(int i = 1; i &lt; v.length; i++) &#123;</div><div class="line">            for(int k = 1; k &lt;= weight; k++) &#123;</div><div class="line">                if(w[i] &lt;= k) &#123;</div><div class="line">                    if(v[i] + c[i - 1][k - w[i]] &gt; c[i - 1][k])</div><div class="line">                        c[i][k] = v[i] + c[i - 1][k - w[i]];</div><div class="line">                    else</div><div class="line">                        c[i][k] = c[i - 1][k];</div><div class="line">                &#125; else</div><div class="line">                    c[i][k] = c[i - 1][k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void printResult() &#123;</div><div class="line">        for(int i = 0; i &lt; v. length; i++) &#123;</div><div class="line">            for(int j = 0; j &lt;= weight; j++)</div><div class="line">                System.out.print(c[i][j] + &quot; &quot;);</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] v = &#123;0, 60, 100, 120&#125;;</div><div class="line">        int[] w = &#123;0, 10, 20, 30&#125;;</div><div class="line">        int weight = 50;</div><div class="line">        DynamicKnapSack knapsack = new DynamicKnapSack(3, weight, v, w);</div><div class="line">        knapsack.solve();</div><div class="line">        knapsack.printResult();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这部分代码里关键的就是solve方法。里面两个遍历循环，i表示从1到n的范围，对应于我们递归方法里描述的c(i, w)中到第i位。而k表示的是当前的重量限制。下面是程序运行的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 180 180 180 180 180 180 180 180 180 180 220</div></pre></td></tr></table></figure><p>最右下角的数值220就是c[3, 50]的解。<br>    至此，我们对于这种问题的解决方法已经分析出来了。它的总体时间复杂度为O(nw) ，其中w是设定的一个重量范围，因此也可以说它的时间复杂度为O(n)。</p><h2 id="二、部分背包问题"><a href="#二、部分背包问题" class="headerlink" title="二、部分背包问题"></a>二、部分背包问题</h2><p>和前面使用动态规划方法解决问题不一样。因为这里是部分背包问题，我们可以采用前面讨论过的一个思路。就是每次选择最优单位价格的物品，直到达到背包重量限制要求。</p><p>以前面的示例来看，我们按照这种方式选择的物品结果应该如下图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv2y9rwkbj305r08tjrb.jpg" alt=""></p><p>现在，我们从实现的角度再来考虑一下。我们这里的最优解是每次挑选性价比最高的物品。对于这一组物品来说，我们需要将他们按照性价比从最高到最低的顺序来取。我们可能需要将他们进行排序。然后再依次取出来放入背包中。假定我们已经有数组v，w，他们已经按照性价比排好序了。一个参考代码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public double selectMax() &#123;</div><div class="line">        double maxValue = 0.0;</div><div class="line">        int sum = 0;</div><div class="line">        int i;</div><div class="line">        for(i = 0; i &lt; v.length; i++) &#123;</div><div class="line">            if(sum + w[i] &lt; weight) &#123;</div><div class="line">                sum += w[i];</div><div class="line">                maxValue += v[i];</div><div class="line">            &#125; else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        if(i &lt; v.length &amp;&amp; sum &lt; weight) &#123;</div><div class="line">           maxValue += (double)(weight - sum) / w[i] * v[i];</div><div class="line">        &#125;</div><div class="line">        return maxValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里省略了对数组v, w的定义。关键点在于我们选择了若干了物品后要判断是否装满了背包重量。如果没有，还要从后面的里面挑选一部分。所以有一个if(i &lt; v.length &amp;&amp; sum &lt; weight)的判断。</p><p>在实现后我们来看该问题这种解法的时间复杂度，因为需要将数组排序，我们的时间复杂度为O(nlgn)。</p><p>在前面我们挑选按照性价比排好序的物品时，排序消耗了主要的时间。在这里，我们是否真的需要去把这些物品排序呢？在某些情况下，我们只要选择一堆物品，保证他们物品重量在指定范围内。如果我们一次挑出来一批这样的物品，而且他们满足这样的条件是不是更好呢？这一种思路是借鉴快速排序里对元素进行划分的思路。主要过程如下：</p><ol><li>求每个元素的单位价值，pi = vi /wi。然后数组按照pi进行划分，这样会被分成3个部分，L, M, N。其中L &lt; M &lt; N。这里L表示单位价值小于某个指定值的集合，M是等于这个值的集合，而N是大于这个值的集合。</li><li>我们可以首先看N的集合，因为这里都是单位价值高的集合。我们将他们的重量累加，如果WN的重量等于我们期望的值W，则N中间的结果就是我们找到的结果。</li><li>如果WN的重量大于W，我们需要在N集合里做进一步划分。</li><li>如果WN的重量小于W，我们需要在N的基础上再去L的集合里划分，找里面大的一部分。</li></ol><p>这样重复步骤1到4.</p><p>这里和快速排序的思路基本上差不多，只是需要将一个分割的集合给记录下来。其时间复杂度也更好一点，为O(N)。这里就简单的描述下思路，等后续再将具体的实现代码给补上。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们这里讨论的两种背包问题因为问题的不同其本质解决方法也不同。对于0-1背包来说，他们构成了一个最优解问题的基础。我们可以通过从最小的结果集递推出最终最优结果。他们之间构成了一个递归的关系。而对于部分背包问题来说，我们可以考虑用贪婪算法，每次选择当前看来最优的结果。最终也构成了一个最优的结果。一个小小的前提变化，问题解决的思路却大不同。里面的思想值得反复体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为$v_i$，它的重量为$w_i$。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？问题结构如下图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="0-1背包" scheme="http://yoursite.com/tags/0-1%E8%83%8C%E5%8C%85/"/>
    
      <category term="部分背包" scheme="http://yoursite.com/tags/%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（11）：最长回文子串</title>
    <link href="http://yoursite.com/2017/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2017/08/09/数据结构与算法题解（11）：最长回文子串/</id>
    <published>2017-08-09T12:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定字符串S，求它的最长回文子串。假设S的最长长度为1000，并且仅有唯一的最长回文子串。</p><a id="more"></a><h2 id="一、暴力法（-Brute-Force）"><a href="#一、暴力法（-Brute-Force）" class="headerlink" title="一、暴力法（ Brute Force）"></a>一、暴力法（ Brute Force）</h2><p>最简便，但同时时间复杂度也是最高的肯定是暴力解法，就是遍历字符串的“所有子串”，并判断每个子串是否为对称回文。因为字符串所有子串的复杂度为$O(n^2)$，在判断回文，总体的复杂度达到$O(n^3)$。</p><ul><li><p>复杂度：时间 $O(n^3) $空间 $O(1)$<br>可以做一些简单的优化：</p></li><li><p>从最长的子串开始遍历，一旦找到一个回文，就终止迭代。</p></li><li>判断回文采用收缩法，从最外一对字符往中心推进。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">        for (int size = s.length(); size &gt; 0; size--) &#123;</div><div class="line">            for (int low = 0, high = low+size-1; high &lt; s.length(); low++, high++) &#123;</div><div class="line">                if (shrinkCheckPalindrome(s,low,high)) &#123;</div><div class="line">                    return s.substring(low,high+1);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return s.substring(0,1);</div><div class="line">    &#125;</div><div class="line">    public boolean shrinkCheckPalindrome(String s, int low, int high) &#123;</div><div class="line">        while (low &lt;= high) &#123;</div><div class="line">            if (s.charAt(low) == s.charAt(high)) &#123;</div><div class="line">                low++; high--;</div><div class="line">            &#125; else &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：第一大问题拆解为小问题，第二重复利用之前的计算结果，来解答这道题。那如何划分小问题呢，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了，但是由于使用动态规划，使计算时间从$O(N^3)$减少到$O(n^2)$。</p><ul><li>复杂度：时间 $O(n^2) $空间 $O(n^2)$</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">      int n = s.length();</div><div class="line">      String res = null;</div><div class="line">      boolean[][] dp = new boolean[n][n];</div><div class="line">      for (int i = n - 1; i &gt;= 0; i--) &#123;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">          dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]);</div><div class="line">          if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123;</div><div class="line">            res = s.substring(i, j + 1);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、中心扩散法"><a href="#三、中心扩散法" class="headerlink" title="三、中心扩散法"></a>三、中心扩散法</h2><p>动态规划虽然优化了时间，但也浪费了空间。实际上我们并不需要一直存储所有子字符串的回文情况，我们需要知道的只是中心对称的较小一层是否是回文。所以如果我们从小到大连续以某点为个中心的所有子字符串进行计算，就能省略这个空间。  这种解法中，外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散，一旦不是回文就不再计算其他以此为中心的较大的字符串。由于中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称，所以我们要分别计算这两种对称情况。</p><ul><li>复杂度：时间 O(n^2) 空间 O(1)<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2qfx50bj305r08tjrb.jpg" alt=""></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    private int max = 0;</div><div class="line">    private String res = &quot;&quot;;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">        if (s.length() == 1) &#123; return s; &#125;</div><div class="line">        for (int i = 0; i &lt; s.length()-1; i++) &#123;</div><div class="line">            checkPalindromeExpand(s,i,i);</div><div class="line">            checkPalindromeExpand(s,i,i+1);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    public void checkPalindromeExpand(String s, int low, int high) &#123;</div><div class="line">        while (low &gt;= 0 &amp;&amp; high &lt; s.length()) &#123;</div><div class="line">            if (s.charAt(low) == s.charAt(high)) &#123;</div><div class="line">                if (high - low + 1 &gt; max) &#123;</div><div class="line">                    max = high - low + 1;</div><div class="line">                    res = s.substring(low,high+1);</div><div class="line">                &#125;</div><div class="line">                low--; high++;</div><div class="line">            &#125; else &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、马拉车算法"><a href="#四、马拉车算法" class="headerlink" title="四、马拉车算法"></a>四、马拉车算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 预处理字符串，避免奇偶问题</span></div><div class="line">        String str = preProcess(s);</div><div class="line">        <span class="comment">// idx是当前能够向右延伸的最远的回文串中心点，随着迭代而更新</span></div><div class="line">        <span class="comment">// max是当前最长回文串在总字符串中所能延伸到的最右端的位置</span></div><div class="line">        <span class="comment">// maxIdx是当前已知的最长回文串中心点</span></div><div class="line">        <span class="comment">// maxSpan是当前已知的最长回文串向左或向右能延伸的长度</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxSpan = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr = <span class="number">1</span>; curr &lt; str.length(); curr++)&#123;</div><div class="line">            <span class="comment">// 找出当前下标相对于idx的对称点</span></div><div class="line">            <span class="keyword">int</span> symmetryOfCurr = <span class="number">2</span> * idx - curr;</div><div class="line">            <span class="comment">// 如果当前已知延伸的最右端大于当前下标，我们可以用对称点的P值，否则记为1等待检查</span></div><div class="line">            p[curr] = max &gt; curr? Math.min(p[symmetryOfCurr], max - curr):<span class="number">1</span>;</div><div class="line">            <span class="comment">// 检查并更新当前下标为中心的回文串最远延伸的长度</span></div><div class="line">            <span class="keyword">while</span>((curr+p[curr])&lt;str.length() &amp;&amp; str.charAt(curr+p[curr])==str.charAt(curr-p[curr]))&#123;</div><div class="line">                p[curr]++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 检查并更新当前已知能够延伸最远的回文串信息</span></div><div class="line">            <span class="keyword">if</span>(curr+p[curr]&gt;max)&#123;</div><div class="line">                max = p[curr] + curr;</div><div class="line">                idx = curr;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 检查并更新当前已知的最长回文串信息</span></div><div class="line">            <span class="keyword">if</span>(p[curr]&gt;maxSpan)&#123;</div><div class="line">                maxSpan = p[curr];</div><div class="line">                maxIdx = curr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//去除占位符</span></div><div class="line">        <span class="keyword">return</span> s.substring((maxIdx-maxSpan)/<span class="number">2</span>,(maxSpan+maxIdx)/<span class="number">2</span>-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 预处理，如ABC,变为$#A#B#C#</span></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">preProcess</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        </div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"$"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</div><div class="line">            sb.append(<span class="string">"#"</span>);</div><div class="line">            sb.append(s.charAt(i));</div><div class="line">        &#125;</div><div class="line">        sb.append(<span class="string">"#"</span>);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定字符串S，求它的最长回文子串。假设S的最长长度为1000，并且仅有唯一的最长回文子串。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长回文子串" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（9）：最长公共子序列和最长公共子串</title>
    <link href="http://yoursite.com/2017/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%889%EF%BC%89%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2017/08/08/数据结构与算法题解（9）：最长公共子序列和最长公共子串/</id>
    <published>2017-08-08T14:20:45.000Z</published>
    <updated>2018-11-03T11:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、最长公共子序列（LCS）"><a href="#一、最长公共子序列（LCS）" class="headerlink" title="一、最长公共子序列（LCS）"></a>一、最长公共子序列（LCS）</h2><p>求最长公共子序列的数目，注意这里的子序列可以不是连续序列，务必问清楚题意。求『最长』类的题目往往与动态规划有点关系，这里是两个字符串，故应为双序列动态规划。</p><a id="more"></a><p>这道题的状态很容易找，不妨先试试以$f[i][j]$表示字符串 A 的前 i 位和字符串 B 的前 j 位的最长公共子序列数目，那么接下来试试寻找其状态转移方程。</p><p>从实际例子ABCD和EDCA出发，首先初始化f的长度为字符串长度加1，那么有$f[0][0] = 0, f[0][<em>] = 0, f[</em>][0] = 0$,最后应该返回$f[lenA][lenB]$. 即 f 中索引与字符串索引对应(字符串索引从1开始算起)，那么在A 的第一个字符与 B 的第一个字符相等时，$f[1][1] = 1 + f[0][0]$, 否则$f[1][1] = max(f[0][1], f[1][0])$。</p><p>推而广之，也就意味着若$A[i] == B[j]$, 则分别去掉这两个字符后，原 LCS 数目减一，那为什么一定是1而不是0或者2呢？因为不管公共子序列是以哪个字符结尾，在$A[i] == B[j]$时 LCS 最多只能增加1. 而在$A[i] != B[j]$时，由于A[i] 或者 B[j] 不可能同时出现在最终的 LCS 中，故这个问题可进一步缩小，$f[i][j] = max(f[i - 1][j], f[i][j - 1])$. 需要注意的是这种状态转移方程只依赖最终的 LCS 数目，而不依赖于公共子序列到底是以第几个索引结束。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv2zxf8n5j311l08tmyd.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">int</span>[][] lcs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> + lenA][<span class="number">1</span> + lenB];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> + lenA; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1</span> + lenB; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                    lcs[i][j] = <span class="number">1</span> + lcs[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    lcs[i][j] = Math.max(lcs[i - <span class="number">1</span>][j], lcs[i][j - <span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lcs[lenA][lenB];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonSubsequence="</span> + longestCommonSubsequence(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、最长公共子串"><a href="#二、最长公共子串" class="headerlink" title="二、最长公共子串"></a>二、最长公共子串</h2><h3 id="2-1-简单考虑"><a href="#2-1-简单考虑" class="headerlink" title="2.1 简单考虑"></a>2.1 简单考虑</h3><p>可以使用两根指针索引分别指向两个字符串的当前遍历位置，若遇到相等的字符时则同时向后移动一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();     </div><div class="line">        <span class="keyword">int</span> lcs = <span class="number">0</span>, lcs_temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenB; ++j) &#123;</div><div class="line">                lcs_temp = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> ((i + lcs_temp &lt; lenA) &amp;&amp;</div><div class="line">                       (j + lcs_temp &lt; lenB) &amp;&amp;</div><div class="line">                       (A.charAt(i + lcs_temp) == B.charAt(j + lcs_temp)))</div><div class="line">                &#123;</div><div class="line">                    ++lcs_temp;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (lcs_temp &gt; lcs) &#123;</div><div class="line">                    lcs = lcs_temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lcs;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonString="</span> + longestCommonSubstring(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h3><p>把$D[i][j] $定义为：两个string的前i个和前j个字符串，尾部连到最后的最长子串。</p><p>然后$D[i][j] = $</p><ol><li>$i = 0 || j = 0 : 0$</li><li>$s1.char[i - 1] = s2.char[j - 1] ? D[i-1][j-1] + 1 : 0;$</li></ol><p>另外，创建一个max的缓存，不段更新即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();        </div><div class="line">        <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[lenA + <span class="number">1</span>][lenB + <span class="number">1</span>];        </div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">      </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lenA; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lenB; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</div><div class="line">                    D[i][j] = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                        D[i][j] = D[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        D[i][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;                </div><div class="line">                max = Math.max(max, D[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonString="</span> + longestCommonSubstring(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、最长公共子序列（LCS）&quot;&gt;&lt;a href=&quot;#一、最长公共子序列（LCS）&quot; class=&quot;headerlink&quot; title=&quot;一、最长公共子序列（LCS）&quot;&gt;&lt;/a&gt;一、最长公共子序列（LCS）&lt;/h2&gt;&lt;p&gt;求最长公共子序列的数目，注意这里的子序列可以不是连续序列，务必问清楚题意。求『最长』类的题目往往与动态规划有点关系，这里是两个字符串，故应为双序列动态规划。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长公共子序列" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
      <category term="最长公共子串" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（8）：KMP算法</title>
    <link href="http://yoursite.com/2017/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%888%EF%BC%89%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/08/08/数据结构与算法题解（8）：KMP算法/</id>
    <published>2017-08-08T11:20:45.000Z</published>
    <updated>2018-11-07T15:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>KMP算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。其中第一位就是《计算机程序设计艺术》的作者！</p><a id="more"></a><p>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字（接下来称它为P），如果它在一个主串（接下来称为T）中出现，就返回它的具体位置，否则返回-1（常用手段）。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv3adonj8j30d7031weg.jpg" alt=""></p><p>首先，对于这个问题有一个很单纯的想法：从左到右一个个匹配，如果这个过程中有某个字符不匹配，就跳回去，将模式串向右移动一位。这有什么难的？</p><p>我们可以这样初始化：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzxbrzm27j313s0fuweq.jpg" alt=""></p><p>之后我们只需要比较i指针指向的字符和j指针指向的字符是否一致。如果一致就都向后移动，如果不一致，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv3ae5lrwj30dc05o0st.jpg" alt=""></p><p>A和E不相等，那就把i指针移回第1位（假设下标从0开始），j移动到模式串的第0位，然后又重新开始这个步骤：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzxc7wg1xj31220g4dg2.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">public static int bf(String ts,String ps) &#123;</div><div class="line">char[] t = ts.toCharArray();</div><div class="line">char[] p = ps.toCharArray();</div><div class="line">int i = 0; // 主串的位置</div><div class="line">int j = 0; // 模式串的位置</div><div class="line">while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</div><div class="line">    if (t[i] == p[j]) &#123; // 当两个字符相同，就比较下一个</div><div class="line">    i++;</div><div class="line">    j++;</div><div class="line">    &#125;else &#123;</div><div class="line">    i = i - j + 1; // 一旦不匹配，i后退</div><div class="line">    j = 0; // j归0</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">if (j == p.length) &#123;</div><div class="line">return i - j;</div><div class="line">     &#125;else &#123;</div><div class="line">        return -1;</div><div class="line">     &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的程序是没有问题的，但不够好！如果是人为来寻找的话，肯定不会再把i移动回第1位，因为主串匹配失败的位置前面除了第一个A之外再也没有A了，我们为什么能知道主串前面只有一个A？因为我们已经知道前面三个字符都是匹配的！（这很重要）。移动过去肯定也是不匹配的！有一个想法，i可以不动，我们只需要移动j即可，如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzxdes7rjj314i0g4glu.jpg" alt=""></p><p>上面的这种情况还是比较理想的情况，我们最多也就多比较了再次。但假如是在主串“SSSSSSSSSSSSSA”中查找“SSSSB”，比较到最后一个才知道不匹配，然后i回溯，这个的效率是显然是最低的。</p><p>大牛们是无法忍受“暴力破解”这种低效的手段的，于是他们三个研究出了KMP算法。其思想就如同我们上边所看到的一样：“利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。”</p><p>所以，整个KMP的重点就在于当某一个字符与主串不匹配时，我们应该知道j指针要移动到哪？</p><p>接下来我们自己来发现j的移动规律：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzxdtx6j9j311y0g6glv.jpg" alt=""></p><p>如图：C和D不匹配了，我们要把j移动到哪？显然是第1位。为什么？因为前面有一个A相同啊：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3af3vw9j30d905kt8t.jpg" alt=""></p><p>如下图也是一样的情况：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzxe6j4frj312m0gi0t1.jpg" alt=""></p><p>可以把j指针移动到第2位，因为前面有两个字母是一样的：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwzxeixjouj31260fet90.jpg" alt=""></p><p>至此我们可以大概看出一点端倪，当匹配失败时，j要移动的下一个位置k。存在着这样的性质：最前面的k个字符和j之前的最后k个字符是一样的。</p><p>如果用数学公式来表示是这样的</p><script type="math/tex; mode=display">P[0，k-1] == P[j-k， j-1]</script><p>这个相当重要，如果觉得不好记的话，可以通过下图来理解：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwzxeyvassj30yg0gemxq.jpg" alt=""></p><p>弄明白了这个就应该可能明白为什么可以直接将j移动到k位置了。</p><p>因为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">当T[i] != P[j]时</div><div class="line"></div><div class="line">有T[i-j ~ i-1] == P[0 ~ j-1]</div><div class="line"></div><div class="line">由P[0 ~ k-1] == P[j-k ~ j-1]</div><div class="line"></div><div class="line">必然：T[i-k ~ i-1] == P[0 ~ k-1]</div></pre></td></tr></table></figure><p>公式很无聊，能看明白就行了，不需要记住。</p><p>这一段只是为了证明我们为什么可以直接将j移动到k而无须再比较前面的k个字符。</p><p>好，接下来就是重点了，怎么求这个（这些）k呢？因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，所以用一个数组next来保存，next[j] = k，表示当T[i] != P[j]时，j指针的下一个位置。</p><p>很多教材或博文在这个地方都是讲得比较含糊或是根本就一笔带过，甚至就是贴一段代码上来，为什么是这样求？怎么可以这样求？根本就没有说清楚。而这里恰恰是整个算法最关键的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static int[] getNext(String ps) &#123;</div><div class="line">        char[] p = ps.toCharArray();  </div><div class="line">int[] next = new int[p.length];  </div><div class="line">next[0] = -1;  </div><div class="line">int j = 0; </div><div class="line">int k = -1; </div><div class="line">while (j &lt; p.length - 1) &#123;</div><div class="line">    if (k == -1 || p[j] == p[k]) &#123;</div><div class="line">        next[++j] = ++k;</div><div class="line">    &#125; else &#123;</div><div class="line">    k = next[k]; </div><div class="line">    &#125;</div><div class="line">        &#125;</div><div class="line">return next;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个版本的求next数组的算法应该是流传最广泛的，代码是很简洁。可是真的很让人摸不到头脑，它这样计算的依据到底是什么？<br>好，先把这个放一边，我们自己来推导思路，现在要始终记住一点，next[j]的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置。<br>先来看第一个：当j为0时，如果这时候不匹配，怎么办？<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzxfbddq4j30tu0g80sw.jpg" alt=""><br>像上图这种情况，j已经在最左边了，不可能再移动了，这时候要应该是i指针后移。所以在代码中才会有next[0] = -1;这个初始化。<br>如果是当j为1的时候呢？<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwv3agjfeij30a305g3yi.jpg" alt=""></p><p>显然，j指针一定是后移到0位置的。因为它前面也就只有这一个位置了~~~<br>下面这个是最重要的，请看如下图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzxfqx5oyj312w0fyq3p.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv3agzf4bj30aq04jjrl.jpg" alt=""></p><p>请仔细对比这两个图。我们发现一个规律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当P[k] == P[j]时，</div><div class="line">有next[j+1] == next[j] + 1</div></pre></td></tr></table></figure><p>其实这个是可以证明的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）</div><div class="line">这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。</div><div class="line">即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。</div></pre></td></tr></table></figure><p>这里的公式不是很好懂，还是看图会容易理解些。<br>那如果P[k] != P[j]呢？比如下图所示：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzxgdh3r6j31040cmt97.jpg" alt=""><br>像这种情况，如果你从代码上看应该是这一句：k = next[k];为什么是这样子？你看下面应该就明白了。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzxgp5o1ej31bi0h0mxq.jpg" alt=""><br>现在你应该知道为什么要k = next[k]了吧！像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。</p><p>在P[K]!=P[j]时，我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</p><p>有了next数组之后就一切好办了，我们可以动手写KMP算法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String ts, String ps)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] t = ts.toCharArray();</div><div class="line">    <span class="keyword">char</span>[] p = ps.toCharArray();</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 主串的位置</span></div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串的位置</span></div><div class="line">    <span class="keyword">int</span>[] next = getNext(ps);</div><div class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</div><div class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || t[i] == p[j]) &#123; <span class="comment">// 当j为-1时，要移动的是i，当然j也要归0</span></div><div class="line">        i++;</div><div class="line">        j++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// i不需要回溯了</span></div><div class="line">        <span class="comment">// i = i - j + 1;</span></div><div class="line">        j = next[j]; <span class="comment">// j回到指定位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (j == p.length) &#123;</div><div class="line">    <span class="keyword">return</span> i - j;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和暴力破解相比，就改动了4个地方。其中最主要的一点就是，i不需要回溯了。</p><p>最后，来看一下上边的算法存在的缺陷。来看第一个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwzxh5m1m0j30w60e83yp.jpg" alt=""><br>显然，当我们上边的算法得到的next数组应该是[ -1，0，0，1 ]</p><p>所以下一步我们应该是把j移动到第1个元素：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwzxhhpxv0j314q0hojrq.jpg" alt=""><br>不难发现，这一步是完全没有意义的。因为后面的B已经不匹配了，那前面的B也一定是不匹配的，同样的情况其实还发生在第2个元素A上。<br>显然，发生问题的原因在于P[j] == P[next[j]]。<br>所以我们也只需要添加一个判断条件即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String ps) &#123;</div><div class="line">        <span class="keyword">char</span>[] p = ps.toCharArray();  </div><div class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];  </div><div class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;  </div><div class="line"><span class="keyword">int</span> j = <span class="number">0</span>; </div><div class="line"><span class="keyword">int</span> k = -<span class="number">1</span>; </div><div class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</div><div class="line">    <span class="keyword">if</span> (p[++j] == p[++k]) &#123; <span class="comment">// 当两个字符相等时要跳过</span></div><div class="line">    next[++j] = ++k;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    next[j] = k;;</div><div class="line">    &#125; </div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">    k = next[k];</div><div class="line">    &#125;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">return</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KMP算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。其中第一位就是《计算机程序设计艺术》的作者！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP算法" scheme="http://yoursite.com/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（7）：最短编辑距离</title>
    <link href="http://yoursite.com/2017/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%887%EF%BC%89%EF%BC%9A%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2017/08/07/数据结构与算法题解（7）：最短编辑距离/</id>
    <published>2017-08-07T14:20:45.000Z</published>
    <updated>2018-11-03T09:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>现代搜索技术的发展很多以提供优质、高效的服务作为目标。比如说：baidu、google、sousou等知名全文搜索系统。当我们输入一个错误的query=”Jave” 的时候，返回中有大量包含正确的拼写 “Java”的网页。是怎么做到的呢？这其中，字符串的相似度计算是做到这一点的方法之一。</p><a id="more"></a><h2 id="一、字符串编辑距离"><a href="#一、字符串编辑距离" class="headerlink" title="一、字符串编辑距离"></a>一、字符串编辑距离</h2><p>是一种字符串之间相似度计算的方法。给定两个字符串S、T，将S转换成T所需要的删除，插入，替换操作的数量就叫做S到T的编辑路径。而最短的编辑路径就叫做字符串S和T的编辑距离。</p><p>举个例子：S=“eeba”   T=”abac”   我们可以按照这样的步骤转变：(1) 将S中的第一个e变成a;(2) 删除S中的第二个e;(3)在S中最后添加一个c; 那么S到T的编辑路径就等于3。当然，这种变换并不是唯一的，但如果3是所有变换中最小值的话。那么我们就可以说S和T的编辑距离等于3了。</p><h2 id="二、动态规划解决编辑距离"><a href="#二、动态规划解决编辑距离" class="headerlink" title="二、动态规划解决编辑距离"></a>二、动态规划解决编辑距离</h2><p>动态规划(dynamic programming)是一种解决复杂问题最优解的策略。它的基本思路就是：将一个复杂的最优解问题分解成一系列较为简单的最优解问题，再将较为简单的的最优解问题进一步分解，直到可以一眼看出最优解为止。</p><p>动态规划算法是解决复杂问题最优解的重要算法。其算法的难度并不在于算法本身的递归难以实现，而主要是编程者对问题本身的认识是否符合动态规划的思想。现在我们就来看看动态规划是如何解决编辑距离的。</p><p>假设$dp[i-1][j-1]$表示一个长为$i-1$的字符串$str1$变为长为$j-1$的字符串str2的最短距离，如果我们此时想要把$str1a$这个字符串变成$str2b$这个字符串，我们有如下几种选择：</p><ul><li>替换： 在str1变成str2的步骤后，我们将str1a中的a替换为b，就得到str2b (如果a和b相等，就不用操作)</li><li>增加： 在str1a变成str2的步骤后，我们再在末尾添加一个b，就得到str2b (str1a先根据已知距离变成str2，再加个b)</li><li>删除： 在str1变成str2b的步骤后，对于str1a，我们将末尾的a删去，就得到str2b (str1a将a删去得到str1，而str1到str2b的编辑距离已知)</li></ul><p>根据这三种操作，我们可以得到递推式</p><p>若a和b相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1])</div></pre></td></tr></table></figure><p>若a和b不相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)</div></pre></td></tr></table></figure><p>因为将一个非空字符串变成空字符串的最小操作数是字母个数（全删），反之亦然，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[0][j]=j, dp[i][0]=i</div></pre></td></tr></table></figure><p>最后我们只要返回dp[m][n]即可，其中m是word1的长度，n是word2的长度</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static int minDistance(String word1, String word2) &#123;</div><div class="line">        int m = word1.length(), n = word2.length();</div><div class="line">        int[][] dp = new int[m + 1][n + 1];</div><div class="line">        // 初始化空字符串的情况</div><div class="line">        for(int i = 1; i &lt;= m; i++)&#123;</div><div class="line">            dp[i][0] = i;</div><div class="line">        &#125;</div><div class="line">        for(int i = 1; i &lt;= n; i++)&#123;</div><div class="line">            dp[0][i] = i;</div><div class="line">        &#125;</div><div class="line">        for(int i = 1; i &lt;= m; i++)&#123;</div><div class="line">            for(int j = 1; j &lt;= n; j++)&#123;</div><div class="line">                // 增加操作：str1a变成str2后再加上b，得到str2b</div><div class="line">                int insertion = dp[i][j-1] + 1;</div><div class="line">                // 删除操作：str1a删除a后，再由str1变为str2b</div><div class="line">                int deletion = dp[i-1][j] + 1;</div><div class="line">                // 替换操作：先由str1变为str2，然后str1a的a替换为b，得到str2b</div><div class="line">                int replace = dp[i-1][j-1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1);</div><div class="line">                // 三者取最小</div><div class="line">                dp[i][j] = Math.min(replace, Math.min(insertion, deletion));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return dp[m][n];</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        String source = &quot;zhanghua&quot;;  </div><div class="line">        String target = &quot;zhanghau&quot;;  </div><div class="line">        System.out.println(&quot;minDistance=&quot; + minDistance(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minDistance=2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代搜索技术的发展很多以提供优质、高效的服务作为目标。比如说：baidu、google、sousou等知名全文搜索系统。当我们输入一个错误的query=”Jave” 的时候，返回中有大量包含正确的拼写 “Java”的网页。是怎么做到的呢？这其中，字符串的相似度计算是做到这一点的方法之一。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短编辑距离" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
</feed>
