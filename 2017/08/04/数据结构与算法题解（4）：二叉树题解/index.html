<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构,算法,二叉树," />





  <link rel="alternate" href="/atom.xml" title="Free Will" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico?v=5.1.0" />






<meta name="description" content="二叉树相关题解java实现。">
<meta name="keywords" content="数据结构,算法,二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法题解（4）：二叉树题解">
<meta property="og:url" content="http://yoursite.com/2017/08/04/数据结构与算法题解（4）：二叉树题解/index.html">
<meta property="og:site_name" content="Free Will">
<meta property="og:description" content="二叉树相关题解java实现。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.49.39.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.51.43.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午2.54.39.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.06.35.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午12.17.30.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午9.50.37.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/15017653485586.jpg">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.29.00.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.39.38.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.44.34.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午10.55.51.png">
<meta property="og:updated_time" content="2017-09-01T07:02:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法题解（4）：二叉树题解">
<meta name="twitter:description" content="二叉树相关题解java实现。">
<meta name="twitter:image" content="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.49.39.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title> 数据结构与算法题解（4）：二叉树题解 | Free Will </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9a21041c6a1d47620a3a748589516274";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Free Will</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tech-stack">
          <a href="/tech-stack" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-balance-scale"></i> <br />
            
            技术栈
          </a>
        </li>
      
        
        <li class="menu-item menu-item-read-books">
          <a href="/read-books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            读书记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-on-earth">
          <a href="/on-earth" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-firefox"></i> <br />
            
            人间事
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于我
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜一下
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input" placeholder="search my blog...">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  

</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/04/数据结构与算法题解（4）：二叉树题解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="狗皮膏药">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/img/v.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Free Will">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Free Will" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                数据结构与算法题解（4）：二叉树题解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T23:20:45+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>二叉树相关题解java实现。</p>
<a id="more"></a>
<h2 id="一、重建二叉树（剑6）"><a href="#一、重建二叉树（剑6）" class="headerlink" title="一、重建二叉树（剑6）"></a>一、重建二叉树（剑6）</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.49.39.png" alt="屏幕快照 2017-07-28 上午10.49.39"></p>
<ol>
<li>根据前序遍历的特点，我们知道根结点为1</li>
<li>观察中序遍历。其中root节点G左侧的472必然是root的左子树，G右侧的5386必然是root的右子树。</li>
<li>观察左子树472，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为2。</li>
<li>同样的道理，root的右子树节点5386中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</li>
<li>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。</li>
</ol>
<p>该步递归的过程可以简洁表达如下：</p>
<ol>
<li>确定根,确定左子树，确定右子树。</li>
<li>在左子树中递归。</li>
<li>在右子树中递归。</li>
<li>打印当前根。</li>
</ol>
<p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.51.43.png" alt="屏幕快照 2017-07-28 上午10.51.43"></p>
<p>递归代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; </div><div class="line">        return reConBTree(pre,0,pre.length-1,in,0,in.length-1);</div><div class="line">    &#125;</div><div class="line">    public TreeNode reConBTree(int [] pre,int preleft,int preright,int [] in,int inleft,int inright)&#123;</div><div class="line">        if(preleft &gt; preright || inleft&gt; inright)//当到达边界条件时候返回null</div><div class="line">            return null;</div><div class="line">        //新建一个TreeNode</div><div class="line">        TreeNode root = new TreeNode(pre[preleft]);</div><div class="line">        //对中序数组进行输入边界的遍历</div><div class="line">        for(int i = inleft; i&lt;= inright; i++)&#123;</div><div class="line">            if(pre[preleft] == in[i])&#123;</div><div class="line">                //重构左子树，注意边界条件</div><div class="line">                root.left = reConBTree(pre,preleft+1,preleft+i-inleft,in,inleft,i-1);</div><div class="line">                //重构右子树，注意边界条件</div><div class="line">                root.right = reConBTree(pre,preleft+i+1-inleft,preright,in,i+1,inright);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;      </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">## 二、树的子结构（剑18）</div><div class="line">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</div><div class="line"></div><div class="line">要查找树A中是否存在和树B结构一样的子树，我们可以分成两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A以R为根结点的子树是不是包含和树B一样的结构。</div><div class="line"></div><div class="line">第一步在树A中查找与根结点的值一样的结点，实际上就是树的遍历。对二叉树这种数据结构熟悉的读者自然知道可以用递归的方法去遍历，也可以用循环的方法去遍历。由于递归的代码实现比较简洁，面试时如果没有特别要求，通常会采用递归的方式。参考代码如下：</div><div class="line">&gt;java第一步</div><div class="line"></div><div class="line">```java</div><div class="line">public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        //一定要注意边界条件的检查，即检查空指针。否则程序容易奔溃，面试时尤其要注意。这里当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</div><div class="line">        if(root1!=null&amp;&amp;root2!=null)&#123;</div><div class="line">        ////如果找到了对应Tree2的根节点的点</div><div class="line">            if(root1.val==root2.val)&#123;</div><div class="line">            //以这个根节点为为起点判断是否包含Tree2</div><div class="line">                result = DoesTree1HaveTree2(root1,root2);</div><div class="line">            &#125;</div><div class="line">            //如果找不到，那么就再去root的左儿子当作起点，去判断是否包含Tree2</div><div class="line">            if(!result)&#123;</div><div class="line">                result=HasSubtree(root1.left,root2);</div><div class="line">            &#125;</div><div class="line">            //如果还找不到，那么就再去root的右儿子当作起点，去判断是否包含Tree2</div><div class="line">            if(!result)&#123;</div><div class="line">                result=HasSubtree(root1.right,root2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第二步是判断树A中以R为根结点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果结点R的值和树B的根结点不同，则以R为根结点的子树和树B一定不具有相同的结点；如果他们的值相同，则递归地判断它们各自的左右结点的值是不是相同。递归的终止条件是我们达到了树A或者树B的叶结点。</p>
<p>代码如下：</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</div><div class="line">       <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></div><div class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></div><div class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//如果其中有一个点没有对应上，返回false</span></div><div class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果根节点对应的上，那么就分别去左右子节点里面匹配</span></div><div class="line">        <span class="keyword">return</span> DoesTree1HaveTree2(root1.left,root2.left)&amp;&amp;DoesTree1HaveTree2(root1.right,root2.right);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午2.54.39.png" alt="屏幕快照 2017-08-01 下午2.54.39"></p>
<p>二叉树相关的代码有大量的指针操作，每一次使用指针的时候，我们都要问自己这个指针有没有可能是NULL，如果是NULL该怎么处理。</p>
<h2 id="三、二叉树的镜像（剑19）"><a href="#三、二叉树的镜像（剑19）" class="headerlink" title="三、二叉树的镜像（剑19）"></a>三、二叉树的镜像（剑19）</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.06.35.png" alt="屏幕快照 2017-08-01 下午3.06.35"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界</span></div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//交换左右子树</span></div><div class="line">        TreeNode temp = root.left;</div><div class="line">        root.left=root.right;</div><div class="line">        root.right=temp;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.right);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、从上往下打印二叉树（剑23）"><a href="#四、从上往下打印二叉树（剑23）" class="headerlink" title="四、从上往下打印二叉树（剑23）"></a>四、从上往下打印二叉树（剑23）</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午12.17.30.png" alt="屏幕快照 2017-08-02 上午12.17.30"></p>
<p>每次打印一个结点时，如果该结点有子结点，则把该结点的子结点放到队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; List=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> List;&#125;</div><div class="line">        </div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);<span class="comment">//先把根结点加入队列q</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;<span class="comment">//队列非空时</span></div><div class="line">            TreeNode treenode=queue.remove();<span class="comment">//取出队列头结点</span></div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;<span class="comment">//向队列加入左孩子（若有）</span></div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125;<span class="comment">//向队列加入右孩子（若有）</span></div><div class="line">            List.add(treenode.val);<span class="comment">//加到打印列表中</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> List;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="五、二叉搜索树的后序遍历序列（剑24）"><a href="#五、二叉搜索树的后序遍历序列（剑24）" class="headerlink" title="五、二叉搜索树的后序遍历序列（剑24）"></a>五、二叉搜索树的后序遍历序列（剑24）</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午9.50.37.png" alt="屏幕快照 2017-08-02 上午9.50.37"><br>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分成两部分：第一部分是左子树结点的值，它们都比根结点小；第二部分是右子树结点的值，它们都比根结点大。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = sequence.length;</div><div class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">        <span class="keyword">int</span> root = sequence[length-<span class="number">1</span>];<span class="comment">//根结点</span></div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//外部初始化     </span></div><div class="line">        <span class="comment">//找到左子树的最后一个结点位置</span></div><div class="line">        <span class="keyword">for</span>(;i&lt;length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//如果右子树的结点值小于根结点的值，则返回false</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[j]&lt;root)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</div><div class="line">        <span class="comment">//递归左右子树</span></div><div class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line">            left = VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//Arrays的copyOfRange方法</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;length-<span class="number">1</span>)&#123;</div><div class="line">            right = VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,length-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left&amp;&amp;right;                </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="六、二叉树中和为某一值的路径（剑25）"><a href="#六、二叉树中和为某一值的路径（剑25）" class="headerlink" title="六、二叉树中和为某一值的路径（剑25）"></a>六、二叉树中和为某一值的路径（剑25）</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</div><div class="line">        list.add(root.val);</div><div class="line">        target -= root.val;<span class="comment">//每次减去结点的值</span></div><div class="line">        <span class="comment">//如果target等于0，则说明这条路径和为target，添加到listAll中</span></div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</div><div class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));<span class="comment">//因为add添加的是引用，如果不new一个的话，后面的操作会更改listAll中list的值</span></div><div class="line">        <span class="comment">//向左孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)FindPath(root.left, target);</div><div class="line">        <span class="comment">//向右孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)FindPath(root.right, target);</div><div class="line">        <span class="comment">//如果不满足条件，则回到父节点；</span></div><div class="line">        list.remove(list.size()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> listAll;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="七、二叉搜索树与双向链表（剑27）"><a href="#七、二叉搜索树与双向链表（剑27）" class="headerlink" title="七、二叉搜索树与双向链表（剑27）"></a>七、二叉搜索树与双向链表（剑27）</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    TreeNode head = <span class="keyword">null</span>;</div><div class="line">    TreeNode realHead = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        ConvertSub(pRootOfTree);</div><div class="line">        <span class="keyword">return</span> realHead<span class="comment">//realHead是每个子树排序后的第一个结点，head是排序后的最后一个结点;</span></div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        <span class="comment">//递归中序遍历</span></div><div class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        ConvertSub(pRootOfTree.left);</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//初始处</span></div><div class="line">            head = pRootOfTree;</div><div class="line">            realHead = pRootOfTree;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//前两句实现双向，第三句跳到下一个节点。</span></div><div class="line">            head.right = pRootOfTree;</div><div class="line">            pRootOfTree.left = head;</div><div class="line">            head = pRootOfTree;</div><div class="line">        &#125;</div><div class="line">        ConvertSub(pRootOfTree.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="八、二叉树的深度（剑39-1）"><a href="#八、二叉树的深度（剑39-1）" class="headerlink" title="八、二叉树的深度（剑39.1）"></a>八、二叉树的深度（剑39.1）</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>Java 经典的求二叉树深度 递归写法</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="九、平衡二叉树（剑39-2）"><a href="#九、平衡二叉树（剑39-2）" class="headerlink" title="九、平衡二叉树（剑39.2）"></a>九、平衡二叉树（剑39.2）</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>有了求二叉树的深度的经验之后，我们就很容易想到一个思路：在遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义它就是一颗平衡的二叉树。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</div><div class="line">        <span class="keyword">int</span> diff = left-right;</div><div class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">1</span>||diff&lt;-<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left)&amp;&amp;IsBalanced_Solution(root.right);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十、二叉搜索树的最低公共祖先（剑50-1）"><a href="#十、二叉搜索树的最低公共祖先（剑50-1）" class="headerlink" title="十、二叉搜索树的最低公共祖先（剑50.1）"></a>十、二叉搜索树的最低公共祖先（剑50.1）</h2><p>二叉搜索树是经过排序的，位于左子树的节点都比父节点小，位于右子树的节点都比父节点大。既然要找最低的公共祖先节点，我们可以从根节点开始进行比较。若当前节点的值比两个节点的值都大，那么最低的祖先节点一定在当前节点的左子树中，则遍历当前节点的左子节点；反之，若当前节点的值比两个节点的值都小，那么最低的祖先节点一定在当前节点的右子树中，则遍历当前节点的右子节点；这样，直到找到一个节点，位于两个节点值的中间，则找到了最低的公共祖先节点。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==q||root==p)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> root;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十一、普通二叉树的最低公共祖先（剑50-2）"><a href="#十一、普通二叉树的最低公共祖先（剑50-2）" class="headerlink" title="十一、普通二叉树的最低公共祖先（剑50.2）"></a>十一、普通二叉树的最低公共祖先（剑50.2）</h2><p>一种简单的方法是DFS分别寻找到两个节点p和q的路径，然后对比路径，查看他们的第一个分岔口，则为LCA。<br>这个思路比较简单，代码写起来不如下面这种方法优雅：</p>
<p>我们仍然可以用递归来解决，递归寻找两个带查询LCA的节点p和q，当找到后，返回给它们的父亲。如果某个节点的左右子树分别包括这两个节点，那么这个节点必然是所求的解，返回该节点。否则，返回左或者右子树（哪个包含p或者q的就返回哪个）。复杂度O(n)</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q)&#123;<span class="keyword">return</span> root;&#125;</div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>? left:right;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十二、二叉树的下一个结点（剑58）"><a href="#十二、二叉树的下一个结点（剑58）" class="headerlink" title="十二、二叉树的下一个结点（剑58）"></a>十二、二叉树的下一个结点（剑58）</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><img src="http://omu7tit09.bkt.clouddn.com/15017653485586.jpg" alt=""><br>我们可发现分成两大类：</p>
<ol>
<li>有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，F，C，G）</li>
<li>没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。<blockquote>
<p>java</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            pNode = pNode.right;</div><div class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                pNode = pNode.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> pNode;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pNode.next.left==pNode)<span class="keyword">return</span> pNode.next;</div><div class="line">            pNode = pNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;             </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十三、对称的二叉树（剑59）"><a href="#十三、对称的二叉树（剑59）" class="headerlink" title="十三、对称的二叉树（剑59）"></a>十三、对称的二叉树（剑59）</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>如果先序遍历的顺序分为两种先左后右和先右后左两种顺序遍历，如果两者相等说明二叉树是对称的二叉树</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot1,TreeNode pRoot2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>&amp;&amp;pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>||pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1.val==pRoot2.val)&#123;<span class="keyword">return</span></div><div class="line">            isSymmetrical(pRoot1.left,pRoot2.right)&amp;&amp;isSymmetrical(pRoot1.right,pRoot2.left);</div><div class="line">        &#125;<span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十四、把二叉树打印成多行（剑60）"><a href="#十四、把二叉树打印成多行（剑60）" class="headerlink" title="十四、把二叉树打印成多行（剑60）"></a>十四、把二叉树打印成多行（剑60）</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br>用end记录每层结点数目，start记录每层已经打印的数目，当start=end，重新建立list，开始下一层打印。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> result;&#125;</div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        queue.add(pRoot);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,end = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            TreeNode treenode = queue.remove();</div><div class="line">            list.add(treenode.val);</div><div class="line">            start++;</div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;</div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125; </div><div class="line">            <span class="keyword">if</span>(start==end)&#123;</div><div class="line">                end = queue.size();</div><div class="line">                start = <span class="number">0</span>;</div><div class="line">                result.add(list);</div><div class="line">                list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十五、按S型打印二叉树（剑61）"><a href="#十五、按S型打印二叉树（剑61）" class="headerlink" title="十五、按S型打印二叉树（剑61）"></a>十五、按S型打印二叉树（剑61）</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.29.00.png" alt="屏幕快照 2017-08-03 上午9.29.00"></p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; alist =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> alist;</div><div class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        stack1.add(pRoot);</div><div class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();           </div><div class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                    TreeNode treenode=stack1.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.right);</div><div class="line">                    &#125;                </div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</div><div class="line">                    TreeNode treenode = stack2.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.right);                        </div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> alist;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十六、序列化与反序列化二叉树（剑62）"><a href="#十六、序列化与反序列化二叉树（剑62）" class="headerlink" title="十六、序列化与反序列化二叉树（剑62）"></a>十六、序列化与反序列化二叉树（剑62）</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树<br>算法思想：根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</p>
<p>依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。另外，结点之间的数值用逗号隔开。</p>
<p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.39.38.png" alt="屏幕快照 2017-08-03 上午9.39.38"></p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;   <span class="comment">//计数变量</span></div><div class="line">  </div><div class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//新建字符串</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            sb.append(<span class="string">"#,"</span>);</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        sb.append(root.val + <span class="string">","</span>);</div><div class="line">        sb.append(Serialize(root.left));</div><div class="line">        sb.append(Serialize(root.right));</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">  &#125;</div><div class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        index++;</div><div class="line">        <span class="comment">//int len = str.length();</span></div><div class="line">        <span class="comment">//if(index &gt;= len)&#123;</span></div><div class="line">        <span class="comment">//    return null;</span></div><div class="line">       <span class="comment">// &#125;</span></div><div class="line">        String[] strr = str.split(<span class="string">","</span>);</div><div class="line">        TreeNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));</div><div class="line">            node.left = Deserialize(str);</div><div class="line">            node.right = Deserialize(str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十七、二叉搜索树的第K个结点（剑63）"><a href="#十七、二叉搜索树的第K个结点（剑63）" class="headerlink" title="十七、二叉搜索树的第K个结点（剑63）"></a>十七、二叉搜索树的第K个结点（剑63）</h2><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如在下图二叉搜索树里，按结点数值大小顺序第三个结点的值是4.<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.44.34.png" alt="屏幕快照 2017-08-03 上午9.44.34"><br>如果按照中序遍历的顺序遍历一颗二叉搜索树，遍历序列的数值是递增排序的，只需要用中序遍历算法遍历一颗二叉搜索树，就很容易找出它的第K大的结点。</p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123; <span class="comment">//中序遍历寻找第k个</span></div><div class="line">            TreeNode node = KthNode(root.left,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            index ++;</div><div class="line">            <span class="keyword">if</span>(index == k)</div><div class="line">                <span class="keyword">return</span> root;</div><div class="line">            node = KthNode(root.right,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十八、数据流中的中位数（剑64）"><a href="#十八、数据流中的中位数（剑64）" class="headerlink" title="十八、数据流中的中位数（剑64）"></a>十八、数据流中的中位数（剑64）</h2><p>Java的PriorityQueue是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器，比如下面反转比较，完成大顶堆。</p>
<p>为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：</p>
<ol>
<li>两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；</li>
<li>大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。</li>
</ol>
<p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午10.55.51.png" alt="屏幕快照 2017-08-03 上午10.55.51"></p>
<blockquote>
<p>java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</div><div class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">            <span class="comment">//PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器</span></div><div class="line">            <span class="keyword">return</span> o2.compareTo(o1); </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//当数据总数为偶数时，新加入的元素，应当进入小根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素</span></div><div class="line">        maxHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMaxNum = maxHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【大根堆中的最大元素】进入小根堆</span></div><div class="line">        minHeap.offer(filteredMaxNum);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//当数据总数为奇数时，新加入的元素，应当进入大根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素</span></div><div class="line">        minHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMinNum = minHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【小根堆中的最小元素】进入大根堆</span></div><div class="line">        maxHeap.offer(filteredMinNum);</div><div class="line">    &#125;</div><div class="line">    count++;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double((minHeap.peek() + maxHeap.peek())) / <span class="number">2</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="十九、-二叉树最大路径和（leetcode-124）"><a href="#十九、-二叉树最大路径和（leetcode-124）" class="headerlink" title="十九、 二叉树最大路径和（leetcode 124）"></a>十九、 二叉树最大路径和（leetcode 124）</h2><p>一个很有意思的问题，一个社区，所有的房子构成一棵二叉树，每个房子里有一定价值的财物，这棵二叉树有一个根节点root。如果相邻的两座房子同时被进入，就会触发警报。一个小偷，最初只能访问root节点，并可以通过二叉树的边访问房子（注：访问不意味着进入），请问不触发警报的前提下他能偷到的财物的最大价值是多少？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">以下面这棵二叉树为例，最多能偷走3+3+1=7的财物    </div><div class="line">     3 </div><div class="line">    / \ </div><div class="line">   2   3 </div><div class="line">    \     \ </div><div class="line">     3     1</div></pre></td></tr></table></figure>
<p>分析：<br>这个问题乍一看上去可能没什么思路，但是如果是用递归，可以很优雅的解决这个问题，这需要读者对递归有比较深刻的理解。下面给出解决这个问题的java代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import common.TreeNode;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">	//使用一个cache 缓存以每个节点为根节点的rob方法返回值，减少计算量</div><div class="line">    Map&lt;TreeNode, Integer&gt; cache = new HashMap&lt;TreeNode, Integer&gt;();</div><div class="line">    public int rob(TreeNode root) &#123;</div><div class="line">    	//如果当前节点为空 直接返回0</div><div class="line">        if(null == root)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        //首先查看缓存中有没有这个节点的rob方法返回值</div><div class="line">        if(null != cache.get(root))&#123;</div><div class="line">            return cache.get(root);</div><div class="line">        &#125;</div><div class="line">        //计算当前节点左孩子的rob方法返回值</div><div class="line">        int maxLeft = rob(root.left);</div><div class="line">        //计算当前节点右孩子的rob方法返回值</div><div class="line">        int maxRight = rob(root.right);</div><div class="line">        int maxLeftLeft = 0;</div><div class="line">        int maxLeftRight = 0;</div><div class="line">        //如果当前节点有左孩子</div><div class="line">        if(null != root.left)&#123;</div><div class="line">        	//计算其左孩子的左孩子的rob值</div><div class="line">            maxLeftLeft = rob(root.left.left);</div><div class="line">            //计算其左孩子的右孩子的rob值</div><div class="line">            maxLeftRight = rob(root.left.right);</div><div class="line">        &#125;</div><div class="line">        int maxRightLeft = 0;</div><div class="line">        int maxRightRight = 0;</div><div class="line">        //如果当前节点有右孩子</div><div class="line">        if(null != root.right)&#123;</div><div class="line">        	//计算其右孩子的左孩子的rob值</div><div class="line">            maxRightLeft = rob(root.right.left);</div><div class="line">            //计算其右孩子的右孩子的rob值</div><div class="line">            maxRightRight = rob(root.right.right);</div><div class="line">        &#125;</div><div class="line">        //不偷当前节点能偷到的财物的最大值</div><div class="line">        int notIncludeCurrentNodeMax = maxLeft + maxRight;</div><div class="line">        //偷当前节点能偷到的财物的最大值</div><div class="line">        int includeCurrentNodeMax = maxLeftLeft + maxLeftRight + maxRightLeft + maxRightRight + root.val;</div><div class="line">        //以其中的较大值作为当前节点的rob方法返回值</div><div class="line">        int res = notIncludeCurrentNodeMax &gt; includeCurrentNodeMax ? notIncludeCurrentNodeMax : includeCurrentNodeMax;</div><div class="line">        //缓存当前节点的rob方法返回值</div><div class="line">        cache.put(root, res);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="面经中出现过的二叉树题："><a href="#面经中出现过的二叉树题：" class="headerlink" title="面经中出现过的二叉树题："></a>面经中出现过的二叉树题：</h2><h3 id="已整理"><a href="#已整理" class="headerlink" title="已整理"></a>已整理</h3><ul>
<li>一、给定二叉树的先序跟后序遍历，能不能将二叉树重建（不能，因为先序：父节点-左节点-右节点，后序：左节点-右节点-父节点，两者的拓扑序列是一样的，所以无法建立），如果给出一个二叉搜索树的后续能不能建立（可以，因为只要将遍历结果排序就可以得到中序结果）。</li>
<li>二、判断一棵树是否是另一棵的子树。</li>
<li>三、 翻转二叉树 </li>
<li>四、二叉树打印路径</li>
<li>六、输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。二叉树路径和等于某个值的所有路径输出。</li>
<li>七、排序二叉树转双向链表</li>
<li>十、输入根节点和两个子节点，找到最小公共父节点，2叉树只有孩子节点；查找二叉树某两个节点的最近公共祖先</li>
<li>十二、输入二叉树节点 P, 找到二叉树中序遍历 P 的下一个节点。</li>
<li>十四、把二叉树打印成多行；中序遍历二叉树，利用O(1)空间统计遍历的每个节点的层次</li>
<li>十五、手写S型遍历二叉树，如何优化，最后说了个空间优化的方法 </li>
<li>十九、leetcode 124 二叉树最大路径和</li>
</ul>
<h3 id="未整理"><a href="#未整理" class="headerlink" title="未整理"></a>未整理</h3><p>求完全二叉树的节点个数，要求最优解法，我写的是递归，复杂度O(logn*logn)</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>感谢打赏，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/wechat-reward-image.png" alt="狗皮膏药 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/alipay-reward-image.png" alt="狗皮膏药 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/二叉树/" rel="tag"># 二叉树</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/04/数据结构与算法题解（3）：字符串题解/" rel="next" title="数据结构与算法题解（3）：字符串题解">
                <i class="fa fa-chevron-left"></i> 数据结构与算法题解（3）：字符串题解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/05/数据结构与算法题解（5）：剑指offer解题报告/" rel="prev" title="数据结构与算法题解（5）：剑指offer解题报告">
                数据结构与算法题解（5）：剑指offer解题报告 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/img/v.png"
                alt="狗皮膏药" />
            
              <p class="site-author-name" itemprop="name">狗皮膏药</p>
              <p class="site-description motion-element" itemprop="description">人类被赋予了一种工作，那就是精神的成长</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">175</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">260</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://plushunter.github.io/yiyu/" target="_blank" title="絮语">
                    
                      <i class="fa fa-fw fa-heartbeat"></i>絮语</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plushunter.github.io/movies/" target="_blank" title="电影">
                    
                      <i class="fa fa-fw fa-film"></i>电影</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plushunter.github.io/books/" target="_blank" title="读书">
                    
                      <i class="fa fa-fw fa-book"></i>读书</a>
                </span>
              
            
          </div>

         

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-anchor"></i>
                GREAT BLOG
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.farmostwood.net" title="木遥" target="_blank">木遥</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://coolshell.cn" title="酷壳" target="_blank">酷壳</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://mindhacks.cn" title="刘未鹏" target="_blank">刘未鹏</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://freemind.pluskid.org" title="张驰原" target="_blank">张驰原</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.flickering.cn" title="火光摇曳" target="_blank">火光摇曳</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://macshuo.com" title="MacTalk" target="_blank">MacTalk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.matrix67.com" title="Matrix67" target="_blank">Matrix67</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://developers.googleblog.cn" title="Google Developers" target="_blank">Google Developers</a>
                  </li>
                
              </ul>
            </div>
          


          

        </div>

      
  
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、重建二叉树（剑6）"><span class="nav-text">一、重建二叉树（剑6）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、二叉树的镜像（剑19）"><span class="nav-text">三、二叉树的镜像（剑19）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、从上往下打印二叉树（剑23）"><span class="nav-text">四、从上往下打印二叉树（剑23）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、二叉搜索树的后序遍历序列（剑24）"><span class="nav-text">五、二叉搜索树的后序遍历序列（剑24）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、二叉树中和为某一值的路径（剑25）"><span class="nav-text">六、二叉树中和为某一值的路径（剑25）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、二叉搜索树与双向链表（剑27）"><span class="nav-text">七、二叉搜索树与双向链表（剑27）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、二叉树的深度（剑39-1）"><span class="nav-text">八、二叉树的深度（剑39.1）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、平衡二叉树（剑39-2）"><span class="nav-text">九、平衡二叉树（剑39.2）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、二叉搜索树的最低公共祖先（剑50-1）"><span class="nav-text">十、二叉搜索树的最低公共祖先（剑50.1）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、普通二叉树的最低公共祖先（剑50-2）"><span class="nav-text">十一、普通二叉树的最低公共祖先（剑50.2）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、二叉树的下一个结点（剑58）"><span class="nav-text">十二、二叉树的下一个结点（剑58）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、对称的二叉树（剑59）"><span class="nav-text">十三、对称的二叉树（剑59）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十四、把二叉树打印成多行（剑60）"><span class="nav-text">十四、把二叉树打印成多行（剑60）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十五、按S型打印二叉树（剑61）"><span class="nav-text">十五、按S型打印二叉树（剑61）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十六、序列化与反序列化二叉树（剑62）"><span class="nav-text">十六、序列化与反序列化二叉树（剑62）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十七、二叉搜索树的第K个结点（剑63）"><span class="nav-text">十七、二叉搜索树的第K个结点（剑63）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十八、数据流中的中位数（剑64）"><span class="nav-text">十八、数据流中的中位数（剑64）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十九、-二叉树最大路径和（leetcode-124）"><span class="nav-text">十九、 二叉树最大路径和（leetcode 124）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面经中出现过的二叉树题："><span class="nav-text">面经中出现过的二叉树题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#已整理"><span class="nav-text">已整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未整理"><span class="nav-text">未整理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      


      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">狗皮膏药</span>
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(searchString, position) {
      var subjectString = this.toString();
      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
  };
}
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  


</body>
</html>
